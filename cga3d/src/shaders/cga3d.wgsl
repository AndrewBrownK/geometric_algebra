//
// AUTO-GENERATED - DO NOT MODIFY
//
// To contribute to this file, see the adjacent codegen package.
// https://github.com/AndrewBrownK/geometric_algebra/
//

struct Scalar {
    // 1
     g0: f32,
}

struct AntiScalar {
    // e12345
     g0: f32,
}

struct Magnitude {
    // 1, e12345
     g0: vec2<f32>,
}

struct FlatPoint {
    // e15, e25, e35, e45
     g0: vec4<f32>,
}

struct PointAtOrigin {
    // e45
     g0: f32,
}

struct PointAtInfinity {
    // e15, e25, e35
     g0: vec3<f32>,
}

struct Line {
    // -e145, -e245, -e345
     g0: vec3<f32>,
    // e235, -e135, e125
     g1: vec3<f32>,
}

struct LineAtOrigin {
    // -e145, -e245, -e345
     g0: vec3<f32>,
}

struct LineAtInfinity {
    // e235, -e135, e125
     g0: vec3<f32>,
}

struct Plane {
    // e2345, -e1345, e1245, -e1235
     g0: vec4<f32>,
}

struct PlaneAtOrigin {
    // e2345, -e1345, e1245
     g0: vec3<f32>,
}

struct Horizon {
    // -e1235
     g0: f32,
}

struct RoundPoint {
    // e1, e2, e3
     g0: vec3<f32>,
    // e4, e5
     g1: vec2<f32>,
}

struct Dipole {
    // -e14, -e24, -e34
     g0: vec3<f32>,
    // e23, -e13, e12
     g1: vec3<f32>,
    // e15, e25, e35, e45
     g2: vec4<f32>,
}

struct Circle {
    // e234, -e134, e124, -e123
     g0: vec4<f32>,
    // -e145, -e245, -e345
     g1: vec3<f32>,
    // e235, -e135, e125
     g2: vec3<f32>,
}

struct Sphere {
    // e2345, -e1345, e1245
     g0: vec3<f32>,
    // e1234, -e1235
     g1: vec2<f32>,
}

struct Infinity {
    // e5
     g0: f32,
}

struct Origin {
    // e4
     g0: f32,
}

struct Motor {
    // -e145, -e245, -e345, e12345
     g0: vec4<f32>,
    // e235, -e135, e125
     g1: vec3<f32>,
}

struct Rotor {
    // -e145, -e245, -e345, e12345
     g0: vec4<f32>,
}

struct Translator {
    // e235, -e135, e125, e12345
     g0: vec4<f32>,
}

struct Flector {
    // e15, e25, e35, e45
     g0: vec4<f32>,
    // e2345, -e1345, e1245, -e1235
     g1: vec4<f32>,
}

struct MultiVector {
    // 1, e12345
     g0: vec2<f32>,
    // e1, e2, e3
     g1: vec3<f32>,
    // e4, e5
     g2: vec2<f32>,
    // -e14, -e24, -e34
     g3: vec3<f32>,
    // e23, -e13, e12
     g4: vec3<f32>,
    // e15, e25, e35, e45
     g5: vec4<f32>,
    // e234, -e134, e124, -e123
     g6: vec4<f32>,
    // -e145, -e245, -e345
     g7: vec3<f32>,
    // e235, -e135, e125
     g8: vec3<f32>,
    // e2345, -e1345, e1245
     g9: vec3<f32>,
    // e1234, -e1235
     g10: vec2<f32>,
}

fn anti_scalar_one() -> AntiScalar {
    return AntiScalar(0.0);
}

fn circle_one() -> Circle {
    return Circle(vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn dipole_one() -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn flat_point_one() -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0));
}

fn flector_one() -> Flector {
    return Flector(vec4<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_one() -> Horizon {
    return Horizon(0.0);
}

fn infinity_one() -> Infinity {
    return Infinity(0.0);
}

fn line_one() -> Line {
    return Line(vec3<f32>(0.0), vec3<f32>(0.0));
}

fn line_at_infinity_one() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0));
}

fn line_at_origin_one() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0));
}

fn magnitude_one() -> Magnitude {
    return Magnitude(vec2<f32>(1.0, 0.0));
}

fn motor_one() -> Motor {
    return Motor(vec4<f32>(0.0), vec3<f32>(0.0));
}

fn multi_vector_one() -> MultiVector {
    return MultiVector(vec2<f32>(1.0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_one() -> Origin {
    return Origin(0.0);
}

fn plane_one() -> Plane {
    return Plane(vec4<f32>(0.0));
}

fn plane_at_origin_one() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0));
}

fn point_at_infinity_one() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0));
}

fn point_at_origin_one() -> PointAtOrigin {
    return PointAtOrigin(0.0);
}

fn rotor_one() -> Rotor {
    return Rotor(vec4<f32>(0.0));
}

fn round_point_one() -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_one() -> Scalar {
    return Scalar(1.0);
}

fn sphere_one() -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_one() -> Translator {
    return Translator(vec4<f32>(0.0));
}

fn anti_scalar_zero() -> AntiScalar {
    return AntiScalar(0.0);
}

fn circle_zero() -> Circle {
    return Circle(vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn dipole_zero() -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn flat_point_zero() -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0));
}

fn flector_zero() -> Flector {
    return Flector(vec4<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_zero() -> Horizon {
    return Horizon(0.0);
}

fn infinity_zero() -> Infinity {
    return Infinity(0.0);
}

fn line_zero() -> Line {
    return Line(vec3<f32>(0.0), vec3<f32>(0.0));
}

fn line_at_infinity_zero() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0));
}

fn line_at_origin_zero() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0));
}

fn magnitude_zero() -> Magnitude {
    return Magnitude(vec2<f32>(0.0));
}

fn motor_zero() -> Motor {
    return Motor(vec4<f32>(0.0), vec3<f32>(0.0));
}

fn multi_vector_zero() -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_zero() -> Origin {
    return Origin(0.0);
}

fn plane_zero() -> Plane {
    return Plane(vec4<f32>(0.0));
}

fn plane_at_origin_zero() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0));
}

fn point_at_infinity_zero() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0));
}

fn point_at_origin_zero() -> PointAtOrigin {
    return PointAtOrigin(0.0);
}

fn rotor_zero() -> Rotor {
    return Rotor(vec4<f32>(0.0));
}

fn round_point_zero() -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_zero() -> Scalar {
    return Scalar(0.0);
}

fn sphere_zero() -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_zero() -> Translator {
    return Translator(vec4<f32>(0.0));
}

fn anti_scalar_neg(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn circle_neg(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g1 * vec3<f32>(1.0, -1.0, 1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn dipole_neg(self_: Dipole) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g2 * vec4<f32>(-1.0));
}

fn flat_point_neg(self_: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(-1.0));
}

fn flector_neg(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn horizon_neg(self_: Horizon) -> Horizon {
    return Horizon(self_.g0);
}

fn infinity_neg(self_: Infinity) -> Infinity {
    return Infinity(-self_.g0);
}

fn line_neg(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_infinity_neg(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_origin_neg(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn magnitude_neg(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(-1.0, 1.0));
}

fn motor_neg(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn multi_vector_neg(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(-1.0, 1.0), self_.g1 * vec3<f32>(-1.0), self_.g2 * vec2<f32>(-1.0), self_.g3 * vec3<f32>(-1.0), self_.g4 * vec3<f32>(-1.0), self_.g5 * vec4<f32>(-1.0), self_.g6 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g7 * vec3<f32>(1.0, -1.0, 1.0), self_.g8 * vec3<f32>(-1.0, 1.0, -1.0), self_.g9 * vec3<f32>(1.0, -1.0, 1.0), self_.g10 * vec2<f32>(-1.0, 1.0));
}

fn origin_neg(self_: Origin) -> Origin {
    return Origin(-self_.g0);
}

fn plane_neg(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn plane_at_origin_neg(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn point_at_infinity_neg(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_at_origin_neg(self_: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(-self_.g0);
}

fn rotor_neg(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn round_point_neg(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec2<f32>(-1.0));
}

fn scalar_neg(self_: Scalar) -> Scalar {
    return Scalar(-self_.g0);
}

fn sphere_neg(self_: Sphere) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(1.0, -1.0, 1.0), self_.g1 * vec2<f32>(-1.0, 1.0));
}

fn translator_neg(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn anti_scalar_anti_scalar_add(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 + other.g0);
}

fn anti_scalar_line_add(self_: AntiScalar, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), other.g1);
}

fn anti_scalar_line_at_infinity_add(self_: AntiScalar, other: LineAtInfinity) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_line_at_origin_add(self_: AntiScalar, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_magnitude_add(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) + other.g0);
}

fn anti_scalar_motor_add(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0, other.g1);
}

fn anti_scalar_multi_vector_add(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0) + other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn anti_scalar_rotor_add(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn anti_scalar_scalar_add(self_: AntiScalar, other: Scalar) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) + vec2<f32>(other.g0, 0.0));
}

fn anti_scalar_translator_add(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn circle_circle_add(self_: Circle, other: Circle) -> Circle {
    return Circle(self_.g0 + other.g0, self_.g1 + other.g1, self_.g2 + other.g2);
}

fn circle_line_add(self_: Circle, other: Line) -> Circle {
    return Circle(self_.g0, self_.g1 + other.g0, self_.g2 + other.g1);
}

fn circle_line_at_infinity_add(self_: Circle, other: LineAtInfinity) -> Circle {
    return Circle(self_.g0, self_.g1, self_.g2 + other.g0);
}

fn circle_line_at_origin_add(self_: Circle, other: LineAtOrigin) -> Circle {
    return Circle(self_.g0, self_.g1 + other.g0, self_.g2);
}

fn circle_multi_vector_add(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, self_.g0 + other.g6, self_.g1 + other.g7, self_.g2 + other.g8, other.g9, other.g10);
}

fn dipole_dipole_add(self_: Dipole, other: Dipole) -> Dipole {
    return Dipole(self_.g0 + other.g0, self_.g1 + other.g1, self_.g2 + other.g2);
}

fn dipole_flat_point_add(self_: Dipole, other: FlatPoint) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2 + other.g0);
}

fn dipole_multi_vector_add(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, self_.g0 + other.g3, self_.g1 + other.g4, self_.g2 + other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn dipole_point_at_infinity_add(self_: Dipole, other: PointAtInfinity) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn dipole_point_at_origin_add(self_: Dipole, other: PointAtOrigin) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flat_point_dipole_add(self_: FlatPoint, other: Dipole) -> Dipole {
    return Dipole(other.g0, other.g1, self_.g0 + other.g2);
}

fn flat_point_flat_point_add(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 + other.g0);
}

fn flat_point_flector_add(self_: FlatPoint, other: Flector) -> Flector {
    return Flector(self_.g0 + other.g0, other.g1);
}

fn flat_point_multi_vector_add(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, self_.g0 + other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn flat_point_plane_add(self_: FlatPoint, other: Plane) -> Flector {
    return Flector(self_.g0, other.g0);
}

fn flat_point_point_at_infinity_add(self_: FlatPoint, other: PointAtInfinity) -> FlatPoint {
    return FlatPoint(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flat_point_point_at_origin_add(self_: FlatPoint, other: PointAtOrigin) -> FlatPoint {
    return FlatPoint(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_flat_point_add(self_: Flector, other: FlatPoint) -> Flector {
    return Flector(self_.g0 + other.g0, self_.g1);
}

fn flector_flector_add(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn flector_horizon_add(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g0, self_.g1 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_multi_vector_add(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, self_.g0 + other.g5, other.g6, other.g7, other.g8, vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) + other.g9, vec2<f32>(0.0, self_.g1.w) + other.g10);
}

fn flector_plane_add(self_: Flector, other: Plane) -> Flector {
    return Flector(self_.g0, self_.g1 + other.g0);
}

fn flector_plane_at_origin_add(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0, self_.g1 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_point_at_infinity_add(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn flector_point_at_origin_add(self_: Flector, other: PointAtOrigin) -> Flector {
    return Flector(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn horizon_flector_add(self_: Horizon, other: Flector) -> Flector {
    return Flector(other.g0, vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g1);
}

fn horizon_horizon_add(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 + other.g0);
}

fn horizon_multi_vector_add(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, vec2<f32>(0.0, self_.g0) + other.g10);
}

fn horizon_plane_add(self_: Horizon, other: Plane) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn horizon_plane_at_origin_add(self_: Horizon, other: PlaneAtOrigin) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_sphere_add(self_: Horizon, other: Sphere) -> Sphere {
    return Sphere(other.g0, vec2<f32>(0.0, self_.g0) + other.g1);
}

fn infinity_infinity_add(self_: Infinity, other: Infinity) -> Infinity {
    return Infinity(self_.g0 + other.g0);
}

fn infinity_multi_vector_add(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, vec2<f32>(0.0, self_.g0) + other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn infinity_round_point_add(self_: Infinity, other: RoundPoint) -> RoundPoint {
    return RoundPoint(other.g0, vec2<f32>(0.0, self_.g0) + other.g1);
}

fn line_anti_scalar_add(self_: Line, other: AntiScalar) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn line_circle_add(self_: Line, other: Circle) -> Circle {
    return Circle(other.g0, self_.g0 + other.g1, self_.g1 + other.g2);
}

fn line_line_add(self_: Line, other: Line) -> Line {
    return Line(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn line_line_at_infinity_add(self_: Line, other: LineAtInfinity) -> Line {
    return Line(self_.g0, self_.g1 + other.g0);
}

fn line_line_at_origin_add(self_: Line, other: LineAtOrigin) -> Line {
    return Line(self_.g0 + other.g0, self_.g1);
}

fn line_motor_add(self_: Line, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, self_.g1 + other.g1);
}

fn line_multi_vector_add(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, self_.g0 + other.g7, self_.g1 + other.g8, other.g9, other.g10);
}

fn line_rotor_add(self_: Line, other: Rotor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, self_.g1);
}

fn line_translator_add(self_: Line, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn line_at_infinity_anti_scalar_add(self_: LineAtInfinity, other: AntiScalar) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_infinity_circle_add(self_: LineAtInfinity, other: Circle) -> Circle {
    return Circle(other.g0, other.g1, self_.g0 + other.g2);
}

fn line_at_infinity_line_add(self_: LineAtInfinity, other: Line) -> Line {
    return Line(other.g0, self_.g0 + other.g1);
}

fn line_at_infinity_line_at_infinity_add(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 + other.g0);
}

fn line_at_infinity_line_at_origin_add(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return Line(other.g0, self_.g0);
}

fn line_at_infinity_motor_add(self_: LineAtInfinity, other: Motor) -> Motor {
    return Motor(other.g0, self_.g0 + other.g1);
}

fn line_at_infinity_multi_vector_add(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, self_.g0 + other.g8, other.g9, other.g10);
}

fn line_at_infinity_rotor_add(self_: LineAtInfinity, other: Rotor) -> Motor {
    return Motor(other.g0, self_.g0);
}

fn line_at_infinity_translator_add(self_: LineAtInfinity, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn line_at_origin_anti_scalar_add(self_: LineAtOrigin, other: AntiScalar) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_origin_circle_add(self_: LineAtOrigin, other: Circle) -> Circle {
    return Circle(other.g0, self_.g0 + other.g1, other.g2);
}

fn line_at_origin_line_add(self_: LineAtOrigin, other: Line) -> Line {
    return Line(self_.g0 + other.g0, other.g1);
}

fn line_at_origin_line_at_infinity_add(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return Line(self_.g0, other.g0);
}

fn line_at_origin_line_at_origin_add(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 + other.g0);
}

fn line_at_origin_motor_add(self_: LineAtOrigin, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, other.g1);
}

fn line_at_origin_multi_vector_add(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, self_.g0 + other.g7, other.g8, other.g9, other.g10);
}

fn line_at_origin_rotor_add(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn line_at_origin_translator_add(self_: LineAtOrigin, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn magnitude_anti_scalar_add(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 + vec2<f32>(0.0, other.g0));
}

fn magnitude_magnitude_add(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 + other.g0);
}

fn magnitude_multi_vector_add(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 + other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn magnitude_scalar_add(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 + vec2<f32>(other.g0, 0.0));
}

fn motor_anti_scalar_add(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn motor_line_add(self_: Motor, other: Line) -> Motor {
    return Motor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 + other.g1);
}

fn motor_line_at_infinity_add(self_: Motor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, self_.g1 + other.g0);
}

fn motor_line_at_origin_add(self_: Motor, other: LineAtOrigin) -> Motor {
    return Motor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn motor_motor_add(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn motor_multi_vector_add(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) + other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g7, self_.g1 + other.g8, other.g9, other.g10);
}

fn motor_rotor_add(self_: Motor, other: Rotor) -> Motor {
    return Motor(self_.g0 + other.g0, self_.g1);
}

fn motor_translator_add(self_: Motor, other: Translator) -> Motor {
    return Motor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn multi_vector_anti_scalar_add(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_circle_add(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6 + other.g0, self_.g7 + other.g1, self_.g8 + other.g2, self_.g9, self_.g10);
}

fn multi_vector_dipole_add(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3 + other.g0, self_.g4 + other.g1, self_.g5 + other.g2, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_flat_point_add(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 + other.g0, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_flector_add(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 + other.g0, self_.g6, self_.g7, self_.g8, self_.g9 + vec3<f32>(other.g1.x, other.g1.y, other.g1.z), self_.g10 + vec2<f32>(0.0, other.g1.w));
}

fn multi_vector_horizon_add(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10 + vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_add(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 + vec2<f32>(0.0, other.g0), self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_line_add(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 + other.g0, self_.g8 + other.g1, self_.g9, self_.g10);
}

fn multi_vector_line_at_infinity_add(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8 + other.g0, self_.g9, self_.g10);
}

fn multi_vector_line_at_origin_add(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 + other.g0, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_magnitude_add(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(self_.g0 + other.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_motor_add(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g8 + other.g1, self_.g9, self_.g10);
}

fn multi_vector_multi_vector_add(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 + other.g0, self_.g1 + other.g1, self_.g2 + other.g2, self_.g3 + other.g3, self_.g4 + other.g4, self_.g5 + other.g5, self_.g6 + other.g6, self_.g7 + other.g7, self_.g8 + other.g8, self_.g9 + other.g9, self_.g10 + other.g10);
}

fn multi_vector_origin_add(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 + vec2<f32>(other.g0, 0.0), self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_plane_add(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g10 + vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_add(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9 + other.g0, self_.g10);
}

fn multi_vector_point_at_infinity_add(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_point_at_origin_add(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_rotor_add(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g8, self_.g9, self_.g10);
}

fn multi_vector_round_point_add(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 + other.g0, self_.g2 + other.g1, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_scalar_add(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(other.g0, 0.0), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_sphere_add(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9 + other.g0, self_.g10 + other.g1);
}

fn multi_vector_translator_add(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g9, self_.g10);
}

fn origin_multi_vector_add(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, vec2<f32>(self_.g0, 0.0) + other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn origin_origin_add(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 + other.g0);
}

fn origin_round_point_add(self_: Origin, other: RoundPoint) -> RoundPoint {
    return RoundPoint(other.g0, vec2<f32>(self_.g0, 0.0) + other.g1);
}

fn plane_flat_point_add(self_: Plane, other: FlatPoint) -> Flector {
    return Flector(other.g0, self_.g0);
}

fn plane_flector_add(self_: Plane, other: Flector) -> Flector {
    return Flector(other.g0, self_.g0 + other.g1);
}

fn plane_horizon_add(self_: Plane, other: Horizon) -> Plane {
    return Plane(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_multi_vector_add(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g9, vec2<f32>(0.0, self_.g0.w) + other.g10);
}

fn plane_plane_add(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0 + other.g0);
}

fn plane_plane_at_origin_add(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return Plane(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_sphere_add(self_: Plane, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g0, vec2<f32>(0.0, self_.g0.w) + other.g1);
}

fn plane_at_origin_flector_add(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return Flector(other.g0, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g1);
}

fn plane_at_origin_horizon_add(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_at_origin_multi_vector_add(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, self_.g0 + other.g9, other.g10);
}

fn plane_at_origin_plane_add(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn plane_at_origin_plane_at_origin_add(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 + other.g0);
}

fn plane_at_origin_sphere_add(self_: PlaneAtOrigin, other: Sphere) -> Sphere {
    return Sphere(self_.g0 + other.g0, other.g1);
}

fn point_at_infinity_dipole_add(self_: PointAtInfinity, other: Dipole) -> Dipole {
    return Dipole(other.g0, other.g1, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g2);
}

fn point_at_infinity_flat_point_add(self_: PointAtInfinity, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn point_at_infinity_flector_add(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, other.g1);
}

fn point_at_infinity_multi_vector_add(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn point_at_infinity_point_at_infinity_add(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 + other.g0);
}

fn point_at_infinity_point_at_origin_add(self_: PointAtInfinity, other: PointAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn point_at_origin_dipole_add(self_: PointAtOrigin, other: Dipole) -> Dipole {
    return Dipole(other.g0, other.g1, vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g2);
}

fn point_at_origin_flat_point_add(self_: PointAtOrigin, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn point_at_origin_flector_add(self_: PointAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0, other.g1);
}

fn point_at_origin_multi_vector_add(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn point_at_origin_point_at_infinity_add(self_: PointAtOrigin, other: PointAtInfinity) -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_point_at_origin_add(self_: PointAtOrigin, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 + other.g0);
}

fn rotor_anti_scalar_add(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_add(self_: Rotor, other: Line) -> Motor {
    return Motor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), other.g1);
}

fn rotor_line_at_infinity_add(self_: Rotor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, other.g0);
}

fn rotor_line_at_origin_add(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_motor_add(self_: Rotor, other: Motor) -> Motor {
    return Motor(self_.g0 + other.g0, other.g1);
}

fn rotor_multi_vector_add(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) + other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g7, other.g8, other.g9, other.g10);
}

fn rotor_rotor_add(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0 + other.g0);
}

fn rotor_translator_add(self_: Rotor, other: Translator) -> Motor {
    return Motor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn round_point_infinity_add(self_: RoundPoint, other: Infinity) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1 + vec2<f32>(0.0, other.g0));
}

fn round_point_multi_vector_add(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, self_.g0 + other.g1, self_.g1 + other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn round_point_origin_add(self_: RoundPoint, other: Origin) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1 + vec2<f32>(other.g0, 0.0));
}

fn round_point_round_point_add(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn scalar_anti_scalar_add(self_: Scalar, other: AntiScalar) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) + vec2<f32>(0.0, other.g0));
}

fn scalar_magnitude_add(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) + other.g0);
}

fn scalar_multi_vector_add(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0, 0.0) + other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, other.g9, other.g10);
}

fn scalar_scalar_add(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 + other.g0);
}

fn sphere_horizon_add(self_: Sphere, other: Horizon) -> Sphere {
    return Sphere(self_.g0, self_.g1 + vec2<f32>(0.0, other.g0));
}

fn sphere_multi_vector_add(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, other.g8, self_.g0 + other.g9, self_.g1 + other.g10);
}

fn sphere_plane_add(self_: Sphere, other: Plane) -> Sphere {
    return Sphere(self_.g0 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 + vec2<f32>(0.0, other.g0.w));
}

fn sphere_plane_at_origin_add(self_: Sphere, other: PlaneAtOrigin) -> Sphere {
    return Sphere(self_.g0 + other.g0, self_.g1);
}

fn sphere_sphere_add(self_: Sphere, other: Sphere) -> Sphere {
    return Sphere(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn translator_anti_scalar_add(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn translator_line_add(self_: Translator, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g1);
}

fn translator_line_at_infinity_add(self_: Translator, other: LineAtInfinity) -> Translator {
    return Translator(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_line_at_origin_add(self_: Translator, other: LineAtOrigin) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_motor_add(self_: Translator, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g1);
}

fn translator_multi_vector_add(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) + other.g0, other.g1, other.g2, other.g3, other.g4, other.g5, other.g6, other.g7, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g8, other.g9, other.g10);
}

fn translator_rotor_add(self_: Translator, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_translator_add(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0 + other.g0);
}

fn anti_scalar_anti_scalar_div(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn circle_circle_div(self_: Circle, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g2.x, other.g2.y, other.g2.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn dipole_dipole_div(self_: Dipole, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g2.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn flat_point_flat_point_div(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn flector_flector_div(self_: Flector, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn horizon_horizon_div(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn infinity_infinity_div(self_: Infinity, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn line_line_div(self_: Line, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn line_at_infinity_line_at_infinity_div(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn line_at_origin_line_at_origin_div(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn magnitude_magnitude_div(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x, self_.g0.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g0.x, other.g0.y) * vec2<f32>(1.0, 1.0));
}

fn motor_motor_div(self_: Motor, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn multi_vector_multi_vector_div(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x, self_.g0.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g0.x, other.g0.y) * vec2<f32>(1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0), vec2<f32>(self_.g2.x, self_.g2.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g2.x, other.g2.y) * vec2<f32>(1.0, 1.0), vec3<f32>(self_.g3.x, self_.g3.y, self_.g3.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g3.x, other.g3.y, other.g3.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g4.x, other.g4.y, other.g4.z) * vec3<f32>(1.0, 1.0, 1.0), vec4<f32>(self_.g5.x, self_.g5.y, self_.g5.z, self_.g5.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g5.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g6.x, self_.g6.y, self_.g6.z, self_.g6.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g6.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g7.x, self_.g7.y, self_.g7.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g7.x, other.g7.y, other.g7.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g8.x, self_.g8.y, self_.g8.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g8.x, other.g8.y, other.g8.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g9.x, self_.g9.y, self_.g9.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g9.x, other.g9.y, other.g9.z) * vec3<f32>(1.0, 1.0, 1.0), vec2<f32>(self_.g10.x, self_.g10.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g10.x, other.g10.y) * vec2<f32>(1.0, 1.0));
}

fn origin_origin_div(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn plane_plane_div(self_: Plane, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn plane_at_origin_plane_at_origin_div(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn point_at_infinity_point_at_infinity_div(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn point_at_origin_point_at_origin_div(self_: PointAtOrigin, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn rotor_rotor_div(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn round_point_round_point_div(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0), vec2<f32>(self_.g1.x, self_.g1.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g1.x, other.g1.y) * vec2<f32>(1.0, 1.0));
}

fn scalar_scalar_div(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn sphere_sphere_div(self_: Sphere, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0), vec2<f32>(self_.g1.x, self_.g1.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g1.x, other.g1.y) * vec2<f32>(1.0, 1.0));
}

fn translator_translator_div(self_: Translator, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn circle_line_into(self_: Circle) -> Line {
    return Line(self_.g1, self_.g2);
}

fn circle_line_at_infinity_into(self_: Circle) -> LineAtInfinity {
    return LineAtInfinity(self_.g2);
}

fn circle_line_at_origin_into(self_: Circle) -> LineAtOrigin {
    return LineAtOrigin(self_.g1);
}

fn dipole_flat_point_into(self_: Dipole) -> FlatPoint {
    return FlatPoint(self_.g2);
}

fn dipole_point_at_infinity_into(self_: Dipole) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z));
}

fn dipole_point_at_origin_into(self_: Dipole) -> PointAtOrigin {
    return PointAtOrigin(self_.g2.w);
}

fn flat_point_point_at_infinity_into(self_: FlatPoint) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn flat_point_point_at_origin_into(self_: FlatPoint) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w);
}

fn flector_flat_point_into(self_: Flector) -> FlatPoint {
    return FlatPoint(self_.g0);
}

fn flector_horizon_into(self_: Flector) -> Horizon {
    return Horizon(self_.g1.w);
}

fn flector_plane_into(self_: Flector) -> Plane {
    return Plane(self_.g1);
}

fn flector_plane_at_origin_into(self_: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z));
}

fn flector_point_at_infinity_into(self_: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn flector_point_at_origin_into(self_: Flector) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w);
}

fn line_line_at_infinity_into(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(self_.g1);
}

fn line_line_at_origin_into(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(self_.g0);
}

fn magnitude_anti_scalar_into(self_: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.y);
}

fn magnitude_scalar_into(self_: Magnitude) -> Scalar {
    return Scalar(self_.g0.x);
}

fn motor_anti_scalar_into(self_: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn motor_line_into(self_: Motor) -> Line {
    return Line(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), self_.g1);
}

fn motor_line_at_infinity_into(self_: Motor) -> LineAtInfinity {
    return LineAtInfinity(self_.g1);
}

fn motor_line_at_origin_into(self_: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn motor_rotor_into(self_: Motor) -> Rotor {
    return Rotor(self_.g0);
}

fn motor_translator_into(self_: Motor) -> Translator {
    return Translator(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g0.w));
}

fn multi_vector_anti_scalar_into(self_: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.y);
}

fn multi_vector_circle_into(self_: MultiVector) -> Circle {
    return Circle(self_.g6, self_.g7, self_.g8);
}

fn multi_vector_dipole_into(self_: MultiVector) -> Dipole {
    return Dipole(self_.g3, self_.g4, self_.g5);
}

fn multi_vector_flat_point_into(self_: MultiVector) -> FlatPoint {
    return FlatPoint(self_.g5);
}

fn multi_vector_flector_into(self_: MultiVector) -> Flector {
    return Flector(self_.g5, vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g10.y));
}

fn multi_vector_horizon_into(self_: MultiVector) -> Horizon {
    return Horizon(self_.g10.y);
}

fn multi_vector_infinity_into(self_: MultiVector) -> Infinity {
    return Infinity(self_.g2.y);
}

fn multi_vector_line_into(self_: MultiVector) -> Line {
    return Line(self_.g7, self_.g8);
}

fn multi_vector_line_at_infinity_into(self_: MultiVector) -> LineAtInfinity {
    return LineAtInfinity(self_.g8);
}

fn multi_vector_line_at_origin_into(self_: MultiVector) -> LineAtOrigin {
    return LineAtOrigin(self_.g7);
}

fn multi_vector_magnitude_into(self_: MultiVector) -> Magnitude {
    return Magnitude(self_.g0);
}

fn multi_vector_motor_into(self_: MultiVector) -> Motor {
    return Motor(vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g0.y), self_.g8);
}

fn multi_vector_origin_into(self_: MultiVector) -> Origin {
    return Origin(self_.g2.x);
}

fn multi_vector_plane_into(self_: MultiVector) -> Plane {
    return Plane(vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g10.y));
}

fn multi_vector_plane_at_origin_into(self_: MultiVector) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g9);
}

fn multi_vector_point_at_infinity_into(self_: MultiVector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z));
}

fn multi_vector_point_at_origin_into(self_: MultiVector) -> PointAtOrigin {
    return PointAtOrigin(self_.g5.w);
}

fn multi_vector_rotor_into(self_: MultiVector) -> Rotor {
    return Rotor(vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g0.y));
}

fn multi_vector_round_point_into(self_: MultiVector) -> RoundPoint {
    return RoundPoint(self_.g1, self_.g2);
}

fn multi_vector_scalar_into(self_: MultiVector) -> Scalar {
    return Scalar(self_.g0.x);
}

fn multi_vector_sphere_into(self_: MultiVector) -> Sphere {
    return Sphere(self_.g9, self_.g10);
}

fn multi_vector_translator_into(self_: MultiVector) -> Translator {
    return Translator(vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g0.y));
}

fn plane_horizon_into(self_: Plane) -> Horizon {
    return Horizon(self_.g0.w);
}

fn plane_plane_at_origin_into(self_: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn rotor_anti_scalar_into(self_: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn rotor_line_at_origin_into(self_: Rotor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn round_point_infinity_into(self_: RoundPoint) -> Infinity {
    return Infinity(self_.g1.y);
}

fn round_point_origin_into(self_: RoundPoint) -> Origin {
    return Origin(self_.g1.x);
}

fn sphere_horizon_into(self_: Sphere) -> Horizon {
    return Horizon(self_.g1.y);
}

fn sphere_plane_into(self_: Sphere) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g1.y));
}

fn sphere_plane_at_origin_into(self_: Sphere) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0);
}

fn translator_anti_scalar_into(self_: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn translator_line_at_infinity_into(self_: Translator) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn anti_scalar_anti_scalar_mul(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn circle_circle_mul(self_: Circle, other: Circle) -> Circle {
    return Circle(self_.g0 * other.g0, self_.g1 * other.g1, self_.g2 * other.g2);
}

fn dipole_dipole_mul(self_: Dipole, other: Dipole) -> Dipole {
    return Dipole(self_.g0 * other.g0, self_.g1 * other.g1, self_.g2 * other.g2);
}

fn flat_point_flat_point_mul(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 * other.g0);
}

fn flector_flector_mul(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn horizon_horizon_mul(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_infinity_mul(self_: Infinity, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn line_line_mul(self_: Line, other: Line) -> Line {
    return Line(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn line_at_infinity_line_at_infinity_mul(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * other.g0);
}

fn line_at_origin_line_at_origin_mul(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * other.g0);
}

fn magnitude_magnitude_mul(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 * other.g0);
}

fn motor_motor_mul(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn multi_vector_multi_vector_mul(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * other.g0, self_.g1 * other.g1, self_.g2 * other.g2, self_.g3 * other.g3, self_.g4 * other.g4, self_.g5 * other.g5, self_.g6 * other.g6, self_.g7 * other.g7, self_.g8 * other.g8, self_.g9 * other.g9, self_.g10 * other.g10);
}

fn origin_origin_mul(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn plane_plane_mul(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0 * other.g0);
}

fn plane_at_origin_plane_at_origin_mul(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * other.g0);
}

fn point_at_infinity_point_at_infinity_mul(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * other.g0);
}

fn point_at_origin_point_at_origin_mul(self_: PointAtOrigin, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn rotor_rotor_mul(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0 * other.g0);
}

fn round_point_round_point_mul(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn scalar_scalar_mul(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn sphere_sphere_mul(self_: Sphere, other: Sphere) -> Sphere {
    return Sphere(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn translator_translator_mul(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0 * other.g0);
}

fn anti_scalar_anti_scalar_sub(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 - other.g0);
}

fn anti_scalar_line_sub(self_: AntiScalar, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0) - other.g1);
}

fn anti_scalar_line_at_infinity_sub(self_: AntiScalar, other: LineAtInfinity) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_line_at_origin_sub(self_: AntiScalar, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_magnitude_sub(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) - other.g0);
}

fn anti_scalar_motor_sub(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0, vec3<f32>(0.0) - other.g1);
}

fn anti_scalar_multi_vector_sub(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn anti_scalar_rotor_sub(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn anti_scalar_scalar_sub(self_: AntiScalar, other: Scalar) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) - vec2<f32>(other.g0, 0.0));
}

fn anti_scalar_translator_sub(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn circle_circle_sub(self_: Circle, other: Circle) -> Circle {
    return Circle(self_.g0 - other.g0, self_.g1 - other.g1, self_.g2 - other.g2);
}

fn circle_line_sub(self_: Circle, other: Line) -> Circle {
    return Circle(self_.g0, self_.g1 - other.g0, self_.g2 - other.g1);
}

fn circle_line_at_infinity_sub(self_: Circle, other: LineAtInfinity) -> Circle {
    return Circle(self_.g0, self_.g1, self_.g2 - other.g0);
}

fn circle_line_at_origin_sub(self_: Circle, other: LineAtOrigin) -> Circle {
    return Circle(self_.g0, self_.g1 - other.g0, self_.g2);
}

fn circle_multi_vector_sub(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, self_.g0 - other.g6, self_.g1 - other.g7, self_.g2 - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn dipole_dipole_sub(self_: Dipole, other: Dipole) -> Dipole {
    return Dipole(self_.g0 - other.g0, self_.g1 - other.g1, self_.g2 - other.g2);
}

fn dipole_flat_point_sub(self_: Dipole, other: FlatPoint) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2 - other.g0);
}

fn dipole_multi_vector_sub(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, self_.g0 - other.g3, self_.g1 - other.g4, self_.g2 - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn dipole_point_at_infinity_sub(self_: Dipole, other: PointAtInfinity) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn dipole_point_at_origin_sub(self_: Dipole, other: PointAtOrigin) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flat_point_dipole_sub(self_: FlatPoint, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, self_.g0 - other.g2);
}

fn flat_point_flat_point_sub(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 - other.g0);
}

fn flat_point_flector_sub(self_: FlatPoint, other: Flector) -> Flector {
    return Flector(self_.g0 - other.g0, vec4<f32>(0.0) - other.g1);
}

fn flat_point_multi_vector_sub(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, self_.g0 - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn flat_point_plane_sub(self_: FlatPoint, other: Plane) -> Flector {
    return Flector(self_.g0, vec4<f32>(0.0) - other.g0);
}

fn flat_point_point_at_infinity_sub(self_: FlatPoint, other: PointAtInfinity) -> FlatPoint {
    return FlatPoint(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flat_point_point_at_origin_sub(self_: FlatPoint, other: PointAtOrigin) -> FlatPoint {
    return FlatPoint(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_flat_point_sub(self_: Flector, other: FlatPoint) -> Flector {
    return Flector(self_.g0 - other.g0, self_.g1);
}

fn flector_flector_sub(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn flector_horizon_sub(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g0, self_.g1 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_multi_vector_sub(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, self_.g0 - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) - other.g9, vec2<f32>(0.0, self_.g1.w) - other.g10);
}

fn flector_plane_sub(self_: Flector, other: Plane) -> Flector {
    return Flector(self_.g0, self_.g1 - other.g0);
}

fn flector_plane_at_origin_sub(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0, self_.g1 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_point_at_infinity_sub(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn flector_point_at_origin_sub(self_: Flector, other: PointAtOrigin) -> Flector {
    return Flector(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn horizon_flector_sub(self_: Horizon, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g1);
}

fn horizon_horizon_sub(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 - other.g0);
}

fn horizon_multi_vector_sub(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0, self_.g0) - other.g10);
}

fn horizon_plane_sub(self_: Horizon, other: Plane) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn horizon_plane_at_origin_sub(self_: Horizon, other: PlaneAtOrigin) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_sphere_sub(self_: Horizon, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(0.0) - other.g0, vec2<f32>(0.0, self_.g0) - other.g1);
}

fn infinity_infinity_sub(self_: Infinity, other: Infinity) -> Infinity {
    return Infinity(self_.g0 - other.g0);
}

fn infinity_multi_vector_sub(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0, self_.g0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn infinity_round_point_sub(self_: Infinity, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - other.g0, vec2<f32>(0.0, self_.g0) - other.g1);
}

fn line_anti_scalar_sub(self_: Line, other: AntiScalar) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn line_circle_sub(self_: Line, other: Circle) -> Circle {
    return Circle(vec4<f32>(0.0) - other.g0, self_.g0 - other.g1, self_.g1 - other.g2);
}

fn line_line_sub(self_: Line, other: Line) -> Line {
    return Line(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn line_line_at_infinity_sub(self_: Line, other: LineAtInfinity) -> Line {
    return Line(self_.g0, self_.g1 - other.g0);
}

fn line_line_at_origin_sub(self_: Line, other: LineAtOrigin) -> Line {
    return Line(self_.g0 - other.g0, self_.g1);
}

fn line_motor_sub(self_: Line, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, self_.g1 - other.g1);
}

fn line_multi_vector_sub(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, self_.g0 - other.g7, self_.g1 - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn line_rotor_sub(self_: Line, other: Rotor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, self_.g1);
}

fn line_translator_sub(self_: Line, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn line_at_infinity_anti_scalar_sub(self_: LineAtInfinity, other: AntiScalar) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_infinity_circle_sub(self_: LineAtInfinity, other: Circle) -> Circle {
    return Circle(vec4<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, self_.g0 - other.g2);
}

fn line_at_infinity_line_sub(self_: LineAtInfinity, other: Line) -> Line {
    return Line(vec3<f32>(0.0) - other.g0, self_.g0 - other.g1);
}

fn line_at_infinity_line_at_infinity_sub(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 - other.g0);
}

fn line_at_infinity_line_at_origin_sub(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(0.0) - other.g0, self_.g0);
}

fn line_at_infinity_motor_sub(self_: LineAtInfinity, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0) - other.g0, self_.g0 - other.g1);
}

fn line_at_infinity_multi_vector_sub(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, self_.g0 - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn line_at_infinity_rotor_sub(self_: LineAtInfinity, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0) - other.g0, self_.g0);
}

fn line_at_infinity_translator_sub(self_: LineAtInfinity, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn line_at_origin_anti_scalar_sub(self_: LineAtOrigin, other: AntiScalar) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_origin_circle_sub(self_: LineAtOrigin, other: Circle) -> Circle {
    return Circle(vec4<f32>(0.0) - other.g0, self_.g0 - other.g1, vec3<f32>(0.0) - other.g2);
}

fn line_at_origin_line_sub(self_: LineAtOrigin, other: Line) -> Line {
    return Line(self_.g0 - other.g0, vec3<f32>(0.0) - other.g1);
}

fn line_at_origin_line_at_infinity_sub(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return Line(self_.g0, vec3<f32>(0.0) - other.g0);
}

fn line_at_origin_line_at_origin_sub(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 - other.g0);
}

fn line_at_origin_motor_sub(self_: LineAtOrigin, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, vec3<f32>(0.0) - other.g1);
}

fn line_at_origin_multi_vector_sub(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, self_.g0 - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn line_at_origin_rotor_sub(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn line_at_origin_translator_sub(self_: LineAtOrigin, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn magnitude_anti_scalar_sub(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 - vec2<f32>(0.0, other.g0));
}

fn magnitude_magnitude_sub(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 - other.g0);
}

fn magnitude_multi_vector_sub(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn magnitude_scalar_sub(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 - vec2<f32>(other.g0, 0.0));
}

fn motor_anti_scalar_sub(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn motor_line_sub(self_: Motor, other: Line) -> Motor {
    return Motor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 - other.g1);
}

fn motor_line_at_infinity_sub(self_: Motor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, self_.g1 - other.g0);
}

fn motor_line_at_origin_sub(self_: Motor, other: LineAtOrigin) -> Motor {
    return Motor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn motor_motor_sub(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn motor_multi_vector_sub(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g7, self_.g1 - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn motor_rotor_sub(self_: Motor, other: Rotor) -> Motor {
    return Motor(self_.g0 - other.g0, self_.g1);
}

fn motor_translator_sub(self_: Motor, other: Translator) -> Motor {
    return Motor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn multi_vector_anti_scalar_sub(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_circle_sub(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6 - other.g0, self_.g7 - other.g1, self_.g8 - other.g2, self_.g9, self_.g10);
}

fn multi_vector_dipole_sub(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3 - other.g0, self_.g4 - other.g1, self_.g5 - other.g2, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_flat_point_sub(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 - other.g0, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_flector_sub(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 - other.g0, self_.g6, self_.g7, self_.g8, self_.g9 - vec3<f32>(other.g1.x, other.g1.y, other.g1.z), self_.g10 - vec2<f32>(0.0, other.g1.w));
}

fn multi_vector_horizon_sub(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10 - vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_sub(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 - vec2<f32>(0.0, other.g0), self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_line_sub(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 - other.g0, self_.g8 - other.g1, self_.g9, self_.g10);
}

fn multi_vector_line_at_infinity_sub(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8 - other.g0, self_.g9, self_.g10);
}

fn multi_vector_line_at_origin_sub(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 - other.g0, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_magnitude_sub(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(self_.g0 - other.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_motor_sub(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g8 - other.g1, self_.g9, self_.g10);
}

fn multi_vector_multi_vector_sub(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 - other.g0, self_.g1 - other.g1, self_.g2 - other.g2, self_.g3 - other.g3, self_.g4 - other.g4, self_.g5 - other.g5, self_.g6 - other.g6, self_.g7 - other.g7, self_.g8 - other.g8, self_.g9 - other.g9, self_.g10 - other.g10);
}

fn multi_vector_origin_sub(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 - vec2<f32>(other.g0, 0.0), self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_plane_sub(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g10 - vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_sub(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9 - other.g0, self_.g10);
}

fn multi_vector_point_at_infinity_sub(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_point_at_origin_sub(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5 - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_rotor_sub(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g8, self_.g9, self_.g10);
}

fn multi_vector_round_point_sub(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 - other.g0, self_.g2 - other.g1, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_scalar_sub(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(other.g0, 0.0), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn multi_vector_sphere_sub(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9 - other.g0, self_.g10 - other.g1);
}

fn multi_vector_translator_sub(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g9, self_.g10);
}

fn origin_multi_vector_sub(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(self_.g0, 0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn origin_origin_sub(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 - other.g0);
}

fn origin_round_point_sub(self_: Origin, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - other.g0, vec2<f32>(self_.g0, 0.0) - other.g1);
}

fn plane_flat_point_sub(self_: Plane, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, self_.g0);
}

fn plane_flector_sub(self_: Plane, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, self_.g0 - other.g1);
}

fn plane_horizon_sub(self_: Plane, other: Horizon) -> Plane {
    return Plane(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_multi_vector_sub(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g9, vec2<f32>(0.0, self_.g0.w) - other.g10);
}

fn plane_plane_sub(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0 - other.g0);
}

fn plane_plane_at_origin_sub(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return Plane(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_sphere_sub(self_: Plane, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g0, vec2<f32>(0.0, self_.g0.w) - other.g1);
}

fn plane_at_origin_flector_sub(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g1);
}

fn plane_at_origin_horizon_sub(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_at_origin_multi_vector_sub(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, self_.g0 - other.g9, vec2<f32>(0.0) - other.g10);
}

fn plane_at_origin_plane_sub(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn plane_at_origin_plane_at_origin_sub(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 - other.g0);
}

fn plane_at_origin_sphere_sub(self_: PlaneAtOrigin, other: Sphere) -> Sphere {
    return Sphere(self_.g0 - other.g0, vec2<f32>(0.0) - other.g1);
}

fn point_at_infinity_dipole_sub(self_: PointAtInfinity, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g2);
}

fn point_at_infinity_flat_point_sub(self_: PointAtInfinity, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn point_at_infinity_flector_sub(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, vec4<f32>(0.0) - other.g1);
}

fn point_at_infinity_multi_vector_sub(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn point_at_infinity_point_at_infinity_sub(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 - other.g0);
}

fn point_at_infinity_point_at_origin_sub(self_: PointAtInfinity, other: PointAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn point_at_origin_dipole_sub(self_: PointAtOrigin, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g2);
}

fn point_at_origin_flat_point_sub(self_: PointAtOrigin, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn point_at_origin_flector_sub(self_: PointAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0, vec4<f32>(0.0) - other.g1);
}

fn point_at_origin_multi_vector_sub(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn point_at_origin_point_at_infinity_sub(self_: PointAtOrigin, other: PointAtInfinity) -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_point_at_origin_sub(self_: PointAtOrigin, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 - other.g0);
}

fn rotor_anti_scalar_sub(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_sub(self_: Rotor, other: Line) -> Motor {
    return Motor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0) - other.g1);
}

fn rotor_line_at_infinity_sub(self_: Rotor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, vec3<f32>(0.0) - other.g0);
}

fn rotor_line_at_origin_sub(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_motor_sub(self_: Rotor, other: Motor) -> Motor {
    return Motor(self_.g0 - other.g0, vec3<f32>(0.0) - other.g1);
}

fn rotor_multi_vector_sub(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn rotor_rotor_sub(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0 - other.g0);
}

fn rotor_translator_sub(self_: Rotor, other: Translator) -> Motor {
    return Motor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn round_point_infinity_sub(self_: RoundPoint, other: Infinity) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1 - vec2<f32>(0.0, other.g0));
}

fn round_point_multi_vector_sub(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, self_.g0 - other.g1, self_.g1 - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn round_point_origin_sub(self_: RoundPoint, other: Origin) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1 - vec2<f32>(other.g0, 0.0));
}

fn round_point_round_point_sub(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn scalar_anti_scalar_sub(self_: Scalar, other: AntiScalar) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) - vec2<f32>(0.0, other.g0));
}

fn scalar_magnitude_sub(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) - other.g0);
}

fn scalar_multi_vector_sub(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0, 0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn scalar_scalar_sub(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 - other.g0);
}

fn sphere_horizon_sub(self_: Sphere, other: Horizon) -> Sphere {
    return Sphere(self_.g0, self_.g1 - vec2<f32>(0.0, other.g0));
}

fn sphere_multi_vector_sub(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(0.0) - other.g8, self_.g0 - other.g9, self_.g1 - other.g10);
}

fn sphere_plane_sub(self_: Sphere, other: Plane) -> Sphere {
    return Sphere(self_.g0 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 - vec2<f32>(0.0, other.g0.w));
}

fn sphere_plane_at_origin_sub(self_: Sphere, other: PlaneAtOrigin) -> Sphere {
    return Sphere(self_.g0 - other.g0, self_.g1);
}

fn sphere_sphere_sub(self_: Sphere, other: Sphere) -> Sphere {
    return Sphere(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn translator_anti_scalar_sub(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn translator_line_sub(self_: Translator, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g1);
}

fn translator_line_at_infinity_sub(self_: Translator, other: LineAtInfinity) -> Translator {
    return Translator(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_line_at_origin_sub(self_: Translator, other: LineAtOrigin) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_motor_sub(self_: Translator, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g1);
}

fn translator_multi_vector_sub(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) - other.g0, vec3<f32>(0.0) - other.g1, vec2<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec3<f32>(0.0) - other.g4, vec4<f32>(0.0) - other.g5, vec4<f32>(0.0) - other.g6, vec3<f32>(0.0) - other.g7, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g8, vec3<f32>(0.0) - other.g9, vec2<f32>(0.0) - other.g10);
}

fn translator_rotor_sub(self_: Translator, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_translator_sub(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0 - other.g0);
}

fn anti_scalar_anti_scalar_anti_wedge_dot(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_circle_anti_wedge_dot(self_: AntiScalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn anti_scalar_dipole_anti_wedge_dot(self_: AntiScalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn anti_scalar_flat_point_anti_wedge_dot(self_: AntiScalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_flector_anti_wedge_dot(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_anti_wedge_dot(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_infinity_anti_wedge_dot(self_: AntiScalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn anti_scalar_line_anti_wedge_dot(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_anti_wedge_dot(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_anti_wedge_dot(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_anti_wedge_dot(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_anti_wedge_dot(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_anti_wedge_dot(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn anti_scalar_origin_anti_wedge_dot(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_anti_wedge_dot(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_anti_wedge_dot(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_anti_wedge_dot(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_origin_anti_wedge_dot(self_: AntiScalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn anti_scalar_rotor_anti_wedge_dot(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_round_point_anti_wedge_dot(self_: AntiScalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_scalar_anti_wedge_dot(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_sphere_anti_wedge_dot(self_: AntiScalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_translator_anti_wedge_dot(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn circle_anti_scalar_anti_wedge_dot(self_: Circle, other: AntiScalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn circle_circle_anti_wedge_dot(self_: Circle, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, other.g2.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.w) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_dipole_anti_wedge_dot(self_: Circle, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g2.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g2.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g2.w) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g0.wwwz * other.g2.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn circle_flat_point_anti_wedge_dot(self_: Circle, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_flector_anti_wedge_dot(self_: Circle, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn circle_horizon_anti_wedge_dot(self_: Circle, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0));
}

fn circle_infinity_anti_wedge_dot(self_: Circle, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_line_anti_wedge_dot(self_: Circle, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_line_at_infinity_anti_wedge_dot(self_: Circle, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_line_at_origin_anti_wedge_dot(self_: Circle, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_magnitude_anti_wedge_dot(self_: Circle, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_motor_anti_wedge_dot(self_: Circle, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_multi_vector_anti_wedge_dot(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g5.z, other.g8.z) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g5.w, other.g6.w) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, -other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, -other.g2.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, -other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g6.w, -other.g7.z, other.g7.y, other.g8.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, other.g6.w, -other.g7.x, other.g8.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, other.g6.w, other.g8.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g6.x, -other.g6.y, -other.g6.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.w) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z));
}

fn circle_origin_anti_wedge_dot(self_: Circle, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g2 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g2 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_plane_anti_wedge_dot(self_: Circle, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_plane_at_origin_anti_wedge_dot(self_: Circle, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_point_at_infinity_anti_wedge_dot(self_: Circle, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_point_at_origin_anti_wedge_dot(self_: Circle, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn circle_rotor_anti_wedge_dot(self_: Circle, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_round_point_anti_wedge_dot(self_: Circle, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_scalar_anti_wedge_dot(self_: Circle, other: Scalar) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn circle_sphere_anti_wedge_dot(self_: Circle, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_translator_anti_wedge_dot(self_: Circle, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_anti_scalar_anti_wedge_dot(self_: Dipole, other: AntiScalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_circle_anti_wedge_dot(self_: Dipole, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn dipole_dipole_anti_wedge_dot(self_: Dipole, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g2.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_flat_point_anti_wedge_dot(self_: Dipole, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_flector_anti_wedge_dot(self_: Dipole, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_horizon_anti_wedge_dot(self_: Dipole, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_infinity_anti_wedge_dot(self_: Dipole, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0));
}

fn dipole_line_anti_wedge_dot(self_: Dipole, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_line_at_infinity_anti_wedge_dot(self_: Dipole, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_line_at_origin_anti_wedge_dot(self_: Dipole, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_magnitude_anti_wedge_dot(self_: Dipole, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0.x, -other.g0.x, -other.g0.x, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_motor_anti_wedge_dot(self_: Dipole, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_multi_vector_anti_wedge_dot(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g8.x, other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g8.y, other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g8.z, other.g5.z) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g7.x, other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g7.y, other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g7.z, other.g4.z) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g2.w) * vec2<f32>(other.g6.w, other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g2.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g2.w) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.y, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g2.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.y, -other.g8.z, other.g8.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g8.z, other.g2.y, -other.g8.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g8.y, other.g8.x, other.g2.y, other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y), vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, -other.g5.x) + vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, -other.g5.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, -other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, -other.g0.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g2.w) * other.g9, vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g2.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * other.g2 * vec2<f32>(1.0, -1.0));
}

fn dipole_origin_anti_wedge_dot(self_: Dipole, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(other.g0, 0.0));
}

fn dipole_plane_anti_wedge_dot(self_: Dipole, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_plane_at_origin_anti_wedge_dot(self_: Dipole, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_point_at_infinity_anti_wedge_dot(self_: Dipole, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_point_at_origin_anti_wedge_dot(self_: Dipole, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_rotor_anti_wedge_dot(self_: Dipole, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g2.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_round_point_anti_wedge_dot(self_: Dipole, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn dipole_scalar_anti_wedge_dot(self_: Dipole, other: Scalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0));
}

fn dipole_sphere_anti_wedge_dot(self_: Dipole, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.x, -other.g0.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_translator_anti_wedge_dot(self_: Dipole, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g2.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn flat_point_anti_scalar_anti_wedge_dot(self_: FlatPoint, other: AntiScalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_circle_anti_wedge_dot(self_: FlatPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn flat_point_dipole_anti_wedge_dot(self_: FlatPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_flat_point_anti_wedge_dot(self_: FlatPoint, other: FlatPoint) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flat_point_flector_anti_wedge_dot(self_: FlatPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_horizon_anti_wedge_dot(self_: FlatPoint, other: Horizon) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn flat_point_infinity_anti_wedge_dot(self_: FlatPoint, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0.w * other.g0);
}

fn flat_point_line_anti_wedge_dot(self_: FlatPoint, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn flat_point_line_at_infinity_anti_wedge_dot(self_: FlatPoint, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_line_at_origin_anti_wedge_dot(self_: FlatPoint, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn flat_point_magnitude_anti_wedge_dot(self_: FlatPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_motor_anti_wedge_dot(self_: FlatPoint, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flat_point_multi_vector_anti_wedge_dot(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g6.w, other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g0.w) * other.g9, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g0.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(1.0, -1.0));
}

fn flat_point_origin_anti_wedge_dot(self_: FlatPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0));
}

fn flat_point_plane_anti_wedge_dot(self_: FlatPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_plane_at_origin_anti_wedge_dot(self_: FlatPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_point_at_infinity_anti_wedge_dot(self_: FlatPoint, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_point_at_origin_anti_wedge_dot(self_: FlatPoint, other: PointAtOrigin) -> Translator {
    return Translator(vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_rotor_anti_wedge_dot(self_: FlatPoint, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flat_point_round_point_anti_wedge_dot(self_: FlatPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn flat_point_scalar_anti_wedge_dot(self_: FlatPoint, other: Scalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn flat_point_sphere_anti_wedge_dot(self_: FlatPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_translator_anti_wedge_dot(self_: FlatPoint, other: Translator) -> FlatPoint {
    return FlatPoint(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn flector_anti_scalar_anti_wedge_dot(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_circle_anti_wedge_dot(self_: Flector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w));
}

fn flector_dipole_anti_wedge_dot(self_: Flector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g2.w) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g1.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_flat_point_anti_wedge_dot(self_: Flector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_flector_anti_wedge_dot(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_horizon_anti_wedge_dot(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_infinity_anti_wedge_dot(self_: Flector, other: Infinity) -> Flector {
    return Flector(self_.g1.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn flector_line_anti_wedge_dot(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z));
}

fn flector_line_at_infinity_anti_wedge_dot(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn flector_line_at_origin_anti_wedge_dot(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn flector_magnitude_anti_wedge_dot(self_: Flector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y));
}

fn flector_motor_anti_wedge_dot(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn flector_multi_vector_anti_wedge_dot(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g6.w, other.g5.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g1.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g1.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g1.w) * other.g9 - vec3<f32>(self_.g1.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g6.z, other.g8.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y));
}

fn flector_origin_anti_wedge_dot(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0));
}

fn flector_plane_anti_wedge_dot(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_plane_at_origin_anti_wedge_dot(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_point_at_infinity_anti_wedge_dot(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_point_at_origin_anti_wedge_dot(self_: Flector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_rotor_anti_wedge_dot(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g1.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn flector_round_point_anti_wedge_dot(self_: Flector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + self_.g1.xyzx * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) - vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn flector_scalar_anti_wedge_dot(self_: Flector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_sphere_anti_wedge_dot(self_: Flector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_translator_anti_wedge_dot(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_anti_scalar_anti_wedge_dot(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_circle_anti_wedge_dot(self_: Horizon, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w));
}

fn horizon_dipole_anti_wedge_dot(self_: Horizon, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_flat_point_anti_wedge_dot(self_: Horizon, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0.w);
}

fn horizon_flector_anti_wedge_dot(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_line_anti_wedge_dot(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_anti_wedge_dot(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_anti_wedge_dot(self_: Horizon, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y));
}

fn horizon_motor_anti_wedge_dot(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_anti_wedge_dot(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9 - vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y));
}

fn horizon_origin_anti_wedge_dot(self_: Horizon, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_plane_anti_wedge_dot(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_anti_wedge_dot(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_origin_anti_wedge_dot(self_: Horizon, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn horizon_rotor_anti_wedge_dot(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_round_point_anti_wedge_dot(self_: Horizon, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_scalar_anti_wedge_dot(self_: Horizon, other: Scalar) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn horizon_sphere_anti_wedge_dot(self_: Horizon, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_translator_anti_wedge_dot(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn infinity_anti_scalar_anti_wedge_dot(self_: Infinity, other: AntiScalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_circle_anti_wedge_dot(self_: Infinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_dipole_anti_wedge_dot(self_: Infinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g2.w));
}

fn infinity_flat_point_anti_wedge_dot(self_: Infinity, other: FlatPoint) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn infinity_flector_anti_wedge_dot(self_: Infinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn infinity_line_anti_wedge_dot(self_: Infinity, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn infinity_line_at_origin_anti_wedge_dot(self_: Infinity, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn infinity_magnitude_anti_wedge_dot(self_: Infinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn infinity_motor_anti_wedge_dot(self_: Infinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_multi_vector_anti_wedge_dot(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, -other.g10.x) + vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0) * other.g7 - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn infinity_origin_anti_wedge_dot(self_: Infinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_plane_anti_wedge_dot(self_: Infinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn infinity_plane_at_origin_anti_wedge_dot(self_: Infinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn infinity_point_at_origin_anti_wedge_dot(self_: Infinity, other: PointAtOrigin) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_rotor_anti_wedge_dot(self_: Infinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_round_point_anti_wedge_dot(self_: Infinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_scalar_anti_wedge_dot(self_: Infinity, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_sphere_anti_wedge_dot(self_: Infinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_translator_anti_wedge_dot(self_: Infinity, other: Translator) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn line_anti_scalar_anti_wedge_dot(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_circle_anti_wedge_dot(self_: Line, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_dipole_anti_wedge_dot(self_: Line, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_flat_point_anti_wedge_dot(self_: Line, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn line_flector_anti_wedge_dot(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z));
}

fn line_horizon_anti_wedge_dot(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_infinity_anti_wedge_dot(self_: Line, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_anti_wedge_dot(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_line_at_infinity_anti_wedge_dot(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_line_at_origin_anti_wedge_dot(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_magnitude_anti_wedge_dot(self_: Line, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_motor_anti_wedge_dot(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_multi_vector_anti_wedge_dot(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z));
}

fn line_origin_anti_wedge_dot(self_: Line, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_plane_anti_wedge_dot(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_plane_at_origin_anti_wedge_dot(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_point_at_infinity_anti_wedge_dot(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_point_at_origin_anti_wedge_dot(self_: Line, other: PointAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn line_rotor_anti_wedge_dot(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_round_point_anti_wedge_dot(self_: Line, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_scalar_anti_wedge_dot(self_: Line, other: Scalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn line_sphere_anti_wedge_dot(self_: Line, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn line_translator_anti_wedge_dot(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_anti_scalar_anti_wedge_dot(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_circle_anti_wedge_dot(self_: LineAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_dipole_anti_wedge_dot(self_: LineAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_at_infinity_flat_point_anti_wedge_dot(self_: LineAtInfinity, other: FlatPoint) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_infinity_flector_anti_wedge_dot(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z));
}

fn line_at_infinity_line_anti_wedge_dot(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_line_at_origin_anti_wedge_dot(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_magnitude_anti_wedge_dot(self_: LineAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_motor_anti_wedge_dot(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_multi_vector_anti_wedge_dot(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn line_at_infinity_origin_anti_wedge_dot(self_: LineAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_anti_wedge_dot(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_at_infinity_plane_at_origin_anti_wedge_dot(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_at_infinity_point_at_origin_anti_wedge_dot(self_: LineAtInfinity, other: PointAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_rotor_anti_wedge_dot(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_round_point_anti_wedge_dot(self_: LineAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_scalar_anti_wedge_dot(self_: LineAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_sphere_anti_wedge_dot(self_: LineAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn line_at_infinity_translator_anti_wedge_dot(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_anti_wedge_dot(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_circle_anti_wedge_dot(self_: LineAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_dipole_anti_wedge_dot(self_: LineAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn line_at_origin_flat_point_anti_wedge_dot(self_: LineAtOrigin, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn line_at_origin_flector_anti_wedge_dot(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z));
}

fn line_at_origin_horizon_anti_wedge_dot(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_infinity_anti_wedge_dot(self_: LineAtOrigin, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_anti_wedge_dot(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_line_at_infinity_anti_wedge_dot(self_: LineAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_line_at_origin_anti_wedge_dot(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, -other.g0.z));
}

fn line_at_origin_magnitude_anti_wedge_dot(self_: LineAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_motor_anti_wedge_dot(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_multi_vector_anti_wedge_dot(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z));
}

fn line_at_origin_origin_anti_wedge_dot(self_: LineAtOrigin, other: Origin) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn line_at_origin_plane_anti_wedge_dot(self_: LineAtOrigin, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_at_origin_plane_at_origin_anti_wedge_dot(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_at_origin_point_at_infinity_anti_wedge_dot(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_at_origin_point_at_origin_anti_wedge_dot(self_: LineAtOrigin, other: PointAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_rotor_anti_wedge_dot(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_round_point_anti_wedge_dot(self_: LineAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_scalar_anti_wedge_dot(self_: LineAtOrigin, other: Scalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn line_at_origin_sphere_anti_wedge_dot(self_: LineAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0));
}

fn line_at_origin_translator_anti_wedge_dot(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_anti_scalar_anti_wedge_dot(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_circle_anti_wedge_dot(self_: Magnitude, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g0.w), vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_dipole_anti_wedge_dot(self_: Magnitude, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * other.g2, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g2.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flat_point_anti_wedge_dot(self_: Magnitude, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flector_anti_wedge_dot(self_: Magnitude, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w));
}

fn magnitude_horizon_anti_wedge_dot(self_: Magnitude, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0));
}

fn magnitude_infinity_anti_wedge_dot(self_: Magnitude, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0));
}

fn magnitude_line_anti_wedge_dot(self_: Magnitude, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_infinity_anti_wedge_dot(self_: Magnitude, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_origin_anti_wedge_dot(self_: Magnitude, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_magnitude_anti_wedge_dot(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_anti_wedge_dot(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_multi_vector_anti_wedge_dot(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g10 + vec2<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g0.y) * other.g3, vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, -other.g6.w) + vec4<f32>(self_.g0.y) * other.g5, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g5.w) + vec4<f32>(self_.g0.y) * other.g6, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g4 + vec3<f32>(self_.g0.y) * other.g7, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g0.y) * other.g8, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g0.y) * other.g9, vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10);
}

fn magnitude_origin_anti_wedge_dot(self_: Magnitude, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0));
}

fn magnitude_plane_anti_wedge_dot(self_: Magnitude, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w));
}

fn magnitude_plane_at_origin_anti_wedge_dot(self_: Magnitude, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0));
}

fn magnitude_point_at_infinity_anti_wedge_dot(self_: Magnitude, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_point_at_origin_anti_wedge_dot(self_: Magnitude, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_rotor_anti_wedge_dot(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_round_point_anti_wedge_dot(self_: Magnitude, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_scalar_anti_wedge_dot(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0.yx * vec2<f32>(other.g0));
}

fn magnitude_sphere_anti_wedge_dot(self_: Magnitude, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_translator_anti_wedge_dot(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_anti_scalar_anti_wedge_dot(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_circle_anti_wedge_dot(self_: Motor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_dipole_anti_wedge_dot(self_: Motor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g2 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn motor_flat_point_anti_wedge_dot(self_: Motor, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn motor_flector_anti_wedge_dot(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z));
}

fn motor_horizon_anti_wedge_dot(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_infinity_anti_wedge_dot(self_: Motor, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_anti_wedge_dot(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_infinity_anti_wedge_dot(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_origin_anti_wedge_dot(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_magnitude_anti_wedge_dot(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_motor_anti_wedge_dot(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_multi_vector_anti_wedge_dot(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z) + vec2<f32>(self_.g0.w) * other.g0 - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g6 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z));
}

fn motor_origin_anti_wedge_dot(self_: Motor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_plane_anti_wedge_dot(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn motor_plane_at_origin_anti_wedge_dot(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn motor_point_at_infinity_anti_wedge_dot(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn motor_point_at_origin_anti_wedge_dot(self_: Motor, other: PointAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn motor_rotor_anti_wedge_dot(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_round_point_anti_wedge_dot(self_: Motor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0 + self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_scalar_anti_wedge_dot(self_: Motor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_sphere_anti_wedge_dot(self_: Motor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0 - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn motor_translator_anti_wedge_dot(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_anti_scalar_anti_wedge_dot(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_circle_anti_wedge_dot(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g2.x) * other.g2 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g2 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g0.w) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, other.g2.y) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, other.g2.z) + vec4<f32>(self_.g6.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.y) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * other.g2 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.y) * other.g1 + vec3<f32>(self_.g6.w) * other.g2 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * other.g2 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_dipole_anti_wedge_dot(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g2.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g2.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g10.y) * other.g0, vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(other.g2.w), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g2.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, -other.g2.w, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g2.w) - vec3<f32>(self_.g6.w) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g1 - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * other.g2 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, other.g1.z) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g6.wwwz * other.g2.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g2.w) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g5.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g2.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g10.y) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(-other.g2.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_flat_point_anti_wedge_dot(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + self_.g2 * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_flector_anti_wedge_dot(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g2.y, self_.g2.y, self_.g2.y, self_.g2.x) * other.g1 + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g3.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + self_.g2 * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_horizon_anti_wedge_dot(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0) + self_.g9 * vec3<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_anti_wedge_dot(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), self_.g3 * vec3<f32>(other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0) + self_.g7 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0));
}

fn multi_vector_line_anti_wedge_dot(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z));
}

fn multi_vector_line_at_infinity_anti_wedge_dot(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_line_at_origin_anti_wedge_dot(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_magnitude_anti_wedge_dot(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec3<f32>(other.g0.y) + self_.g9 * vec3<f32>(other.g0.x), self_.g2 * vec2<f32>(other.g0.y) - self_.g10 * vec2<f32>(other.g0.x), self_.g3 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.x), self_.g4 * vec3<f32>(other.g0.y) + self_.g7 * vec3<f32>(other.g0.x), self_.g5 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(-other.g0.x, -other.g0.x, -other.g0.x, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + self_.g6 * vec4<f32>(other.g0.y), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0.x) + self_.g7 * vec3<f32>(other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.x) + self_.g8 * vec3<f32>(other.g0.y), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.x) + self_.g9 * vec3<f32>(other.g0.y), self_.g2 * vec2<f32>(other.g0.x) + self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_motor_anti_wedge_dot(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_multi_vector_anti_wedge_dot(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g9.x, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g9.y, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g9.z, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g10.x, other.g2.x) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g8.x, other.g5.x) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g8.y, other.g5.y) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g8.z, other.g5.z) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g7.x, other.g4.x) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g7.y, other.g4.y) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g7.z, other.g4.z) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g5.w) * vec2<f32>(other.g6.w, other.g5.w) - vec2<f32>(self_.g6.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g6.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g6.z) * vec2<f32>(other.g5.z, other.g8.z) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g5.w, other.g6.w) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g8.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g8.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g8.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g2.y, -other.g10.y) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g2.x) * other.g8 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g5.w) * other.g4 + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g8.z, -other.g2.y, other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g8.y, -other.g8.x, -other.g2.y) + vec3<f32>(self_.g6.w) * other.g7 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g10.y) * other.g3, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g10 + vec2<f32>(self_.g0.y) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g2 * vec2<f32>(other.g6.w) + self_.g2 * vec2<f32>(other.g0.y) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g3.x, other.g5.x) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g3.y, other.g5.y) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g5.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g6.w) * other.g2 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g10 * vec2<f32>(other.g5.w) - self_.g10 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g0.y) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g2.x) * other.g9 + vec3<f32>(self_.g2.x) * other.g4 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.y, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, other.g0.y, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g6.w) * other.g3 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g10.x) * other.g7 + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g6.w) * other.g9 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g10.x) * other.g8 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, -other.g6.w) + vec4<f32>(self_.g0.y) * other.g5 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, other.g4.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g10.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, -other.g10.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g2.y, -other.g8.z, other.g8.y, other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g8.z, other.g2.y, -other.g8.x, other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g8.y, other.g8.x, other.g2.y, other.g1.z) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, -other.g0.x) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g5.w) + vec4<f32>(self_.g0.y) * other.g6 + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.x, other.g6.z, -other.g6.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g6.z, -other.g2.x, other.g6.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g6.y, -other.g6.x, -other.g2.x, -other.g7.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.y) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, -other.g5.x) + vec4<f32>(self_.g3.x) * vec4<f32>(-other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, -other.g5.y) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g4.z, -other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, -other.g4.x, -other.g0.x, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g9.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g9.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g9.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g5.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g6.w, -other.g7.z, other.g7.y, other.g8.x) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g7.z, other.g6.w, -other.g7.x, other.g8.y) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g7.y, other.g7.x, other.g6.w, other.g8.z) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g6.w) * vec4<f32>(-other.g6.x, -other.g6.y, -other.g6.z, other.g0.y) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z) + vec4<f32>(self_.g9.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g4.x, -other.g4.y, -other.g4.z, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g4 + vec3<f32>(self_.g0.y) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * other.g8 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g5.w) * other.g9 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g10.y) * other.g3, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g0.y) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g2.y) * other.g7 - vec3<f32>(self_.g2.y) * other.g1 + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g6.w) * other.g8 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g10.y) * other.g9 - vec3<f32>(self_.g10.y) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g0.y) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g5.w) * other.g7 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g6.w) * other.g4 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g10.x) * other.g8 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g2 * vec2<f32>(-other.g5.w) + self_.g2 * vec2<f32>(other.g0.x) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * other.g2 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g6.w) * other.g10 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g6.z, other.g8.z) + self_.g10 * vec2<f32>(other.g6.w) + self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_origin_anti_wedge_dot(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g0, 0.0), self_.g8 * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0), self_.g4 * vec3<f32>(other.g0) + self_.g9 * vec3<f32>(other.g0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g8 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g0, 0.0));
}

fn multi_vector_plane_anti_wedge_dot(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g2.y, self_.g2.y, self_.g2.y, self_.g2.x) * other.g0 + vec4<f32>(self_.g7.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.x) * other.g0, vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_plane_at_origin_anti_wedge_dot(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * other.g0, vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_infinity_anti_wedge_dot(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_origin_anti_wedge_dot(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0), self_.g4 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0) - self_.g9 * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(-other.g0));
}

fn multi_vector_rotor_anti_wedge_dot(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g5.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g6.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_round_point_anti_wedge_dot(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(self_.g0.y) * other.g0 - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g1.x) + self_.g9 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g10.x) * other.g0, self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.y, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.y, 0.0, other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.y, other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.y) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g2.y) * other.g0 + self_.g7 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0 + self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn multi_vector_scalar_anti_wedge_dot(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g10 * vec2<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0));
}

fn multi_vector_sphere_anti_wedge_dot(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(self_.g0.x) * other.g0 + self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g1.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.x) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, -other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, -other.g1.x, -other.g0.z) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_translator_anti_wedge_dot(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), self_.g1 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g5.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g8 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn origin_anti_scalar_anti_wedge_dot(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_circle_anti_wedge_dot(self_: Origin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g2, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * other.g2, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_dipole_anti_wedge_dot(self_: Origin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g2.w, 0.0));
}

fn origin_flat_point_anti_wedge_dot(self_: Origin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_flector_anti_wedge_dot(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_horizon_anti_wedge_dot(self_: Origin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_infinity_anti_wedge_dot(self_: Origin, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_anti_wedge_dot(self_: Origin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_at_infinity_anti_wedge_dot(self_: Origin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_at_origin_anti_wedge_dot(self_: Origin, other: LineAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_magnitude_anti_wedge_dot(self_: Origin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0));
}

fn origin_motor_anti_wedge_dot(self_: Origin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_multi_vector_anti_wedge_dot(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.y, other.g2.y), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g8, vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9 + vec3<f32>(self_.g0) * other.g4, vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g10.y), vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.y) + vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * other.g8, vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g5.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0));
}

fn origin_plane_anti_wedge_dot(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_plane_at_origin_anti_wedge_dot(self_: Origin, other: PlaneAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_point_at_infinity_anti_wedge_dot(self_: Origin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn origin_point_at_origin_anti_wedge_dot(self_: Origin, other: PointAtOrigin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0));
}

fn origin_rotor_anti_wedge_dot(self_: Origin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_round_point_anti_wedge_dot(self_: Origin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.y), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_scalar_anti_wedge_dot(self_: Origin, other: Scalar) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0));
}

fn origin_sphere_anti_wedge_dot(self_: Origin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.y, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_translator_anti_wedge_dot(self_: Origin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_anti_scalar_anti_wedge_dot(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_circle_anti_wedge_dot(self_: Plane, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w));
}

fn plane_dipole_anti_wedge_dot(self_: Plane, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_flat_point_anti_wedge_dot(self_: Plane, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_flector_anti_wedge_dot(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_horizon_anti_wedge_dot(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_infinity_anti_wedge_dot(self_: Plane, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_anti_wedge_dot(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z));
}

fn plane_line_at_infinity_anti_wedge_dot(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_line_at_origin_anti_wedge_dot(self_: Plane, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn plane_magnitude_anti_wedge_dot(self_: Plane, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y));
}

fn plane_motor_anti_wedge_dot(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_multi_vector_anti_wedge_dot(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g0.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 - vec3<f32>(self_.g0.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y));
}

fn plane_origin_anti_wedge_dot(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_plane_anti_wedge_dot(self_: Plane, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_anti_wedge_dot(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_at_infinity_anti_wedge_dot(self_: Plane, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_point_at_origin_anti_wedge_dot(self_: Plane, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_rotor_anti_wedge_dot(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_round_point_anti_wedge_dot(self_: Plane, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0.xyzx * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) - vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_scalar_anti_wedge_dot(self_: Plane, other: Scalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0));
}

fn plane_sphere_anti_wedge_dot(self_: Plane, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_translator_anti_wedge_dot(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_at_origin_anti_scalar_anti_wedge_dot(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_circle_anti_wedge_dot(self_: PlaneAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z));
}

fn plane_at_origin_dipole_anti_wedge_dot(self_: PlaneAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_flat_point_anti_wedge_dot(self_: PlaneAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_flector_anti_wedge_dot(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_horizon_anti_wedge_dot(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_infinity_anti_wedge_dot(self_: PlaneAtOrigin, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_anti_wedge_dot(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z));
}

fn plane_at_origin_line_at_infinity_anti_wedge_dot(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_at_origin_line_at_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn plane_at_origin_magnitude_anti_wedge_dot(self_: PlaneAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0));
}

fn plane_at_origin_motor_anti_wedge_dot(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z));
}

fn plane_at_origin_multi_vector_anti_wedge_dot(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g8.z));
}

fn plane_at_origin_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: Origin) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_at_origin_plane_anti_wedge_dot(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z));
}

fn plane_at_origin_point_at_infinity_anti_wedge_dot(self_: PlaneAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_point_at_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: PointAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_rotor_anti_wedge_dot(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0));
}

fn plane_at_origin_round_point_anti_wedge_dot(self_: PlaneAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_scalar_anti_wedge_dot(self_: PlaneAtOrigin, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn plane_at_origin_sphere_anti_wedge_dot(self_: PlaneAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_translator_anti_wedge_dot(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z));
}

fn point_at_infinity_anti_scalar_anti_wedge_dot(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_anti_wedge_dot(self_: PointAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn point_at_infinity_dipole_anti_wedge_dot(self_: PointAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_flat_point_anti_wedge_dot(self_: PointAtInfinity, other: FlatPoint) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_flector_anti_wedge_dot(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_line_anti_wedge_dot(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_line_at_origin_anti_wedge_dot(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_magnitude_anti_wedge_dot(self_: PointAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_motor_anti_wedge_dot(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_multi_vector_anti_wedge_dot(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn point_at_infinity_origin_anti_wedge_dot(self_: PointAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_anti_wedge_dot(self_: PointAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_at_origin_anti_wedge_dot(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_point_at_origin_anti_wedge_dot(self_: PointAtInfinity, other: PointAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_rotor_anti_wedge_dot(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_round_point_anti_wedge_dot(self_: PointAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn point_at_infinity_scalar_anti_wedge_dot(self_: PointAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_sphere_anti_wedge_dot(self_: PointAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_translator_anti_wedge_dot(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_origin_anti_scalar_anti_wedge_dot(self_: PointAtOrigin, other: AntiScalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn point_at_origin_circle_anti_wedge_dot(self_: PointAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0));
}

fn point_at_origin_dipole_anti_wedge_dot(self_: PointAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_flat_point_anti_wedge_dot(self_: PointAtOrigin, other: FlatPoint) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_at_origin_flector_anti_wedge_dot(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_horizon_anti_wedge_dot(self_: PointAtOrigin, other: Horizon) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn point_at_origin_infinity_anti_wedge_dot(self_: PointAtOrigin, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn point_at_origin_line_anti_wedge_dot(self_: PointAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_line_at_infinity_anti_wedge_dot(self_: PointAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_line_at_origin_anti_wedge_dot(self_: PointAtOrigin, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_magnitude_anti_wedge_dot(self_: PointAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_motor_anti_wedge_dot(self_: PointAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_multi_vector_anti_wedge_dot(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, other.g5.w), vec3<f32>(self_.g0) * other.g4, vec2<f32>(self_.g0) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9, vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0) * other.g7, vec2<f32>(self_.g0) * other.g2 * vec2<f32>(1.0, -1.0));
}

fn point_at_origin_origin_anti_wedge_dot(self_: PointAtOrigin, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0));
}

fn point_at_origin_plane_anti_wedge_dot(self_: PointAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_plane_at_origin_anti_wedge_dot(self_: PointAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_point_at_infinity_anti_wedge_dot(self_: PointAtOrigin, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_point_at_origin_anti_wedge_dot(self_: PointAtOrigin, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn point_at_origin_rotor_anti_wedge_dot(self_: PointAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_round_point_anti_wedge_dot(self_: PointAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn point_at_origin_scalar_anti_wedge_dot(self_: PointAtOrigin, other: Scalar) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn point_at_origin_sphere_anti_wedge_dot(self_: PointAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_translator_anti_wedge_dot(self_: PointAtOrigin, other: Translator) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn rotor_anti_scalar_anti_wedge_dot(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_circle_anti_wedge_dot(self_: Rotor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_dipole_anti_wedge_dot(self_: Rotor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn rotor_flat_point_anti_wedge_dot(self_: Rotor, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn rotor_flector_anti_wedge_dot(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_anti_wedge_dot(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_infinity_anti_wedge_dot(self_: Rotor, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_anti_wedge_dot(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_infinity_anti_wedge_dot(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_origin_anti_wedge_dot(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_magnitude_anti_wedge_dot(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_motor_anti_wedge_dot(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_multi_vector_anti_wedge_dot(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10);
}

fn rotor_origin_anti_wedge_dot(self_: Rotor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_plane_anti_wedge_dot(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_anti_wedge_dot(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_at_infinity_anti_wedge_dot(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn rotor_point_at_origin_anti_wedge_dot(self_: Rotor, other: PointAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn rotor_rotor_anti_wedge_dot(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_round_point_anti_wedge_dot(self_: Rotor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_scalar_anti_wedge_dot(self_: Rotor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_sphere_anti_wedge_dot(self_: Rotor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_translator_anti_wedge_dot(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_anti_scalar_anti_wedge_dot(self_: RoundPoint, other: AntiScalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_circle_anti_wedge_dot(self_: RoundPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_dipole_anti_wedge_dot(self_: RoundPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(-other.g2.w));
}

fn round_point_flat_point_anti_wedge_dot(self_: RoundPoint, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(-other.g0.w));
}

fn round_point_flector_anti_wedge_dot(self_: RoundPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g1, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(-other.g0.w));
}

fn round_point_horizon_anti_wedge_dot(self_: RoundPoint, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_infinity_anti_wedge_dot(self_: RoundPoint, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_anti_wedge_dot(self_: RoundPoint, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_at_infinity_anti_wedge_dot(self_: RoundPoint, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_at_origin_anti_wedge_dot(self_: RoundPoint, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_magnitude_anti_wedge_dot(self_: RoundPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn round_point_motor_anti_wedge_dot(self_: RoundPoint, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) - vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_multi_vector_anti_wedge_dot(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g9.x, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g9.y, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g9.z, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(other.g6.w) + self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g1.x) * other.g9 + vec3<f32>(self_.g1.x) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g10.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, -other.g10.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, other.g6.z, -other.g6.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g6.z, -other.g2.x, other.g6.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g6.y, -other.g6.x, -other.g2.x, -other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.y) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.y) * other.g7 - vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(-other.g5.w) + self_.g1 * vec2<f32>(other.g0.x));
}

fn round_point_origin_anti_wedge_dot(self_: RoundPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_anti_wedge_dot(self_: RoundPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_at_origin_anti_wedge_dot(self_: RoundPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_point_at_infinity_anti_wedge_dot(self_: RoundPoint, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn round_point_point_at_origin_anti_wedge_dot(self_: RoundPoint, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(-other.g0));
}

fn round_point_rotor_anti_wedge_dot(self_: RoundPoint, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_round_point_anti_wedge_dot(self_: RoundPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_scalar_anti_wedge_dot(self_: RoundPoint, other: Scalar) -> Sphere {
    return Sphere(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_sphere_anti_wedge_dot(self_: RoundPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_translator_anti_wedge_dot(self_: RoundPoint, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_anti_scalar_anti_wedge_dot(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_circle_anti_wedge_dot(self_: Scalar, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g0.w));
}

fn scalar_dipole_anti_wedge_dot(self_: Scalar, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g2.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z));
}

fn scalar_flat_point_anti_wedge_dot(self_: Scalar, other: FlatPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn scalar_flector_anti_wedge_dot(self_: Scalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_horizon_anti_wedge_dot(self_: Scalar, other: Horizon) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn scalar_infinity_anti_wedge_dot(self_: Scalar, other: Infinity) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_line_anti_wedge_dot(self_: Scalar, other: Line) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn scalar_line_at_infinity_anti_wedge_dot(self_: Scalar, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_anti_wedge_dot(self_: Scalar, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0));
}

fn scalar_magnitude_anti_wedge_dot(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(1.0, -1.0));
}

fn scalar_motor_anti_wedge_dot(self_: Scalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_multi_vector_anti_wedge_dot(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0) * other.g9, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g10, vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0) * other.g7, vec4<f32>(self_.g0) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, -other.g6.w), vec4<f32>(self_.g0) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g5.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2);
}

fn scalar_origin_anti_wedge_dot(self_: Scalar, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0));
}

fn scalar_plane_anti_wedge_dot(self_: Scalar, other: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w));
}

fn scalar_plane_at_origin_anti_wedge_dot(self_: Scalar, other: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn scalar_point_at_infinity_anti_wedge_dot(self_: Scalar, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_origin_anti_wedge_dot(self_: Scalar, other: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn scalar_rotor_anti_wedge_dot(self_: Scalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_round_point_anti_wedge_dot(self_: Scalar, other: RoundPoint) -> Sphere {
    return Sphere(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_scalar_anti_wedge_dot(self_: Scalar, other: Scalar) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn scalar_sphere_anti_wedge_dot(self_: Scalar, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g1);
}

fn scalar_translator_anti_wedge_dot(self_: Scalar, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_anti_scalar_anti_wedge_dot(self_: Sphere, other: AntiScalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_circle_anti_wedge_dot(self_: Sphere, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_dipole_anti_wedge_dot(self_: Sphere, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_flat_point_anti_wedge_dot(self_: Sphere, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_flector_anti_wedge_dot(self_: Sphere, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_horizon_anti_wedge_dot(self_: Sphere, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_infinity_anti_wedge_dot(self_: Sphere, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_anti_wedge_dot(self_: Sphere, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn sphere_line_at_infinity_anti_wedge_dot(self_: Sphere, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn sphere_line_at_origin_anti_wedge_dot(self_: Sphere, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0));
}

fn sphere_magnitude_anti_wedge_dot(self_: Sphere, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_motor_anti_wedge_dot(self_: Sphere, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_multi_vector_anti_wedge_dot(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.y, -other.g10.y) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(other.g5.w) - self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g1.x) * other.g7 + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g4.x, -other.g4.y, -other.g4.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g1.y) * other.g9 - vec3<f32>(self_.g1.y) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g8.z) + self_.g1 * vec2<f32>(other.g6.w) + self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_origin_anti_wedge_dot(self_: Sphere, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_anti_wedge_dot(self_: Sphere, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_at_origin_anti_wedge_dot(self_: Sphere, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_point_at_infinity_anti_wedge_dot(self_: Sphere, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_point_at_origin_anti_wedge_dot(self_: Sphere, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_rotor_anti_wedge_dot(self_: Sphere, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_round_point_anti_wedge_dot(self_: Sphere, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_scalar_anti_wedge_dot(self_: Sphere, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0));
}

fn sphere_sphere_anti_wedge_dot(self_: Sphere, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_translator_anti_wedge_dot(self_: Sphere, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn translator_anti_scalar_anti_wedge_dot(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_circle_anti_wedge_dot(self_: Translator, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_dipole_anti_wedge_dot(self_: Translator, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z) + vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn translator_flat_point_anti_wedge_dot(self_: Translator, other: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_flector_anti_wedge_dot(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_anti_wedge_dot(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_infinity_anti_wedge_dot(self_: Translator, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn translator_line_anti_wedge_dot(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_line_at_infinity_anti_wedge_dot(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_anti_wedge_dot(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_magnitude_anti_wedge_dot(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_motor_anti_wedge_dot(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_multi_vector_anti_wedge_dot(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z) + vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10);
}

fn translator_origin_anti_wedge_dot(self_: Translator, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_plane_anti_wedge_dot(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_anti_wedge_dot(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn translator_point_at_infinity_anti_wedge_dot(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_origin_anti_wedge_dot(self_: Translator, other: PointAtOrigin) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn translator_rotor_anti_wedge_dot(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_round_point_anti_wedge_dot(self_: Translator, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_scalar_anti_wedge_dot(self_: Translator, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_sphere_anti_wedge_dot(self_: Translator, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_translator_anti_wedge_dot(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_anti_scalar_geometric_anti_product(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_circle_geometric_anti_product(self_: AntiScalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn anti_scalar_dipole_geometric_anti_product(self_: AntiScalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn anti_scalar_flat_point_geometric_anti_product(self_: AntiScalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_flector_geometric_anti_product(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_geometric_anti_product(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_infinity_geometric_anti_product(self_: AntiScalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn anti_scalar_line_geometric_anti_product(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_geometric_anti_product(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_geometric_anti_product(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_geometric_anti_product(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_geometric_anti_product(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_geometric_anti_product(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn anti_scalar_origin_geometric_anti_product(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_geometric_anti_product(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_geometric_anti_product(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_geometric_anti_product(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_origin_geometric_anti_product(self_: AntiScalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn anti_scalar_rotor_geometric_anti_product(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_round_point_geometric_anti_product(self_: AntiScalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_scalar_geometric_anti_product(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_sphere_geometric_anti_product(self_: AntiScalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_translator_geometric_anti_product(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn circle_anti_scalar_geometric_anti_product(self_: Circle, other: AntiScalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn circle_circle_geometric_anti_product(self_: Circle, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, other.g2.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.w) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_dipole_geometric_anti_product(self_: Circle, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g2.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g2.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g2.w) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g0.wwwz * other.g2.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn circle_flat_point_geometric_anti_product(self_: Circle, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_flector_geometric_anti_product(self_: Circle, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn circle_horizon_geometric_anti_product(self_: Circle, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0));
}

fn circle_infinity_geometric_anti_product(self_: Circle, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_line_geometric_anti_product(self_: Circle, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_line_at_infinity_geometric_anti_product(self_: Circle, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_line_at_origin_geometric_anti_product(self_: Circle, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_magnitude_geometric_anti_product(self_: Circle, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_motor_geometric_anti_product(self_: Circle, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_multi_vector_geometric_anti_product(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g5.z, other.g8.z) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g5.w, other.g6.w) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, -other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, -other.g2.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, -other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g6.w, -other.g7.z, other.g7.y, other.g8.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, other.g6.w, -other.g7.x, other.g8.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, other.g6.w, other.g8.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g6.x, -other.g6.y, -other.g6.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.w) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z));
}

fn circle_origin_geometric_anti_product(self_: Circle, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g2 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g2 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_plane_geometric_anti_product(self_: Circle, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_plane_at_origin_geometric_anti_product(self_: Circle, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_point_at_infinity_geometric_anti_product(self_: Circle, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_point_at_origin_geometric_anti_product(self_: Circle, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn circle_rotor_geometric_anti_product(self_: Circle, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_round_point_geometric_anti_product(self_: Circle, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_scalar_geometric_anti_product(self_: Circle, other: Scalar) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn circle_sphere_geometric_anti_product(self_: Circle, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_translator_geometric_anti_product(self_: Circle, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_anti_scalar_geometric_anti_product(self_: Dipole, other: AntiScalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_circle_geometric_anti_product(self_: Dipole, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn dipole_dipole_geometric_anti_product(self_: Dipole, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g2.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_flat_point_geometric_anti_product(self_: Dipole, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_flector_geometric_anti_product(self_: Dipole, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_horizon_geometric_anti_product(self_: Dipole, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_infinity_geometric_anti_product(self_: Dipole, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0));
}

fn dipole_line_geometric_anti_product(self_: Dipole, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_line_at_infinity_geometric_anti_product(self_: Dipole, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_line_at_origin_geometric_anti_product(self_: Dipole, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_magnitude_geometric_anti_product(self_: Dipole, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0.x, -other.g0.x, -other.g0.x, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_motor_geometric_anti_product(self_: Dipole, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_multi_vector_geometric_anti_product(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g8.x, other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g8.y, other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g8.z, other.g5.z) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g7.x, other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g7.y, other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g7.z, other.g4.z) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g2.w) * vec2<f32>(other.g6.w, other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g2.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g2.w) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.y, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g2.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.y, -other.g8.z, other.g8.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g8.z, other.g2.y, -other.g8.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g8.y, other.g8.x, other.g2.y, other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y), vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, -other.g5.x) + vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, -other.g5.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, -other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, -other.g0.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g2.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g2.w) * other.g9, vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g2.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * other.g2 * vec2<f32>(1.0, -1.0));
}

fn dipole_origin_geometric_anti_product(self_: Dipole, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(other.g0, 0.0));
}

fn dipole_plane_geometric_anti_product(self_: Dipole, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_plane_at_origin_geometric_anti_product(self_: Dipole, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_point_at_infinity_geometric_anti_product(self_: Dipole, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_point_at_origin_geometric_anti_product(self_: Dipole, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_rotor_geometric_anti_product(self_: Dipole, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g2.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_round_point_geometric_anti_product(self_: Dipole, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn dipole_scalar_geometric_anti_product(self_: Dipole, other: Scalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0));
}

fn dipole_sphere_geometric_anti_product(self_: Dipole, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.x, -other.g0.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_translator_geometric_anti_product(self_: Dipole, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g2.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn flat_point_anti_scalar_geometric_anti_product(self_: FlatPoint, other: AntiScalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_circle_geometric_anti_product(self_: FlatPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn flat_point_dipole_geometric_anti_product(self_: FlatPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_flat_point_geometric_anti_product(self_: FlatPoint, other: FlatPoint) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flat_point_flector_geometric_anti_product(self_: FlatPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_horizon_geometric_anti_product(self_: FlatPoint, other: Horizon) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn flat_point_infinity_geometric_anti_product(self_: FlatPoint, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0.w * other.g0);
}

fn flat_point_line_geometric_anti_product(self_: FlatPoint, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn flat_point_line_at_infinity_geometric_anti_product(self_: FlatPoint, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_line_at_origin_geometric_anti_product(self_: FlatPoint, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn flat_point_magnitude_geometric_anti_product(self_: FlatPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_motor_geometric_anti_product(self_: FlatPoint, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flat_point_multi_vector_geometric_anti_product(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g6.w, other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g0.w) * other.g9, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g0.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(1.0, -1.0));
}

fn flat_point_origin_geometric_anti_product(self_: FlatPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0));
}

fn flat_point_plane_geometric_anti_product(self_: FlatPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_plane_at_origin_geometric_anti_product(self_: FlatPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_point_at_infinity_geometric_anti_product(self_: FlatPoint, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_point_at_origin_geometric_anti_product(self_: FlatPoint, other: PointAtOrigin) -> Translator {
    return Translator(vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_rotor_geometric_anti_product(self_: FlatPoint, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flat_point_round_point_geometric_anti_product(self_: FlatPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn flat_point_scalar_geometric_anti_product(self_: FlatPoint, other: Scalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn flat_point_sphere_geometric_anti_product(self_: FlatPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_translator_geometric_anti_product(self_: FlatPoint, other: Translator) -> FlatPoint {
    return FlatPoint(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn flector_anti_scalar_geometric_anti_product(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_circle_geometric_anti_product(self_: Flector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w));
}

fn flector_dipole_geometric_anti_product(self_: Flector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g2.w) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g1.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_flat_point_geometric_anti_product(self_: Flector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_flector_geometric_anti_product(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_horizon_geometric_anti_product(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_infinity_geometric_anti_product(self_: Flector, other: Infinity) -> Flector {
    return Flector(self_.g1.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn flector_line_geometric_anti_product(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z));
}

fn flector_line_at_infinity_geometric_anti_product(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn flector_line_at_origin_geometric_anti_product(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn flector_magnitude_geometric_anti_product(self_: Flector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y));
}

fn flector_motor_geometric_anti_product(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn flector_multi_vector_geometric_anti_product(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g6.w, other.g5.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g1.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g1.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g1.w) * other.g9 - vec3<f32>(self_.g1.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g6.z, other.g8.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y));
}

fn flector_origin_geometric_anti_product(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0));
}

fn flector_plane_geometric_anti_product(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_plane_at_origin_geometric_anti_product(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_point_at_infinity_geometric_anti_product(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_point_at_origin_geometric_anti_product(self_: Flector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_rotor_geometric_anti_product(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g1.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn flector_round_point_geometric_anti_product(self_: Flector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + self_.g1.xyzx * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) - vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn flector_scalar_geometric_anti_product(self_: Flector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_sphere_geometric_anti_product(self_: Flector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_translator_geometric_anti_product(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_anti_scalar_geometric_anti_product(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_circle_geometric_anti_product(self_: Horizon, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w));
}

fn horizon_dipole_geometric_anti_product(self_: Horizon, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_flat_point_geometric_anti_product(self_: Horizon, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0.w);
}

fn horizon_flector_geometric_anti_product(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_line_geometric_anti_product(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_geometric_anti_product(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_geometric_anti_product(self_: Horizon, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y));
}

fn horizon_motor_geometric_anti_product(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_geometric_anti_product(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9 - vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y));
}

fn horizon_origin_geometric_anti_product(self_: Horizon, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_plane_geometric_anti_product(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_geometric_anti_product(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_origin_geometric_anti_product(self_: Horizon, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn horizon_rotor_geometric_anti_product(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_round_point_geometric_anti_product(self_: Horizon, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_scalar_geometric_anti_product(self_: Horizon, other: Scalar) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn horizon_sphere_geometric_anti_product(self_: Horizon, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_translator_geometric_anti_product(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn infinity_anti_scalar_geometric_anti_product(self_: Infinity, other: AntiScalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_circle_geometric_anti_product(self_: Infinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_dipole_geometric_anti_product(self_: Infinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g2.w));
}

fn infinity_flat_point_geometric_anti_product(self_: Infinity, other: FlatPoint) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn infinity_flector_geometric_anti_product(self_: Infinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn infinity_line_geometric_anti_product(self_: Infinity, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn infinity_line_at_origin_geometric_anti_product(self_: Infinity, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn infinity_magnitude_geometric_anti_product(self_: Infinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn infinity_motor_geometric_anti_product(self_: Infinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_multi_vector_geometric_anti_product(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, -other.g10.x) + vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0) * other.g7 - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn infinity_origin_geometric_anti_product(self_: Infinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_plane_geometric_anti_product(self_: Infinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn infinity_plane_at_origin_geometric_anti_product(self_: Infinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn infinity_point_at_origin_geometric_anti_product(self_: Infinity, other: PointAtOrigin) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_rotor_geometric_anti_product(self_: Infinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_round_point_geometric_anti_product(self_: Infinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_scalar_geometric_anti_product(self_: Infinity, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_sphere_geometric_anti_product(self_: Infinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_translator_geometric_anti_product(self_: Infinity, other: Translator) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn line_anti_scalar_geometric_anti_product(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_circle_geometric_anti_product(self_: Line, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_dipole_geometric_anti_product(self_: Line, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_flat_point_geometric_anti_product(self_: Line, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn line_flector_geometric_anti_product(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z));
}

fn line_horizon_geometric_anti_product(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_infinity_geometric_anti_product(self_: Line, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_geometric_anti_product(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_line_at_infinity_geometric_anti_product(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_line_at_origin_geometric_anti_product(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_magnitude_geometric_anti_product(self_: Line, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_motor_geometric_anti_product(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_multi_vector_geometric_anti_product(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z));
}

fn line_origin_geometric_anti_product(self_: Line, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_plane_geometric_anti_product(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_plane_at_origin_geometric_anti_product(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_point_at_infinity_geometric_anti_product(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_point_at_origin_geometric_anti_product(self_: Line, other: PointAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn line_rotor_geometric_anti_product(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_round_point_geometric_anti_product(self_: Line, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_scalar_geometric_anti_product(self_: Line, other: Scalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn line_sphere_geometric_anti_product(self_: Line, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn line_translator_geometric_anti_product(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_anti_scalar_geometric_anti_product(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_circle_geometric_anti_product(self_: LineAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_dipole_geometric_anti_product(self_: LineAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_at_infinity_flat_point_geometric_anti_product(self_: LineAtInfinity, other: FlatPoint) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_infinity_flector_geometric_anti_product(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z));
}

fn line_at_infinity_line_geometric_anti_product(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_line_at_origin_geometric_anti_product(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_magnitude_geometric_anti_product(self_: LineAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_motor_geometric_anti_product(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_multi_vector_geometric_anti_product(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn line_at_infinity_origin_geometric_anti_product(self_: LineAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_geometric_anti_product(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_at_infinity_plane_at_origin_geometric_anti_product(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_at_infinity_point_at_origin_geometric_anti_product(self_: LineAtInfinity, other: PointAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_rotor_geometric_anti_product(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_round_point_geometric_anti_product(self_: LineAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_scalar_geometric_anti_product(self_: LineAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_sphere_geometric_anti_product(self_: LineAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn line_at_infinity_translator_geometric_anti_product(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_geometric_anti_product(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_circle_geometric_anti_product(self_: LineAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_dipole_geometric_anti_product(self_: LineAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn line_at_origin_flat_point_geometric_anti_product(self_: LineAtOrigin, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn line_at_origin_flector_geometric_anti_product(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z));
}

fn line_at_origin_horizon_geometric_anti_product(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_infinity_geometric_anti_product(self_: LineAtOrigin, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_geometric_anti_product(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_line_at_infinity_geometric_anti_product(self_: LineAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_line_at_origin_geometric_anti_product(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, -other.g0.z));
}

fn line_at_origin_magnitude_geometric_anti_product(self_: LineAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_motor_geometric_anti_product(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_multi_vector_geometric_anti_product(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z));
}

fn line_at_origin_origin_geometric_anti_product(self_: LineAtOrigin, other: Origin) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn line_at_origin_plane_geometric_anti_product(self_: LineAtOrigin, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_at_origin_plane_at_origin_geometric_anti_product(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_at_origin_point_at_infinity_geometric_anti_product(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn line_at_origin_point_at_origin_geometric_anti_product(self_: LineAtOrigin, other: PointAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_rotor_geometric_anti_product(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_round_point_geometric_anti_product(self_: LineAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_scalar_geometric_anti_product(self_: LineAtOrigin, other: Scalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn line_at_origin_sphere_geometric_anti_product(self_: LineAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0));
}

fn line_at_origin_translator_geometric_anti_product(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_anti_scalar_geometric_anti_product(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_circle_geometric_anti_product(self_: Magnitude, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g0.w), vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_dipole_geometric_anti_product(self_: Magnitude, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * other.g2, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g2.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flat_point_geometric_anti_product(self_: Magnitude, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flector_geometric_anti_product(self_: Magnitude, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w));
}

fn magnitude_horizon_geometric_anti_product(self_: Magnitude, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0));
}

fn magnitude_infinity_geometric_anti_product(self_: Magnitude, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0));
}

fn magnitude_line_geometric_anti_product(self_: Magnitude, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_infinity_geometric_anti_product(self_: Magnitude, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_origin_geometric_anti_product(self_: Magnitude, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_magnitude_geometric_anti_product(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_geometric_anti_product(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_multi_vector_geometric_anti_product(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g10 + vec2<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g0.y) * other.g3, vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, -other.g6.w) + vec4<f32>(self_.g0.y) * other.g5, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g5.w) + vec4<f32>(self_.g0.y) * other.g6, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g4 + vec3<f32>(self_.g0.y) * other.g7, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g0.y) * other.g8, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g0.y) * other.g9, vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10);
}

fn magnitude_origin_geometric_anti_product(self_: Magnitude, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0));
}

fn magnitude_plane_geometric_anti_product(self_: Magnitude, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w));
}

fn magnitude_plane_at_origin_geometric_anti_product(self_: Magnitude, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0));
}

fn magnitude_point_at_infinity_geometric_anti_product(self_: Magnitude, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_point_at_origin_geometric_anti_product(self_: Magnitude, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_rotor_geometric_anti_product(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_round_point_geometric_anti_product(self_: Magnitude, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_scalar_geometric_anti_product(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0.yx * vec2<f32>(other.g0));
}

fn magnitude_sphere_geometric_anti_product(self_: Magnitude, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_translator_geometric_anti_product(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_anti_scalar_geometric_anti_product(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_circle_geometric_anti_product(self_: Motor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_dipole_geometric_anti_product(self_: Motor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g2 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn motor_flat_point_geometric_anti_product(self_: Motor, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn motor_flector_geometric_anti_product(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z));
}

fn motor_horizon_geometric_anti_product(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_infinity_geometric_anti_product(self_: Motor, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_geometric_anti_product(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_infinity_geometric_anti_product(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_origin_geometric_anti_product(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_magnitude_geometric_anti_product(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_motor_geometric_anti_product(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_multi_vector_geometric_anti_product(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z) + vec2<f32>(self_.g0.w) * other.g0 - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g6 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z));
}

fn motor_origin_geometric_anti_product(self_: Motor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_plane_geometric_anti_product(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn motor_plane_at_origin_geometric_anti_product(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn motor_point_at_infinity_geometric_anti_product(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn motor_point_at_origin_geometric_anti_product(self_: Motor, other: PointAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn motor_rotor_geometric_anti_product(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_round_point_geometric_anti_product(self_: Motor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0 + self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_scalar_geometric_anti_product(self_: Motor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_sphere_geometric_anti_product(self_: Motor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0 - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn motor_translator_geometric_anti_product(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_anti_scalar_geometric_anti_product(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_circle_geometric_anti_product(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g2.x) * other.g2 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g2 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g0.w) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, other.g2.y) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, other.g2.z) + vec4<f32>(self_.g6.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.y) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * other.g2 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.y) * other.g1 + vec3<f32>(self_.g6.w) * other.g2 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * other.g2 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_dipole_geometric_anti_product(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g2.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g2.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g10.y) * other.g0, vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(other.g2.w), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g2.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, -other.g2.w, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g2.w) - vec3<f32>(self_.g6.w) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g1 - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * other.g2 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, other.g1.z) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g6.wwwz * other.g2.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g2.w) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g5.wwwz * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g0.z) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g2.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g10.y) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(-other.g2.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_flat_point_geometric_anti_product(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + self_.g2 * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_flector_geometric_anti_product(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g2.y, self_.g2.y, self_.g2.y, self_.g2.x) * other.g1 + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g3.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, -other.g1.w, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, -other.g1.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + self_.g2 * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_horizon_geometric_anti_product(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0) + self_.g9 * vec3<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_geometric_anti_product(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), self_.g3 * vec3<f32>(other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0) + self_.g7 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0));
}

fn multi_vector_line_geometric_anti_product(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z));
}

fn multi_vector_line_at_infinity_geometric_anti_product(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_line_at_origin_geometric_anti_product(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_magnitude_geometric_anti_product(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec3<f32>(other.g0.y) + self_.g9 * vec3<f32>(other.g0.x), self_.g2 * vec2<f32>(other.g0.y) - self_.g10 * vec2<f32>(other.g0.x), self_.g3 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.x), self_.g4 * vec3<f32>(other.g0.y) + self_.g7 * vec3<f32>(other.g0.x), self_.g5 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(-other.g0.x, -other.g0.x, -other.g0.x, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + self_.g6 * vec4<f32>(other.g0.y), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0.x) + self_.g7 * vec3<f32>(other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.x) + self_.g8 * vec3<f32>(other.g0.y), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.x) + self_.g9 * vec3<f32>(other.g0.y), self_.g2 * vec2<f32>(other.g0.x) + self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_motor_geometric_anti_product(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_multi_vector_geometric_anti_product(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g9.x, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g9.y, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g9.z, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g10.x, other.g2.x) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g8.x, other.g5.x) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g8.y, other.g5.y) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g8.z, other.g5.z) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g7.x, other.g4.x) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g7.y, other.g4.y) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g7.z, other.g4.z) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g6.z, other.g3.z) - vec2<f32>(self_.g5.w) * vec2<f32>(other.g6.w, other.g5.w) - vec2<f32>(self_.g6.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g6.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g6.z) * vec2<f32>(other.g5.z, other.g8.z) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g5.w, other.g6.w) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g8.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g8.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g8.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g2.y, -other.g10.y) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g2.x) * other.g8 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g5.w) * other.g4 + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g8.z, -other.g2.y, other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g8.y, -other.g8.x, -other.g2.y) + vec3<f32>(self_.g6.w) * other.g7 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g10.y) * other.g3, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g10 + vec2<f32>(self_.g0.y) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g2 * vec2<f32>(other.g6.w) + self_.g2 * vec2<f32>(other.g0.y) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g3.x, other.g5.x) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g3.y, other.g5.y) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g5.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g6.w) * other.g2 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g10 * vec2<f32>(other.g5.w) - self_.g10 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g0.y) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g2.x) * other.g9 + vec3<f32>(self_.g2.x) * other.g4 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.y, -other.g1.z, other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, other.g0.y, -other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g6.w) * other.g3 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g10.x) * other.g7 + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) - vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g6.w) * other.g9 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g10.x) * other.g8 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, -other.g6.w) + vec4<f32>(self_.g0.y) * other.g5 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, other.g4.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g10.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, -other.g10.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g2.y, -other.g8.z, other.g8.y, other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g8.z, other.g2.y, -other.g8.x, other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g8.y, other.g8.x, other.g2.y, other.g1.z) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g5.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, -other.g0.x) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g8.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g5.w) + vec4<f32>(self_.g0.y) * other.g6 + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.x, other.g6.z, -other.g6.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g6.z, -other.g2.x, other.g6.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g6.y, -other.g6.x, -other.g2.x, -other.g7.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.y) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, -other.g5.x) + vec4<f32>(self_.g3.x) * vec4<f32>(-other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, -other.g5.y) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g4.z, -other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, -other.g4.x, -other.g0.x, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g9.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g9.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g9.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g5.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g5.w) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g6.w, -other.g7.z, other.g7.y, other.g8.x) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g7.z, other.g6.w, -other.g7.x, other.g8.y) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g7.y, other.g7.x, other.g6.w, other.g8.z) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g6.w) * vec4<f32>(-other.g6.x, -other.g6.y, -other.g6.z, other.g0.y) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z) + vec4<f32>(self_.g9.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g4.x, -other.g4.y, -other.g4.z, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g4 + vec3<f32>(self_.g0.y) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * other.g8 + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g5.w) * other.g9 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g10.y) * other.g3, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g0.y) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g2.y) * other.g7 - vec3<f32>(self_.g2.y) * other.g1 + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g5.z, -other.g10.y, other.g5.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g5.y, -other.g5.x, -other.g10.y) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g6.w) * other.g8 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g10.y) * other.g9 - vec3<f32>(self_.g10.y) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g0.y) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x) + vec3<f32>(self_.g5.w) * other.g7 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g6.w) * other.g4 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g10.x) * other.g8 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g2 * vec2<f32>(-other.g5.w) + self_.g2 * vec2<f32>(other.g0.x) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * other.g2 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g6.w) * other.g10 * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g6.z, other.g8.z) + self_.g10 * vec2<f32>(other.g6.w) + self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_origin_geometric_anti_product(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g0, 0.0), self_.g8 * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0), self_.g4 * vec3<f32>(other.g0) + self_.g9 * vec3<f32>(other.g0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g8 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g0, 0.0));
}

fn multi_vector_plane_geometric_anti_product(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g2.y, self_.g2.y, self_.g2.y, self_.g2.x) * other.g0 + vec4<f32>(self_.g7.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.x) * other.g0, vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_plane_at_origin_geometric_anti_product(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * other.g0, vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_infinity_geometric_anti_product(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_origin_geometric_anti_product(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0), self_.g4 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0) - self_.g9 * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(-other.g0));
}

fn multi_vector_rotor_geometric_anti_product(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g5.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g6.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_round_point_geometric_anti_product(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(self_.g0.y) * other.g0 - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g1.x) + self_.g9 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g10.x) * other.g0, self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.y, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.y, 0.0, other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.y, other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.y) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g2.y) * other.g0 + self_.g7 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x) * other.g0 + self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn multi_vector_scalar_geometric_anti_product(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g10 * vec2<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0));
}

fn multi_vector_sphere_geometric_anti_product(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(self_.g0.x) * other.g0 + self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g1.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.x) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, -other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, -other.g1.x, -other.g0.z) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - self_.g4 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_translator_geometric_anti_product(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), self_.g1 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g5.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g8 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn origin_anti_scalar_geometric_anti_product(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_circle_geometric_anti_product(self_: Origin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g2, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * other.g2, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_dipole_geometric_anti_product(self_: Origin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g2.w, 0.0));
}

fn origin_flat_point_geometric_anti_product(self_: Origin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_flector_geometric_anti_product(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_horizon_geometric_anti_product(self_: Origin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_infinity_geometric_anti_product(self_: Origin, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_geometric_anti_product(self_: Origin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_at_infinity_geometric_anti_product(self_: Origin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_at_origin_geometric_anti_product(self_: Origin, other: LineAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_magnitude_geometric_anti_product(self_: Origin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0));
}

fn origin_motor_geometric_anti_product(self_: Origin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_multi_vector_geometric_anti_product(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.y, other.g2.y), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g8, vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9 + vec3<f32>(self_.g0) * other.g4, vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g10.y), vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.y) + vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * other.g8, vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g5.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0));
}

fn origin_plane_geometric_anti_product(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_plane_at_origin_geometric_anti_product(self_: Origin, other: PlaneAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_point_at_infinity_geometric_anti_product(self_: Origin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn origin_point_at_origin_geometric_anti_product(self_: Origin, other: PointAtOrigin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0));
}

fn origin_rotor_geometric_anti_product(self_: Origin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_round_point_geometric_anti_product(self_: Origin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.y), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_scalar_geometric_anti_product(self_: Origin, other: Scalar) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0));
}

fn origin_sphere_geometric_anti_product(self_: Origin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.y, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_translator_geometric_anti_product(self_: Origin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_anti_scalar_geometric_anti_product(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_circle_geometric_anti_product(self_: Plane, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w));
}

fn plane_dipole_geometric_anti_product(self_: Plane, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_flat_point_geometric_anti_product(self_: Plane, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_flector_geometric_anti_product(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_horizon_geometric_anti_product(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_infinity_geometric_anti_product(self_: Plane, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_geometric_anti_product(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z));
}

fn plane_line_at_infinity_geometric_anti_product(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_line_at_origin_geometric_anti_product(self_: Plane, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn plane_magnitude_geometric_anti_product(self_: Plane, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y));
}

fn plane_motor_geometric_anti_product(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_multi_vector_geometric_anti_product(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) - vec3<f32>(self_.g0.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 - vec3<f32>(self_.g0.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y));
}

fn plane_origin_geometric_anti_product(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_plane_geometric_anti_product(self_: Plane, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_geometric_anti_product(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_at_infinity_geometric_anti_product(self_: Plane, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_point_at_origin_geometric_anti_product(self_: Plane, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_rotor_geometric_anti_product(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_round_point_geometric_anti_product(self_: Plane, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0.xyzx * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) - vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_scalar_geometric_anti_product(self_: Plane, other: Scalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0));
}

fn plane_sphere_geometric_anti_product(self_: Plane, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_translator_geometric_anti_product(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_at_origin_anti_scalar_geometric_anti_product(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_circle_geometric_anti_product(self_: PlaneAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z));
}

fn plane_at_origin_dipole_geometric_anti_product(self_: PlaneAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_flat_point_geometric_anti_product(self_: PlaneAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_flector_geometric_anti_product(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_horizon_geometric_anti_product(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_infinity_geometric_anti_product(self_: PlaneAtOrigin, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_geometric_anti_product(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z));
}

fn plane_at_origin_line_at_infinity_geometric_anti_product(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_at_origin_line_at_origin_geometric_anti_product(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn plane_at_origin_magnitude_geometric_anti_product(self_: PlaneAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0));
}

fn plane_at_origin_motor_geometric_anti_product(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, other.g1.z));
}

fn plane_at_origin_multi_vector_geometric_anti_product(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g8.z));
}

fn plane_at_origin_origin_geometric_anti_product(self_: PlaneAtOrigin, other: Origin) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_at_origin_plane_geometric_anti_product(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_geometric_anti_product(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, other.g0.z));
}

fn plane_at_origin_point_at_infinity_geometric_anti_product(self_: PlaneAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_point_at_origin_geometric_anti_product(self_: PlaneAtOrigin, other: PointAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_rotor_geometric_anti_product(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0));
}

fn plane_at_origin_round_point_geometric_anti_product(self_: PlaneAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_scalar_geometric_anti_product(self_: PlaneAtOrigin, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn plane_at_origin_sphere_geometric_anti_product(self_: PlaneAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_translator_geometric_anti_product(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z));
}

fn point_at_infinity_anti_scalar_geometric_anti_product(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_geometric_anti_product(self_: PointAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn point_at_infinity_dipole_geometric_anti_product(self_: PointAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_flat_point_geometric_anti_product(self_: PointAtInfinity, other: FlatPoint) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_flector_geometric_anti_product(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_line_geometric_anti_product(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_line_at_origin_geometric_anti_product(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_magnitude_geometric_anti_product(self_: PointAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_motor_geometric_anti_product(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_multi_vector_geometric_anti_product(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g1.z, -other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.y, other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, -other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn point_at_infinity_origin_geometric_anti_product(self_: PointAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_geometric_anti_product(self_: PointAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_at_origin_geometric_anti_product(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_point_at_origin_geometric_anti_product(self_: PointAtInfinity, other: PointAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_rotor_geometric_anti_product(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn point_at_infinity_round_point_geometric_anti_product(self_: PointAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn point_at_infinity_scalar_geometric_anti_product(self_: PointAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_sphere_geometric_anti_product(self_: PointAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_translator_geometric_anti_product(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_origin_anti_scalar_geometric_anti_product(self_: PointAtOrigin, other: AntiScalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn point_at_origin_circle_geometric_anti_product(self_: PointAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0));
}

fn point_at_origin_dipole_geometric_anti_product(self_: PointAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_flat_point_geometric_anti_product(self_: PointAtOrigin, other: FlatPoint) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_at_origin_flector_geometric_anti_product(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_horizon_geometric_anti_product(self_: PointAtOrigin, other: Horizon) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn point_at_origin_infinity_geometric_anti_product(self_: PointAtOrigin, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn point_at_origin_line_geometric_anti_product(self_: PointAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_line_at_infinity_geometric_anti_product(self_: PointAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_line_at_origin_geometric_anti_product(self_: PointAtOrigin, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_magnitude_geometric_anti_product(self_: PointAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_motor_geometric_anti_product(self_: PointAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_multi_vector_geometric_anti_product(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, other.g5.w), vec3<f32>(self_.g0) * other.g4, vec2<f32>(self_.g0) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9, vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0) * other.g7, vec2<f32>(self_.g0) * other.g2 * vec2<f32>(1.0, -1.0));
}

fn point_at_origin_origin_geometric_anti_product(self_: PointAtOrigin, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0));
}

fn point_at_origin_plane_geometric_anti_product(self_: PointAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_plane_at_origin_geometric_anti_product(self_: PointAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_point_at_infinity_geometric_anti_product(self_: PointAtOrigin, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_point_at_origin_geometric_anti_product(self_: PointAtOrigin, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn point_at_origin_rotor_geometric_anti_product(self_: PointAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_origin_round_point_geometric_anti_product(self_: PointAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(1.0, -1.0));
}

fn point_at_origin_scalar_geometric_anti_product(self_: PointAtOrigin, other: Scalar) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn point_at_origin_sphere_geometric_anti_product(self_: PointAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_translator_geometric_anti_product(self_: PointAtOrigin, other: Translator) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn rotor_anti_scalar_geometric_anti_product(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_circle_geometric_anti_product(self_: Rotor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_dipole_geometric_anti_product(self_: Rotor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn rotor_flat_point_geometric_anti_product(self_: Rotor, other: FlatPoint) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn rotor_flector_geometric_anti_product(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_geometric_anti_product(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_infinity_geometric_anti_product(self_: Rotor, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_geometric_anti_product(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_infinity_geometric_anti_product(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_origin_geometric_anti_product(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_magnitude_geometric_anti_product(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_motor_geometric_anti_product(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_multi_vector_geometric_anti_product(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, other.g7.z) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.x, -other.g6.z, other.g6.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, other.g2.x, -other.g6.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, other.g5.w) + vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10);
}

fn rotor_origin_geometric_anti_product(self_: Rotor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_plane_geometric_anti_product(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_geometric_anti_product(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_at_infinity_geometric_anti_product(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn rotor_point_at_origin_geometric_anti_product(self_: Rotor, other: PointAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn rotor_rotor_geometric_anti_product(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_round_point_geometric_anti_product(self_: Rotor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_scalar_geometric_anti_product(self_: Rotor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_sphere_geometric_anti_product(self_: Rotor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_translator_geometric_anti_product(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_anti_scalar_geometric_anti_product(self_: RoundPoint, other: AntiScalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_circle_geometric_anti_product(self_: RoundPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_dipole_geometric_anti_product(self_: RoundPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(-other.g2.w));
}

fn round_point_flat_point_geometric_anti_product(self_: RoundPoint, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(-other.g0.w));
}

fn round_point_flector_geometric_anti_product(self_: RoundPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g1, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(-other.g0.w));
}

fn round_point_horizon_geometric_anti_product(self_: RoundPoint, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_infinity_geometric_anti_product(self_: RoundPoint, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_geometric_anti_product(self_: RoundPoint, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_at_infinity_geometric_anti_product(self_: RoundPoint, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_at_origin_geometric_anti_product(self_: RoundPoint, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_magnitude_geometric_anti_product(self_: RoundPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn round_point_motor_geometric_anti_product(self_: RoundPoint, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) - vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_multi_vector_geometric_anti_product(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g9.x, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g9.y, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g9.z, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) - vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(other.g6.w) + self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) - vec3<f32>(self_.g1.x) * other.g9 + vec3<f32>(self_.g1.x) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, -other.g5.z, other.g5.y, other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g5.z, other.g10.y, -other.g5.x, other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g5.y, other.g5.x, other.g10.y, other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g10.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, -other.g10.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, other.g6.z, -other.g6.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g6.z, -other.g2.x, other.g6.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g6.y, -other.g6.x, -other.g2.x, -other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.y) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, other.g2.y) + vec3<f32>(self_.g1.y) * other.g7 - vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, -other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, -other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(-other.g5.w) + self_.g1 * vec2<f32>(other.g0.x));
}

fn round_point_origin_geometric_anti_product(self_: RoundPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_geometric_anti_product(self_: RoundPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_at_origin_geometric_anti_product(self_: RoundPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_point_at_infinity_geometric_anti_product(self_: RoundPoint, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn round_point_point_at_origin_geometric_anti_product(self_: RoundPoint, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(-other.g0));
}

fn round_point_rotor_geometric_anti_product(self_: RoundPoint, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_round_point_geometric_anti_product(self_: RoundPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_scalar_geometric_anti_product(self_: RoundPoint, other: Scalar) -> Sphere {
    return Sphere(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_sphere_geometric_anti_product(self_: RoundPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_translator_geometric_anti_product(self_: RoundPoint, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_anti_scalar_geometric_anti_product(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_circle_geometric_anti_product(self_: Scalar, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g0.w));
}

fn scalar_dipole_geometric_anti_product(self_: Scalar, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g2.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z));
}

fn scalar_flat_point_geometric_anti_product(self_: Scalar, other: FlatPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn scalar_flector_geometric_anti_product(self_: Scalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_horizon_geometric_anti_product(self_: Scalar, other: Horizon) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn scalar_infinity_geometric_anti_product(self_: Scalar, other: Infinity) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_line_geometric_anti_product(self_: Scalar, other: Line) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn scalar_line_at_infinity_geometric_anti_product(self_: Scalar, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_geometric_anti_product(self_: Scalar, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0));
}

fn scalar_magnitude_geometric_anti_product(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(1.0, -1.0));
}

fn scalar_motor_geometric_anti_product(self_: Scalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_multi_vector_geometric_anti_product(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0) * other.g9, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g10, vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0) * other.g7, vec4<f32>(self_.g0) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, -other.g6.w), vec4<f32>(self_.g0) * vec4<f32>(-other.g3.x, -other.g3.y, -other.g3.z, other.g5.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2);
}

fn scalar_origin_geometric_anti_product(self_: Scalar, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0, 0.0));
}

fn scalar_plane_geometric_anti_product(self_: Scalar, other: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w));
}

fn scalar_plane_at_origin_geometric_anti_product(self_: Scalar, other: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn scalar_point_at_infinity_geometric_anti_product(self_: Scalar, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_origin_geometric_anti_product(self_: Scalar, other: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn scalar_rotor_geometric_anti_product(self_: Scalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn scalar_round_point_geometric_anti_product(self_: Scalar, other: RoundPoint) -> Sphere {
    return Sphere(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_scalar_geometric_anti_product(self_: Scalar, other: Scalar) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn scalar_sphere_geometric_anti_product(self_: Scalar, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g1);
}

fn scalar_translator_geometric_anti_product(self_: Scalar, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_anti_scalar_geometric_anti_product(self_: Sphere, other: AntiScalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_circle_geometric_anti_product(self_: Sphere, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_dipole_geometric_anti_product(self_: Sphere, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) - vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_flat_point_geometric_anti_product(self_: Sphere, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_flector_geometric_anti_product(self_: Sphere, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g1.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_horizon_geometric_anti_product(self_: Sphere, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_infinity_geometric_anti_product(self_: Sphere, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_geometric_anti_product(self_: Sphere, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn sphere_line_at_infinity_geometric_anti_product(self_: Sphere, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn sphere_line_at_origin_geometric_anti_product(self_: Sphere, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0));
}

fn sphere_magnitude_geometric_anti_product(self_: Sphere, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_motor_geometric_anti_product(self_: Sphere, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_multi_vector_geometric_anti_product(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.y, -other.g10.y) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g0.x, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(other.g5.w) - self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g1.x) * other.g7 + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, -other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, -other.g2.y, -other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, -other.g2.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, -other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, -other.g10.x, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g4.x, -other.g4.y, -other.g4.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, -other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, -other.g5.w) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, other.g10.y) - vec3<f32>(self_.g1.y) * other.g9 - vec3<f32>(self_.g1.y) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g0.y) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, other.g8.z) + self_.g1 * vec2<f32>(other.g6.w) + self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_origin_geometric_anti_product(self_: Sphere, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_geometric_anti_product(self_: Sphere, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_at_origin_geometric_anti_product(self_: Sphere, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_point_at_infinity_geometric_anti_product(self_: Sphere, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_point_at_origin_geometric_anti_product(self_: Sphere, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_rotor_geometric_anti_product(self_: Sphere, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_round_point_geometric_anti_product(self_: Sphere, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.y, -other.g1.y, -other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_scalar_geometric_anti_product(self_: Sphere, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0));
}

fn sphere_sphere_geometric_anti_product(self_: Sphere, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_translator_geometric_anti_product(self_: Sphere, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn translator_anti_scalar_geometric_anti_product(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_circle_geometric_anti_product(self_: Translator, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_dipole_geometric_anti_product(self_: Translator, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g2.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g2.w, other.g0.z) + vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn translator_flat_point_geometric_anti_product(self_: Translator, other: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_flector_geometric_anti_product(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_geometric_anti_product(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_infinity_geometric_anti_product(self_: Translator, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn translator_line_geometric_anti_product(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_line_at_infinity_geometric_anti_product(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_geometric_anti_product(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_magnitude_geometric_anti_product(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_motor_geometric_anti_product(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_multi_vector_geometric_anti_product(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, -other.g9.z, other.g9.y, other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, -other.g4.z, other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, other.g5.w, -other.g9.x, other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g0.x, -other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, other.g5.w, other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g4.y, other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g6.z) + vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, other.g2.x) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, -other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, -other.g10.x) + vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10);
}

fn translator_origin_geometric_anti_product(self_: Translator, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_plane_geometric_anti_product(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_geometric_anti_product(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn translator_point_at_infinity_geometric_anti_product(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_origin_geometric_anti_product(self_: Translator, other: PointAtOrigin) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn translator_rotor_geometric_anti_product(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_round_point_geometric_anti_product(self_: Translator, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_scalar_geometric_anti_product(self_: Translator, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_sphere_geometric_anti_product(self_: Translator, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_translator_geometric_anti_product(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_anti_scalar_geometric_product(self_: AntiScalar, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_circle_geometric_product(self_: AntiScalar, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w));
}

fn anti_scalar_dipole_geometric_product(self_: AntiScalar, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z));
}

fn anti_scalar_flat_point_geometric_product(self_: AntiScalar, other: FlatPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn anti_scalar_flector_geometric_product(self_: AntiScalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_horizon_geometric_product(self_: AntiScalar, other: Horizon) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn anti_scalar_infinity_geometric_product(self_: AntiScalar, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_line_geometric_product(self_: AntiScalar, other: Line) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0));
}

fn anti_scalar_line_at_infinity_geometric_product(self_: AntiScalar, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_geometric_product(self_: AntiScalar, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0));
}

fn anti_scalar_magnitude_geometric_product(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(-1.0, 1.0));
}

fn anti_scalar_motor_geometric_product(self_: AntiScalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_multi_vector_geometric_product(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g7, vec4<f32>(self_.g0) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0) * other.g4, vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g2);
}

fn anti_scalar_origin_geometric_product(self_: AntiScalar, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0));
}

fn anti_scalar_plane_geometric_product(self_: AntiScalar, other: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w));
}

fn anti_scalar_plane_at_origin_geometric_product(self_: AntiScalar, other: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn anti_scalar_point_at_infinity_geometric_product(self_: AntiScalar, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_origin_geometric_product(self_: AntiScalar, other: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn anti_scalar_rotor_geometric_product(self_: AntiScalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_round_point_geometric_product(self_: AntiScalar, other: RoundPoint) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_scalar_geometric_product(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_sphere_geometric_product(self_: AntiScalar, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_translator_geometric_product(self_: AntiScalar, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_anti_scalar_geometric_product(self_: Circle, other: AntiScalar) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0));
}

fn circle_circle_geometric_product(self_: Circle, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g0.wwwz * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z));
}

fn circle_dipole_geometric_product(self_: Circle, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_flat_point_geometric_product(self_: Circle, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_flector_geometric_product(self_: Circle, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) - vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_horizon_geometric_product(self_: Circle, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_infinity_geometric_product(self_: Circle, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0));
}

fn circle_line_geometric_product(self_: Circle, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + self_.g0.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_line_at_infinity_geometric_product(self_: Circle, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_line_at_origin_geometric_product(self_: Circle, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_magnitude_geometric_product(self_: Circle, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_motor_geometric_product(self_: Circle, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_multi_vector_geometric_product(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g8.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g8.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g8.z, -other.g5.z) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g6.w, other.g5.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(1.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.y) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, -other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, -other.g2.y) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, other.g9.z, -other.g9.y, -other.g5.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g9.z, other.g5.w, other.g9.x, -other.g5.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g9.y, -other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z));
}

fn circle_origin_geometric_product(self_: Circle, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn circle_plane_geometric_product(self_: Circle, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) - vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_plane_at_origin_geometric_product(self_: Circle, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_point_at_infinity_geometric_product(self_: Circle, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_point_at_origin_geometric_product(self_: Circle, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_rotor_geometric_product(self_: Circle, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_round_point_geometric_product(self_: Circle, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 - self_.g2 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_scalar_geometric_product(self_: Circle, other: Scalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn circle_sphere_geometric_product(self_: Circle, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_translator_geometric_product(self_: Circle, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn dipole_anti_scalar_geometric_product(self_: Dipole, other: AntiScalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0));
}

fn dipole_circle_geometric_product(self_: Dipole, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g0.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g0.w, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g2.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g2.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_dipole_geometric_product(self_: Dipole, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn dipole_flat_point_geometric_product(self_: Dipole, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + self_.g2.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_flector_geometric_product(self_: Dipole, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g1.w));
}

fn dipole_horizon_geometric_product(self_: Dipole, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0));
}

fn dipole_infinity_geometric_product(self_: Dipole, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_line_geometric_product(self_: Dipole, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_line_at_infinity_geometric_product(self_: Dipole, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_line_at_origin_geometric_product(self_: Dipole, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_magnitude_geometric_product(self_: Dipole, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_motor_geometric_product(self_: Dipole, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, -other.g1.z) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g2.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_multi_vector_geometric_product(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g5.z, other.g8.z) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g5.w, -other.g6.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g2.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.w) * other.g2 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) - vec3<f32>(self_.g2.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g2.w) * other.g9, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g5.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g5.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g5.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, other.g7.z, -other.g7.y, -other.g8.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g7.z, -other.g6.w, other.g7.x, -other.g8.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g7.y, -other.g7.x, -other.g6.w, -other.g8.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.x, other.g6.z, -other.g6.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g6.z, other.g2.x, other.g6.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g6.y, -other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g2.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g2.w) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g2.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g2.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g2.w) * other.g10 * vec2<f32>(-1.0, 1.0));
}

fn dipole_origin_geometric_product(self_: Dipole, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_plane_geometric_product(self_: Dipole, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0.w));
}

fn dipole_plane_at_origin_geometric_product(self_: Dipole, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g2.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn dipole_point_at_infinity_geometric_product(self_: Dipole, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_point_at_origin_geometric_product(self_: Dipole, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), self_.g2.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn dipole_rotor_geometric_product(self_: Dipole, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_round_point_geometric_product(self_: Dipole, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_scalar_geometric_product(self_: Dipole, other: Scalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_sphere_geometric_product(self_: Dipole, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g2.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn dipole_translator_geometric_product(self_: Dipole, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_anti_scalar_geometric_product(self_: FlatPoint, other: AntiScalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn flat_point_circle_geometric_product(self_: FlatPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_dipole_geometric_product(self_: FlatPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn flat_point_flat_point_geometric_product(self_: FlatPoint, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_flector_geometric_product(self_: FlatPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w));
}

fn flat_point_horizon_geometric_product(self_: FlatPoint, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn flat_point_infinity_geometric_product(self_: FlatPoint, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn flat_point_line_geometric_product(self_: FlatPoint, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_line_at_infinity_geometric_product(self_: FlatPoint, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_line_at_origin_geometric_product(self_: FlatPoint, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_magnitude_geometric_product(self_: FlatPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_motor_geometric_product(self_: FlatPoint, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_multi_vector_geometric_product(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g5.w, -other.g6.w), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g9, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g0.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0));
}

fn flat_point_origin_geometric_product(self_: FlatPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_plane_geometric_product(self_: FlatPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w));
}

fn flat_point_plane_at_origin_geometric_product(self_: FlatPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn flat_point_point_at_infinity_geometric_product(self_: FlatPoint, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_point_at_origin_geometric_product(self_: FlatPoint, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_rotor_geometric_product(self_: FlatPoint, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_round_point_geometric_product(self_: FlatPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_scalar_geometric_product(self_: FlatPoint, other: Scalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_sphere_geometric_product(self_: FlatPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn flat_point_translator_geometric_product(self_: FlatPoint, other: Translator) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn flector_anti_scalar_geometric_product(self_: Flector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_circle_geometric_product(self_: Flector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_dipole_geometric_product(self_: Flector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g2.w));
}

fn flector_flat_point_geometric_product(self_: Flector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w));
}

fn flector_flector_geometric_product(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w));
}

fn flector_horizon_geometric_product(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g1.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_infinity_geometric_product(self_: Flector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_geometric_product(self_: Flector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_at_infinity_geometric_product(self_: Flector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_at_origin_geometric_product(self_: Flector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_magnitude_geometric_product(self_: Flector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.x));
}

fn flector_motor_geometric_product(self_: Flector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_multi_vector_geometric_product(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g5.w, -other.g6.w) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g6.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g1.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g0.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.w) * other.g7 + vec3<f32>(self_.g1.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.x));
}

fn flector_origin_geometric_product(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_plane_geometric_product(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g1.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w));
}

fn flector_plane_at_origin_geometric_product(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn flector_point_at_infinity_geometric_product(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn flector_point_at_origin_geometric_product(self_: Flector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0));
}

fn flector_rotor_geometric_product(self_: Flector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_round_point_geometric_product(self_: Flector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_scalar_geometric_product(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_sphere_geometric_product(self_: Flector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g1.xyzx * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn flector_translator_geometric_product(self_: Flector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_anti_scalar_geometric_product(self_: Horizon, other: AntiScalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn horizon_circle_geometric_product(self_: Horizon, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_dipole_geometric_product(self_: Horizon, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w));
}

fn horizon_flat_point_geometric_product(self_: Horizon, other: FlatPoint) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0.w);
}

fn horizon_flector_geometric_product(self_: Horizon, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w));
}

fn horizon_line_geometric_product(self_: Horizon, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_geometric_product(self_: Horizon, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_geometric_product(self_: Horizon, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn horizon_motor_geometric_product(self_: Horizon, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_multi_vector_geometric_product(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0) * other.g7 + vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn horizon_origin_geometric_product(self_: Horizon, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_plane_geometric_product(self_: Horizon, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_geometric_product(self_: Horizon, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_origin_geometric_product(self_: Horizon, other: PointAtOrigin) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn horizon_rotor_geometric_product(self_: Horizon, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_round_point_geometric_product(self_: Horizon, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_scalar_geometric_product(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_sphere_geometric_product(self_: Horizon, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_translator_geometric_product(self_: Horizon, other: Translator) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn infinity_anti_scalar_geometric_product(self_: Infinity, other: AntiScalar) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn infinity_circle_geometric_product(self_: Infinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w));
}

fn infinity_dipole_geometric_product(self_: Infinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_flat_point_geometric_product(self_: Infinity, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0.w);
}

fn infinity_flector_geometric_product(self_: Infinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_line_geometric_product(self_: Infinity, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn infinity_line_at_origin_geometric_product(self_: Infinity, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn infinity_magnitude_geometric_product(self_: Infinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.y));
}

fn infinity_motor_geometric_product(self_: Infinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w));
}

fn infinity_multi_vector_geometric_product(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g2.x, other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.x) + vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0) * other.g3, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9 + vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.y));
}

fn infinity_origin_geometric_product(self_: Infinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_plane_geometric_product(self_: Infinity, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn infinity_plane_at_origin_geometric_product(self_: Infinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn infinity_point_at_origin_geometric_product(self_: Infinity, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn infinity_rotor_geometric_product(self_: Infinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w));
}

fn infinity_round_point_geometric_product(self_: Infinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_scalar_geometric_product(self_: Infinity, other: Scalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_sphere_geometric_product(self_: Infinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_translator_geometric_product(self_: Infinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0.w);
}

fn line_anti_scalar_geometric_product(self_: Line, other: AntiScalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0));
}

fn line_circle_geometric_product(self_: Line, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_dipole_geometric_product(self_: Line, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_flat_point_geometric_product(self_: Line, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_flector_geometric_product(self_: Line, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_horizon_geometric_product(self_: Line, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_infinity_geometric_product(self_: Line, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_line_geometric_product(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_line_at_infinity_geometric_product(self_: Line, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_line_at_origin_geometric_product(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_magnitude_geometric_product(self_: Line, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_motor_geometric_product(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_multi_vector_geometric_product(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_origin_geometric_product(self_: Line, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn line_plane_geometric_product(self_: Line, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_plane_at_origin_geometric_product(self_: Line, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_point_at_infinity_geometric_product(self_: Line, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_point_at_origin_geometric_product(self_: Line, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_rotor_geometric_product(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_round_point_geometric_product(self_: Line, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_scalar_geometric_product(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_sphere_geometric_product(self_: Line, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_translator_geometric_product(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_at_infinity_anti_scalar_geometric_product(self_: LineAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_circle_geometric_product(self_: LineAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_infinity_dipole_geometric_product(self_: LineAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_flat_point_geometric_product(self_: LineAtInfinity, other: FlatPoint) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_infinity_flector_geometric_product(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_line_geometric_product(self_: LineAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_line_at_origin_geometric_product(self_: LineAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_magnitude_geometric_product(self_: LineAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_motor_geometric_product(self_: LineAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_multi_vector_geometric_product(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_infinity_origin_geometric_product(self_: LineAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_geometric_product(self_: LineAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_at_origin_geometric_product(self_: LineAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_point_at_origin_geometric_product(self_: LineAtInfinity, other: PointAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_rotor_geometric_product(self_: LineAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_round_point_geometric_product(self_: LineAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_at_infinity_scalar_geometric_product(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_sphere_geometric_product(self_: LineAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_translator_geometric_product(self_: LineAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_geometric_product(self_: LineAtOrigin, other: AntiScalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn line_at_origin_circle_geometric_product(self_: LineAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn line_at_origin_dipole_geometric_product(self_: LineAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_flat_point_geometric_product(self_: LineAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_flector_geometric_product(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_horizon_geometric_product(self_: LineAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_infinity_geometric_product(self_: LineAtOrigin, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_geometric_product(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_origin_line_at_infinity_geometric_product(self_: LineAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_origin_line_at_origin_geometric_product(self_: LineAtOrigin, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_magnitude_geometric_product(self_: LineAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_motor_geometric_product(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_origin_multi_vector_geometric_product(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z));
}

fn line_at_origin_origin_geometric_product(self_: LineAtOrigin, other: Origin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_plane_geometric_product(self_: LineAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_plane_at_origin_geometric_product(self_: LineAtOrigin, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_point_at_infinity_geometric_product(self_: LineAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_point_at_origin_geometric_product(self_: LineAtOrigin, other: PointAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn line_at_origin_rotor_geometric_product(self_: LineAtOrigin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_round_point_geometric_product(self_: LineAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn line_at_origin_scalar_geometric_product(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_sphere_geometric_product(self_: LineAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_translator_geometric_product(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn magnitude_anti_scalar_geometric_product(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0.yx * vec2<f32>(-other.g0));
}

fn magnitude_circle_geometric_product(self_: Magnitude, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_dipole_geometric_product(self_: Magnitude, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * other.g2, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flat_point_geometric_product(self_: Magnitude, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flector_geometric_product(self_: Magnitude, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.w));
}

fn magnitude_horizon_geometric_product(self_: Magnitude, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0));
}

fn magnitude_infinity_geometric_product(self_: Magnitude, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0));
}

fn magnitude_line_geometric_product(self_: Magnitude, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_infinity_geometric_product(self_: Magnitude, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_origin_geometric_product(self_: Magnitude, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_magnitude_geometric_product(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0));
}

fn magnitude_motor_geometric_product(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_multi_vector_geometric_product(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * other.g1 - vec3<f32>(self_.g0.y) * other.g9, vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10, vec3<f32>(self_.g0.x) * other.g3 - vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * other.g4 - vec3<f32>(self_.g0.y) * other.g7, vec4<f32>(self_.g0.x) * other.g5 + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0.x) * other.g6 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4, vec3<f32>(self_.g0.x) * other.g8 + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1, vec2<f32>(self_.g0.x) * other.g10 - vec2<f32>(self_.g0.y) * other.g2);
}

fn magnitude_origin_geometric_product(self_: Magnitude, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0, 0.0));
}

fn magnitude_plane_geometric_product(self_: Magnitude, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w));
}

fn magnitude_plane_at_origin_geometric_product(self_: Magnitude, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0));
}

fn magnitude_point_at_infinity_geometric_product(self_: Magnitude, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_point_at_origin_geometric_product(self_: Magnitude, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_rotor_geometric_product(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_round_point_geometric_product(self_: Magnitude, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_scalar_geometric_product(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_sphere_geometric_product(self_: Magnitude, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_translator_geometric_product(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_anti_scalar_geometric_product(self_: Motor, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_circle_geometric_product(self_: Motor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn motor_dipole_geometric_product(self_: Motor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_flat_point_geometric_product(self_: Motor, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) - self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_flector_geometric_product(self_: Motor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_horizon_geometric_product(self_: Motor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_infinity_geometric_product(self_: Motor, other: Infinity) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn motor_line_geometric_product(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_line_at_infinity_geometric_product(self_: Motor, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn motor_line_at_origin_geometric_product(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_magnitude_geometric_product(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_motor_geometric_product(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_multi_vector_geometric_product(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) - vec2<f32>(self_.g0.w) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn motor_origin_geometric_product(self_: Motor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn motor_plane_geometric_product(self_: Motor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_plane_at_origin_geometric_product(self_: Motor, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_point_at_infinity_geometric_product(self_: Motor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_point_at_origin_geometric_product(self_: Motor, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_rotor_geometric_product(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_round_point_geometric_product(self_: Motor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0 - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_scalar_geometric_product(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_sphere_geometric_product(self_: Motor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0 - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_translator_geometric_product(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_anti_scalar_geometric_product(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0), vec3<f32>(0.0) - self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g7 * vec3<f32>(other.g0), vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), self_.g4 * vec3<f32>(other.g0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g2 * vec2<f32>(other.g0));
}

fn multi_vector_circle_geometric_product(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g2.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g2.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * other.g2 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(-other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g1 - self_.g1 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.x) * other.g2 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g6.wwwz * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g2.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g3.x) * vec4<f32>(-other.g0.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g1.z, -other.g0.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g0.w, -other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g5.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g2 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g5.w) * other.g2 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g10.y) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * other.g2 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z));
}

fn multi_vector_dipole_geometric_product(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g2.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 - self_.g7 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g2 * vec2<f32>(other.g2.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, other.g2.w, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g2.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g10.y) * other.g0, vec4<f32>(self_.g0.x) * other.g2 + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.y) * other.g1 - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.y) * other.g1 - vec3<f32>(self_.g6.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g10.y) * other.g0, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(other.g2.w));
}

fn multi_vector_flat_point_geometric_product(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g7 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + self_.g5.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_flector_geometric_product(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) - vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) - vec4<f32>(self_.g10.y, self_.g10.y, self_.g10.y, self_.g10.x) * other.g1, vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g2.x) * other.g1 + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g1.z, other.g0.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) - vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g3.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_horizon_geometric_product(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), self_.g3 * vec3<f32>(other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0) + self_.g7 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_geometric_product(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0) + self_.g9 * vec3<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_line_geometric_product(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + self_.g6.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, -other.g1.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_line_at_infinity_geometric_product(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_line_at_origin_geometric_product(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_magnitude_geometric_product(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0), self_.g1 * vec3<f32>(other.g0.x) - self_.g9 * vec3<f32>(other.g0.y), self_.g2 * vec2<f32>(other.g0.x) + self_.g10 * vec2<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.x) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.y), self_.g4 * vec3<f32>(other.g0.x) - self_.g7 * vec3<f32>(other.g0.y), self_.g5 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6 * vec4<f32>(other.g0.x), self_.g4 * vec3<f32>(other.g0.y) + self_.g7 * vec3<f32>(other.g0.x), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.y) + self_.g8 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.y) + self_.g9 * vec3<f32>(other.g0.x), vec2<f32>(0.0) - self_.g2 * vec2<f32>(other.g0.y) + self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_motor_geometric_product(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g1.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, -other.g1.z) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) - self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_multi_vector_geometric_product(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g2.y, other.g10.y) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g2.x, other.g10.x) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g5.z, other.g8.z) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g5.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g5.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g5.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g5.w, -other.g6.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g8.x, -other.g5.x) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g8.y, -other.g5.y) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g8.z, -other.g5.z) - vec2<f32>(self_.g6.w) * vec2<f32>(other.g6.w, other.g5.w) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g8.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g8.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g8.z) * vec2<f32>(other.g6.z, -other.g3.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * other.g1 - vec3<f32>(self_.g0.y) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g5.w) * other.g7 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g6.w) * other.g4 + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g10.x) * other.g8 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g3.x, other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g3.y, other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g3.z, other.g5.z) + self_.g2 * vec2<f32>(other.g5.w) + self_.g2 * vec2<f32>(other.g0.x) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g6.w) * other.g10 * vec2<f32>(1.0, -1.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g10 * vec2<f32>(-other.g6.w) + self_.g10 * vec2<f32>(other.g0.y), vec3<f32>(self_.g0.x) * other.g3 - vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g2.x) * other.g7 + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) - vec3<f32>(self_.g5.w) * other.g3 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, -other.g0.y, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.y) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) + vec3<f32>(self_.g10.x) * other.g9 + vec3<f32>(self_.g10.x) * other.g4, vec3<f32>(self_.g0.x) * other.g4 - vec3<f32>(self_.g0.y) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) - vec3<f32>(self_.g2.x) * other.g8 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g5.w) * other.g9 + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g8.z, -other.g2.y, -other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g8.y, other.g8.x, -other.g2.y) - vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g10.y) * other.g3, vec4<f32>(self_.g0.x) * other.g5 + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g8.z, other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g8.y, -other.g8.x, other.g2.y, -other.g7.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.x) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g5.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g5.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g5.z) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g9.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g9.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, other.g0.y) + vec4<f32>(self_.g7.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.y) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * other.g6 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, -other.g4.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x) + vec4<f32>(self_.g3.x) * vec4<f32>(-other.g6.w, other.g7.z, -other.g7.y, -other.g8.x) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g7.z, -other.g6.w, other.g7.x, -other.g8.y) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g7.y, -other.g7.x, -other.g6.w, -other.g8.z) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g2.x, other.g6.z, -other.g6.y, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g6.z, other.g2.x, other.g6.x, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g6.y, -other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g5.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g5.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g5.w, other.g9.z, -other.g9.y, -other.g5.x) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g9.z, other.g5.w, other.g9.x, -other.g5.y) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g9.y, -other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.x) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g7.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g7.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g9.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g9.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g9.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.y) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) - vec3<f32>(self_.g6.w) * other.g9 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g10.x) * other.g8 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * other.g8 + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) - vec3<f32>(self_.g2.y) * other.g9 + vec3<f32>(self_.g2.y) * other.g4 + vec3<f32>(self_.g4.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g5.w) * other.g8 - vec3<f32>(self_.g6.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g10.y) * other.g7 + vec3<f32>(self_.g10.y) * other.g1, vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * other.g8 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g5.w) * other.g4 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g6.w) * other.g7 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g10.y) * other.g3, vec2<f32>(self_.g0.x) * other.g10 - vec2<f32>(self_.g0.y) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g2 * vec2<f32>(other.g6.w) - self_.g2 * vec2<f32>(other.g0.y) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g5.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g7.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g7.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g7.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g6.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g10 * vec2<f32>(other.g5.w) + self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_origin_geometric_product(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0) - self_.g7 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0));
}

fn multi_vector_plane_geometric_product(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) - vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) - vec4<f32>(self_.g10.y, self_.g10.y, self_.g10.y, self_.g10.x) * other.g0, vec4<f32>(self_.g2.x) * other.g0 + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) - self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_geometric_product(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_point_at_infinity_geometric_product(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_origin_geometric_product(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g5.w) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0) - self_.g7 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + self_.g5.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0) + self_.g6.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_rotor_geometric_product(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(0.0) - self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_round_point_geometric_product(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(self_.g0.x) * other.g0 + self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g7 * vec3<f32>(other.g1.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 - self_.g8 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x) + vec4<f32>(self_.g7.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g4 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_scalar_geometric_product(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_sphere_geometric_product(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g1.x) - self_.g9 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g10.x) * other.g0, self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.x, other.g1.x, other.g1.x, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g2.y) * other.g0 + self_.g7 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * other.g0 - self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn multi_vector_translator_geometric_product(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g7 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g6.w) * other.g0 + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) - self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g0.z));
}

fn origin_anti_scalar_geometric_product(self_: Origin, other: AntiScalar) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0));
}

fn origin_circle_geometric_product(self_: Origin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g2, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g2, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0));
}

fn origin_dipole_geometric_product(self_: Origin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec2<f32>(self_.g0) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_flat_point_geometric_product(self_: Origin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_flector_geometric_product(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_horizon_geometric_product(self_: Origin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_infinity_geometric_product(self_: Origin, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_geometric_product(self_: Origin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0));
}

fn origin_line_at_infinity_geometric_product(self_: Origin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn origin_line_at_origin_geometric_product(self_: Origin, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_magnitude_geometric_product(self_: Origin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.y, 0.0));
}

fn origin_motor_geometric_product(self_: Origin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_multi_vector_geometric_product(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g2.y, other.g10.y), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec2<f32>(self_.g0) * vec2<f32>(other.g5.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g7 + vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g8, vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y), vec4<f32>(self_.g0) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g8, vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(-other.g0.y, 0.0));
}

fn origin_plane_geometric_product(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_plane_at_origin_geometric_product(self_: Origin, other: PlaneAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_point_at_infinity_geometric_product(self_: Origin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_point_at_origin_geometric_product(self_: Origin, other: PointAtOrigin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_rotor_geometric_product(self_: Origin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_round_point_geometric_product(self_: Origin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g1.y, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_scalar_geometric_product(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_sphere_geometric_product(self_: Origin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_translator_geometric_product(self_: Origin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn plane_anti_scalar_geometric_product(self_: Plane, other: AntiScalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0));
}

fn plane_circle_geometric_product(self_: Plane, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_dipole_geometric_product(self_: Plane, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w));
}

fn plane_flat_point_geometric_product(self_: Plane, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w));
}

fn plane_flector_geometric_product(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w));
}

fn plane_horizon_geometric_product(self_: Plane, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_infinity_geometric_product(self_: Plane, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_geometric_product(self_: Plane, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_line_at_infinity_geometric_product(self_: Plane, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_line_at_origin_geometric_product(self_: Plane, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_magnitude_geometric_product(self_: Plane, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x));
}

fn plane_motor_geometric_product(self_: Plane, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_multi_vector_geometric_product(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g6.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x));
}

fn plane_origin_geometric_product(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_plane_geometric_product(self_: Plane, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_plane_at_origin_geometric_product(self_: Plane, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_point_at_infinity_geometric_product(self_: Plane, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn plane_point_at_origin_geometric_product(self_: Plane, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0));
}

fn plane_rotor_geometric_product(self_: Plane, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_round_point_geometric_product(self_: Plane, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_scalar_geometric_product(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_sphere_geometric_product(self_: Plane, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0.xyzx * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_translator_geometric_product(self_: Plane, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_anti_scalar_geometric_product(self_: PlaneAtOrigin, other: AntiScalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn plane_at_origin_circle_geometric_product(self_: PlaneAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_dipole_geometric_product(self_: PlaneAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g2.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z));
}

fn plane_at_origin_flat_point_geometric_product(self_: PlaneAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn plane_at_origin_flector_geometric_product(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn plane_at_origin_horizon_geometric_product(self_: PlaneAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_infinity_geometric_product(self_: PlaneAtOrigin, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_geometric_product(self_: PlaneAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_line_at_infinity_geometric_product(self_: PlaneAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_line_at_origin_geometric_product(self_: PlaneAtOrigin, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_magnitude_geometric_product(self_: PlaneAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0));
}

fn plane_at_origin_motor_geometric_product(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_multi_vector_geometric_product(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z));
}

fn plane_at_origin_origin_geometric_product(self_: PlaneAtOrigin, other: Origin) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn plane_at_origin_plane_geometric_product(self_: PlaneAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_plane_at_origin_geometric_product(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_point_at_infinity_geometric_product(self_: PlaneAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn plane_at_origin_point_at_origin_geometric_product(self_: PlaneAtOrigin, other: PointAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn plane_at_origin_rotor_geometric_product(self_: PlaneAtOrigin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_round_point_geometric_product(self_: PlaneAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_scalar_geometric_product(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_sphere_geometric_product(self_: PlaneAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_translator_geometric_product(self_: PlaneAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_anti_scalar_geometric_product(self_: PointAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_geometric_product(self_: PointAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_dipole_geometric_product(self_: PointAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn point_at_infinity_flat_point_geometric_product(self_: PointAtInfinity, other: FlatPoint) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_flector_geometric_product(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z));
}

fn point_at_infinity_line_geometric_product(self_: PointAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_line_at_origin_geometric_product(self_: PointAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_magnitude_geometric_product(self_: PointAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_motor_geometric_product(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_multi_vector_geometric_product(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn point_at_infinity_origin_geometric_product(self_: PointAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_geometric_product(self_: PointAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn point_at_infinity_plane_at_origin_geometric_product(self_: PointAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn point_at_infinity_point_at_origin_geometric_product(self_: PointAtInfinity, other: PointAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_rotor_geometric_product(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_round_point_geometric_product(self_: PointAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_scalar_geometric_product(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_sphere_geometric_product(self_: PointAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn point_at_infinity_translator_geometric_product(self_: PointAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_origin_anti_scalar_geometric_product(self_: PointAtOrigin, other: AntiScalar) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn point_at_origin_circle_geometric_product(self_: PointAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_dipole_geometric_product(self_: PointAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0));
}

fn point_at_origin_flat_point_geometric_product(self_: PointAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_flector_geometric_product(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w));
}

fn point_at_origin_horizon_geometric_product(self_: PointAtOrigin, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn point_at_origin_infinity_geometric_product(self_: PointAtOrigin, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn point_at_origin_line_geometric_product(self_: PointAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_line_at_infinity_geometric_product(self_: PointAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_line_at_origin_geometric_product(self_: PointAtOrigin, other: LineAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn point_at_origin_magnitude_geometric_product(self_: PointAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_motor_geometric_product(self_: PointAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_multi_vector_geometric_product(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g5.w, -other.g6.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g7, vec2<f32>(self_.g0) * other.g2 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g9, vec4<f32>(self_.g0) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g4, vec2<f32>(self_.g0) * other.g10 * vec2<f32>(-1.0, 1.0));
}

fn point_at_origin_origin_geometric_product(self_: PointAtOrigin, other: Origin) -> Origin {
    return Origin(0.0 - self_.g0 * other.g0);
}

fn point_at_origin_plane_geometric_product(self_: PointAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w));
}

fn point_at_origin_plane_at_origin_geometric_product(self_: PointAtOrigin, other: PlaneAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0));
}

fn point_at_origin_point_at_infinity_geometric_product(self_: PointAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_point_at_origin_geometric_product(self_: PointAtOrigin, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn point_at_origin_rotor_geometric_product(self_: PointAtOrigin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_round_point_geometric_product(self_: PointAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_scalar_geometric_product(self_: PointAtOrigin, other: Scalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn point_at_origin_sphere_geometric_product(self_: PointAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn point_at_origin_translator_geometric_product(self_: PointAtOrigin, other: Translator) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn rotor_anti_scalar_geometric_product(self_: Rotor, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_circle_geometric_product(self_: Rotor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn rotor_dipole_geometric_product(self_: Rotor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_flat_point_geometric_product(self_: Rotor, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_flector_geometric_product(self_: Rotor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_horizon_geometric_product(self_: Rotor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_infinity_geometric_product(self_: Rotor, other: Infinity) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn rotor_line_geometric_product(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn rotor_line_at_infinity_geometric_product(self_: Rotor, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn rotor_line_at_origin_geometric_product(self_: Rotor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_magnitude_geometric_product(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_motor_geometric_product(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn rotor_multi_vector_geometric_product(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) - vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g0.w) * other.g7, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) - vec2<f32>(self_.g0.w) * other.g2);
}

fn rotor_origin_geometric_product(self_: Rotor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn rotor_plane_geometric_product(self_: Rotor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_plane_at_origin_geometric_product(self_: Rotor, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_point_at_infinity_geometric_product(self_: Rotor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_point_at_origin_geometric_product(self_: Rotor, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_rotor_geometric_product(self_: Rotor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_round_point_geometric_product(self_: Rotor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_scalar_geometric_product(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_sphere_geometric_product(self_: Rotor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_translator_geometric_product(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn round_point_anti_scalar_geometric_product(self_: RoundPoint, other: AntiScalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0));
}

fn round_point_circle_geometric_product(self_: RoundPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_dipole_geometric_product(self_: RoundPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g1 * vec2<f32>(other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_flat_point_geometric_product(self_: RoundPoint, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_flector_geometric_product(self_: RoundPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_horizon_geometric_product(self_: RoundPoint, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_infinity_geometric_product(self_: RoundPoint, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_geometric_product(self_: RoundPoint, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn round_point_line_at_infinity_geometric_product(self_: RoundPoint, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn round_point_line_at_origin_geometric_product(self_: RoundPoint, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn round_point_magnitude_geometric_product(self_: RoundPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0.y));
}

fn round_point_motor_geometric_product(self_: RoundPoint, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) - self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_multi_vector_geometric_product(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g2.y, other.g10.y) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g2.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g3.x, other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g3.y, other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g3.z, other.g5.z) + self_.g1 * vec2<f32>(other.g5.w) + self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g1.x) * other.g7 + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) - vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, other.g2.y, -other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) - vec3<f32>(self_.g1.y) * other.g9 + vec3<f32>(self_.g1.y) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(other.g6.w) - self_.g1 * vec2<f32>(other.g0.y));
}

fn round_point_origin_geometric_product(self_: RoundPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_geometric_product(self_: RoundPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_at_origin_geometric_product(self_: RoundPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_point_at_infinity_geometric_product(self_: RoundPoint, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_point_at_origin_geometric_product(self_: RoundPoint, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_rotor_geometric_product(self_: RoundPoint, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_round_point_geometric_product(self_: RoundPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_scalar_geometric_product(self_: RoundPoint, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_sphere_geometric_product(self_: RoundPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.x, other.g1.x, other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_translator_geometric_product(self_: RoundPoint, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) - self_.g1 * vec2<f32>(other.g0.w));
}

fn scalar_anti_scalar_geometric_product(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_circle_geometric_product(self_: Scalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn scalar_dipole_geometric_product(self_: Scalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn scalar_flat_point_geometric_product(self_: Scalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_flector_geometric_product(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_geometric_product(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_infinity_geometric_product(self_: Scalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn scalar_line_geometric_product(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_geometric_product(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_geometric_product(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_geometric_product(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_geometric_product(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_geometric_product(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn scalar_origin_geometric_product(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_geometric_product(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_geometric_product(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_geometric_product(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_origin_geometric_product(self_: Scalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn scalar_rotor_geometric_product(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_round_point_geometric_product(self_: Scalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_scalar_geometric_product(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_sphere_geometric_product(self_: Scalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_translator_geometric_product(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn sphere_anti_scalar_geometric_product(self_: Sphere, other: AntiScalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_circle_geometric_product(self_: Sphere, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_dipole_geometric_product(self_: Sphere, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g2.w));
}

fn sphere_flat_point_geometric_product(self_: Sphere, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_flector_geometric_product(self_: Sphere, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) - vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g1, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_horizon_geometric_product(self_: Sphere, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_infinity_geometric_product(self_: Sphere, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_geometric_product(self_: Sphere, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_at_infinity_geometric_product(self_: Sphere, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_at_origin_geometric_product(self_: Sphere, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_magnitude_geometric_product(self_: Sphere, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_motor_geometric_product(self_: Sphere, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_multi_vector_geometric_product(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(-other.g6.w) + self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) + vec3<f32>(self_.g1.x) * other.g9 + vec3<f32>(self_.g1.x) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.y) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.y) * other.g7 + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(other.g5.w) + self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_origin_geometric_product(self_: Sphere, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_geometric_product(self_: Sphere, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) - vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_at_origin_geometric_product(self_: Sphere, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_point_at_infinity_geometric_product(self_: Sphere, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn sphere_point_at_origin_geometric_product(self_: Sphere, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_rotor_geometric_product(self_: Sphere, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_round_point_geometric_product(self_: Sphere, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_scalar_geometric_product(self_: Sphere, other: Scalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_sphere_geometric_product(self_: Sphere, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_translator_geometric_product(self_: Sphere, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_anti_scalar_geometric_product(self_: Translator, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_circle_geometric_product(self_: Translator, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn translator_dipole_geometric_product(self_: Translator, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_flat_point_geometric_product(self_: Translator, other: FlatPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn translator_flector_geometric_product(self_: Translator, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_horizon_geometric_product(self_: Translator, other: Horizon) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn translator_infinity_geometric_product(self_: Translator, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0.w * other.g0);
}

fn translator_line_geometric_product(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_line_at_infinity_geometric_product(self_: Translator, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_geometric_product(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_magnitude_geometric_product(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_motor_geometric_product(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_multi_vector_geometric_product(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g3.z) + vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) - vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10, vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * other.g7, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) - vec2<f32>(self_.g0.w) * other.g2);
}

fn translator_origin_geometric_product(self_: Translator, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn translator_plane_geometric_product(self_: Translator, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_plane_at_origin_geometric_product(self_: Translator, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_point_at_infinity_geometric_product(self_: Translator, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_origin_geometric_product(self_: Translator, other: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_rotor_geometric_product(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_round_point_geometric_product(self_: Translator, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) - vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_scalar_geometric_product(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_sphere_geometric_product(self_: Translator, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_translator_geometric_product(self_: Translator, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_anti_scalar_wedge_dot(self_: AntiScalar, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_circle_wedge_dot(self_: AntiScalar, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w));
}

fn anti_scalar_dipole_wedge_dot(self_: AntiScalar, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z));
}

fn anti_scalar_flat_point_wedge_dot(self_: AntiScalar, other: FlatPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn anti_scalar_flector_wedge_dot(self_: AntiScalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_horizon_wedge_dot(self_: AntiScalar, other: Horizon) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn anti_scalar_infinity_wedge_dot(self_: AntiScalar, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_line_wedge_dot(self_: AntiScalar, other: Line) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0));
}

fn anti_scalar_line_at_infinity_wedge_dot(self_: AntiScalar, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_wedge_dot(self_: AntiScalar, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0));
}

fn anti_scalar_magnitude_wedge_dot(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(-1.0, 1.0));
}

fn anti_scalar_motor_wedge_dot(self_: AntiScalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_multi_vector_wedge_dot(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g7, vec4<f32>(self_.g0) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0) * other.g4, vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g2);
}

fn anti_scalar_origin_wedge_dot(self_: AntiScalar, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0));
}

fn anti_scalar_plane_wedge_dot(self_: AntiScalar, other: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w));
}

fn anti_scalar_plane_at_origin_wedge_dot(self_: AntiScalar, other: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn anti_scalar_point_at_infinity_wedge_dot(self_: AntiScalar, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_origin_wedge_dot(self_: AntiScalar, other: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn anti_scalar_rotor_wedge_dot(self_: AntiScalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_round_point_wedge_dot(self_: AntiScalar, other: RoundPoint) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_scalar_wedge_dot(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_sphere_wedge_dot(self_: AntiScalar, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_translator_wedge_dot(self_: AntiScalar, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_anti_scalar_wedge_dot(self_: Circle, other: AntiScalar) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0));
}

fn circle_circle_wedge_dot(self_: Circle, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g0.wwwz * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z));
}

fn circle_dipole_wedge_dot(self_: Circle, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_flat_point_wedge_dot(self_: Circle, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_flector_wedge_dot(self_: Circle, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) - vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, other.g0.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_horizon_wedge_dot(self_: Circle, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_infinity_wedge_dot(self_: Circle, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0));
}

fn circle_line_wedge_dot(self_: Circle, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + self_.g0.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_line_at_infinity_wedge_dot(self_: Circle, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_line_at_origin_wedge_dot(self_: Circle, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_magnitude_wedge_dot(self_: Circle, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_motor_wedge_dot(self_: Circle, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_multi_vector_wedge_dot(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g8.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g8.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g8.z, -other.g5.z) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g6.w, other.g5.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(1.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.y) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g8.z, -other.g2.y, -other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g8.y, other.g8.x, -other.g2.y) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g5.w, other.g9.z, -other.g9.y, -other.g5.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g9.z, other.g5.w, other.g9.x, -other.g5.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g9.y, -other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z));
}

fn circle_origin_wedge_dot(self_: Circle, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn circle_plane_wedge_dot(self_: Circle, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) - vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_plane_at_origin_wedge_dot(self_: Circle, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_point_at_infinity_wedge_dot(self_: Circle, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_point_at_origin_wedge_dot(self_: Circle, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_rotor_wedge_dot(self_: Circle, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_round_point_wedge_dot(self_: Circle, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 - self_.g2 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_scalar_wedge_dot(self_: Circle, other: Scalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn circle_sphere_wedge_dot(self_: Circle, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_translator_wedge_dot(self_: Circle, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn dipole_anti_scalar_wedge_dot(self_: Dipole, other: AntiScalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0));
}

fn dipole_circle_wedge_dot(self_: Dipole, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g0.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g0.w, -other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g2.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g2.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_dipole_wedge_dot(self_: Dipole, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn dipole_flat_point_wedge_dot(self_: Dipole, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + self_.g2.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_flector_wedge_dot(self_: Dipole, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g1.w));
}

fn dipole_horizon_wedge_dot(self_: Dipole, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0));
}

fn dipole_infinity_wedge_dot(self_: Dipole, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_line_wedge_dot(self_: Dipole, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_line_at_infinity_wedge_dot(self_: Dipole, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_line_at_origin_wedge_dot(self_: Dipole, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_magnitude_wedge_dot(self_: Dipole, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_motor_wedge_dot(self_: Dipole, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, -other.g1.z) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g2.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_multi_vector_wedge_dot(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g5.z, other.g8.z) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g2.w) * vec2<f32>(other.g5.w, -other.g6.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g2.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.w) * other.g2 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) - vec3<f32>(self_.g2.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g2.w) * other.g9, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g5.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g5.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g5.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, other.g7.z, -other.g7.y, -other.g8.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g7.z, -other.g6.w, other.g7.x, -other.g8.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g7.y, -other.g7.x, -other.g6.w, -other.g8.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.x, other.g6.z, -other.g6.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g6.z, other.g2.x, other.g6.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g6.y, -other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g2.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g2.w) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g2.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g2.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g2.w) * other.g10 * vec2<f32>(-1.0, 1.0));
}

fn dipole_origin_wedge_dot(self_: Dipole, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_plane_wedge_dot(self_: Dipole, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0.w));
}

fn dipole_plane_at_origin_wedge_dot(self_: Dipole, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g2.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn dipole_point_at_infinity_wedge_dot(self_: Dipole, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn dipole_point_at_origin_wedge_dot(self_: Dipole, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), self_.g2.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn dipole_rotor_wedge_dot(self_: Dipole, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_round_point_wedge_dot(self_: Dipole, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_scalar_wedge_dot(self_: Dipole, other: Scalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_sphere_wedge_dot(self_: Dipole, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g2.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn dipole_translator_wedge_dot(self_: Dipole, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_anti_scalar_wedge_dot(self_: FlatPoint, other: AntiScalar) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn flat_point_circle_wedge_dot(self_: FlatPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_dipole_wedge_dot(self_: FlatPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn flat_point_flat_point_wedge_dot(self_: FlatPoint, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_flector_wedge_dot(self_: FlatPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w));
}

fn flat_point_horizon_wedge_dot(self_: FlatPoint, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn flat_point_infinity_wedge_dot(self_: FlatPoint, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn flat_point_line_wedge_dot(self_: FlatPoint, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_line_at_infinity_wedge_dot(self_: FlatPoint, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_line_at_origin_wedge_dot(self_: FlatPoint, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_magnitude_wedge_dot(self_: FlatPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_motor_wedge_dot(self_: FlatPoint, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_multi_vector_wedge_dot(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g5.w, -other.g6.w), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * other.g7, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g9, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g0.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0));
}

fn flat_point_origin_wedge_dot(self_: FlatPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_plane_wedge_dot(self_: FlatPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w));
}

fn flat_point_plane_at_origin_wedge_dot(self_: FlatPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn flat_point_point_at_infinity_wedge_dot(self_: FlatPoint, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn flat_point_point_at_origin_wedge_dot(self_: FlatPoint, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_rotor_wedge_dot(self_: FlatPoint, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_round_point_wedge_dot(self_: FlatPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_scalar_wedge_dot(self_: FlatPoint, other: Scalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_sphere_wedge_dot(self_: FlatPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn flat_point_translator_wedge_dot(self_: FlatPoint, other: Translator) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn flector_anti_scalar_wedge_dot(self_: Flector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_circle_wedge_dot(self_: Flector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g2 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_dipole_wedge_dot(self_: Flector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g2.w));
}

fn flector_flat_point_wedge_dot(self_: Flector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w));
}

fn flector_flector_wedge_dot(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w));
}

fn flector_horizon_wedge_dot(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g1.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_infinity_wedge_dot(self_: Flector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_wedge_dot(self_: Flector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_at_infinity_wedge_dot(self_: Flector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_at_origin_wedge_dot(self_: Flector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_magnitude_wedge_dot(self_: Flector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.x));
}

fn flector_motor_wedge_dot(self_: Flector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_multi_vector_wedge_dot(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g5.w, -other.g6.w) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g6.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g1.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g0.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g0.w) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.w) * other.g7 + vec3<f32>(self_.g1.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.x));
}

fn flector_origin_wedge_dot(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_plane_wedge_dot(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g1.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w));
}

fn flector_plane_at_origin_wedge_dot(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn flector_point_at_infinity_wedge_dot(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn flector_point_at_origin_wedge_dot(self_: Flector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0));
}

fn flector_rotor_wedge_dot(self_: Flector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_round_point_wedge_dot(self_: Flector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_scalar_wedge_dot(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_sphere_wedge_dot(self_: Flector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + self_.g1.xyzx * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn flector_translator_wedge_dot(self_: Flector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_anti_scalar_wedge_dot(self_: Horizon, other: AntiScalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn horizon_circle_wedge_dot(self_: Horizon, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_dipole_wedge_dot(self_: Horizon, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w));
}

fn horizon_flat_point_wedge_dot(self_: Horizon, other: FlatPoint) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0.w);
}

fn horizon_flector_wedge_dot(self_: Horizon, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w));
}

fn horizon_line_wedge_dot(self_: Horizon, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_wedge_dot(self_: Horizon, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_wedge_dot(self_: Horizon, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn horizon_motor_wedge_dot(self_: Horizon, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_multi_vector_wedge_dot(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0) * other.g7 + vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn horizon_origin_wedge_dot(self_: Horizon, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_plane_wedge_dot(self_: Horizon, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_wedge_dot(self_: Horizon, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_origin_wedge_dot(self_: Horizon, other: PointAtOrigin) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn horizon_rotor_wedge_dot(self_: Horizon, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_round_point_wedge_dot(self_: Horizon, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_scalar_wedge_dot(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_sphere_wedge_dot(self_: Horizon, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_translator_wedge_dot(self_: Horizon, other: Translator) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn infinity_anti_scalar_wedge_dot(self_: Infinity, other: AntiScalar) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn infinity_circle_wedge_dot(self_: Infinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w));
}

fn infinity_dipole_wedge_dot(self_: Infinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_flat_point_wedge_dot(self_: Infinity, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0.w);
}

fn infinity_flector_wedge_dot(self_: Infinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_line_wedge_dot(self_: Infinity, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn infinity_line_at_origin_wedge_dot(self_: Infinity, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn infinity_magnitude_wedge_dot(self_: Infinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.y));
}

fn infinity_motor_wedge_dot(self_: Infinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w));
}

fn infinity_multi_vector_wedge_dot(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g2.x, other.g10.x), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.x) + vec4<f32>(self_.g0) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0) * other.g3, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9 + vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.y));
}

fn infinity_origin_wedge_dot(self_: Infinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_plane_wedge_dot(self_: Infinity, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn infinity_plane_at_origin_wedge_dot(self_: Infinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn infinity_point_at_origin_wedge_dot(self_: Infinity, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn infinity_rotor_wedge_dot(self_: Infinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w));
}

fn infinity_round_point_wedge_dot(self_: Infinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_scalar_wedge_dot(self_: Infinity, other: Scalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_sphere_wedge_dot(self_: Infinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_translator_wedge_dot(self_: Infinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0.w);
}

fn line_anti_scalar_wedge_dot(self_: Line, other: AntiScalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0));
}

fn line_circle_wedge_dot(self_: Line, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_dipole_wedge_dot(self_: Line, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_flat_point_wedge_dot(self_: Line, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_flector_wedge_dot(self_: Line, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_horizon_wedge_dot(self_: Line, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_infinity_wedge_dot(self_: Line, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_line_wedge_dot(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_line_at_infinity_wedge_dot(self_: Line, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_line_at_origin_wedge_dot(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_magnitude_wedge_dot(self_: Line, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_motor_wedge_dot(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_multi_vector_wedge_dot(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_origin_wedge_dot(self_: Line, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn line_plane_wedge_dot(self_: Line, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_plane_at_origin_wedge_dot(self_: Line, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_point_at_infinity_wedge_dot(self_: Line, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_point_at_origin_wedge_dot(self_: Line, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_rotor_wedge_dot(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_round_point_wedge_dot(self_: Line, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_scalar_wedge_dot(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_sphere_wedge_dot(self_: Line, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), self_.g1 * vec3<f32>(other.g1.x), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_translator_wedge_dot(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_at_infinity_anti_scalar_wedge_dot(self_: LineAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_circle_wedge_dot(self_: LineAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_infinity_dipole_wedge_dot(self_: LineAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_flat_point_wedge_dot(self_: LineAtInfinity, other: FlatPoint) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_infinity_flector_wedge_dot(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_line_wedge_dot(self_: LineAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_line_at_origin_wedge_dot(self_: LineAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_magnitude_wedge_dot(self_: LineAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_motor_wedge_dot(self_: LineAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_multi_vector_wedge_dot(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_infinity_origin_wedge_dot(self_: LineAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_wedge_dot(self_: LineAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_at_origin_wedge_dot(self_: LineAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_point_at_origin_wedge_dot(self_: LineAtInfinity, other: PointAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_rotor_wedge_dot(self_: LineAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_infinity_round_point_wedge_dot(self_: LineAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn line_at_infinity_scalar_wedge_dot(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_sphere_wedge_dot(self_: LineAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_translator_wedge_dot(self_: LineAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_wedge_dot(self_: LineAtOrigin, other: AntiScalar) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn line_at_origin_circle_wedge_dot(self_: LineAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn line_at_origin_dipole_wedge_dot(self_: LineAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_flat_point_wedge_dot(self_: LineAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_flector_wedge_dot(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_horizon_wedge_dot(self_: LineAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_infinity_wedge_dot(self_: LineAtOrigin, other: Infinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_wedge_dot(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_origin_line_at_infinity_wedge_dot(self_: LineAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn line_at_origin_line_at_origin_wedge_dot(self_: LineAtOrigin, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_magnitude_wedge_dot(self_: LineAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_motor_wedge_dot(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_origin_multi_vector_wedge_dot(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z));
}

fn line_at_origin_origin_wedge_dot(self_: LineAtOrigin, other: Origin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_plane_wedge_dot(self_: LineAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_plane_at_origin_wedge_dot(self_: LineAtOrigin, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_point_at_infinity_wedge_dot(self_: LineAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_point_at_origin_wedge_dot(self_: LineAtOrigin, other: PointAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn line_at_origin_rotor_wedge_dot(self_: LineAtOrigin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_round_point_wedge_dot(self_: LineAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn line_at_origin_scalar_wedge_dot(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_sphere_wedge_dot(self_: LineAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_translator_wedge_dot(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn magnitude_anti_scalar_wedge_dot(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0.yx * vec2<f32>(-other.g0));
}

fn magnitude_circle_wedge_dot(self_: Magnitude, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_dipole_wedge_dot(self_: Magnitude, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * other.g2, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flat_point_wedge_dot(self_: Magnitude, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_flector_wedge_dot(self_: Magnitude, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.w));
}

fn magnitude_horizon_wedge_dot(self_: Magnitude, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0));
}

fn magnitude_infinity_wedge_dot(self_: Magnitude, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0));
}

fn magnitude_line_wedge_dot(self_: Magnitude, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_infinity_wedge_dot(self_: Magnitude, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_line_at_origin_wedge_dot(self_: Magnitude, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_magnitude_wedge_dot(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0));
}

fn magnitude_motor_wedge_dot(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_multi_vector_wedge_dot(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * other.g1 - vec3<f32>(self_.g0.y) * other.g9, vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10, vec3<f32>(self_.g0.x) * other.g3 - vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * other.g4 - vec3<f32>(self_.g0.y) * other.g7, vec4<f32>(self_.g0.x) * other.g5 + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0.x) * other.g6 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4, vec3<f32>(self_.g0.x) * other.g8 + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1, vec2<f32>(self_.g0.x) * other.g10 - vec2<f32>(self_.g0.y) * other.g2);
}

fn magnitude_origin_wedge_dot(self_: Magnitude, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0, 0.0));
}

fn magnitude_plane_wedge_dot(self_: Magnitude, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w));
}

fn magnitude_plane_at_origin_wedge_dot(self_: Magnitude, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0));
}

fn magnitude_point_at_infinity_wedge_dot(self_: Magnitude, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_point_at_origin_wedge_dot(self_: Magnitude, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_rotor_wedge_dot(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_round_point_wedge_dot(self_: Magnitude, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_scalar_wedge_dot(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_sphere_wedge_dot(self_: Magnitude, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_translator_wedge_dot(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_anti_scalar_wedge_dot(self_: Motor, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_circle_wedge_dot(self_: Motor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn motor_dipole_wedge_dot(self_: Motor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_flat_point_wedge_dot(self_: Motor, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) - self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_flector_wedge_dot(self_: Motor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_horizon_wedge_dot(self_: Motor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_infinity_wedge_dot(self_: Motor, other: Infinity) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn motor_line_wedge_dot(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_line_at_infinity_wedge_dot(self_: Motor, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn motor_line_at_origin_wedge_dot(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_magnitude_wedge_dot(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_motor_wedge_dot(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_multi_vector_wedge_dot(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) - vec3<f32>(self_.g0.w) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) - vec2<f32>(self_.g0.w) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn motor_origin_wedge_dot(self_: Motor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn motor_plane_wedge_dot(self_: Motor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_plane_at_origin_wedge_dot(self_: Motor, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_point_at_infinity_wedge_dot(self_: Motor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_point_at_origin_wedge_dot(self_: Motor, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_rotor_wedge_dot(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_round_point_wedge_dot(self_: Motor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0 - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z));
}

fn motor_scalar_wedge_dot(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_sphere_wedge_dot(self_: Motor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0 - self_.g1 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.w) * other.g1 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_translator_wedge_dot(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_anti_scalar_wedge_dot(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0), vec3<f32>(0.0) - self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g7 * vec3<f32>(other.g0), vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), self_.g4 * vec3<f32>(other.g0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g2 * vec2<f32>(other.g0));
}

fn multi_vector_circle_wedge_dot(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g2.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g2.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * other.g2 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(-other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, other.g0.w, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g1 - self_.g1 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.x) * other.g2 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.y) + self_.g6.wwwz * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, -other.g2.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g3.x) * vec4<f32>(-other.g0.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g1.z, -other.g0.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g0.w, -other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + self_.g5.wwwz * other.g0.xyzz * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g2 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g5.w) * other.g2 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g10.y) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * other.g2 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z));
}

fn multi_vector_dipole_wedge_dot(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g2.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 - self_.g7 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g2 * vec2<f32>(other.g2.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, other.g2.w, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g2.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g10.y) * other.g0, vec4<f32>(self_.g0.x) * other.g2 + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g2.w, other.g1.z, -other.g1.y, -other.g2.x) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g1.z, other.g2.w, other.g1.x, -other.g2.y) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g2.w, -other.g2.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.y) * other.g1 - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.y) * other.g1 - vec3<f32>(self_.g6.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g10.y) * other.g0, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(other.g2.w));
}

fn multi_vector_flat_point_wedge_dot(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g7 * vec3<f32>(other.g0.w), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + self_.g5.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_flector_wedge_dot(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) - vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g1.z, other.g1.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g3.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, -other.g1.z) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) - vec4<f32>(self_.g10.y, self_.g10.y, self_.g10.y, self_.g10.x) * other.g1, vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g2.x) * other.g1 + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g1.z, other.g0.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g1.y, -other.g1.x, other.g0.w, -other.g0.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(self_.g1.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) - vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g3.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_horizon_wedge_dot(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), self_.g3 * vec3<f32>(other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0) + self_.g7 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_wedge_dot(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(-other.g0, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0) + self_.g9 * vec3<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_line_wedge_dot(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + self_.g6.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, -other.g1.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_line_at_infinity_wedge_dot(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_line_at_origin_wedge_dot(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_magnitude_wedge_dot(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0), self_.g1 * vec3<f32>(other.g0.x) - self_.g9 * vec3<f32>(other.g0.y), self_.g2 * vec2<f32>(other.g0.x) + self_.g10 * vec2<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.x) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.y), self_.g4 * vec3<f32>(other.g0.x) - self_.g7 * vec3<f32>(other.g0.y), self_.g5 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g6 * vec4<f32>(other.g0.x), self_.g4 * vec3<f32>(other.g0.y) + self_.g7 * vec3<f32>(other.g0.x), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.y) + self_.g8 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.y) + self_.g9 * vec3<f32>(other.g0.x), vec2<f32>(0.0) - self_.g2 * vec2<f32>(other.g0.y) + self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_motor_wedge_dot(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g1.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) - vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, -other.g1.y) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, -other.g1.z) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) - self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_multi_vector_wedge_dot(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * other.g0.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g2.y, other.g10.y) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g2.x, other.g10.x) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g5.x, other.g8.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g5.y, other.g8.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g5.z, other.g8.z) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g4.x, other.g7.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g4.y, other.g7.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g4.z, other.g7.z) - vec2<f32>(self_.g5.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g5.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g5.z) * vec2<f32>(other.g3.z, other.g6.z) + vec2<f32>(self_.g5.w) * vec2<f32>(other.g5.w, -other.g6.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g8.x, -other.g5.x) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g8.y, -other.g5.y) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g8.z, -other.g5.z) - vec2<f32>(self_.g6.w) * vec2<f32>(other.g6.w, other.g5.w) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g8.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g8.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g8.z) * vec2<f32>(other.g6.z, -other.g3.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * other.g1 - vec3<f32>(self_.g0.y) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g5.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g5.w) * other.g7 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g6.w) * other.g4 + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g10.x) * other.g8 - vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * other.g2 + vec2<f32>(self_.g0.y) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g3.x, other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g3.y, other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g3.z, other.g5.z) + self_.g2 * vec2<f32>(other.g5.w) + self_.g2 * vec2<f32>(other.g0.x) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g6.w) * other.g10 * vec2<f32>(1.0, -1.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g10 * vec2<f32>(-other.g6.w) + self_.g10 * vec2<f32>(other.g0.y), vec3<f32>(self_.g0.x) * other.g3 - vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g2.x) * other.g7 + vec3<f32>(self_.g2.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) - vec3<f32>(self_.g5.w) * other.g3 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g6.w, -other.g7.z, other.g7.y) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g7.z, other.g6.w, -other.g7.x) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, -other.g0.y, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g7.y, other.g7.x, other.g6.w) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g0.y) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) + vec3<f32>(self_.g10.x) * other.g9 + vec3<f32>(self_.g10.x) * other.g4, vec3<f32>(self_.g0.x) * other.g4 - vec3<f32>(self_.g0.y) * other.g7 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) - vec3<f32>(self_.g2.x) * other.g8 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g5.w) * other.g9 + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g2.y, -other.g8.z, other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g8.z, -other.g2.y, -other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g8.y, other.g8.x, -other.g2.y) - vec3<f32>(self_.g6.w) * other.g1 + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g10.y) * other.g3, vec4<f32>(self_.g0.x) * other.g5 + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g8.z, other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g8.y, -other.g8.x, other.g2.y, -other.g7.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.x) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g5.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g5.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g5.z) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g9.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g9.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g9.z) + vec4<f32>(self_.g5.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g5.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g5.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g5.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g8.z) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g8.x, other.g8.y, other.g8.z, other.g0.y) + vec4<f32>(self_.g7.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.y) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * other.g6 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, -other.g4.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x) + vec4<f32>(self_.g3.x) * vec4<f32>(-other.g6.w, other.g7.z, -other.g7.y, -other.g8.x) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g7.z, -other.g6.w, other.g7.x, -other.g8.y) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g7.y, -other.g7.x, -other.g6.w, -other.g8.z) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g1.y, other.g1.x, other.g0.y, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g2.x, other.g6.z, -other.g6.y, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g6.z, other.g2.x, other.g6.x, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g6.y, -other.g6.x, other.g2.x, -other.g1.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g5.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g5.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z) - vec4<f32>(self_.g5.w) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g5.w, other.g9.z, -other.g9.y, -other.g5.x) + vec4<f32>(self_.g6.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g9.z, other.g5.w, other.g9.x, -other.g5.y) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g9.y, -other.g9.x, other.g5.w, -other.g5.z) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0) + vec4<f32>(self_.g6.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.x) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g7.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g7.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g8.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g8.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g9.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g9.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g9.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.y) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * other.g7 + vec3<f32>(self_.g0.y) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g2.y) * other.g3 + vec3<f32>(self_.g3.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x) - vec3<f32>(self_.g5.w) * other.g1 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) - vec3<f32>(self_.g6.w) * other.g9 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g10.x) * other.g8 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * other.g8 + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) - vec3<f32>(self_.g2.y) * other.g9 + vec3<f32>(self_.g2.y) * other.g4 + vec3<f32>(self_.g4.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y) + vec3<f32>(self_.g5.w) * other.g8 - vec3<f32>(self_.g6.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g7.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g8.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g8.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g8.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g10.y) * other.g7 + vec3<f32>(self_.g10.y) * other.g1, vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g2.x) * other.g8 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g5.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g5.w) * other.g4 + vec3<f32>(self_.g6.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g6.w) * other.g7 + vec3<f32>(self_.g7.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g8.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g9.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) - vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g10.y) * other.g3, vec2<f32>(self_.g0.x) * other.g10 - vec2<f32>(self_.g0.y) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g2 * vec2<f32>(other.g6.w) - self_.g2 * vec2<f32>(other.g0.y) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g5.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g7.x, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g7.y, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g7.z, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g6.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g10 * vec2<f32>(other.g5.w) + self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_origin_wedge_dot(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.y) * vec2<f32>(-other.g0, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0) - self_.g7 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0));
}

fn multi_vector_plane_wedge_dot(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) - vec2<f32>(self_.g6.z, self_.g6.w) * vec2<f32>(other.g0.z, other.g0.w) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) - vec4<f32>(self_.g10.y, self_.g10.y, self_.g10.y, self_.g10.x) * other.g0, vec4<f32>(self_.g2.x) * other.g0 + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) - self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_wedge_dot(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g2.y) * other.g0 + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_point_at_infinity_wedge_dot(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.w) * other.g0 + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_origin_wedge_dot(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g5.w) * vec2<f32>(other.g0, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0) - self_.g7 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + self_.g5.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0) + self_.g6.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_rotor_wedge_dot(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g7.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g6.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g8.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(-other.g0.z, other.g0.w, other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g0.w, 0.0) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(self_.g5.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(0.0) - self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_round_point_wedge_dot(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(self_.g0.x) * other.g0 + self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g2.x) * other.g0 + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g7 * vec3<f32>(other.g1.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 - self_.g8 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x) + vec4<f32>(self_.g7.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g4 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g9 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(0.0) - vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_scalar_wedge_dot(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_sphere_wedge_dot(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.y) * other.g1 + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g1.x) - self_.g9 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g10.x) * other.g0, self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g5.w) * other.g0 + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g5.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g5.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g5.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.x, other.g1.x, other.g1.x, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g6.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g6.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g2.y) * other.g0 + self_.g7 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * other.g0 - self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * other.g1 + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn multi_vector_translator_wedge_dot(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - self_.g7 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g6.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g6.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g6.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g6.w) * other.g0 + vec4<f32>(self_.g7.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g7.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g7.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, self_.g8.x) * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0), vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g5.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g5.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) - self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, other.g0.z));
}

fn origin_anti_scalar_wedge_dot(self_: Origin, other: AntiScalar) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0));
}

fn origin_circle_wedge_dot(self_: Origin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g2, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g2, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0));
}

fn origin_dipole_wedge_dot(self_: Origin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec2<f32>(self_.g0) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_flat_point_wedge_dot(self_: Origin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_flector_wedge_dot(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_horizon_wedge_dot(self_: Origin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_infinity_wedge_dot(self_: Origin, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_line_wedge_dot(self_: Origin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0));
}

fn origin_line_at_infinity_wedge_dot(self_: Origin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn origin_line_at_origin_wedge_dot(self_: Origin, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_magnitude_wedge_dot(self_: Origin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.y, 0.0));
}

fn origin_motor_wedge_dot(self_: Origin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_multi_vector_wedge_dot(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g2.y, other.g10.y), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec2<f32>(self_.g0) * vec2<f32>(other.g5.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g7 + vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g8, vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y), vec4<f32>(self_.g0) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g8, vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, 0.0) + vec2<f32>(self_.g0) * vec2<f32>(-other.g0.y, 0.0));
}

fn origin_plane_wedge_dot(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_plane_at_origin_wedge_dot(self_: Origin, other: PlaneAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_point_at_infinity_wedge_dot(self_: Origin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_point_at_origin_wedge_dot(self_: Origin, other: PointAtOrigin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_rotor_wedge_dot(self_: Origin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn origin_round_point_wedge_dot(self_: Origin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g1.y, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_scalar_wedge_dot(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_sphere_wedge_dot(self_: Origin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_translator_wedge_dot(self_: Origin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0) * vec2<f32>(-other.g0.w, 0.0));
}

fn plane_anti_scalar_wedge_dot(self_: Plane, other: AntiScalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0));
}

fn plane_circle_wedge_dot(self_: Plane, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_dipole_wedge_dot(self_: Plane, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w));
}

fn plane_flat_point_wedge_dot(self_: Plane, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w));
}

fn plane_flector_wedge_dot(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w));
}

fn plane_horizon_wedge_dot(self_: Plane, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_infinity_wedge_dot(self_: Plane, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_wedge_dot(self_: Plane, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_line_at_infinity_wedge_dot(self_: Plane, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_line_at_origin_wedge_dot(self_: Plane, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_magnitude_wedge_dot(self_: Plane, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x));
}

fn plane_motor_wedge_dot(self_: Plane, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_multi_vector_wedge_dot(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g6.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g0.w) * other.g7 + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x));
}

fn plane_origin_wedge_dot(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_plane_wedge_dot(self_: Plane, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_plane_at_origin_wedge_dot(self_: Plane, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_point_at_infinity_wedge_dot(self_: Plane, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn plane_point_at_origin_wedge_dot(self_: Plane, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0));
}

fn plane_rotor_wedge_dot(self_: Plane, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_round_point_wedge_dot(self_: Plane, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_scalar_wedge_dot(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_sphere_wedge_dot(self_: Plane, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0.xyzx * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_translator_wedge_dot(self_: Plane, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_anti_scalar_wedge_dot(self_: PlaneAtOrigin, other: AntiScalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn plane_at_origin_circle_wedge_dot(self_: PlaneAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_dipole_wedge_dot(self_: PlaneAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g2.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z));
}

fn plane_at_origin_flat_point_wedge_dot(self_: PlaneAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn plane_at_origin_flector_wedge_dot(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn plane_at_origin_horizon_wedge_dot(self_: PlaneAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_infinity_wedge_dot(self_: PlaneAtOrigin, other: Infinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_wedge_dot(self_: PlaneAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_line_at_infinity_wedge_dot(self_: PlaneAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_line_at_origin_wedge_dot(self_: PlaneAtOrigin, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_magnitude_wedge_dot(self_: PlaneAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0));
}

fn plane_at_origin_motor_wedge_dot(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_multi_vector_wedge_dot(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x), vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z));
}

fn plane_at_origin_origin_wedge_dot(self_: PlaneAtOrigin, other: Origin) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn plane_at_origin_plane_wedge_dot(self_: PlaneAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_plane_at_origin_wedge_dot(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_point_at_infinity_wedge_dot(self_: PlaneAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn plane_at_origin_point_at_origin_wedge_dot(self_: PlaneAtOrigin, other: PointAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn plane_at_origin_rotor_wedge_dot(self_: PlaneAtOrigin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_round_point_wedge_dot(self_: PlaneAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_scalar_wedge_dot(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_sphere_wedge_dot(self_: PlaneAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_translator_wedge_dot(self_: PlaneAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_anti_scalar_wedge_dot(self_: PointAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_wedge_dot(self_: PointAtInfinity, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_dipole_wedge_dot(self_: PointAtInfinity, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.w, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, -other.g2.w, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, -other.g2.w, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn point_at_infinity_flat_point_wedge_dot(self_: PointAtInfinity, other: FlatPoint) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_flector_wedge_dot(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z));
}

fn point_at_infinity_line_wedge_dot(self_: PointAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_line_at_origin_wedge_dot(self_: PointAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_magnitude_wedge_dot(self_: PointAtInfinity, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_motor_wedge_dot(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_multi_vector_wedge_dot(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g6.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g6.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g5.w, -other.g9.z, other.g9.y, -other.g3.x) + vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g4.z, -other.g4.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, -other.g5.w, -other.g9.x, -other.g3.y) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g4.z, other.g0.x, other.g4.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, -other.g5.w, -other.g3.z) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, -other.g4.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g6.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g6.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.x, other.g6.z, -other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g6.z, other.g2.x, other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g6.y, -other.g6.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g6.w, other.g7.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.y, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g6.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn point_at_infinity_origin_wedge_dot(self_: PointAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_wedge_dot(self_: PointAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn point_at_infinity_plane_at_origin_wedge_dot(self_: PointAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn point_at_infinity_point_at_origin_wedge_dot(self_: PointAtInfinity, other: PointAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_rotor_wedge_dot(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_round_point_wedge_dot(self_: PointAtInfinity, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_scalar_wedge_dot(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_sphere_wedge_dot(self_: PointAtInfinity, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn point_at_infinity_translator_wedge_dot(self_: PointAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_origin_anti_scalar_wedge_dot(self_: PointAtOrigin, other: AntiScalar) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn point_at_origin_circle_wedge_dot(self_: PointAtOrigin, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_dipole_wedge_dot(self_: PointAtOrigin, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g2.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec2<f32>(0.0));
}

fn point_at_origin_flat_point_wedge_dot(self_: PointAtOrigin, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_flector_wedge_dot(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w));
}

fn point_at_origin_horizon_wedge_dot(self_: PointAtOrigin, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn point_at_origin_infinity_wedge_dot(self_: PointAtOrigin, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn point_at_origin_line_wedge_dot(self_: PointAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_line_at_infinity_wedge_dot(self_: PointAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_line_at_origin_wedge_dot(self_: PointAtOrigin, other: LineAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(0.0));
}

fn point_at_origin_magnitude_wedge_dot(self_: PointAtOrigin, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_motor_wedge_dot(self_: PointAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_multi_vector_wedge_dot(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g5.w, -other.g6.w), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g7, vec2<f32>(self_.g0) * other.g2 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g9, vec4<f32>(self_.g0) * vec4<f32>(other.g5.x, other.g5.y, other.g5.z, other.g0.x), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g6.x, other.g6.y, other.g6.z, other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g4, vec2<f32>(self_.g0) * other.g10 * vec2<f32>(-1.0, 1.0));
}

fn point_at_origin_origin_wedge_dot(self_: PointAtOrigin, other: Origin) -> Origin {
    return Origin(0.0 - self_.g0 * other.g0);
}

fn point_at_origin_plane_wedge_dot(self_: PointAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.w));
}

fn point_at_origin_plane_at_origin_wedge_dot(self_: PointAtOrigin, other: PlaneAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0));
}

fn point_at_origin_point_at_infinity_wedge_dot(self_: PointAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_point_at_origin_wedge_dot(self_: PointAtOrigin, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn point_at_origin_rotor_wedge_dot(self_: PointAtOrigin, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_round_point_wedge_dot(self_: PointAtOrigin, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_scalar_wedge_dot(self_: PointAtOrigin, other: Scalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn point_at_origin_sphere_wedge_dot(self_: PointAtOrigin, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn point_at_origin_translator_wedge_dot(self_: PointAtOrigin, other: Translator) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn rotor_anti_scalar_wedge_dot(self_: Rotor, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_circle_wedge_dot(self_: Rotor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g2.z, other.g2.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, -other.g2.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g2.y, other.g2.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn rotor_dipole_wedge_dot(self_: Rotor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_flat_point_wedge_dot(self_: Rotor, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_flector_wedge_dot(self_: Rotor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g1.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_horizon_wedge_dot(self_: Rotor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_infinity_wedge_dot(self_: Rotor, other: Infinity) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn rotor_line_wedge_dot(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn rotor_line_at_infinity_wedge_dot(self_: Rotor, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn rotor_line_at_origin_wedge_dot(self_: Rotor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_magnitude_wedge_dot(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_motor_wedge_dot(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn rotor_multi_vector_wedge_dot(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g7.x, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g7.y, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g7.z, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) - vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g0.w) * other.g10, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) - vec3<f32>(self_.g0.w) * other.g7, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.y, -other.g8.z, other.g8.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g8.z, -other.g2.y, -other.g8.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g8.y, other.g8.x, -other.g2.y, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, other.g9.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.y, other.g5.z, -other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g5.z, other.g10.y, other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g5.y, -other.g5.x, other.g10.y) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g6.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g6.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g6.w) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) - vec2<f32>(self_.g0.w) * other.g2);
}

fn rotor_origin_wedge_dot(self_: Rotor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn rotor_plane_wedge_dot(self_: Rotor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_plane_at_origin_wedge_dot(self_: Rotor, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_point_at_infinity_wedge_dot(self_: Rotor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_point_at_origin_wedge_dot(self_: Rotor, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_rotor_wedge_dot(self_: Rotor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_round_point_wedge_dot(self_: Rotor, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(0.0) - vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_scalar_wedge_dot(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_sphere_wedge_dot(self_: Rotor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.x, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_translator_wedge_dot(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn round_point_anti_scalar_wedge_dot(self_: RoundPoint, other: AntiScalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0));
}

fn round_point_circle_wedge_dot(self_: RoundPoint, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_dipole_wedge_dot(self_: RoundPoint, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, other.g2.z) + self_.g1 * vec2<f32>(other.g2.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_flat_point_wedge_dot(self_: RoundPoint, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_flector_wedge_dot(self_: RoundPoint, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.w), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g1.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g1.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g1.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_horizon_wedge_dot(self_: RoundPoint, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_infinity_wedge_dot(self_: RoundPoint, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_line_wedge_dot(self_: RoundPoint, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn round_point_line_at_infinity_wedge_dot(self_: RoundPoint, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn round_point_line_at_origin_wedge_dot(self_: RoundPoint, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn round_point_magnitude_wedge_dot(self_: RoundPoint, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0.y));
}

fn round_point_motor_wedge_dot(self_: RoundPoint, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) - self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_multi_vector_wedge_dot(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g9.z) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g2.y, other.g10.y) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g2.x, other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g3.x, other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g3.y, other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g3.z, other.g5.z) + self_.g1 * vec2<f32>(other.g5.w) + self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g1.x) * other.g7 + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) - vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g2.y, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, other.g2.y, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, other.g2.y, -other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.x, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, other.g10.x, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, other.g10.x, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.y, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, -other.g10.y, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, -other.g10.y) - vec3<f32>(self_.g1.y) * other.g9 + vec3<f32>(self_.g1.y) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, other.g0.y, other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, other.g0.y) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(other.g6.w) - self_.g1 * vec2<f32>(other.g0.y));
}

fn round_point_origin_wedge_dot(self_: RoundPoint, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_wedge_dot(self_: RoundPoint, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_at_origin_wedge_dot(self_: RoundPoint, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_point_at_infinity_wedge_dot(self_: RoundPoint, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_point_at_origin_wedge_dot(self_: RoundPoint, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_rotor_wedge_dot(self_: RoundPoint, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, other.g0.w, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, other.g0.w), vec2<f32>(0.0) - self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_round_point_wedge_dot(self_: RoundPoint, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_scalar_wedge_dot(self_: RoundPoint, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_sphere_wedge_dot(self_: RoundPoint, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.x, other.g1.x, other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_translator_wedge_dot(self_: RoundPoint, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) - self_.g1 * vec2<f32>(other.g0.w));
}

fn scalar_anti_scalar_wedge_dot(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_circle_wedge_dot(self_: Scalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn scalar_dipole_wedge_dot(self_: Scalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn scalar_flat_point_wedge_dot(self_: Scalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_flector_wedge_dot(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_wedge_dot(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_infinity_wedge_dot(self_: Scalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn scalar_line_wedge_dot(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_wedge_dot(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_wedge_dot(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_wedge_dot(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_wedge_dot(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_wedge_dot(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn scalar_origin_wedge_dot(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_wedge_dot(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_wedge_dot(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_wedge_dot(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_origin_wedge_dot(self_: Scalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn scalar_rotor_wedge_dot(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_round_point_wedge_dot(self_: Scalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_scalar_wedge_dot(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_sphere_wedge_dot(self_: Scalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_translator_wedge_dot(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn sphere_anti_scalar_wedge_dot(self_: Sphere, other: AntiScalar) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_circle_wedge_dot(self_: Sphere, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(-other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_dipole_wedge_dot(self_: Sphere, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g2.w));
}

fn sphere_flat_point_wedge_dot(self_: Sphere, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_flector_wedge_dot(self_: Sphere, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, other.g0.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, other.g1.w, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, other.g1.w, 0.0) - vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g1, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_horizon_wedge_dot(self_: Sphere, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_infinity_wedge_dot(self_: Sphere, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_wedge_dot(self_: Sphere, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_at_infinity_wedge_dot(self_: Sphere, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_line_at_origin_wedge_dot(self_: Sphere, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_magnitude_wedge_dot(self_: Sphere, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_motor_wedge_dot(self_: Sphere, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w) + vec3<f32>(self_.g1.x) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_multi_vector_wedge_dot(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g10.y, other.g2.y) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g10.x, other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.y, -other.g7.z, other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g7.z, -other.g0.y, -other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g7.y, other.g7.x, -other.g0.y) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(-other.g6.w) + self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) + vec3<f32>(self_.g1.x) * other.g9 + vec3<f32>(self_.g1.x) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(other.g5.w, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, other.g5.w, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, other.g5.z, -other.g5.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g5.z, other.g10.y, other.g5.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g5.y, -other.g5.x, other.g10.y, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.y) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g9.x, -other.g9.y, -other.g9.z, other.g10.x) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g2.x, -other.g6.z, other.g6.y, other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g6.z, -other.g2.x, -other.g6.x, other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g6.y, other.g6.x, -other.g2.x, other.g7.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, other.g2.y) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g6.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g6.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g2.y, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, other.g2.y, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, other.g2.y) + vec3<f32>(self_.g1.y) * other.g7 + vec3<f32>(self_.g1.y) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) - vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(other.g5.w) + self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_origin_wedge_dot(self_: Sphere, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_wedge_dot(self_: Sphere, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) - vec4<f32>(self_.g1.y, self_.g1.y, self_.g1.y, self_.g1.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_plane_at_origin_wedge_dot(self_: Sphere, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_point_at_infinity_wedge_dot(self_: Sphere, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn sphere_point_at_origin_wedge_dot(self_: Sphere, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_rotor_wedge_dot(self_: Sphere, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, -other.g0.w, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, -other.g0.w), self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_round_point_wedge_dot(self_: Sphere, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_scalar_wedge_dot(self_: Sphere, other: Scalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_sphere_wedge_dot(self_: Sphere, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, other.g1.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_translator_wedge_dot(self_: Sphere, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_anti_scalar_wedge_dot(self_: Translator, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0, -other.g0, -other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_circle_wedge_dot(self_: Translator, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g1.z, other.g1.y, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.w, -other.g1.x, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g2.x, -other.g2.y, -other.g2.z, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn translator_dipole_wedge_dot(self_: Translator, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g2.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.w, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, -other.g2.w, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, -other.g2.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_flat_point_wedge_dot(self_: Translator, other: FlatPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn translator_flector_wedge_dot(self_: Translator, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g0.w, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, -other.g0.w, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, -other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_horizon_wedge_dot(self_: Translator, other: Horizon) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn translator_infinity_wedge_dot(self_: Translator, other: Infinity) -> Horizon {
    return Horizon(0.0 - self_.g0.w * other.g0);
}

fn translator_line_wedge_dot(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_line_at_infinity_wedge_dot(self_: Translator, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_wedge_dot(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_magnitude_wedge_dot(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0.y, -other.g0.y, -other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_motor_wedge_dot(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g1.x, -other.g1.y, -other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_multi_vector_wedge_dot(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g3.z) + vec2<f32>(self_.g0.w) * other.g0.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g10.x, -other.g3.z, other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, -other.g10.x, -other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g3.y, other.g3.x, -other.g10.x) - vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * other.g10, vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) - vec3<f32>(self_.g0.w) * other.g7, vec4<f32>(self_.g0.x) * vec4<f32>(-other.g6.w, -other.g7.z, other.g7.y, other.g6.x) + vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.y, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g7.z, -other.g6.w, -other.g7.x, other.g6.y) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, -other.g0.y, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g7.y, other.g7.x, -other.g6.w, other.g6.z) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, -other.g0.y, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g8.x, -other.g8.y, -other.g8.z, other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g10.x, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, other.g10.x, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(-other.g5.w, -other.g9.z, other.g9.y) + vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g4.z, -other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g9.z, -other.g5.w, -other.g9.x) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g4.z, other.g0.x, other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g9.y, other.g9.x, -other.g5.w) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, -other.g4.x, other.g0.x) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(-other.g2.x, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, -other.g2.x, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, -other.g2.x) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g7.x) + vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g7.y) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g7.z) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) - vec2<f32>(self_.g0.w) * other.g2);
}

fn translator_origin_wedge_dot(self_: Translator, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn translator_plane_wedge_dot(self_: Translator, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_plane_at_origin_wedge_dot(self_: Translator, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_point_at_infinity_wedge_dot(self_: Translator, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_origin_wedge_dot(self_: Translator, other: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_rotor_wedge_dot(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, -other.g0.w, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, -other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn translator_round_point_wedge_dot(self_: Translator, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) - vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_scalar_wedge_dot(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_sphere_wedge_dot(self_: Translator, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_translator_wedge_dot(self_: Translator, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0.xyzx * vec4<f32>(-other.g0.w, -other.g0.w, -other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_anti_scalar_anti_wedge(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_circle_anti_wedge(self_: AntiScalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn anti_scalar_dipole_anti_wedge(self_: AntiScalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn anti_scalar_flat_point_anti_wedge(self_: AntiScalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_flector_anti_wedge(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_anti_wedge(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_infinity_anti_wedge(self_: AntiScalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn anti_scalar_line_anti_wedge(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_anti_wedge(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_anti_wedge(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_anti_wedge(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_anti_wedge(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_anti_wedge(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn anti_scalar_origin_anti_wedge(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_anti_wedge(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_anti_wedge(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_anti_wedge(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_origin_anti_wedge(self_: AntiScalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn anti_scalar_rotor_anti_wedge(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_round_point_anti_wedge(self_: AntiScalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_scalar_anti_wedge(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_sphere_anti_wedge(self_: AntiScalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_translator_anti_wedge(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn circle_anti_scalar_anti_wedge(self_: Circle, other: AntiScalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn circle_circle_anti_wedge(self_: Circle, other: Circle) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn circle_dipole_anti_wedge(self_: Circle, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g0.w * other.g2.w - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn circle_flat_point_anti_wedge(self_: Circle, other: FlatPoint) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn circle_flector_anti_wedge(self_: Circle, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_horizon_anti_wedge(self_: Circle, other: Horizon) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn circle_line_anti_wedge(self_: Circle, other: Line) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_line_at_infinity_anti_wedge(self_: Circle, other: LineAtInfinity) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_line_at_origin_anti_wedge(self_: Circle, other: LineAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_magnitude_anti_wedge(self_: Circle, other: Magnitude) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y));
}

fn circle_motor_anti_wedge(self_: Circle, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_multi_vector_anti_wedge(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g5.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g5.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g5.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g5.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g3.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, 0.0, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, 0.0) + vec3<f32>(self_.g0.w) * other.g7 + self_.g1 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0) + self_.g1 * vec3<f32>(other.g10.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 + self_.g2 * vec3<f32>(other.g10.x), vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_plane_anti_wedge(self_: Circle, other: Plane) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn circle_plane_at_origin_anti_wedge(self_: Circle, other: PlaneAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn circle_point_at_infinity_anti_wedge(self_: Circle, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn circle_point_at_origin_anti_wedge(self_: Circle, other: PointAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn circle_rotor_anti_wedge(self_: Circle, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_sphere_anti_wedge(self_: Circle, other: Sphere) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn circle_translator_anti_wedge(self_: Circle, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_anti_scalar_anti_wedge(self_: Dipole, other: AntiScalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_circle_anti_wedge(self_: Dipole, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z - self_.g2.w * other.g0.w);
}

fn dipole_flector_anti_wedge(self_: Dipole, other: Flector) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g1.w));
}

fn dipole_horizon_anti_wedge(self_: Dipole, other: Horizon) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0));
}

fn dipole_line_anti_wedge(self_: Dipole, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_line_at_infinity_anti_wedge(self_: Dipole, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn dipole_line_at_origin_anti_wedge(self_: Dipole, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_magnitude_anti_wedge(self_: Dipole, other: Magnitude) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec4<f32>(other.g0.y));
}

fn dipole_motor_anti_wedge(self_: Dipole, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec4<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_multi_vector_anti_wedge(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g8.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g8.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g8.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(-other.g6.w, 0.0), self_.g0 * vec3<f32>(other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, 0.0, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.w) * other.g10 * vec2<f32>(-1.0, 1.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec4<f32>(other.g0.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_plane_anti_wedge(self_: Dipole, other: Plane) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0.w));
}

fn dipole_plane_at_origin_anti_wedge(self_: Dipole, other: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn dipole_rotor_anti_wedge(self_: Dipole, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec4<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_sphere_anti_wedge(self_: Dipole, other: Sphere) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn dipole_translator_anti_wedge(self_: Dipole, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec4<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_anti_scalar_anti_wedge(self_: FlatPoint, other: AntiScalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_circle_anti_wedge(self_: FlatPoint, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn flat_point_flector_anti_wedge(self_: FlatPoint, other: Flector) -> Infinity {
    return Infinity(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g0.w * other.g1.w);
}

fn flat_point_horizon_anti_wedge(self_: FlatPoint, other: Horizon) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn flat_point_magnitude_anti_wedge(self_: FlatPoint, other: Magnitude) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.y));
}

fn flat_point_motor_anti_wedge(self_: FlatPoint, other: Motor) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.w));
}

fn flat_point_multi_vector_anti_wedge(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g6.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_plane_anti_wedge(self_: FlatPoint, other: Plane) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn flat_point_plane_at_origin_anti_wedge(self_: FlatPoint, other: PlaneAtOrigin) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn flat_point_rotor_anti_wedge(self_: FlatPoint, other: Rotor) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.w));
}

fn flat_point_sphere_anti_wedge(self_: FlatPoint, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn flat_point_translator_anti_wedge(self_: FlatPoint, other: Translator) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.w));
}

fn flector_anti_scalar_anti_wedge(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_circle_anti_wedge(self_: Flector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_dipole_anti_wedge(self_: Flector, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g2.w));
}

fn flector_flat_point_anti_wedge(self_: Flector, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z - self_.g1.w * other.g0.w);
}

fn flector_flector_anti_wedge(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_horizon_anti_wedge(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_anti_wedge(self_: Flector, other: Line) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_line_at_infinity_anti_wedge(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn flector_line_at_origin_anti_wedge(self_: Flector, other: LineAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn flector_magnitude_anti_wedge(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_motor_anti_wedge(self_: Flector, other: Motor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_multi_vector_anti_wedge(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g6.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) - vec3<f32>(self_.g1.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g5.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), self_.g0 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g10.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g1.w) * other.g9, vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y));
}

fn flector_origin_anti_wedge(self_: Flector, other: Origin) -> Scalar {
    return Scalar(self_.g1.w * other.g0);
}

fn flector_plane_anti_wedge(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_plane_at_origin_anti_wedge(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_point_at_infinity_anti_wedge(self_: Flector, other: PointAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn flector_point_at_origin_anti_wedge(self_: Flector, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g1.w * other.g0);
}

fn flector_rotor_anti_wedge(self_: Flector, other: Rotor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_round_point_anti_wedge(self_: Flector, other: RoundPoint) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z + self_.g1.w * other.g1.x);
}

fn flector_sphere_anti_wedge(self_: Flector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g1.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_translator_anti_wedge(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn horizon_anti_scalar_anti_wedge(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_circle_anti_wedge(self_: Horizon, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn horizon_dipole_anti_wedge(self_: Horizon, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w));
}

fn horizon_flat_point_anti_wedge(self_: Horizon, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0.w);
}

fn horizon_flector_anti_wedge(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_line_anti_wedge(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_anti_wedge(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_anti_wedge(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.y);
}

fn horizon_motor_anti_wedge(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_anti_wedge(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9, vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y));
}

fn horizon_origin_anti_wedge(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn horizon_plane_anti_wedge(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_anti_wedge(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_origin_anti_wedge(self_: Horizon, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn horizon_rotor_anti_wedge(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_round_point_anti_wedge(self_: Horizon, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0 * other.g1.x);
}

fn horizon_sphere_anti_wedge(self_: Horizon, other: Sphere) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_translator_anti_wedge(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn infinity_anti_scalar_anti_wedge(self_: Infinity, other: AntiScalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_magnitude_anti_wedge(self_: Infinity, other: Magnitude) -> Infinity {
    return Infinity(self_.g0 * other.g0.y);
}

fn infinity_motor_anti_wedge(self_: Infinity, other: Motor) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn infinity_multi_vector_anti_wedge(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.x, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_rotor_anti_wedge(self_: Infinity, other: Rotor) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn infinity_sphere_anti_wedge(self_: Infinity, other: Sphere) -> Scalar {
    return Scalar(self_.g0 * other.g1.x);
}

fn infinity_translator_anti_wedge(self_: Infinity, other: Translator) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn line_anti_scalar_anti_wedge(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_circle_anti_wedge(self_: Line, other: Circle) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_dipole_anti_wedge(self_: Line, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_flector_anti_wedge(self_: Line, other: Flector) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0));
}

fn line_horizon_anti_wedge(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_anti_wedge(self_: Line, other: Line) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_at_infinity_anti_wedge(self_: Line, other: LineAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_anti_wedge(self_: Line, other: LineAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_anti_wedge(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y));
}

fn line_motor_anti_wedge(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_multi_vector_anti_wedge(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g3.z, 0.0), self_.g0 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z), self_.g0 * vec3<f32>(other.g10.x), self_.g1 * vec3<f32>(other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_plane_anti_wedge(self_: Line, other: Plane) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_plane_at_origin_anti_wedge(self_: Line, other: PlaneAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_rotor_anti_wedge(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_sphere_anti_wedge(self_: Line, other: Sphere) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_translator_anti_wedge(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_anti_scalar_anti_wedge(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_circle_anti_wedge(self_: LineAtInfinity, other: Circle) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_at_infinity_dipole_anti_wedge(self_: LineAtInfinity, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_flector_anti_wedge(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0));
}

fn line_at_infinity_line_anti_wedge(self_: LineAtInfinity, other: Line) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_line_at_origin_anti_wedge(self_: LineAtInfinity, other: LineAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_anti_wedge(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_infinity_motor_anti_wedge(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_multi_vector_anti_wedge(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g3.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_anti_wedge(self_: LineAtInfinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn line_at_infinity_plane_at_origin_anti_wedge(self_: LineAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn line_at_infinity_rotor_anti_wedge(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_sphere_anti_wedge(self_: LineAtInfinity, other: Sphere) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_at_infinity_translator_anti_wedge(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_anti_wedge(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_circle_anti_wedge(self_: LineAtOrigin, other: Circle) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn line_at_origin_dipole_anti_wedge(self_: LineAtOrigin, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_flector_anti_wedge(self_: LineAtOrigin, other: Flector) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z));
}

fn line_at_origin_horizon_anti_wedge(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_anti_wedge(self_: LineAtOrigin, other: Line) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_at_infinity_anti_wedge(self_: LineAtOrigin, other: LineAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_magnitude_anti_wedge(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_origin_motor_anti_wedge(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_multi_vector_anti_wedge(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0), self_.g0 * vec3<f32>(other.g6.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z), self_.g0 * vec3<f32>(other.g10.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_plane_anti_wedge(self_: LineAtOrigin, other: Plane) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn line_at_origin_plane_at_origin_anti_wedge(self_: LineAtOrigin, other: PlaneAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_rotor_anti_wedge(self_: LineAtOrigin, other: Rotor) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_sphere_anti_wedge(self_: LineAtOrigin, other: Sphere) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z));
}

fn line_at_origin_translator_anti_wedge(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_anti_scalar_anti_wedge(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_circle_anti_wedge(self_: Magnitude, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2);
}

fn magnitude_dipole_anti_wedge(self_: Magnitude, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * other.g2);
}

fn magnitude_flat_point_anti_wedge(self_: Magnitude, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_flector_anti_wedge(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * other.g1);
}

fn magnitude_horizon_anti_wedge(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.y * other.g0);
}

fn magnitude_infinity_anti_wedge(self_: Magnitude, other: Infinity) -> Infinity {
    return Infinity(self_.g0.y * other.g0);
}

fn magnitude_line_anti_wedge(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1);
}

fn magnitude_line_at_infinity_anti_wedge(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_line_at_origin_anti_wedge(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_magnitude_anti_wedge(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_anti_wedge(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_multi_vector_anti_wedge(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec2<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.y) * other.g3, vec3<f32>(self_.g0.y) * other.g4, vec4<f32>(self_.g0.y) * other.g5, vec4<f32>(self_.g0.y) * other.g6, vec3<f32>(self_.g0.y) * other.g7, vec3<f32>(self_.g0.y) * other.g8, vec3<f32>(self_.g0.y) * other.g9, vec2<f32>(self_.g0.y) * other.g10);
}

fn magnitude_origin_anti_wedge(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.y * other.g0);
}

fn magnitude_plane_anti_wedge(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_plane_at_origin_anti_wedge(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_at_infinity_anti_wedge(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_at_origin_anti_wedge(self_: Magnitude, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.y * other.g0);
}

fn magnitude_rotor_anti_wedge(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_round_point_anti_wedge(self_: Magnitude, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_scalar_anti_wedge(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn magnitude_sphere_anti_wedge(self_: Magnitude, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_translator_anti_wedge(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_anti_scalar_anti_wedge(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_circle_anti_wedge(self_: Motor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_dipole_anti_wedge(self_: Motor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_flat_point_anti_wedge(self_: Motor, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_flector_anti_wedge(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g1);
}

fn motor_horizon_anti_wedge(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_infinity_anti_wedge(self_: Motor, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn motor_line_anti_wedge(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_infinity_anti_wedge(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_origin_anti_wedge(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_magnitude_anti_wedge(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_motor_anti_wedge(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_multi_vector_anti_wedge(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g3.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.w) * other.g4 + self_.g1 * vec3<f32>(other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.w) * other.g8 + self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.w) * other.g10);
}

fn motor_origin_anti_wedge(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn motor_plane_anti_wedge(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_plane_at_origin_anti_wedge(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn motor_point_at_infinity_anti_wedge(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn motor_point_at_origin_anti_wedge(self_: Motor, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w * other.g0);
}

fn motor_rotor_anti_wedge(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_round_point_anti_wedge(self_: Motor, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn motor_scalar_anti_wedge(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn motor_sphere_anti_wedge(self_: Motor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn motor_translator_anti_wedge(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_anti_scalar_anti_wedge(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_circle_anti_wedge(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g2 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_dipole_anti_wedge(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g2.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g10.y) * other.g0, vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(other.g2.w), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_flat_point_anti_wedge(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_flector_anti_wedge(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0), self_.g3 * vec3<f32>(other.g1.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), self_.g9 * vec3<f32>(other.g1.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w));
}

fn multi_vector_horizon_anti_wedge(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0, 0.0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g9 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_anti_wedge(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_line_anti_wedge(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g10.x) * other.g1, vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_line_at_infinity_anti_wedge(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g10.x) * other.g0, vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_line_at_origin_anti_wedge(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_magnitude_anti_wedge(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec2<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.y), self_.g4 * vec3<f32>(other.g0.y), self_.g5 * vec4<f32>(other.g0.y), self_.g6 * vec4<f32>(other.g0.y), self_.g7 * vec3<f32>(other.g0.y), self_.g8 * vec3<f32>(other.g0.y), self_.g9 * vec3<f32>(other.g0.y), self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_motor_anti_wedge(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, self_.g5 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g6 * vec4<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g7 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * other.g1 + self_.g8 * vec3<f32>(other.g0.w), self_.g9 * vec3<f32>(other.g0.w), self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_multi_vector_anti_wedge(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g10.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g10.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g8.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g8.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g8.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g6.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g5.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g5.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g5.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g5.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(-other.g3.z, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(self_.g0.y) * other.g1 + self_.g1 * vec3<f32>(other.g0.y) + self_.g3 * vec3<f32>(other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g9.z, other.g9.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g9.z, 0.0, -other.g9.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g9.y, other.g9.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g8.z, -other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g8.z, 0.0, other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g8.y, -other.g8.x, 0.0) + vec3<f32>(self_.g6.w) * other.g7 + self_.g7 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g10.y) * other.g3, vec2<f32>(self_.g0.y) * other.g2 + self_.g2 * vec2<f32>(other.g0.y) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g5.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g7.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g10 * vec2<f32>(other.g5.w), vec3<f32>(self_.g0.y) * other.g3 + self_.g3 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0) + self_.g7 * vec3<f32>(other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g10.x) * other.g7, vec3<f32>(self_.g0.y) * other.g4 + self_.g4 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g6.w) * other.g9 + self_.g8 * vec3<f32>(other.g10.x) - self_.g9 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g10.x) * other.g8 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.y) * other.g5 + self_.g5 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(self_.g0.y) * other.g6 + self_.g6 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g10.x, -other.g10.x, -other.g10.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.y) * other.g7 + self_.g7 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), vec3<f32>(self_.g0.y) * other.g8 + self_.g8 * vec3<f32>(other.g0.y) + self_.g9 * vec3<f32>(other.g10.y) - vec3<f32>(self_.g10.y) * other.g9, vec3<f32>(self_.g0.y) * other.g9 + self_.g9 * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.y) * other.g10 + self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_origin_anti_wedge(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_plane_anti_wedge(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.w, 0.0), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g7.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g9 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_anti_wedge(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g6.w) * other.g0, vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0));
}

fn multi_vector_point_at_infinity_anti_wedge(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_point_at_origin_anti_wedge(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), self_.g10 * vec2<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_rotor_anti_wedge(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g4 * vec3<f32>(other.g0.w), self_.g5 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g6 * vec4<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g7 * vec3<f32>(other.g0.w), self_.g8 * vec3<f32>(other.g0.w), self_.g9 * vec3<f32>(other.g0.w), self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_round_point_anti_wedge(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_scalar_anti_wedge(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn multi_vector_sphere_anti_wedge(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.x, 0.0), self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g1.x), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g9 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn multi_vector_translator_anti_wedge(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g5 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), self_.g6 * vec4<f32>(other.g0.w), self_.g7 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g8 * vec3<f32>(other.g0.w), self_.g9 * vec3<f32>(other.g0.w), self_.g10 * vec2<f32>(other.g0.w));
}

fn origin_anti_scalar_anti_wedge(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_flector_anti_wedge(self_: Origin, other: Flector) -> Scalar {
    return Scalar(self_.g0 * other.g1.w);
}

fn origin_horizon_anti_wedge(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn origin_magnitude_anti_wedge(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.y);
}

fn origin_motor_anti_wedge(self_: Origin, other: Motor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_multi_vector_anti_wedge(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.y, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_plane_anti_wedge(self_: Origin, other: Plane) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn origin_rotor_anti_wedge(self_: Origin, other: Rotor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_sphere_anti_wedge(self_: Origin, other: Sphere) -> Scalar {
    return Scalar(self_.g0 * other.g1.y);
}

fn origin_translator_anti_wedge(self_: Origin, other: Translator) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn plane_anti_scalar_anti_wedge(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_circle_anti_wedge(self_: Plane, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn plane_dipole_anti_wedge(self_: Plane, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w));
}

fn plane_flat_point_anti_wedge(self_: Plane, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_flector_anti_wedge(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_horizon_anti_wedge(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_anti_wedge(self_: Plane, other: Line) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_line_at_infinity_anti_wedge(self_: Plane, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn plane_line_at_origin_anti_wedge(self_: Plane, other: LineAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn plane_magnitude_anti_wedge(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_motor_anti_wedge(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_multi_vector_anti_wedge(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) - vec3<f32>(self_.g0.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g0.w) * other.g9, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y));
}

fn plane_origin_anti_wedge(self_: Plane, other: Origin) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn plane_plane_anti_wedge(self_: Plane, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_anti_wedge(self_: Plane, other: PlaneAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_at_infinity_anti_wedge(self_: Plane, other: PointAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_point_at_origin_anti_wedge(self_: Plane, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0.w * other.g0);
}

fn plane_rotor_anti_wedge(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_round_point_anti_wedge(self_: Plane, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g1.x);
}

fn plane_sphere_anti_wedge(self_: Plane, other: Sphere) -> Circle {
    return Circle(vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_translator_anti_wedge(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_at_origin_anti_scalar_anti_wedge(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_circle_anti_wedge(self_: PlaneAtOrigin, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z));
}

fn plane_at_origin_dipole_anti_wedge(self_: PlaneAtOrigin, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z));
}

fn plane_at_origin_flat_point_anti_wedge(self_: PlaneAtOrigin, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_flector_anti_wedge(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), self_.g0 * vec3<f32>(other.g1.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_horizon_anti_wedge(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_anti_wedge(self_: PlaneAtOrigin, other: Line) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z));
}

fn plane_at_origin_line_at_infinity_anti_wedge(self_: PlaneAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn plane_at_origin_line_at_origin_anti_wedge(self_: PlaneAtOrigin, other: LineAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_magnitude_anti_wedge(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn plane_at_origin_motor_anti_wedge(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_multi_vector_anti_wedge(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g10.x, -other.g10.x, -other.g10.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), self_.g0 * vec3<f32>(other.g10.y), self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0));
}

fn plane_at_origin_plane_anti_wedge(self_: PlaneAtOrigin, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_anti_wedge(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn plane_at_origin_point_at_infinity_anti_wedge(self_: PlaneAtOrigin, other: PointAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_rotor_anti_wedge(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_round_point_anti_wedge(self_: PlaneAtOrigin, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_sphere_anti_wedge(self_: PlaneAtOrigin, other: Sphere) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y));
}

fn plane_at_origin_translator_anti_wedge(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn point_at_infinity_anti_scalar_anti_wedge(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_anti_wedge(self_: PointAtInfinity, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_flector_anti_wedge(self_: PointAtInfinity, other: Flector) -> Infinity {
    return Infinity(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn point_at_infinity_magnitude_anti_wedge(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn point_at_infinity_motor_anti_wedge(self_: PointAtInfinity, other: Motor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_multi_vector_anti_wedge(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_anti_wedge(self_: PointAtInfinity, other: Plane) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_plane_at_origin_anti_wedge(self_: PointAtInfinity, other: PlaneAtOrigin) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_rotor_anti_wedge(self_: PointAtInfinity, other: Rotor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_sphere_anti_wedge(self_: PointAtInfinity, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn point_at_infinity_translator_anti_wedge(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_origin_anti_scalar_anti_wedge(self_: PointAtOrigin, other: AntiScalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn point_at_origin_circle_anti_wedge(self_: PointAtOrigin, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn point_at_origin_flector_anti_wedge(self_: PointAtOrigin, other: Flector) -> Infinity {
    return Infinity(self_.g0 * other.g1.w);
}

fn point_at_origin_horizon_anti_wedge(self_: PointAtOrigin, other: Horizon) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn point_at_origin_magnitude_anti_wedge(self_: PointAtOrigin, other: Magnitude) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.y);
}

fn point_at_origin_motor_anti_wedge(self_: PointAtOrigin, other: Motor) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.w);
}

fn point_at_origin_multi_vector_anti_wedge(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g6.w, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_plane_anti_wedge(self_: PointAtOrigin, other: Plane) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn point_at_origin_rotor_anti_wedge(self_: PointAtOrigin, other: Rotor) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.w);
}

fn point_at_origin_sphere_anti_wedge(self_: PointAtOrigin, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn point_at_origin_translator_anti_wedge(self_: PointAtOrigin, other: Translator) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.w);
}

fn rotor_anti_scalar_anti_wedge(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_circle_anti_wedge(self_: Rotor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_dipole_anti_wedge(self_: Rotor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_flat_point_anti_wedge(self_: Rotor, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_flector_anti_wedge(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_anti_wedge(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_infinity_anti_wedge(self_: Rotor, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn rotor_line_anti_wedge(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_infinity_anti_wedge(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_origin_anti_wedge(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_magnitude_anti_wedge(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_motor_anti_wedge(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_multi_vector_anti_wedge(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.w) * other.g10);
}

fn rotor_origin_anti_wedge(self_: Rotor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn rotor_plane_anti_wedge(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_anti_wedge(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_at_infinity_anti_wedge(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_point_at_origin_anti_wedge(self_: Rotor, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w * other.g0);
}

fn rotor_rotor_anti_wedge(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_round_point_anti_wedge(self_: Rotor, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_scalar_anti_wedge(self_: Rotor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn rotor_sphere_anti_wedge(self_: Rotor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_translator_anti_wedge(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_anti_scalar_anti_wedge(self_: RoundPoint, other: AntiScalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_flector_anti_wedge(self_: RoundPoint, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g1.x * other.g1.w);
}

fn round_point_horizon_anti_wedge(self_: RoundPoint, other: Horizon) -> Scalar {
    return Scalar(self_.g1.x * other.g0);
}

fn round_point_magnitude_anti_wedge(self_: RoundPoint, other: Magnitude) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn round_point_motor_anti_wedge(self_: RoundPoint, other: Motor) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_multi_vector_anti_wedge(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g10.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g10.x, 0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_anti_wedge(self_: RoundPoint, other: Plane) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g0.w);
}

fn round_point_plane_at_origin_anti_wedge(self_: RoundPoint, other: PlaneAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn round_point_rotor_anti_wedge(self_: RoundPoint, other: Rotor) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_sphere_anti_wedge(self_: RoundPoint, other: Sphere) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn round_point_translator_anti_wedge(self_: RoundPoint, other: Translator) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn scalar_anti_scalar_anti_wedge(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_magnitude_anti_wedge(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_motor_anti_wedge(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_multi_vector_anti_wedge(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_rotor_anti_wedge(self_: Scalar, other: Rotor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_translator_anti_wedge(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn sphere_anti_scalar_anti_wedge(self_: Sphere, other: AntiScalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_circle_anti_wedge(self_: Sphere, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn sphere_dipole_anti_wedge(self_: Sphere, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g2.w));
}

fn sphere_flat_point_anti_wedge(self_: Sphere, other: FlatPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_flector_anti_wedge(self_: Sphere, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), self_.g0 * vec3<f32>(other.g1.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_horizon_anti_wedge(self_: Sphere, other: Horizon) -> Circle {
    return Circle(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0));
}

fn sphere_infinity_anti_wedge(self_: Sphere, other: Infinity) -> Scalar {
    return Scalar(self_.g1.x * other.g0);
}

fn sphere_line_anti_wedge(self_: Sphere, other: Line) -> Dipole {
    return Dipole(vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn sphere_line_at_infinity_anti_wedge(self_: Sphere, other: LineAtInfinity) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0));
}

fn sphere_line_at_origin_anti_wedge(self_: Sphere, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn sphere_magnitude_anti_wedge(self_: Sphere, other: Magnitude) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_motor_anti_wedge(self_: Sphere, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_multi_vector_anti_wedge(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g1.x) * other.g7, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g10.x, -other.g10.x, -other.g10.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), self_.g0 * vec3<f32>(other.g10.y) - vec3<f32>(self_.g1.y) * other.g9, self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_origin_anti_wedge(self_: Sphere, other: Origin) -> Scalar {
    return Scalar(self_.g1.y * other.g0);
}

fn sphere_plane_anti_wedge(self_: Sphere, other: Plane) -> Circle {
    return Circle(vec4<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn sphere_plane_at_origin_anti_wedge(self_: Sphere, other: PlaneAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.y) * other.g0);
}

fn sphere_point_at_infinity_anti_wedge(self_: Sphere, other: PointAtInfinity) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn sphere_point_at_origin_anti_wedge(self_: Sphere, other: PointAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_rotor_anti_wedge(self_: Sphere, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_round_point_anti_wedge(self_: Sphere, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn sphere_sphere_anti_wedge(self_: Sphere, other: Sphere) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0);
}

fn sphere_translator_anti_wedge(self_: Sphere, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn translator_anti_scalar_anti_wedge(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_circle_anti_wedge(self_: Translator, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_dipole_anti_wedge(self_: Translator, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_flat_point_anti_wedge(self_: Translator, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_flector_anti_wedge(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_anti_wedge(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_infinity_anti_wedge(self_: Translator, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn translator_line_anti_wedge(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_line_at_infinity_anti_wedge(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_anti_wedge(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_magnitude_anti_wedge(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_motor_anti_wedge(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_multi_vector_anti_wedge(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g3.z, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.w) * other.g10);
}

fn translator_origin_anti_wedge(self_: Translator, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn translator_plane_anti_wedge(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_anti_wedge(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_point_at_infinity_anti_wedge(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_origin_anti_wedge(self_: Translator, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w * other.g0);
}

fn translator_rotor_anti_wedge(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_round_point_anti_wedge(self_: Translator, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_scalar_anti_wedge(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn translator_sphere_anti_wedge(self_: Translator, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_translator_anti_wedge(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_magnitude_join(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_multi_vector_join(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_scalar_join(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn circle_dipole_join(self_: Circle, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g0.w * other.g2.w - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn circle_flat_point_join(self_: Circle, other: FlatPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn circle_flector_join(self_: Circle, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn circle_infinity_join(self_: Circle, other: Infinity) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn circle_magnitude_join(self_: Circle, other: Magnitude) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x));
}

fn circle_multi_vector_join(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g2 * vec3<f32>(other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z));
}

fn circle_origin_join(self_: Circle, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn circle_point_at_infinity_join(self_: Circle, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn circle_point_at_origin_join(self_: Circle, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn circle_round_point_join(self_: Circle, other: RoundPoint) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_scalar_join(self_: Circle, other: Scalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn dipole_circle_join(self_: Dipole, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z - self_.g2.w * other.g0.w);
}

fn dipole_dipole_join(self_: Dipole, other: Dipole) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn dipole_flat_point_join(self_: Dipole, other: FlatPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn dipole_flector_join(self_: Dipole, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn dipole_infinity_join(self_: Dipole, other: Infinity) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn dipole_line_join(self_: Dipole, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_line_at_infinity_join(self_: Dipole, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn dipole_line_at_origin_join(self_: Dipole, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_magnitude_join(self_: Dipole, other: Magnitude) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec4<f32>(other.g0.x));
}

fn dipole_motor_join(self_: Dipole, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_multi_vector_join(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g6.w), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.x, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g2.x, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g2.x, -other.g1.z), self_.g0 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g2.w) * other.g1, self_.g1 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + self_.g1 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g2.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z));
}

fn dipole_origin_join(self_: Dipole, other: Origin) -> Circle {
    return Circle(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec3<f32>(0.0));
}

fn dipole_point_at_infinity_join(self_: Dipole, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn dipole_point_at_origin_join(self_: Dipole, other: PointAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn dipole_rotor_join(self_: Dipole, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_round_point_join(self_: Dipole, other: RoundPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn dipole_scalar_join(self_: Dipole, other: Scalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_translator_join(self_: Dipole, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn flat_point_circle_join(self_: FlatPoint, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn flat_point_dipole_join(self_: FlatPoint, other: Dipole) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flat_point_magnitude_join(self_: FlatPoint, other: Magnitude) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.x));
}

fn flat_point_multi_vector_join(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g6.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g0.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn flat_point_origin_join(self_: FlatPoint, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn flat_point_round_point_join(self_: FlatPoint, other: RoundPoint) -> Line {
    return Line(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn flat_point_scalar_join(self_: FlatPoint, other: Scalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flector_circle_join(self_: Flector, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn flector_dipole_join(self_: Flector, other: Dipole) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flector_magnitude_join(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_multi_vector_join(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.x));
}

fn flector_origin_join(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_round_point_join(self_: Flector, other: RoundPoint) -> Motor {
    return Motor(self_.g0.xyzx * vec4<f32>(other.g1.x, other.g1.x, other.g1.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn flector_scalar_join(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn horizon_magnitude_join(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.x);
}

fn horizon_multi_vector_join(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn horizon_origin_join(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn horizon_round_point_join(self_: Horizon, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.x);
}

fn horizon_scalar_join(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_circle_join(self_: Infinity, other: Circle) -> Plane {
    return Plane(vec4<f32>(0.0) - vec4<f32>(self_.g0) * other.g0);
}

fn infinity_dipole_join(self_: Infinity, other: Dipole) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn infinity_magnitude_join(self_: Infinity, other: Magnitude) -> Infinity {
    return Infinity(self_.g0 * other.g0.x);
}

fn infinity_multi_vector_join(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g10.x), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g2.x), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w));
}

fn infinity_origin_join(self_: Infinity, other: Origin) -> PointAtOrigin {
    return PointAtOrigin(0.0 - self_.g0 * other.g0);
}

fn infinity_round_point_join(self_: Infinity, other: RoundPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x));
}

fn infinity_scalar_join(self_: Infinity, other: Scalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_sphere_join(self_: Infinity, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.x);
}

fn line_dipole_join(self_: Line, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_join(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn line_multi_vector_join(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g1 * vec3<f32>(other.g2.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_origin_join(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0));
}

fn line_round_point_join(self_: Line, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn line_scalar_join(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_at_infinity_dipole_join(self_: LineAtInfinity, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_join(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_infinity_multi_vector_join(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_infinity_origin_join(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_round_point_join(self_: LineAtInfinity, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn line_at_infinity_scalar_join(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_dipole_join(self_: LineAtOrigin, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_magnitude_join(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_multi_vector_join(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec2<f32>(0.0));
}

fn line_at_origin_round_point_join(self_: LineAtOrigin, other: RoundPoint) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn line_at_origin_scalar_join(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn magnitude_anti_scalar_join(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn magnitude_circle_join(self_: Magnitude, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2);
}

fn magnitude_dipole_join(self_: Magnitude, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * other.g2);
}

fn magnitude_flat_point_join(self_: Magnitude, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_flector_join(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.x) * other.g1);
}

fn magnitude_horizon_join(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.x * other.g0);
}

fn magnitude_infinity_join(self_: Magnitude, other: Infinity) -> Infinity {
    return Infinity(self_.g0.x * other.g0);
}

fn magnitude_line_join(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_line_at_infinity_join(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_line_at_origin_join(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_join(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x));
}

fn magnitude_motor_join(self_: Magnitude, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_multi_vector_join(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), vec3<f32>(self_.g0.x) * other.g1, vec2<f32>(self_.g0.x) * other.g2, vec3<f32>(self_.g0.x) * other.g3, vec3<f32>(self_.g0.x) * other.g4, vec4<f32>(self_.g0.x) * other.g5, vec4<f32>(self_.g0.x) * other.g6, vec3<f32>(self_.g0.x) * other.g7, vec3<f32>(self_.g0.x) * other.g8, vec3<f32>(self_.g0.x) * other.g9, vec2<f32>(self_.g0.x) * other.g10);
}

fn magnitude_origin_join(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.x * other.g0);
}

fn magnitude_plane_join(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_plane_at_origin_join(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_at_infinity_join(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_at_origin_join(self_: Magnitude, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.x * other.g0);
}

fn magnitude_rotor_join(self_: Magnitude, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_round_point_join(self_: Magnitude, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_scalar_join(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_sphere_join(self_: Magnitude, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_translator_join(self_: Magnitude, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x) * other.g0);
}

fn motor_dipole_join(self_: Motor, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_magnitude_join(self_: Motor, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn motor_multi_vector_join(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g1 * vec3<f32>(other.g2.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn motor_origin_join(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0));
}

fn motor_round_point_join(self_: Motor, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn motor_scalar_join(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn multi_vector_anti_scalar_join(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn multi_vector_circle_join(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * other.g2 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(other.g0.w));
}

fn multi_vector_dipole_join(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * other.g2, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g2.y) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.y) * other.g1, vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_flat_point_join(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_flector_join(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_horizon_join(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_join(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_line_join(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_line_at_infinity_join(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g2.x) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_line_at_origin_join(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn multi_vector_magnitude_join(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec2<f32>(other.g0.x), self_.g3 * vec3<f32>(other.g0.x), self_.g4 * vec3<f32>(other.g0.x), self_.g5 * vec4<f32>(other.g0.x), self_.g6 * vec4<f32>(other.g0.x), self_.g7 * vec3<f32>(other.g0.x), self_.g8 * vec3<f32>(other.g0.x), self_.g9 * vec3<f32>(other.g0.x), self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_motor_join(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_multi_vector_join(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g10.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g10.x) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g8.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g8.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g8.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g5.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g5.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g5.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g3.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g2.x), vec3<f32>(self_.g0.x) * other.g1 + self_.g1 * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.x) * other.g2 + self_.g2 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g3 - self_.g1 * vec3<f32>(other.g2.x) + vec3<f32>(self_.g2.x) * other.g1 + self_.g3 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + self_.g4 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * other.g5 + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g2.y, other.g2.y, other.g2.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g2.x) + self_.g5 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.x) * other.g6 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, 0.0, other.g3.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, 0.0, -other.g4.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g2.x, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g2.x, 0.0, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g2.x, -other.g1.z) + self_.g6 * vec4<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g7 - self_.g1 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g2.y) * other.g3 + self_.g3 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g5.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + vec3<f32>(self_.g2.y) * other.g4 + self_.g4 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + self_.g8 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g7.z, -other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g7.z, 0.0, other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g7.y, -other.g7.x, 0.0) + vec3<f32>(self_.g2.x) * other.g8 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + self_.g4 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g5.w) * other.g4 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g2.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g8 * vec3<f32>(other.g2.x) + self_.g9 * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.x) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g2 * vec2<f32>(other.g6.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g6.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z) + self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_origin_join(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0));
}

fn multi_vector_plane_join(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_join(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0));
}

fn multi_vector_point_at_infinity_join(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g2.x) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_origin_join(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), self_.g4 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn multi_vector_rotor_join(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn multi_vector_round_point_join(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g2.x) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0, self_.g4 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_scalar_join(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_sphere_join(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn multi_vector_translator_join(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn origin_circle_join(self_: Origin, other: Circle) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g2, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0));
}

fn origin_dipole_join(self_: Origin, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0));
}

fn origin_flat_point_join(self_: Origin, other: FlatPoint) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn origin_flector_join(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w));
}

fn origin_horizon_join(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_infinity_join(self_: Origin, other: Infinity) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn origin_line_join(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_line_at_infinity_join(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_join(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.x);
}

fn origin_motor_join(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_multi_vector_join(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g10.y), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y), vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g8, vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, 0.0));
}

fn origin_plane_join(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn origin_point_at_infinity_join(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_round_point_join(self_: Origin, other: RoundPoint) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y));
}

fn origin_scalar_join(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_sphere_join(self_: Origin, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.y);
}

fn origin_translator_join(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_magnitude_join(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_multi_vector_join(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x));
}

fn plane_origin_join(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn plane_round_point_join(self_: Plane, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g1.x);
}

fn plane_scalar_join(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_at_origin_magnitude_join(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn plane_at_origin_multi_vector_join(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0));
}

fn plane_at_origin_round_point_join(self_: PlaneAtOrigin, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_scalar_join(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_join(self_: PointAtInfinity, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_dipole_join(self_: PointAtInfinity, other: Dipole) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z));
}

fn point_at_infinity_magnitude_join(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn point_at_infinity_multi_vector_join(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g6.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn point_at_infinity_origin_join(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_round_point_join(self_: PointAtInfinity, other: RoundPoint) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn point_at_infinity_scalar_join(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_origin_circle_join(self_: PointAtOrigin, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn point_at_origin_dipole_join(self_: PointAtOrigin, other: Dipole) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn point_at_origin_magnitude_join(self_: PointAtOrigin, other: Magnitude) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.x);
}

fn point_at_origin_multi_vector_join(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g4, vec2<f32>(0.0));
}

fn point_at_origin_round_point_join(self_: PointAtOrigin, other: RoundPoint) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_scalar_join(self_: PointAtOrigin, other: Scalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn rotor_dipole_join(self_: Rotor, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_magnitude_join(self_: Rotor, other: Magnitude) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0.x));
}

fn rotor_multi_vector_join(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec2<f32>(0.0));
}

fn rotor_round_point_join(self_: Rotor, other: RoundPoint) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn rotor_scalar_join(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn round_point_circle_join(self_: RoundPoint, other: Circle) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_dipole_join(self_: RoundPoint, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1);
}

fn round_point_flat_point_join(self_: RoundPoint, other: FlatPoint) -> Line {
    return Line(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn round_point_flector_join(self_: RoundPoint, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g0.w, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g0.w, other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn round_point_horizon_join(self_: RoundPoint, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0);
}

fn round_point_infinity_join(self_: RoundPoint, other: Infinity) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn round_point_line_join(self_: RoundPoint, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn round_point_line_at_infinity_join(self_: RoundPoint, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn round_point_line_at_origin_join(self_: RoundPoint, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn round_point_magnitude_join(self_: RoundPoint, other: Magnitude) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn round_point_motor_join(self_: RoundPoint, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn round_point_multi_vector_join(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g10.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g10.x), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.x) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g2.y, other.g2.y, other.g2.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, 0.0, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, 0.0, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + vec3<f32>(self_.g1.y) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, 0.0, other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, 0.0) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(other.g6.w));
}

fn round_point_origin_join(self_: RoundPoint, other: Origin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn round_point_plane_join(self_: RoundPoint, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g0.w);
}

fn round_point_plane_at_origin_join(self_: RoundPoint, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn round_point_point_at_infinity_join(self_: RoundPoint, other: PointAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn round_point_point_at_origin_join(self_: RoundPoint, other: PointAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn round_point_rotor_join(self_: RoundPoint, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn round_point_round_point_join(self_: RoundPoint, other: RoundPoint) -> Dipole {
    return Dipole(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x));
}

fn round_point_scalar_join(self_: RoundPoint, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_sphere_join(self_: RoundPoint, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn round_point_translator_join(self_: RoundPoint, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn scalar_anti_scalar_join(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_circle_join(self_: Scalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn scalar_dipole_join(self_: Scalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn scalar_flat_point_join(self_: Scalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_flector_join(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_join(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_infinity_join(self_: Scalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn scalar_line_join(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_join(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_join(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_join(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_join(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_join(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn scalar_origin_join(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_join(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_join(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_join(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_origin_join(self_: Scalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn scalar_rotor_join(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_round_point_join(self_: Scalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_scalar_join(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_sphere_join(self_: Scalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_translator_join(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn sphere_infinity_join(self_: Sphere, other: Infinity) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0);
}

fn sphere_magnitude_join(self_: Sphere, other: Magnitude) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_multi_vector_join(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_origin_join(self_: Sphere, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g1.y * other.g0);
}

fn sphere_round_point_join(self_: Sphere, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn sphere_scalar_join(self_: Sphere, other: Scalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn translator_dipole_join(self_: Translator, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_magnitude_join(self_: Translator, other: Magnitude) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0.x));
}

fn translator_multi_vector_join(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g3.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn translator_origin_join(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_round_point_join(self_: Translator, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn translator_scalar_join(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn anti_scalar_anti_scalar_meet(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_circle_meet(self_: AntiScalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn anti_scalar_dipole_meet(self_: AntiScalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn anti_scalar_flat_point_meet(self_: AntiScalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_flector_meet(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_meet(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_infinity_meet(self_: AntiScalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn anti_scalar_line_meet(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_meet(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_meet(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_meet(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_meet(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_meet(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn anti_scalar_origin_meet(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_meet(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_meet(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_meet(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_origin_meet(self_: AntiScalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn anti_scalar_rotor_meet(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_round_point_meet(self_: AntiScalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_scalar_meet(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_sphere_meet(self_: AntiScalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn anti_scalar_translator_meet(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn circle_anti_scalar_meet(self_: Circle, other: AntiScalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn circle_circle_meet(self_: Circle, other: Circle) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn circle_dipole_meet(self_: Circle, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g0.w * other.g2.w - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn circle_flat_point_meet(self_: Circle, other: FlatPoint) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn circle_flector_meet(self_: Circle, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_horizon_meet(self_: Circle, other: Horizon) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn circle_line_meet(self_: Circle, other: Line) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_line_at_infinity_meet(self_: Circle, other: LineAtInfinity) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_line_at_origin_meet(self_: Circle, other: LineAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z));
}

fn circle_magnitude_meet(self_: Circle, other: Magnitude) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y));
}

fn circle_motor_meet(self_: Circle, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_multi_vector_meet(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g5.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g5.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g5.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g5.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g3.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g8.z, -other.g8.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g8.z, 0.0, other.g8.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g8.y, -other.g8.x, 0.0) + vec3<f32>(self_.g0.w) * other.g7 + self_.g1 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g2.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g7.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g7.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0) + self_.g1 * vec3<f32>(other.g10.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g0.w) * other.g9 + self_.g2 * vec3<f32>(other.g10.x), vec4<f32>(self_.g1.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_plane_meet(self_: Circle, other: Plane) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn circle_plane_at_origin_meet(self_: Circle, other: PlaneAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn circle_point_at_infinity_meet(self_: Circle, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn circle_point_at_origin_meet(self_: Circle, other: PointAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn circle_rotor_meet(self_: Circle, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_sphere_meet(self_: Circle, other: Sphere) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g1 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0 + self_.g2 * vec3<f32>(other.g1.x), vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn circle_translator_meet(self_: Circle, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_anti_scalar_meet(self_: Dipole, other: AntiScalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_circle_meet(self_: Dipole, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z - self_.g2.w * other.g0.w);
}

fn dipole_flector_meet(self_: Dipole, other: Flector) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g1.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g1.w));
}

fn dipole_horizon_meet(self_: Dipole, other: Horizon) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0));
}

fn dipole_line_meet(self_: Dipole, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_line_at_infinity_meet(self_: Dipole, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn dipole_line_at_origin_meet(self_: Dipole, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_magnitude_meet(self_: Dipole, other: Magnitude) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec4<f32>(other.g0.y));
}

fn dipole_motor_meet(self_: Dipole, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec4<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_multi_vector_meet(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g8.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g8.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g8.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g2.w) * vec2<f32>(-other.g6.w, 0.0), self_.g0 * vec3<f32>(other.g10.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g9.z, other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g9.z, 0.0, -other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g9.y, other.g9.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.w) * other.g10 * vec2<f32>(-1.0, 1.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec4<f32>(other.g0.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_plane_meet(self_: Dipole, other: Plane) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, other.g0.w));
}

fn dipole_plane_at_origin_meet(self_: Dipole, other: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn dipole_rotor_meet(self_: Dipole, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec4<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn dipole_sphere_meet(self_: Dipole, other: Sphere) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn dipole_translator_meet(self_: Dipole, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), self_.g2 * vec4<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_anti_scalar_meet(self_: FlatPoint, other: AntiScalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flat_point_circle_meet(self_: FlatPoint, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn flat_point_flector_meet(self_: FlatPoint, other: Flector) -> Infinity {
    return Infinity(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g0.w * other.g1.w);
}

fn flat_point_horizon_meet(self_: FlatPoint, other: Horizon) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn flat_point_magnitude_meet(self_: FlatPoint, other: Magnitude) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.y));
}

fn flat_point_motor_meet(self_: FlatPoint, other: Motor) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.w));
}

fn flat_point_multi_vector_meet(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g6.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flat_point_plane_meet(self_: FlatPoint, other: Plane) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn flat_point_plane_at_origin_meet(self_: FlatPoint, other: PlaneAtOrigin) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn flat_point_rotor_meet(self_: FlatPoint, other: Rotor) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.w));
}

fn flat_point_sphere_meet(self_: FlatPoint, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn flat_point_translator_meet(self_: FlatPoint, other: Translator) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.w));
}

fn flector_anti_scalar_meet(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_circle_meet(self_: Flector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_dipole_meet(self_: Flector, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g2.w));
}

fn flector_flat_point_meet(self_: Flector, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z - self_.g1.w * other.g0.w);
}

fn flector_flector_meet(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_horizon_meet(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_line_meet(self_: Flector, other: Line) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_line_at_infinity_meet(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn flector_line_at_origin_meet(self_: Flector, other: LineAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn flector_magnitude_meet(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_motor_meet(self_: Flector, other: Motor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_multi_vector_meet(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(-other.g6.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) - vec3<f32>(self_.g1.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g0.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, -other.g5.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), self_.g0 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g10.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g1.w) * other.g9, vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.y));
}

fn flector_origin_meet(self_: Flector, other: Origin) -> Scalar {
    return Scalar(self_.g1.w * other.g0);
}

fn flector_plane_meet(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_plane_at_origin_meet(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_point_at_infinity_meet(self_: Flector, other: PointAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn flector_point_at_origin_meet(self_: Flector, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g1.w * other.g0);
}

fn flector_rotor_meet(self_: Flector, other: Rotor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_round_point_meet(self_: Flector, other: RoundPoint) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z + self_.g1.w * other.g1.x);
}

fn flector_sphere_meet(self_: Flector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0) - self_.g1 * vec4<f32>(other.g1.x), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn flector_translator_meet(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn horizon_anti_scalar_meet(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_circle_meet(self_: Horizon, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn horizon_dipole_meet(self_: Horizon, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g2.w));
}

fn horizon_flat_point_meet(self_: Horizon, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0.w);
}

fn horizon_flector_meet(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_line_meet(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_meet(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_meet(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.y);
}

fn horizon_motor_meet(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_meet(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g3, vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g5.w), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g9, vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y));
}

fn horizon_origin_meet(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn horizon_plane_meet(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_meet(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_origin_meet(self_: Horizon, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0 * other.g0);
}

fn horizon_rotor_meet(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_round_point_meet(self_: Horizon, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0 * other.g1.x);
}

fn horizon_sphere_meet(self_: Horizon, other: Sphere) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_translator_meet(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn infinity_anti_scalar_meet(self_: Infinity, other: AntiScalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_magnitude_meet(self_: Infinity, other: Magnitude) -> Infinity {
    return Infinity(self_.g0 * other.g0.y);
}

fn infinity_motor_meet(self_: Infinity, other: Motor) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn infinity_multi_vector_meet(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.x, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn infinity_rotor_meet(self_: Infinity, other: Rotor) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn infinity_sphere_meet(self_: Infinity, other: Sphere) -> Scalar {
    return Scalar(self_.g0 * other.g1.x);
}

fn infinity_translator_meet(self_: Infinity, other: Translator) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn line_anti_scalar_meet(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_circle_meet(self_: Line, other: Circle) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_dipole_meet(self_: Line, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_flector_meet(self_: Line, other: Flector) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0));
}

fn line_horizon_meet(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_meet(self_: Line, other: Line) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_at_infinity_meet(self_: Line, other: LineAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_meet(self_: Line, other: LineAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_meet(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y));
}

fn line_motor_meet(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_multi_vector_meet(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g3.z, 0.0), self_.g0 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z), self_.g0 * vec3<f32>(other.g10.x), self_.g1 * vec3<f32>(other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_plane_meet(self_: Line, other: Plane) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_plane_at_origin_meet(self_: Line, other: PlaneAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_rotor_meet(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_sphere_meet(self_: Line, other: Sphere) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_translator_meet(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_anti_scalar_meet(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_circle_meet(self_: LineAtInfinity, other: Circle) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z));
}

fn line_at_infinity_dipole_meet(self_: LineAtInfinity, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_flector_meet(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0));
}

fn line_at_infinity_line_meet(self_: LineAtInfinity, other: Line) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_line_at_origin_meet(self_: LineAtInfinity, other: LineAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_meet(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_infinity_motor_meet(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_multi_vector_meet(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g3.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_plane_meet(self_: LineAtInfinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn line_at_infinity_plane_at_origin_meet(self_: LineAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn line_at_infinity_rotor_meet(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_infinity_sphere_meet(self_: LineAtInfinity, other: Sphere) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0));
}

fn line_at_infinity_translator_meet(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_meet(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_circle_meet(self_: LineAtOrigin, other: Circle) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z));
}

fn line_at_origin_dipole_meet(self_: LineAtOrigin, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_flector_meet(self_: LineAtOrigin, other: Flector) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z));
}

fn line_at_origin_horizon_meet(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_meet(self_: LineAtOrigin, other: Line) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_at_infinity_meet(self_: LineAtOrigin, other: LineAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_magnitude_meet(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_origin_motor_meet(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_multi_vector_meet(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0), self_.g0 * vec3<f32>(other.g6.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z), self_.g0 * vec3<f32>(other.g10.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn line_at_origin_plane_meet(self_: LineAtOrigin, other: Plane) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn line_at_origin_plane_at_origin_meet(self_: LineAtOrigin, other: PlaneAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_rotor_meet(self_: LineAtOrigin, other: Rotor) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_sphere_meet(self_: LineAtOrigin, other: Sphere) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z));
}

fn line_at_origin_translator_meet(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_anti_scalar_meet(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_circle_meet(self_: Magnitude, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2);
}

fn magnitude_dipole_meet(self_: Magnitude, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * other.g2);
}

fn magnitude_flat_point_meet(self_: Magnitude, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_flector_meet(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * other.g1);
}

fn magnitude_horizon_meet(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.y * other.g0);
}

fn magnitude_infinity_meet(self_: Magnitude, other: Infinity) -> Infinity {
    return Infinity(self_.g0.y * other.g0);
}

fn magnitude_line_meet(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1);
}

fn magnitude_line_at_infinity_meet(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_line_at_origin_meet(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_magnitude_meet(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_meet(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_multi_vector_meet(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec2<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.y) * other.g3, vec3<f32>(self_.g0.y) * other.g4, vec4<f32>(self_.g0.y) * other.g5, vec4<f32>(self_.g0.y) * other.g6, vec3<f32>(self_.g0.y) * other.g7, vec3<f32>(self_.g0.y) * other.g8, vec3<f32>(self_.g0.y) * other.g9, vec2<f32>(self_.g0.y) * other.g10);
}

fn magnitude_origin_meet(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.y * other.g0);
}

fn magnitude_plane_meet(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_plane_at_origin_meet(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_at_infinity_meet(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_at_origin_meet(self_: Magnitude, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.y * other.g0);
}

fn magnitude_rotor_meet(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn magnitude_round_point_meet(self_: Magnitude, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_scalar_meet(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn magnitude_sphere_meet(self_: Magnitude, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn magnitude_translator_meet(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_anti_scalar_meet(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_circle_meet(self_: Motor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_dipole_meet(self_: Motor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_flat_point_meet(self_: Motor, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_flector_meet(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g1);
}

fn motor_horizon_meet(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_infinity_meet(self_: Motor, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn motor_line_meet(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_infinity_meet(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_line_at_origin_meet(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_magnitude_meet(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_motor_meet(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_multi_vector_meet(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(-other.g3.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2 + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.w) * other.g4 + self_.g1 * vec3<f32>(other.g10.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.w) * other.g8 + self_.g1 * vec3<f32>(other.g0.y), vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.w) * other.g10);
}

fn motor_origin_meet(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn motor_plane_meet(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_plane_at_origin_meet(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn motor_point_at_infinity_meet(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn motor_point_at_origin_meet(self_: Motor, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w * other.g0);
}

fn motor_rotor_meet(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn motor_round_point_meet(self_: Motor, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn motor_scalar_meet(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn motor_sphere_meet(self_: Motor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), self_.g1 * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn motor_translator_meet(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_anti_scalar_meet(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_circle_meet(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g2.z, -other.g2.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g2.z, 0.0, other.g2.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g2.y, -other.g2.x, 0.0) + vec3<f32>(self_.g6.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g10.x) * other.g1, vec3<f32>(0.0) - self_.g9 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g2 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_dipole_meet(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(-other.g2.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g2.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g2.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g2.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g10.y) * other.g0, vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g10 * vec2<f32>(other.g2.w), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(self_.g0.y) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_flat_point_meet(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0), vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_flector_meet(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0.w, 0.0), self_.g3 * vec3<f32>(other.g1.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z) + self_.g10 * vec2<f32>(other.g0.w), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0), vec4<f32>(self_.g10.x) * other.g1, vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), self_.g9 * vec3<f32>(other.g1.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.w));
}

fn multi_vector_horizon_meet(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0, 0.0), self_.g3 * vec3<f32>(other.g0), vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec4<f32>(self_.g7.x, self_.g7.y, self_.g7.z, self_.g7.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g9 * vec3<f32>(other.g0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_meet(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_line_meet(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g10.x) * other.g1, vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_line_at_infinity_meet(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g10.x) * other.g0, vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_line_at_origin_meet(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g6.w) * other.g0, vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(self_.g10.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_magnitude_meet(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec3<f32>(other.g0.y), self_.g2 * vec2<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.y), self_.g4 * vec3<f32>(other.g0.y), self_.g5 * vec4<f32>(other.g0.y), self_.g6 * vec4<f32>(other.g0.y), self_.g7 * vec3<f32>(other.g0.y), self_.g8 * vec3<f32>(other.g0.y), self_.g9 * vec3<f32>(other.g0.y), self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_motor_meet(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * other.g1, self_.g5 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g6 * vec4<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g7 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * other.g1 + self_.g8 * vec3<f32>(other.g0.w), self_.g9 * vec3<f32>(other.g0.w), self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_multi_vector_meet(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g10.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g10.x, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g8.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g8.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g8.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g7.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g5.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g5.z) * vec2<f32>(-other.g6.z, 0.0) + vec2<f32>(self_.g5.w) * vec2<f32>(-other.g6.w, 0.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g5.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g5.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g5.z, 0.0) + vec2<f32>(self_.g6.w) * vec2<f32>(-other.g5.w, 0.0) + vec2<f32>(self_.g7.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g7.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g7.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g8.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g8.z) * vec2<f32>(-other.g3.z, 0.0) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(self_.g0.y) * other.g1 + self_.g1 * vec3<f32>(other.g0.y) + self_.g3 * vec3<f32>(other.g10.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g9.z, other.g9.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g9.z, 0.0, -other.g9.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g9.y, other.g9.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g8.z, -other.g8.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g8.z, 0.0, other.g8.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g8.y, -other.g8.x, 0.0) + vec3<f32>(self_.g6.w) * other.g7 + self_.g7 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g8.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g8.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g8.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g10.y) * other.g3, vec2<f32>(self_.g0.y) * other.g2 + self_.g2 * vec2<f32>(other.g0.y) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g9.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g9.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g9.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g5.w) * other.g10 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g7.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g7.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g7.z, 0.0) - vec2<f32>(self_.g7.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g7.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g7.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g9.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g10 * vec2<f32>(other.g5.w), vec3<f32>(self_.g0.y) * other.g3 + self_.g3 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0) + self_.g7 * vec3<f32>(other.g10.x) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g9.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g9.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g10.x) * other.g7, vec3<f32>(self_.g0.y) * other.g4 + self_.g4 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g6.w) * other.g9 + self_.g8 * vec3<f32>(other.g10.x) - self_.g9 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g10.x) * other.g8 + vec3<f32>(self_.g10.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.y) * other.g5 + self_.g5 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g7.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(self_.g0.y) * other.g6 + self_.g6 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g10.x, -other.g10.x, -other.g10.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.y) * other.g7 + self_.g7 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), vec3<f32>(self_.g0.y) * other.g8 + self_.g8 * vec3<f32>(other.g0.y) + self_.g9 * vec3<f32>(other.g10.y) - vec3<f32>(self_.g10.y) * other.g9, vec3<f32>(self_.g0.y) * other.g9 + self_.g9 * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.y) * other.g10 + self_.g10 * vec2<f32>(other.g0.y));
}

fn multi_vector_origin_meet(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_plane_meet(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.w, 0.0), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g7.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g10.x) * other.g0, vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g9 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g10.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_meet(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g6.w) * other.g0, vec4<f32>(self_.g7.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(0.0));
}

fn multi_vector_point_at_infinity_meet(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(self_.g10.x) * other.g0, vec2<f32>(self_.g9.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_point_at_origin_meet(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0), vec3<f32>(0.0), self_.g10 * vec2<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_rotor_meet(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(-other.g0.z, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g6.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g4 * vec3<f32>(other.g0.w), self_.g5 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g9.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g9.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g10.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g6 * vec4<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g7 * vec3<f32>(other.g0.w), self_.g8 * vec3<f32>(other.g0.w), self_.g9 * vec3<f32>(other.g0.w), self_.g10 * vec2<f32>(other.g0.w));
}

fn multi_vector_round_point_meet(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g9.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g9.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g9.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g10.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g10.y) * vec2<f32>(other.g1.x, 0.0), vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_scalar_meet(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn multi_vector_sphere_meet(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.x, 0.0), self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g4.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) - vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x), vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g5.w) * other.g1 * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + self_.g7 * vec3<f32>(other.g1.x), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g6.w) * other.g0 + self_.g8 * vec3<f32>(other.g1.x), vec4<f32>(self_.g7.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g7.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g7.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z) + vec4<f32>(self_.g8.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g8.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g8.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g9.x, self_.g9.y, self_.g9.z, self_.g9.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g10.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g10.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g9.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g9.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g9.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g9 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g10.y) * other.g0, vec3<f32>(self_.g0.y) * other.g0, vec2<f32>(self_.g0.y) * other.g1);
}

fn multi_vector_translator_meet(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g0.z, 0.0), self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g6.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g6.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g6.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g2 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g0.z), self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g10.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g5 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g9.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g9.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g9.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), self_.g6 * vec4<f32>(other.g0.w), self_.g7 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g8 * vec3<f32>(other.g0.w), self_.g9 * vec3<f32>(other.g0.w), self_.g10 * vec2<f32>(other.g0.w));
}

fn origin_anti_scalar_meet(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_flector_meet(self_: Origin, other: Flector) -> Scalar {
    return Scalar(self_.g0 * other.g1.w);
}

fn origin_horizon_meet(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn origin_magnitude_meet(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.y);
}

fn origin_motor_meet(self_: Origin, other: Motor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_multi_vector_meet(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g10.y, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn origin_plane_meet(self_: Origin, other: Plane) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn origin_rotor_meet(self_: Origin, other: Rotor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_sphere_meet(self_: Origin, other: Sphere) -> Scalar {
    return Scalar(self_.g0 * other.g1.y);
}

fn origin_translator_meet(self_: Origin, other: Translator) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn plane_anti_scalar_meet(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_circle_meet(self_: Plane, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn plane_dipole_meet(self_: Plane, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) - vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g2.w));
}

fn plane_flat_point_meet(self_: Plane, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_flector_meet(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_horizon_meet(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_meet(self_: Plane, other: Line) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_line_at_infinity_meet(self_: Plane, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn plane_line_at_origin_meet(self_: Plane, other: LineAtOrigin) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, -other.g0.z));
}

fn plane_magnitude_meet(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_motor_meet(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_multi_vector_meet(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) - vec3<f32>(self_.g0.w) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.y) - vec3<f32>(self_.g0.w) * other.g9, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.y));
}

fn plane_origin_meet(self_: Plane, other: Origin) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn plane_plane_meet(self_: Plane, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_meet(self_: Plane, other: PlaneAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_at_infinity_meet(self_: Plane, other: PointAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_point_at_origin_meet(self_: Plane, other: PointAtOrigin) -> Infinity {
    return Infinity(0.0 - self_.g0.w * other.g0);
}

fn plane_rotor_meet(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_round_point_meet(self_: Plane, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g1.x);
}

fn plane_sphere_meet(self_: Plane, other: Sphere) -> Circle {
    return Circle(vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_translator_meet(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_at_origin_anti_scalar_meet(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_circle_meet(self_: PlaneAtOrigin, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z));
}

fn plane_at_origin_dipole_meet(self_: PlaneAtOrigin, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z));
}

fn plane_at_origin_flat_point_meet(self_: PlaneAtOrigin, other: FlatPoint) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_flector_meet(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), self_.g0 * vec3<f32>(other.g1.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn plane_at_origin_horizon_meet(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_meet(self_: PlaneAtOrigin, other: Line) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z));
}

fn plane_at_origin_line_at_infinity_meet(self_: PlaneAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn plane_at_origin_line_at_origin_meet(self_: PlaneAtOrigin, other: LineAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_magnitude_meet(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn plane_at_origin_motor_meet(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_multi_vector_meet(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g6.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g10.x, -other.g10.x, -other.g10.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), self_.g0 * vec3<f32>(other.g10.y), self_.g0 * vec3<f32>(other.g0.y), vec2<f32>(0.0));
}

fn plane_at_origin_plane_meet(self_: PlaneAtOrigin, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_meet(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn plane_at_origin_point_at_infinity_meet(self_: PlaneAtOrigin, other: PointAtInfinity) -> Infinity {
    return Infinity(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_rotor_meet(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_round_point_meet(self_: PlaneAtOrigin, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_sphere_meet(self_: PlaneAtOrigin, other: Sphere) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y));
}

fn plane_at_origin_translator_meet(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn point_at_infinity_anti_scalar_meet(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_meet(self_: PointAtInfinity, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_flector_meet(self_: PointAtInfinity, other: Flector) -> Infinity {
    return Infinity(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn point_at_infinity_magnitude_meet(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn point_at_infinity_motor_meet(self_: PointAtInfinity, other: Motor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_multi_vector_meet(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g6.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g6.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g6.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g10.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_infinity_plane_meet(self_: PointAtInfinity, other: Plane) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_plane_at_origin_meet(self_: PointAtInfinity, other: PlaneAtOrigin) -> Infinity {
    return Infinity(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_rotor_meet(self_: PointAtInfinity, other: Rotor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_sphere_meet(self_: PointAtInfinity, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z));
}

fn point_at_infinity_translator_meet(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_origin_anti_scalar_meet(self_: PointAtOrigin, other: AntiScalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn point_at_origin_circle_meet(self_: PointAtOrigin, other: Circle) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn point_at_origin_flector_meet(self_: PointAtOrigin, other: Flector) -> Infinity {
    return Infinity(self_.g0 * other.g1.w);
}

fn point_at_origin_horizon_meet(self_: PointAtOrigin, other: Horizon) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn point_at_origin_magnitude_meet(self_: PointAtOrigin, other: Magnitude) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.y);
}

fn point_at_origin_motor_meet(self_: PointAtOrigin, other: Motor) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.w);
}

fn point_at_origin_multi_vector_meet(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(-other.g6.w, 0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g10 * vec2<f32>(-1.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn point_at_origin_plane_meet(self_: PointAtOrigin, other: Plane) -> Infinity {
    return Infinity(self_.g0 * other.g0.w);
}

fn point_at_origin_rotor_meet(self_: PointAtOrigin, other: Rotor) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.w);
}

fn point_at_origin_sphere_meet(self_: PointAtOrigin, other: Sphere) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0), vec2<f32>(self_.g0) * other.g1 * vec2<f32>(-1.0, 1.0));
}

fn point_at_origin_translator_meet(self_: PointAtOrigin, other: Translator) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.w);
}

fn rotor_anti_scalar_meet(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_circle_meet(self_: Rotor, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g2.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_dipole_meet(self_: Rotor, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_flat_point_meet(self_: Rotor, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_flector_meet(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, -other.g1.z) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_meet(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_infinity_meet(self_: Rotor, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn rotor_line_meet(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_infinity_meet(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_line_at_origin_meet(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_magnitude_meet(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_motor_meet(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn rotor_multi_vector_meet(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g6.w) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, other.g8.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, other.g8.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, other.g8.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(other.g10.y, 0.0, 0.0, -other.g9.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g10.y, 0.0, -other.g9.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g10.y, -other.g9.z) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.w) * other.g10);
}

fn rotor_origin_meet(self_: Rotor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn rotor_plane_meet(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z), vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_meet(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_at_infinity_meet(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_point_at_origin_meet(self_: Rotor, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w * other.g0);
}

fn rotor_rotor_meet(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_round_point_meet(self_: Rotor, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_scalar_meet(self_: Rotor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn rotor_sphere_meet(self_: Rotor, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.y, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.y, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.y, -other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn rotor_translator_meet(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_anti_scalar_meet(self_: RoundPoint, other: AntiScalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_flector_meet(self_: RoundPoint, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g1.x * other.g1.w);
}

fn round_point_horizon_meet(self_: RoundPoint, other: Horizon) -> Scalar {
    return Scalar(self_.g1.x * other.g0);
}

fn round_point_magnitude_meet(self_: RoundPoint, other: Magnitude) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn round_point_motor_meet(self_: RoundPoint, other: Motor) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_multi_vector_meet(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g9.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g9.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g9.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g10.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g10.x, 0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_plane_meet(self_: RoundPoint, other: Plane) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g0.w);
}

fn round_point_plane_at_origin_meet(self_: RoundPoint, other: PlaneAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn round_point_rotor_meet(self_: RoundPoint, other: Rotor) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_sphere_meet(self_: RoundPoint, other: Sphere) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn round_point_translator_meet(self_: RoundPoint, other: Translator) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn scalar_anti_scalar_meet(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_magnitude_meet(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_motor_meet(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_multi_vector_meet(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_rotor_meet(self_: Scalar, other: Rotor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_translator_meet(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn sphere_anti_scalar_meet(self_: Sphere, other: AntiScalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_circle_meet(self_: Sphere, other: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * other.g2 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, -other.g2.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g2.z, 0.0, other.g2.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, -other.g2.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn sphere_dipole_meet(self_: Sphere, other: Dipole) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) - vec3<f32>(self_.g1.y) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g2.w));
}

fn sphere_flat_point_meet(self_: Sphere, other: FlatPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_flector_meet(self_: Sphere, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z) + self_.g1 * vec2<f32>(other.g0.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), self_.g0 * vec3<f32>(other.g1.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn sphere_horizon_meet(self_: Sphere, other: Horizon) -> Circle {
    return Circle(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0));
}

fn sphere_infinity_meet(self_: Sphere, other: Infinity) -> Scalar {
    return Scalar(self_.g1.x * other.g0);
}

fn sphere_line_meet(self_: Sphere, other: Line) -> Dipole {
    return Dipole(vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn sphere_line_at_infinity_meet(self_: Sphere, other: LineAtInfinity) -> Dipole {
    return Dipole(vec3<f32>(0.0), vec3<f32>(self_.g1.x) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0));
}

fn sphere_line_at_origin_meet(self_: Sphere, other: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn sphere_magnitude_meet(self_: Sphere, other: Magnitude) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_motor_meet(self_: Sphere, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * other.g1, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, -other.g1.y, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g1.z, 0.0, other.g1.x, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, -other.g1.x, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_multi_vector_meet(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.y, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g4.z, other.g4.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, -other.g4.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g4.y, other.g4.x, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) - vec3<f32>(self_.g1.y) * other.g3, vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, -other.g5.z) + self_.g1 * vec2<f32>(other.g5.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g1.x) * other.g7, vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g6.w) + vec3<f32>(self_.g1.x) * other.g8 + vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g8.z, -other.g8.y, -other.g7.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g8.z, 0.0, other.g8.x, -other.g7.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g8.y, -other.g8.x, 0.0, -other.g7.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g7.x, other.g7.y, other.g7.z, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g10.x, -other.g10.x, -other.g10.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g9.x, other.g9.y, other.g9.z, other.g10.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g10.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g9.z, -other.g9.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g9.z, 0.0, other.g9.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g9.y, -other.g9.x, 0.0), self_.g0 * vec3<f32>(other.g10.y) - vec3<f32>(self_.g1.y) * other.g9, self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec2<f32>(other.g0.y));
}

fn sphere_origin_meet(self_: Sphere, other: Origin) -> Scalar {
    return Scalar(self_.g1.y * other.g0);
}

fn sphere_plane_meet(self_: Sphere, other: Plane) -> Circle {
    return Circle(vec4<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn sphere_plane_at_origin_meet(self_: Sphere, other: PlaneAtOrigin) -> Circle {
    return Circle(vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.y) * other.g0);
}

fn sphere_point_at_infinity_meet(self_: Sphere, other: PointAtInfinity) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g1.x) * other.g0, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z));
}

fn sphere_point_at_origin_meet(self_: Sphere, other: PointAtOrigin) -> RoundPoint {
    return RoundPoint(vec3<f32>(0.0), self_.g1 * vec2<f32>(other.g0));
}

fn sphere_rotor_meet(self_: Sphere, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn sphere_round_point_meet(self_: Sphere, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn sphere_sphere_meet(self_: Sphere, other: Sphere) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(-other.g1.x, -other.g1.x, -other.g1.x, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.y) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), self_.g0 * vec3<f32>(other.g1.y) - vec3<f32>(self_.g1.y) * other.g0);
}

fn sphere_translator_meet(self_: Sphere, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec2<f32>(other.g0.w));
}

fn translator_anti_scalar_meet(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_circle_meet(self_: Translator, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g1.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_dipole_meet(self_: Translator, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(self_.g0.w) * other.g2, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_flat_point_meet(self_: Translator, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_flector_meet(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_meet(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_infinity_meet(self_: Translator, other: Infinity) -> Infinity {
    return Infinity(self_.g0.w * other.g0);
}

fn translator_line_meet(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_line_at_infinity_meet(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_meet(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_magnitude_meet(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_motor_meet(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_multi_vector_meet(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(-other.g3.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g3.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g3.z, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g6.z, other.g6.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g6.z, 0.0, -other.g6.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g6.y, other.g6.x, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g10.x) + vec3<f32>(self_.g0.w) * other.g4, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g9.z, other.g9.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g9.z, 0.0, -other.g9.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g9.y, other.g9.x, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g5, vec4<f32>(self_.g0.w) * other.g6, vec3<f32>(self_.g0.w) * other.g7, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g8, vec3<f32>(self_.g0.w) * other.g9, vec2<f32>(self_.g0.w) * other.g10);
}

fn translator_origin_meet(self_: Translator, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn translator_plane_meet(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_meet(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_point_at_infinity_meet(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_origin_meet(self_: Translator, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w * other.g0);
}

fn translator_rotor_meet(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn translator_round_point_meet(self_: Translator, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_scalar_meet(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn translator_sphere_meet(self_: Translator, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec2<f32>(self_.g0.w) * other.g1);
}

fn translator_translator_meet(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_magnitude_wedge(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_multi_vector_wedge(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_scalar_wedge(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn circle_dipole_wedge(self_: Circle, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g0.w * other.g2.w - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn circle_flat_point_wedge(self_: Circle, other: FlatPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn circle_flector_wedge(self_: Circle, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn circle_infinity_wedge(self_: Circle, other: Infinity) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn circle_magnitude_wedge(self_: Circle, other: Magnitude) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x));
}

fn circle_multi_vector_wedge(self_: Circle, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g5.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g5.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g5.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g2 * vec3<f32>(other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z));
}

fn circle_origin_wedge(self_: Circle, other: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0) - self_.g2 * vec3<f32>(other.g0), vec2<f32>(self_.g0.w) * vec2<f32>(-other.g0, 0.0));
}

fn circle_point_at_infinity_wedge(self_: Circle, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn circle_point_at_origin_wedge(self_: Circle, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn circle_round_point_wedge(self_: Circle, other: RoundPoint) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g2 * vec3<f32>(other.g1.x), vec2<f32>(self_.g0.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z));
}

fn circle_scalar_wedge(self_: Circle, other: Scalar) -> Circle {
    return Circle(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec3<f32>(other.g0));
}

fn dipole_circle_wedge(self_: Dipole, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z - self_.g2.w * other.g0.w);
}

fn dipole_dipole_wedge(self_: Dipole, other: Dipole) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.w) * other.g1, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g1.z));
}

fn dipole_flat_point_wedge(self_: Dipole, other: FlatPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn dipole_flector_wedge(self_: Dipole, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, -other.g0.z));
}

fn dipole_infinity_wedge(self_: Dipole, other: Infinity) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn dipole_line_wedge(self_: Dipole, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_line_at_infinity_wedge(self_: Dipole, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn dipole_line_at_origin_wedge(self_: Dipole, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_magnitude_wedge(self_: Dipole, other: Magnitude) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec4<f32>(other.g0.x));
}

fn dipole_motor_wedge(self_: Dipole, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_multi_vector_wedge(self_: Dipole, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g8.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g2.w) * vec2<f32>(0.0, -other.g6.w), vec3<f32>(0.0), vec2<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g2.x, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g2.x, 0.0, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g2.x, -other.g1.z), self_.g0 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g2.w) * other.g1, self_.g1 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + self_.g1 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g2.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, -other.g4.z));
}

fn dipole_origin_wedge(self_: Dipole, other: Origin) -> Circle {
    return Circle(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g0), vec3<f32>(0.0));
}

fn dipole_point_at_infinity_wedge(self_: Dipole, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z));
}

fn dipole_point_at_origin_wedge(self_: Dipole, other: PointAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn dipole_rotor_wedge(self_: Dipole, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn dipole_round_point_wedge(self_: Dipole, other: RoundPoint) -> Circle {
    return Circle(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g0 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g2.w) * other.g0, self_.g1 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g2.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn dipole_scalar_wedge(self_: Dipole, other: Scalar) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec4<f32>(other.g0));
}

fn dipole_translator_wedge(self_: Dipole, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn flat_point_circle_wedge(self_: FlatPoint, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn flat_point_dipole_wedge(self_: FlatPoint, other: Dipole) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flat_point_magnitude_wedge(self_: FlatPoint, other: Magnitude) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0.x));
}

fn flat_point_multi_vector_wedge(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g6.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g0.w) * other.g4, vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn flat_point_origin_wedge(self_: FlatPoint, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn flat_point_round_point_wedge(self_: FlatPoint, other: RoundPoint) -> Line {
    return Line(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn flat_point_scalar_wedge(self_: FlatPoint, other: Scalar) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(other.g0));
}

fn flector_circle_wedge(self_: Flector, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn flector_dipole_wedge(self_: Flector, other: Dipole) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flector_magnitude_wedge(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_multi_vector_wedge(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g0.w) * other.g4 + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.x));
}

fn flector_origin_wedge(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_round_point_wedge(self_: Flector, other: RoundPoint) -> Motor {
    return Motor(self_.g0.xyzx * vec4<f32>(other.g1.x, other.g1.x, other.g1.x, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(-other.g0.x, -other.g0.y, -other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn flector_scalar_wedge(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn horizon_magnitude_wedge(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.x);
}

fn horizon_multi_vector_wedge(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x));
}

fn horizon_origin_wedge(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn horizon_round_point_wedge(self_: Horizon, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.x);
}

fn horizon_scalar_wedge(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn infinity_circle_wedge(self_: Infinity, other: Circle) -> Plane {
    return Plane(vec4<f32>(0.0) - vec4<f32>(self_.g0) * other.g0);
}

fn infinity_dipole_wedge(self_: Infinity, other: Dipole) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn infinity_magnitude_wedge(self_: Infinity, other: Magnitude) -> Infinity {
    return Infinity(self_.g0 * other.g0.x);
}

fn infinity_multi_vector_wedge(self_: Infinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g10.x), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g2.x), vec4<f32>(0.0), vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w));
}

fn infinity_origin_wedge(self_: Infinity, other: Origin) -> PointAtOrigin {
    return PointAtOrigin(0.0 - self_.g0 * other.g0);
}

fn infinity_round_point_wedge(self_: Infinity, other: RoundPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(0.0) - vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x));
}

fn infinity_scalar_wedge(self_: Infinity, other: Scalar) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn infinity_sphere_wedge(self_: Infinity, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.x);
}

fn line_dipole_wedge(self_: Line, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_wedge(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn line_multi_vector_wedge(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g1 * vec3<f32>(other.g2.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_origin_wedge(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0));
}

fn line_round_point_wedge(self_: Line, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn line_scalar_wedge(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_at_infinity_dipole_wedge(self_: LineAtInfinity, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_wedge(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_infinity_multi_vector_wedge(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn line_at_infinity_origin_wedge(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_round_point_wedge(self_: LineAtInfinity, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn line_at_infinity_scalar_wedge(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_dipole_wedge(self_: LineAtOrigin, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_magnitude_wedge(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_multi_vector_wedge(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec2<f32>(0.0));
}

fn line_at_origin_round_point_wedge(self_: LineAtOrigin, other: RoundPoint) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn line_at_origin_scalar_wedge(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn magnitude_anti_scalar_wedge(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn magnitude_circle_wedge(self_: Magnitude, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2);
}

fn magnitude_dipole_wedge(self_: Magnitude, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * other.g2);
}

fn magnitude_flat_point_wedge(self_: Magnitude, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_flector_wedge(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.x) * other.g1);
}

fn magnitude_horizon_wedge(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.x * other.g0);
}

fn magnitude_infinity_wedge(self_: Magnitude, other: Infinity) -> Infinity {
    return Infinity(self_.g0.x * other.g0);
}

fn magnitude_line_wedge(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_line_at_infinity_wedge(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_line_at_origin_wedge(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_wedge(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x));
}

fn magnitude_motor_wedge(self_: Magnitude, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_multi_vector_wedge(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), vec3<f32>(self_.g0.x) * other.g1, vec2<f32>(self_.g0.x) * other.g2, vec3<f32>(self_.g0.x) * other.g3, vec3<f32>(self_.g0.x) * other.g4, vec4<f32>(self_.g0.x) * other.g5, vec4<f32>(self_.g0.x) * other.g6, vec3<f32>(self_.g0.x) * other.g7, vec3<f32>(self_.g0.x) * other.g8, vec3<f32>(self_.g0.x) * other.g9, vec2<f32>(self_.g0.x) * other.g10);
}

fn magnitude_origin_wedge(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.x * other.g0);
}

fn magnitude_plane_wedge(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_plane_at_origin_wedge(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_at_infinity_wedge(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_at_origin_wedge(self_: Magnitude, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.x * other.g0);
}

fn magnitude_rotor_wedge(self_: Magnitude, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_round_point_wedge(self_: Magnitude, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_scalar_wedge(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_sphere_wedge(self_: Magnitude, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn magnitude_translator_wedge(self_: Magnitude, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x) * other.g0);
}

fn motor_dipole_wedge(self_: Motor, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_magnitude_wedge(self_: Motor, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn motor_multi_vector_wedge(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g3.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g1 * vec3<f32>(other.g2.x), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z));
}

fn motor_origin_wedge(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0));
}

fn motor_round_point_wedge(self_: Motor, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn motor_scalar_wedge(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn multi_vector_anti_scalar_wedge(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn multi_vector_circle_wedge(self_: MultiVector, other: Circle) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g2.x) * other.g2 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g2 * vec2<f32>(other.g0.w));
}

fn multi_vector_dipole_wedge(self_: MultiVector, other: Dipole) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g2.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g2.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g2.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g2.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g0.x) * other.g2, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g2.y) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g2.y) * other.g1, vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + self_.g4 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g5.w) * other.g1, vec2<f32>(self_.g3.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g1.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g2.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g2.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g2.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_flat_point_wedge(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_flector_wedge(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0) + self_.g4 * vec3<f32>(other.g0.w), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_horizon_wedge(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_infinity_wedge(self_: MultiVector, other: Infinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g0), vec2<f32>(self_.g6.w) * vec2<f32>(0.0, other.g0));
}

fn multi_vector_line_wedge(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_line_at_infinity_wedge(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g2.x) * other.g0, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_line_at_origin_wedge(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn multi_vector_magnitude_wedge(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), self_.g1 * vec3<f32>(other.g0.x), self_.g2 * vec2<f32>(other.g0.x), self_.g3 * vec3<f32>(other.g0.x), self_.g4 * vec3<f32>(other.g0.x), self_.g5 * vec4<f32>(other.g0.x), self_.g6 * vec4<f32>(other.g0.x), self_.g7 * vec3<f32>(other.g0.x), self_.g8 * vec3<f32>(other.g0.x), self_.g9 * vec3<f32>(other.g0.x), self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_motor_wedge(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g1.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) + vec3<f32>(self_.g2.x) * other.g1, vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g1.z));
}

fn multi_vector_multi_vector_wedge(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g10.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g10.x) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g8.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g8.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g8.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g7.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g7.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g7.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g6.z) + vec2<f32>(self_.g5.w) * vec2<f32>(0.0, -other.g6.w) + vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g5.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g5.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g5.z) + vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g5.w) + vec2<f32>(self_.g7.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g7.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g7.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, -other.g3.z) + vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g2.x), vec3<f32>(self_.g0.x) * other.g1 + self_.g1 * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.x) * other.g2 + self_.g2 * vec2<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g3 - self_.g1 * vec3<f32>(other.g2.x) + vec3<f32>(self_.g2.x) * other.g1 + self_.g3 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g4 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0) + self_.g4 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * other.g5 + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g2.y, other.g2.y, other.g2.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g2.x) + self_.g5 * vec4<f32>(other.g0.x), vec4<f32>(self_.g0.x) * other.g6 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g1.y) * vec4<f32>(-other.g3.z, 0.0, other.g3.x, -other.g4.y) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, -other.g3.x, 0.0, -other.g4.z) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g1.z, other.g1.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, 0.0, -other.g1.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g1.y, other.g1.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g2.x, 0.0, 0.0, -other.g1.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g2.x, 0.0, -other.g1.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g2.x, -other.g1.z) + self_.g6 * vec4<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g7 - self_.g1 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g2.y) * other.g3 + self_.g3 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g2.x) - vec3<f32>(self_.g5.w) * other.g1 + self_.g7 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g8 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + vec3<f32>(self_.g2.y) * other.g4 + self_.g4 * vec3<f32>(other.g2.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + self_.g8 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g9 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g7.z, -other.g7.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g7.z, 0.0, other.g7.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g7.y, -other.g7.x, 0.0) + vec3<f32>(self_.g2.x) * other.g8 - vec3<f32>(self_.g2.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + self_.g4 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0) + vec3<f32>(self_.g5.w) * other.g4 + vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g2.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) - self_.g8 * vec3<f32>(other.g2.x) + self_.g9 * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.x) * other.g10 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g2 * vec2<f32>(other.g6.w) + vec2<f32>(self_.g3.x) * vec2<f32>(-other.g4.x, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(-other.g4.y, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(-other.g4.z, 0.0) - vec2<f32>(self_.g4.x) * vec2<f32>(other.g3.x, other.g5.x) - vec2<f32>(self_.g4.y) * vec2<f32>(other.g3.y, other.g5.y) - vec2<f32>(self_.g4.z) * vec2<f32>(other.g3.z, other.g5.z) + vec2<f32>(self_.g5.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g5.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g5.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g6.x) * vec2<f32>(-other.g1.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g1.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g1.z, 0.0) + vec2<f32>(self_.g6.w) * other.g2 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g1.z) + self_.g10 * vec2<f32>(other.g0.x));
}

fn multi_vector_origin_wedge(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g0), vec3<f32>(0.0), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0, 0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g8 * vec3<f32>(other.g0), vec2<f32>(self_.g6.w) * vec2<f32>(-other.g0, 0.0));
}

fn multi_vector_plane_wedge(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w));
}

fn multi_vector_plane_at_origin_wedge(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(0.0));
}

fn multi_vector_point_at_infinity_wedge(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g6.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g6.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g2.x) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec3<f32>(self_.g3.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g3.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z));
}

fn multi_vector_point_at_origin_wedge(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g6.w) * vec2<f32>(0.0, -other.g0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g0), vec3<f32>(0.0), self_.g4 * vec3<f32>(other.g0), vec2<f32>(0.0));
}

fn multi_vector_rotor_wedge(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec2<f32>(0.0));
}

fn multi_vector_round_point_wedge(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g9.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g9.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g9.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g10.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g10.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1, vec3<f32>(0.0) - self_.g1 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g2.x) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g1.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, -other.g0.z, other.g0.y, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, -other.g0.x, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(-other.g0.y, other.g0.x, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g1.x, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g1.x, 0.0, -other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g1.x, -other.g0.z), self_.g3 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z) * vec3<f32>(other.g1.x) - vec3<f32>(self_.g5.w) * other.g0, self_.g4 * vec3<f32>(other.g1.y) + vec3<f32>(self_.g5.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g5.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g5.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0), vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z) * vec3<f32>(other.g1.y) + vec3<f32>(self_.g7.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g7.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g7.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0) - self_.g8 * vec3<f32>(other.g1.x), vec2<f32>(self_.g6.x) * vec2<f32>(-other.g0.x, 0.0) + vec2<f32>(self_.g6.y) * vec2<f32>(-other.g0.y, 0.0) + vec2<f32>(self_.g6.z) * vec2<f32>(-other.g0.z, 0.0) + vec2<f32>(self_.g6.w) * other.g1 * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g8.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g8.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g8.z) * vec2<f32>(0.0, other.g0.z));
}

fn multi_vector_scalar_wedge(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec3<f32>(other.g0), self_.g2 * vec2<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec3<f32>(other.g0), self_.g5 * vec4<f32>(other.g0), self_.g6 * vec4<f32>(other.g0), self_.g7 * vec3<f32>(other.g0), self_.g8 * vec3<f32>(other.g0), self_.g9 * vec3<f32>(other.g0), self_.g10 * vec2<f32>(other.g0));
}

fn multi_vector_sphere_wedge(self_: MultiVector, other: Sphere) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec2<f32>(self_.g0.x) * other.g1);
}

fn multi_vector_translator_wedge(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, -other.g0.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g1.x) * vec2<f32>(0.0, -other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, -other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, -other.g0.z));
}

fn origin_circle_wedge(self_: Origin, other: Circle) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g2, vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0));
}

fn origin_dipole_wedge(self_: Origin, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z), vec3<f32>(0.0));
}

fn origin_flat_point_wedge(self_: Origin, other: FlatPoint) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn origin_flector_wedge(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w));
}

fn origin_horizon_wedge(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_infinity_wedge(self_: Origin, other: Infinity) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn origin_line_wedge(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_line_at_infinity_wedge(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_wedge(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.x);
}

fn origin_motor_wedge(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_multi_vector_wedge(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g10.y), vec3<f32>(0.0), vec2<f32>(self_.g0) * vec2<f32>(other.g0.x, 0.0), vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y), vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g8, vec2<f32>(self_.g0) * vec2<f32>(other.g6.w, 0.0));
}

fn origin_plane_wedge(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn origin_point_at_infinity_wedge(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_round_point_wedge(self_: Origin, other: RoundPoint) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y));
}

fn origin_scalar_wedge(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_sphere_wedge(self_: Origin, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.y);
}

fn origin_translator_wedge(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_magnitude_wedge(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_multi_vector_wedge(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x));
}

fn plane_origin_wedge(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn plane_round_point_wedge(self_: Plane, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g1.x);
}

fn plane_scalar_wedge(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_at_origin_magnitude_wedge(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn plane_at_origin_multi_vector_wedge(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec2<f32>(0.0));
}

fn plane_at_origin_round_point_wedge(self_: PlaneAtOrigin, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_scalar_wedge(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_circle_wedge(self_: PointAtInfinity, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_dipole_wedge(self_: PointAtInfinity, other: Dipole) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z));
}

fn point_at_infinity_magnitude_wedge(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn point_at_infinity_multi_vector_wedge(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g6.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g6.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g6.z), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g2.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g3.z, -other.g3.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g3.z, 0.0, other.g3.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, -other.g3.x, 0.0), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z));
}

fn point_at_infinity_origin_wedge(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_round_point_wedge(self_: PointAtInfinity, other: RoundPoint) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g1.x), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn point_at_infinity_scalar_wedge(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_origin_circle_wedge(self_: PointAtOrigin, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn point_at_origin_dipole_wedge(self_: PointAtOrigin, other: Dipole) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn point_at_origin_magnitude_wedge(self_: PointAtOrigin, other: Magnitude) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0.x);
}

fn point_at_origin_multi_vector_wedge(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, -other.g6.w), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g1, vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g4, vec2<f32>(0.0));
}

fn point_at_origin_round_point_wedge(self_: PointAtOrigin, other: RoundPoint) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn point_at_origin_scalar_wedge(self_: PointAtOrigin, other: Scalar) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn rotor_dipole_wedge(self_: Rotor, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_magnitude_wedge(self_: Rotor, other: Magnitude) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0.x));
}

fn rotor_multi_vector_wedge(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0), vec2<f32>(0.0));
}

fn rotor_round_point_wedge(self_: Rotor, other: RoundPoint) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn rotor_scalar_wedge(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn round_point_circle_wedge(self_: RoundPoint, other: Circle) -> Sphere {
    return Sphere(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, -other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g1.z, 0.0, other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, -other.g1.x, 0.0) + vec3<f32>(self_.g1.x) * other.g2 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, -other.g2.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, -other.g2.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, -other.g2.z) + self_.g1 * vec2<f32>(other.g0.w));
}

fn round_point_dipole_wedge(self_: RoundPoint, other: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g2.x, other.g2.y, other.g2.z) + vec3<f32>(self_.g1.y) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g2.z, other.g2.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, 0.0, -other.g2.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g2.y, other.g2.x, 0.0) + vec3<f32>(self_.g1.y) * other.g1);
}

fn round_point_flat_point_wedge(self_: RoundPoint, other: FlatPoint) -> Line {
    return Line(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn round_point_flector_wedge(self_: RoundPoint, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g0.w, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g0.w, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g0.w, other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn round_point_horizon_wedge(self_: RoundPoint, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0);
}

fn round_point_infinity_wedge(self_: RoundPoint, other: Infinity) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn round_point_line_wedge(self_: RoundPoint, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn round_point_line_at_infinity_wedge(self_: RoundPoint, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn round_point_line_at_origin_wedge(self_: RoundPoint, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn round_point_magnitude_wedge(self_: RoundPoint, other: Magnitude) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn round_point_motor_wedge(self_: RoundPoint, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, -other.g0.y, -other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g0.z, 0.0, other.g0.x, -other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, -other.g0.x, 0.0, -other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn round_point_multi_vector_wedge(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g9.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g9.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g9.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g10.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g10.x), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g2.x) + vec3<f32>(self_.g1.x) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g1.z, other.g1.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, -other.g1.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g1.y, other.g1.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g2.y, other.g2.y, other.g2.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g2.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g3.z, -other.g3.y, -other.g4.x) + vec4<f32>(self_.g0.y) * vec4<f32>(-other.g3.z, 0.0, other.g3.x, -other.g4.y) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, -other.g3.x, 0.0, -other.g4.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g5.w) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g5.x, other.g5.y, other.g5.z) + vec3<f32>(self_.g1.y) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g5.z, other.g5.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g5.z, 0.0, -other.g5.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g5.y, other.g5.x, 0.0) + vec3<f32>(self_.g1.y) * other.g4, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g7.z, -other.g7.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g7.z, 0.0, other.g7.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g7.y, -other.g7.x, 0.0) + vec3<f32>(self_.g1.x) * other.g8 - vec3<f32>(self_.g1.y) * vec3<f32>(other.g6.x, other.g6.y, other.g6.z), vec2<f32>(self_.g0.x) * vec2<f32>(other.g6.x, -other.g8.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g6.y, -other.g8.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g6.z, -other.g8.z) + self_.g1 * vec2<f32>(other.g6.w));
}

fn round_point_origin_wedge(self_: RoundPoint, other: Origin) -> Dipole {
    return Dipole(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0));
}

fn round_point_plane_wedge(self_: RoundPoint, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g0.w);
}

fn round_point_plane_at_origin_wedge(self_: RoundPoint, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn round_point_point_at_infinity_wedge(self_: RoundPoint, other: PointAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0));
}

fn round_point_point_at_origin_wedge(self_: RoundPoint, other: PointAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn round_point_rotor_wedge(self_: RoundPoint, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, -other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(-other.g0.z, 0.0, other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, -other.g0.x, 0.0));
}

fn round_point_round_point_wedge(self_: RoundPoint, other: RoundPoint) -> Dipole {
    return Dipole(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.x) + vec3<f32>(self_.g1.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, -other.g0.z, other.g0.y) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, -other.g0.x) + vec3<f32>(self_.g0.z) * vec3<f32>(-other.g0.y, other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g1.y, other.g1.y, other.g1.y, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) - vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.x));
}

fn round_point_scalar_wedge(self_: RoundPoint, other: Scalar) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn round_point_sphere_wedge(self_: RoundPoint, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn round_point_translator_wedge(self_: RoundPoint, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn scalar_anti_scalar_wedge(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_circle_wedge(self_: Scalar, other: Circle) -> Circle {
    return Circle(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2);
}

fn scalar_dipole_wedge(self_: Scalar, other: Dipole) -> Dipole {
    return Dipole(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec4<f32>(self_.g0) * other.g2);
}

fn scalar_flat_point_wedge(self_: Scalar, other: FlatPoint) -> FlatPoint {
    return FlatPoint(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_flector_wedge(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_wedge(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_infinity_wedge(self_: Scalar, other: Infinity) -> Infinity {
    return Infinity(self_.g0 * other.g0);
}

fn scalar_line_wedge(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_wedge(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_wedge(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_wedge(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_wedge(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_wedge(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1, vec2<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec3<f32>(self_.g0) * other.g4, vec4<f32>(self_.g0) * other.g5, vec4<f32>(self_.g0) * other.g6, vec3<f32>(self_.g0) * other.g7, vec3<f32>(self_.g0) * other.g8, vec3<f32>(self_.g0) * other.g9, vec2<f32>(self_.g0) * other.g10);
}

fn scalar_origin_wedge(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_wedge(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_wedge(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_wedge(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_origin_wedge(self_: Scalar, other: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0 * other.g0);
}

fn scalar_rotor_wedge(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_round_point_wedge(self_: Scalar, other: RoundPoint) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_scalar_wedge(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_sphere_wedge(self_: Scalar, other: Sphere) -> Sphere {
    return Sphere(vec3<f32>(self_.g0) * other.g0, vec2<f32>(self_.g0) * other.g1);
}

fn scalar_translator_wedge(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn sphere_infinity_wedge(self_: Sphere, other: Infinity) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0);
}

fn sphere_magnitude_wedge(self_: Sphere, other: Magnitude) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_multi_vector_wedge(self_: Sphere, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g2.y) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g2.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec2<f32>(other.g0.x));
}

fn sphere_origin_wedge(self_: Sphere, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g1.y * other.g0);
}

fn sphere_round_point_wedge(self_: Sphere, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn sphere_scalar_wedge(self_: Sphere, other: Scalar) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec2<f32>(other.g0));
}

fn translator_dipole_wedge(self_: Translator, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_magnitude_wedge(self_: Translator, other: Magnitude) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0.x));
}

fn translator_multi_vector_wedge(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, -other.g3.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, -other.g3.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, -other.g3.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g2.x), vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z));
}

fn translator_origin_wedge(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_round_point_wedge(self_: Translator, other: RoundPoint) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(-other.g1.x, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, -other.g1.x, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, -other.g1.x, other.g0.z));
}

fn translator_scalar_wedge(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn anti_scalar_anti_scalar_anti_dot(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_magnitude_anti_dot(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.y);
}

fn anti_scalar_motor_anti_dot(self_: AntiScalar, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn anti_scalar_multi_vector_anti_dot(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.y);
}

fn anti_scalar_rotor_anti_dot(self_: AntiScalar, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn anti_scalar_translator_anti_dot(self_: AntiScalar, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn circle_circle_anti_dot(self_: Circle, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z + self_.g0.w * other.g0.w - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn circle_line_anti_dot(self_: Circle, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn circle_line_at_infinity_anti_dot(self_: Circle, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn circle_line_at_origin_anti_dot(self_: Circle, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn circle_motor_anti_dot(self_: Circle, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn circle_multi_vector_anti_dot(self_: Circle, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g8.x - self_.g0.y * other.g8.y - self_.g0.z * other.g8.z + self_.g0.w * other.g6.w - self_.g1.x * other.g7.x - self_.g1.y * other.g7.y - self_.g1.z * other.g7.z - self_.g2.x * other.g6.x - self_.g2.y * other.g6.y - self_.g2.z * other.g6.z);
}

fn circle_rotor_anti_dot(self_: Circle, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn circle_translator_anti_dot(self_: Circle, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn dipole_dipole_anti_dot(self_: Dipole, other: Dipole) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g2.x + self_.g0.y * other.g2.y + self_.g0.z * other.g2.z + self_.g1.x * other.g1.x + self_.g1.y * other.g1.y + self_.g1.z * other.g1.z + self_.g2.x * other.g0.x + self_.g2.y * other.g0.y + self_.g2.z * other.g0.z - self_.g2.w * other.g2.w);
}

fn dipole_flat_point_anti_dot(self_: Dipole, other: FlatPoint) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g2.w * other.g0.w);
}

fn dipole_flector_anti_dot(self_: Dipole, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g2.w * other.g0.w);
}

fn dipole_multi_vector_anti_dot(self_: Dipole, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g5.x + self_.g0.y * other.g5.y + self_.g0.z * other.g5.z + self_.g1.x * other.g4.x + self_.g1.y * other.g4.y + self_.g1.z * other.g4.z + self_.g2.x * other.g3.x + self_.g2.y * other.g3.y + self_.g2.z * other.g3.z - self_.g2.w * other.g5.w);
}

fn dipole_point_at_infinity_anti_dot(self_: Dipole, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn dipole_point_at_origin_anti_dot(self_: Dipole, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g2.w * other.g0);
}

fn flat_point_dipole_anti_dot(self_: FlatPoint, other: Dipole) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g2.w);
}

fn flat_point_flat_point_anti_dot(self_: FlatPoint, other: FlatPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w);
}

fn flat_point_flector_anti_dot(self_: FlatPoint, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w);
}

fn flat_point_multi_vector_anti_dot(self_: FlatPoint, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g3.x + self_.g0.y * other.g3.y + self_.g0.z * other.g3.z - self_.g0.w * other.g5.w);
}

fn flat_point_point_at_origin_anti_dot(self_: FlatPoint, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn flector_dipole_anti_dot(self_: Flector, other: Dipole) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g2.w);
}

fn flector_flat_point_anti_dot(self_: Flector, other: FlatPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w);
}

fn flector_flector_anti_dot(self_: Flector, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w + self_.g1.x * other.g1.x + self_.g1.y * other.g1.y + self_.g1.z * other.g1.z);
}

fn flector_multi_vector_anti_dot(self_: Flector, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g3.x + self_.g0.y * other.g3.y + self_.g0.z * other.g3.z - self_.g0.w * other.g5.w + self_.g1.x * other.g9.x + self_.g1.y * other.g9.y + self_.g1.z * other.g9.z - self_.g1.w * other.g10.x);
}

fn flector_plane_anti_dot(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn flector_plane_at_origin_anti_dot(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn flector_point_at_origin_anti_dot(self_: Flector, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn flector_sphere_anti_dot(self_: Flector, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z - self_.g1.w * other.g1.x);
}

fn horizon_multi_vector_anti_dot(self_: Horizon, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g10.x);
}

fn horizon_sphere_anti_dot(self_: Horizon, other: Sphere) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g1.x);
}

fn infinity_multi_vector_anti_dot(self_: Infinity, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g2.x);
}

fn infinity_origin_anti_dot(self_: Infinity, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn infinity_round_point_anti_dot(self_: Infinity, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.x);
}

fn line_circle_anti_dot(self_: Line, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_anti_dot(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_anti_dot(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_motor_anti_dot(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_multi_vector_anti_dot(self_: Line, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g7.x - self_.g0.y * other.g7.y - self_.g0.z * other.g7.z - self_.g1.x * other.g6.x - self_.g1.y * other.g6.y - self_.g1.z * other.g6.z);
}

fn line_rotor_anti_dot(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_circle_anti_dot(self_: LineAtInfinity, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_multi_vector_anti_dot(self_: LineAtInfinity, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g6.x - self_.g0.y * other.g6.y - self_.g0.z * other.g6.z);
}

fn line_at_origin_circle_anti_dot(self_: LineAtOrigin, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_anti_dot(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_line_at_origin_anti_dot(self_: LineAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_motor_anti_dot(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_multi_vector_anti_dot(self_: LineAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g7.x - self_.g0.y * other.g7.y - self_.g0.z * other.g7.z);
}

fn line_at_origin_rotor_anti_dot(self_: LineAtOrigin, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn magnitude_anti_scalar_anti_dot(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0);
}

fn magnitude_magnitude_anti_dot(self_: Magnitude, other: Magnitude) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x + self_.g0.y * other.g0.y);
}

fn magnitude_motor_anti_dot(self_: Magnitude, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn magnitude_multi_vector_anti_dot(self_: Magnitude, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x + self_.g0.y * other.g0.y);
}

fn magnitude_rotor_anti_dot(self_: Magnitude, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn magnitude_scalar_anti_dot(self_: Magnitude, other: Scalar) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0);
}

fn magnitude_translator_anti_dot(self_: Magnitude, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn motor_anti_scalar_anti_dot(self_: Motor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn motor_circle_anti_dot(self_: Motor, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_line_anti_dot(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn motor_line_at_origin_anti_dot(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn motor_magnitude_anti_dot(self_: Motor, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn motor_motor_anti_dot(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn motor_multi_vector_anti_dot(self_: Motor, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g7.x - self_.g0.y * other.g7.y - self_.g0.z * other.g7.z + self_.g0.w * other.g0.y - self_.g1.x * other.g6.x - self_.g1.y * other.g6.y - self_.g1.z * other.g6.z);
}

fn motor_rotor_anti_dot(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn motor_translator_anti_dot(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn multi_vector_anti_scalar_anti_dot(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0);
}

fn multi_vector_circle_anti_dot(self_: MultiVector, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g6.x * other.g2.x - self_.g6.y * other.g2.y - self_.g6.z * other.g2.z + self_.g6.w * other.g0.w - self_.g7.x * other.g1.x - self_.g7.y * other.g1.y - self_.g7.z * other.g1.z - self_.g8.x * other.g0.x - self_.g8.y * other.g0.y - self_.g8.z * other.g0.z);
}

fn multi_vector_dipole_anti_dot(self_: MultiVector, other: Dipole) -> AntiScalar {
    return AntiScalar(self_.g3.x * other.g2.x + self_.g3.y * other.g2.y + self_.g3.z * other.g2.z + self_.g4.x * other.g1.x + self_.g4.y * other.g1.y + self_.g4.z * other.g1.z + self_.g5.x * other.g0.x + self_.g5.y * other.g0.y + self_.g5.z * other.g0.z - self_.g5.w * other.g2.w);
}

fn multi_vector_flat_point_anti_dot(self_: MultiVector, other: FlatPoint) -> AntiScalar {
    return AntiScalar(self_.g3.x * other.g0.x + self_.g3.y * other.g0.y + self_.g3.z * other.g0.z - self_.g5.w * other.g0.w);
}

fn multi_vector_flector_anti_dot(self_: MultiVector, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g3.x * other.g0.x + self_.g3.y * other.g0.y + self_.g3.z * other.g0.z - self_.g5.w * other.g0.w + self_.g9.x * other.g1.x + self_.g9.y * other.g1.y + self_.g9.z * other.g1.z - self_.g10.x * other.g1.w);
}

fn multi_vector_horizon_anti_dot(self_: MultiVector, other: Horizon) -> AntiScalar {
    return AntiScalar(0.0 - self_.g10.x * other.g0);
}

fn multi_vector_infinity_anti_dot(self_: MultiVector, other: Infinity) -> AntiScalar {
    return AntiScalar(self_.g2.x * other.g0);
}

fn multi_vector_line_anti_dot(self_: MultiVector, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g6.x * other.g1.x - self_.g6.y * other.g1.y - self_.g6.z * other.g1.z - self_.g7.x * other.g0.x - self_.g7.y * other.g0.y - self_.g7.z * other.g0.z);
}

fn multi_vector_line_at_infinity_anti_dot(self_: MultiVector, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g6.x * other.g0.x - self_.g6.y * other.g0.y - self_.g6.z * other.g0.z);
}

fn multi_vector_line_at_origin_anti_dot(self_: MultiVector, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g7.x * other.g0.x - self_.g7.y * other.g0.y - self_.g7.z * other.g0.z);
}

fn multi_vector_magnitude_anti_dot(self_: MultiVector, other: Magnitude) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x + self_.g0.y * other.g0.y);
}

fn multi_vector_motor_anti_dot(self_: MultiVector, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w - self_.g6.x * other.g1.x - self_.g6.y * other.g1.y - self_.g6.z * other.g1.z - self_.g7.x * other.g0.x - self_.g7.y * other.g0.y - self_.g7.z * other.g0.z);
}

fn multi_vector_multi_vector_anti_dot(self_: MultiVector, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x + self_.g0.y * other.g0.y - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z + self_.g2.x * other.g2.y + self_.g2.y * other.g2.x + self_.g3.x * other.g5.x + self_.g3.y * other.g5.y + self_.g3.z * other.g5.z + self_.g4.x * other.g4.x + self_.g4.y * other.g4.y + self_.g4.z * other.g4.z + self_.g5.x * other.g3.x + self_.g5.y * other.g3.y + self_.g5.z * other.g3.z - self_.g5.w * other.g5.w - self_.g6.x * other.g8.x - self_.g6.y * other.g8.y - self_.g6.z * other.g8.z + self_.g6.w * other.g6.w - self_.g7.x * other.g7.x - self_.g7.y * other.g7.y - self_.g7.z * other.g7.z - self_.g8.x * other.g6.x - self_.g8.y * other.g6.y - self_.g8.z * other.g6.z + self_.g9.x * other.g9.x + self_.g9.y * other.g9.y + self_.g9.z * other.g9.z - self_.g10.x * other.g10.y - self_.g10.y * other.g10.x);
}

fn multi_vector_origin_anti_dot(self_: MultiVector, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g2.y * other.g0);
}

fn multi_vector_plane_anti_dot(self_: MultiVector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g9.x * other.g0.x + self_.g9.y * other.g0.y + self_.g9.z * other.g0.z - self_.g10.x * other.g0.w);
}

fn multi_vector_plane_at_origin_anti_dot(self_: MultiVector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g9.x * other.g0.x + self_.g9.y * other.g0.y + self_.g9.z * other.g0.z);
}

fn multi_vector_point_at_infinity_anti_dot(self_: MultiVector, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(self_.g3.x * other.g0.x + self_.g3.y * other.g0.y + self_.g3.z * other.g0.z);
}

fn multi_vector_point_at_origin_anti_dot(self_: MultiVector, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g5.w * other.g0);
}

fn multi_vector_rotor_anti_dot(self_: MultiVector, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w - self_.g7.x * other.g0.x - self_.g7.y * other.g0.y - self_.g7.z * other.g0.z);
}

fn multi_vector_round_point_anti_dot(self_: MultiVector, other: RoundPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z + self_.g2.x * other.g1.y + self_.g2.y * other.g1.x);
}

fn multi_vector_scalar_anti_dot(self_: MultiVector, other: Scalar) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0);
}

fn multi_vector_sphere_anti_dot(self_: MultiVector, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g9.x * other.g0.x + self_.g9.y * other.g0.y + self_.g9.z * other.g0.z - self_.g10.x * other.g1.y - self_.g10.y * other.g1.x);
}

fn multi_vector_translator_anti_dot(self_: MultiVector, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w - self_.g6.x * other.g0.x - self_.g6.y * other.g0.y - self_.g6.z * other.g0.z);
}

fn origin_infinity_anti_dot(self_: Origin, other: Infinity) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_multi_vector_anti_dot(self_: Origin, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g2.y);
}

fn origin_round_point_anti_dot(self_: Origin, other: RoundPoint) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g1.y);
}

fn plane_flector_anti_dot(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn plane_multi_vector_anti_dot(self_: Plane, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g9.x + self_.g0.y * other.g9.y + self_.g0.z * other.g9.z - self_.g0.w * other.g10.x);
}

fn plane_plane_anti_dot(self_: Plane, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_plane_at_origin_anti_dot(self_: Plane, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_sphere_anti_dot(self_: Plane, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g1.x);
}

fn plane_at_origin_flector_anti_dot(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn plane_at_origin_multi_vector_anti_dot(self_: PlaneAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g9.x + self_.g0.y * other.g9.y + self_.g0.z * other.g9.z);
}

fn plane_at_origin_plane_anti_dot(self_: PlaneAtOrigin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_plane_at_origin_anti_dot(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_sphere_anti_dot(self_: PlaneAtOrigin, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_dipole_anti_dot(self_: PointAtInfinity, other: Dipole) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_multi_vector_anti_dot(self_: PointAtInfinity, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g3.x + self_.g0.y * other.g3.y + self_.g0.z * other.g3.z);
}

fn point_at_origin_dipole_anti_dot(self_: PointAtOrigin, other: Dipole) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g2.w);
}

fn point_at_origin_flat_point_anti_dot(self_: PointAtOrigin, other: FlatPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn point_at_origin_flector_anti_dot(self_: PointAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn point_at_origin_multi_vector_anti_dot(self_: PointAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g5.w);
}

fn point_at_origin_point_at_origin_anti_dot(self_: PointAtOrigin, other: PointAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn rotor_anti_scalar_anti_dot(self_: Rotor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn rotor_circle_anti_dot(self_: Rotor, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_line_anti_dot(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_line_at_origin_anti_dot(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_magnitude_anti_dot(self_: Rotor, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn rotor_motor_anti_dot(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn rotor_multi_vector_anti_dot(self_: Rotor, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g7.x - self_.g0.y * other.g7.y - self_.g0.z * other.g7.z + self_.g0.w * other.g0.y);
}

fn rotor_rotor_anti_dot(self_: Rotor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn rotor_translator_anti_dot(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn round_point_infinity_anti_dot(self_: RoundPoint, other: Infinity) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0);
}

fn round_point_multi_vector_anti_dot(self_: RoundPoint, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z + self_.g1.x * other.g2.y + self_.g1.y * other.g2.x);
}

fn round_point_origin_anti_dot(self_: RoundPoint, other: Origin) -> AntiScalar {
    return AntiScalar(self_.g1.y * other.g0);
}

fn round_point_round_point_anti_dot(self_: RoundPoint, other: RoundPoint) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn scalar_magnitude_anti_dot(self_: Scalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.x);
}

fn scalar_multi_vector_anti_dot(self_: Scalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.x);
}

fn scalar_scalar_anti_dot(self_: Scalar, other: Scalar) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn sphere_flector_anti_dot(self_: Sphere, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z - self_.g1.x * other.g1.w);
}

fn sphere_horizon_anti_dot(self_: Sphere, other: Horizon) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0);
}

fn sphere_multi_vector_anti_dot(self_: Sphere, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g9.x + self_.g0.y * other.g9.y + self_.g0.z * other.g9.z - self_.g1.x * other.g10.y - self_.g1.y * other.g10.x);
}

fn sphere_plane_anti_dot(self_: Sphere, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g1.x * other.g0.w);
}

fn sphere_plane_at_origin_anti_dot(self_: Sphere, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn sphere_sphere_anti_dot(self_: Sphere, other: Sphere) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g1.x * other.g1.y - self_.g1.y * other.g1.x);
}

fn translator_anti_scalar_anti_dot(self_: Translator, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn translator_circle_anti_dot(self_: Translator, other: Circle) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_magnitude_anti_dot(self_: Translator, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn translator_motor_anti_dot(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn translator_multi_vector_anti_dot(self_: Translator, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g6.x - self_.g0.y * other.g6.y - self_.g0.z * other.g6.z + self_.g0.w * other.g0.y);
}

fn translator_rotor_anti_dot(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn translator_translator_anti_dot(self_: Translator, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn anti_scalar_anti_scalar_dot(self_: AntiScalar, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_magnitude_dot(self_: AntiScalar, other: Magnitude) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.y);
}

fn anti_scalar_motor_dot(self_: AntiScalar, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn anti_scalar_multi_vector_dot(self_: AntiScalar, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.y);
}

fn anti_scalar_rotor_dot(self_: AntiScalar, other: Rotor) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn anti_scalar_translator_dot(self_: AntiScalar, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn circle_circle_dot(self_: Circle, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g2.x + self_.g0.y * other.g2.y + self_.g0.z * other.g2.z - self_.g0.w * other.g0.w + self_.g1.x * other.g1.x + self_.g1.y * other.g1.y + self_.g1.z * other.g1.z + self_.g2.x * other.g0.x + self_.g2.y * other.g0.y + self_.g2.z * other.g0.z);
}

fn circle_line_dot(self_: Circle, other: Line) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn circle_line_at_infinity_dot(self_: Circle, other: LineAtInfinity) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn circle_line_at_origin_dot(self_: Circle, other: LineAtOrigin) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn circle_motor_dot(self_: Circle, other: Motor) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn circle_multi_vector_dot(self_: Circle, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g8.x + self_.g0.y * other.g8.y + self_.g0.z * other.g8.z - self_.g0.w * other.g6.w + self_.g1.x * other.g7.x + self_.g1.y * other.g7.y + self_.g1.z * other.g7.z + self_.g2.x * other.g6.x + self_.g2.y * other.g6.y + self_.g2.z * other.g6.z);
}

fn circle_rotor_dot(self_: Circle, other: Rotor) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn circle_translator_dot(self_: Circle, other: Translator) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn dipole_dipole_dot(self_: Dipole, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z + self_.g2.w * other.g2.w);
}

fn dipole_flat_point_dot(self_: Dipole, other: FlatPoint) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g2.w * other.g0.w);
}

fn dipole_flector_dot(self_: Dipole, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g2.w * other.g0.w);
}

fn dipole_multi_vector_dot(self_: Dipole, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g5.x - self_.g0.y * other.g5.y - self_.g0.z * other.g5.z - self_.g1.x * other.g4.x - self_.g1.y * other.g4.y - self_.g1.z * other.g4.z - self_.g2.x * other.g3.x - self_.g2.y * other.g3.y - self_.g2.z * other.g3.z + self_.g2.w * other.g5.w);
}

fn dipole_point_at_infinity_dot(self_: Dipole, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn dipole_point_at_origin_dot(self_: Dipole, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g2.w * other.g0);
}

fn flat_point_dipole_dot(self_: FlatPoint, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g2.w);
}

fn flat_point_flat_point_dot(self_: FlatPoint, other: FlatPoint) -> Scalar {
    return Scalar(self_.g0.w * other.g0.w);
}

fn flat_point_flector_dot(self_: FlatPoint, other: Flector) -> Scalar {
    return Scalar(self_.g0.w * other.g0.w);
}

fn flat_point_multi_vector_dot(self_: FlatPoint, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g3.x - self_.g0.y * other.g3.y - self_.g0.z * other.g3.z + self_.g0.w * other.g5.w);
}

fn flat_point_point_at_origin_dot(self_: FlatPoint, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn flector_dipole_dot(self_: Flector, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g2.w);
}

fn flector_flat_point_dot(self_: Flector, other: FlatPoint) -> Scalar {
    return Scalar(self_.g0.w * other.g0.w);
}

fn flector_flector_dot(self_: Flector, other: Flector) -> Scalar {
    return Scalar(self_.g0.w * other.g0.w - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z);
}

fn flector_multi_vector_dot(self_: Flector, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g3.x - self_.g0.y * other.g3.y - self_.g0.z * other.g3.z + self_.g0.w * other.g5.w - self_.g1.x * other.g9.x - self_.g1.y * other.g9.y - self_.g1.z * other.g9.z + self_.g1.w * other.g10.x);
}

fn flector_plane_dot(self_: Flector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn flector_plane_at_origin_dot(self_: Flector, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn flector_point_at_origin_dot(self_: Flector, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn flector_sphere_dot(self_: Flector, other: Sphere) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z + self_.g1.w * other.g1.x);
}

fn horizon_multi_vector_dot(self_: Horizon, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g10.x);
}

fn horizon_sphere_dot(self_: Horizon, other: Sphere) -> Scalar {
    return Scalar(self_.g0 * other.g1.x);
}

fn infinity_multi_vector_dot(self_: Infinity, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g2.x);
}

fn infinity_origin_dot(self_: Infinity, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn infinity_round_point_dot(self_: Infinity, other: RoundPoint) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g1.x);
}

fn line_circle_dot(self_: Line, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn line_line_dot(self_: Line, other: Line) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_line_at_origin_dot(self_: Line, other: LineAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_motor_dot(self_: Line, other: Motor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_multi_vector_dot(self_: Line, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g7.x + self_.g0.y * other.g7.y + self_.g0.z * other.g7.z + self_.g1.x * other.g6.x + self_.g1.y * other.g6.y + self_.g1.z * other.g6.z);
}

fn line_rotor_dot(self_: Line, other: Rotor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_at_infinity_circle_dot(self_: LineAtInfinity, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_at_infinity_multi_vector_dot(self_: LineAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g6.x + self_.g0.y * other.g6.y + self_.g0.z * other.g6.z);
}

fn line_at_origin_circle_dot(self_: LineAtOrigin, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn line_at_origin_line_dot(self_: LineAtOrigin, other: Line) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_at_origin_line_at_origin_dot(self_: LineAtOrigin, other: LineAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_at_origin_motor_dot(self_: LineAtOrigin, other: Motor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn line_at_origin_multi_vector_dot(self_: LineAtOrigin, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g7.x + self_.g0.y * other.g7.y + self_.g0.z * other.g7.z);
}

fn line_at_origin_rotor_dot(self_: LineAtOrigin, other: Rotor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn magnitude_anti_scalar_dot(self_: Magnitude, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0);
}

fn magnitude_magnitude_dot(self_: Magnitude, other: Magnitude) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x - self_.g0.y * other.g0.y);
}

fn magnitude_motor_dot(self_: Magnitude, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0.w);
}

fn magnitude_multi_vector_dot(self_: Magnitude, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x - self_.g0.y * other.g0.y);
}

fn magnitude_rotor_dot(self_: Magnitude, other: Rotor) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0.w);
}

fn magnitude_scalar_dot(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.x * other.g0);
}

fn magnitude_translator_dot(self_: Magnitude, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0.w);
}

fn motor_anti_scalar_dot(self_: Motor, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn motor_circle_dot(self_: Motor, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn motor_line_dot(self_: Motor, other: Line) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn motor_line_at_origin_dot(self_: Motor, other: LineAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn motor_magnitude_dot(self_: Motor, other: Magnitude) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.y);
}

fn motor_motor_dot(self_: Motor, other: Motor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn motor_multi_vector_dot(self_: Motor, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g7.x + self_.g0.y * other.g7.y + self_.g0.z * other.g7.z - self_.g0.w * other.g0.y + self_.g1.x * other.g6.x + self_.g1.y * other.g6.y + self_.g1.z * other.g6.z);
}

fn motor_rotor_dot(self_: Motor, other: Rotor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn motor_translator_dot(self_: Motor, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.w);
}

fn multi_vector_anti_scalar_dot(self_: MultiVector, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0);
}

fn multi_vector_circle_dot(self_: MultiVector, other: Circle) -> Scalar {
    return Scalar(self_.g6.x * other.g2.x + self_.g6.y * other.g2.y + self_.g6.z * other.g2.z - self_.g6.w * other.g0.w + self_.g7.x * other.g1.x + self_.g7.y * other.g1.y + self_.g7.z * other.g1.z + self_.g8.x * other.g0.x + self_.g8.y * other.g0.y + self_.g8.z * other.g0.z);
}

fn multi_vector_dipole_dot(self_: MultiVector, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g2.x - self_.g3.y * other.g2.y - self_.g3.z * other.g2.z - self_.g4.x * other.g1.x - self_.g4.y * other.g1.y - self_.g4.z * other.g1.z - self_.g5.x * other.g0.x - self_.g5.y * other.g0.y - self_.g5.z * other.g0.z + self_.g5.w * other.g2.w);
}

fn multi_vector_flat_point_dot(self_: MultiVector, other: FlatPoint) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g0.x - self_.g3.y * other.g0.y - self_.g3.z * other.g0.z + self_.g5.w * other.g0.w);
}

fn multi_vector_flector_dot(self_: MultiVector, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g0.x - self_.g3.y * other.g0.y - self_.g3.z * other.g0.z + self_.g5.w * other.g0.w - self_.g9.x * other.g1.x - self_.g9.y * other.g1.y - self_.g9.z * other.g1.z + self_.g10.x * other.g1.w);
}

fn multi_vector_horizon_dot(self_: MultiVector, other: Horizon) -> Scalar {
    return Scalar(self_.g10.x * other.g0);
}

fn multi_vector_infinity_dot(self_: MultiVector, other: Infinity) -> Scalar {
    return Scalar(0.0 - self_.g2.x * other.g0);
}

fn multi_vector_line_dot(self_: MultiVector, other: Line) -> Scalar {
    return Scalar(self_.g6.x * other.g1.x + self_.g6.y * other.g1.y + self_.g6.z * other.g1.z + self_.g7.x * other.g0.x + self_.g7.y * other.g0.y + self_.g7.z * other.g0.z);
}

fn multi_vector_line_at_infinity_dot(self_: MultiVector, other: LineAtInfinity) -> Scalar {
    return Scalar(self_.g6.x * other.g0.x + self_.g6.y * other.g0.y + self_.g6.z * other.g0.z);
}

fn multi_vector_line_at_origin_dot(self_: MultiVector, other: LineAtOrigin) -> Scalar {
    return Scalar(self_.g7.x * other.g0.x + self_.g7.y * other.g0.y + self_.g7.z * other.g0.z);
}

fn multi_vector_magnitude_dot(self_: MultiVector, other: Magnitude) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x - self_.g0.y * other.g0.y);
}

fn multi_vector_motor_dot(self_: MultiVector, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0.w + self_.g6.x * other.g1.x + self_.g6.y * other.g1.y + self_.g6.z * other.g1.z + self_.g7.x * other.g0.x + self_.g7.y * other.g0.y + self_.g7.z * other.g0.z);
}

fn multi_vector_multi_vector_dot(self_: MultiVector, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x - self_.g0.y * other.g0.y + self_.g1.x * other.g1.x + self_.g1.y * other.g1.y + self_.g1.z * other.g1.z - self_.g2.x * other.g2.y - self_.g2.y * other.g2.x - self_.g3.x * other.g5.x - self_.g3.y * other.g5.y - self_.g3.z * other.g5.z - self_.g4.x * other.g4.x - self_.g4.y * other.g4.y - self_.g4.z * other.g4.z - self_.g5.x * other.g3.x - self_.g5.y * other.g3.y - self_.g5.z * other.g3.z + self_.g5.w * other.g5.w + self_.g6.x * other.g8.x + self_.g6.y * other.g8.y + self_.g6.z * other.g8.z - self_.g6.w * other.g6.w + self_.g7.x * other.g7.x + self_.g7.y * other.g7.y + self_.g7.z * other.g7.z + self_.g8.x * other.g6.x + self_.g8.y * other.g6.y + self_.g8.z * other.g6.z - self_.g9.x * other.g9.x - self_.g9.y * other.g9.y - self_.g9.z * other.g9.z + self_.g10.x * other.g10.y + self_.g10.y * other.g10.x);
}

fn multi_vector_origin_dot(self_: MultiVector, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g2.y * other.g0);
}

fn multi_vector_plane_dot(self_: MultiVector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g9.x * other.g0.x - self_.g9.y * other.g0.y - self_.g9.z * other.g0.z + self_.g10.x * other.g0.w);
}

fn multi_vector_plane_at_origin_dot(self_: MultiVector, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g9.x * other.g0.x - self_.g9.y * other.g0.y - self_.g9.z * other.g0.z);
}

fn multi_vector_point_at_infinity_dot(self_: MultiVector, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g0.x - self_.g3.y * other.g0.y - self_.g3.z * other.g0.z);
}

fn multi_vector_point_at_origin_dot(self_: MultiVector, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g5.w * other.g0);
}

fn multi_vector_rotor_dot(self_: MultiVector, other: Rotor) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0.w + self_.g7.x * other.g0.x + self_.g7.y * other.g0.y + self_.g7.z * other.g0.z);
}

fn multi_vector_round_point_dot(self_: MultiVector, other: RoundPoint) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z - self_.g2.x * other.g1.y - self_.g2.y * other.g1.x);
}

fn multi_vector_scalar_dot(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0.x * other.g0);
}

fn multi_vector_sphere_dot(self_: MultiVector, other: Sphere) -> Scalar {
    return Scalar(0.0 - self_.g9.x * other.g0.x - self_.g9.y * other.g0.y - self_.g9.z * other.g0.z + self_.g10.x * other.g1.y + self_.g10.y * other.g1.x);
}

fn multi_vector_translator_dot(self_: MultiVector, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.y * other.g0.w + self_.g6.x * other.g0.x + self_.g6.y * other.g0.y + self_.g6.z * other.g0.z);
}

fn origin_infinity_dot(self_: Origin, other: Infinity) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn origin_multi_vector_dot(self_: Origin, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g2.y);
}

fn origin_round_point_dot(self_: Origin, other: RoundPoint) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g1.y);
}

fn plane_flector_dot(self_: Plane, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn plane_multi_vector_dot(self_: Plane, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g9.x - self_.g0.y * other.g9.y - self_.g0.z * other.g9.z + self_.g0.w * other.g10.x);
}

fn plane_plane_dot(self_: Plane, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_plane_at_origin_dot(self_: Plane, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_sphere_dot(self_: Plane, other: Sphere) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g1.x);
}

fn plane_at_origin_flector_dot(self_: PlaneAtOrigin, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn plane_at_origin_multi_vector_dot(self_: PlaneAtOrigin, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g9.x - self_.g0.y * other.g9.y - self_.g0.z * other.g9.z);
}

fn plane_at_origin_plane_dot(self_: PlaneAtOrigin, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_plane_at_origin_dot(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_sphere_dot(self_: PlaneAtOrigin, other: Sphere) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_dipole_dot(self_: PointAtInfinity, other: Dipole) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_multi_vector_dot(self_: PointAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g3.x - self_.g0.y * other.g3.y - self_.g0.z * other.g3.z);
}

fn point_at_origin_dipole_dot(self_: PointAtOrigin, other: Dipole) -> Scalar {
    return Scalar(self_.g0 * other.g2.w);
}

fn point_at_origin_flat_point_dot(self_: PointAtOrigin, other: FlatPoint) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn point_at_origin_flector_dot(self_: PointAtOrigin, other: Flector) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn point_at_origin_multi_vector_dot(self_: PointAtOrigin, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g5.w);
}

fn point_at_origin_point_at_origin_dot(self_: PointAtOrigin, other: PointAtOrigin) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn rotor_anti_scalar_dot(self_: Rotor, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn rotor_circle_dot(self_: Rotor, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn rotor_line_dot(self_: Rotor, other: Line) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn rotor_line_at_origin_dot(self_: Rotor, other: LineAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn rotor_magnitude_dot(self_: Rotor, other: Magnitude) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.y);
}

fn rotor_motor_dot(self_: Rotor, other: Motor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn rotor_multi_vector_dot(self_: Rotor, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g7.x + self_.g0.y * other.g7.y + self_.g0.z * other.g7.z - self_.g0.w * other.g0.y);
}

fn rotor_rotor_dot(self_: Rotor, other: Rotor) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn rotor_translator_dot(self_: Rotor, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.w);
}

fn round_point_infinity_dot(self_: RoundPoint, other: Infinity) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0);
}

fn round_point_multi_vector_dot(self_: RoundPoint, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z - self_.g1.x * other.g2.y - self_.g1.y * other.g2.x);
}

fn round_point_origin_dot(self_: RoundPoint, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g1.y * other.g0);
}

fn round_point_round_point_dot(self_: RoundPoint, other: RoundPoint) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g1.x * other.g1.y - self_.g1.y * other.g1.x);
}

fn scalar_magnitude_dot(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.x);
}

fn scalar_multi_vector_dot(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g0.x);
}

fn scalar_scalar_dot(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn sphere_flector_dot(self_: Sphere, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z + self_.g1.x * other.g1.w);
}

fn sphere_horizon_dot(self_: Sphere, other: Horizon) -> Scalar {
    return Scalar(self_.g1.x * other.g0);
}

fn sphere_multi_vector_dot(self_: Sphere, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g9.x - self_.g0.y * other.g9.y - self_.g0.z * other.g9.z + self_.g1.x * other.g10.y + self_.g1.y * other.g10.x);
}

fn sphere_plane_dot(self_: Sphere, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g1.x * other.g0.w);
}

fn sphere_plane_at_origin_dot(self_: Sphere, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn sphere_sphere_dot(self_: Sphere, other: Sphere) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g1.x * other.g1.y + self_.g1.y * other.g1.x);
}

fn translator_anti_scalar_dot(self_: Translator, other: AntiScalar) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn translator_circle_dot(self_: Translator, other: Circle) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn translator_magnitude_dot(self_: Translator, other: Magnitude) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.y);
}

fn translator_motor_dot(self_: Translator, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.w);
}

fn translator_multi_vector_dot(self_: Translator, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g6.x + self_.g0.y * other.g6.y + self_.g0.z * other.g6.z - self_.g0.w * other.g0.y);
}

fn translator_rotor_dot(self_: Translator, other: Rotor) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.w);
}

fn translator_translator_dot(self_: Translator, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.w);
}

fn circle_bulk(self_: Circle) -> LineAtInfinity {
    return LineAtInfinity(self_.g2);
}

fn dipole_bulk(self_: Dipole) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z));
}

fn flat_point_bulk(self_: FlatPoint) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn flector_bulk(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(1.0, 1.0, 1.0, 0.0), self_.g1 * vec4<f32>(0.0, 0.0, 0.0, 1.0));
}

fn horizon_bulk(self_: Horizon) -> Horizon {
    return self_;
}

fn infinity_bulk(self_: Infinity) -> Infinity {
    return self_;
}

fn line_bulk(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(self_.g1);
}

fn line_at_infinity_bulk(self_: LineAtInfinity) -> LineAtInfinity {
    return self_;
}

fn motor_bulk(self_: Motor) -> LineAtInfinity {
    return LineAtInfinity(self_.g1);
}

fn multi_vector_bulk(self_: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), self_.g2 * vec2<f32>(0.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g5 * vec4<f32>(1.0, 1.0, 1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g8, vec3<f32>(0.0), self_.g10 * vec2<f32>(0.0, 1.0));
}

fn plane_bulk(self_: Plane) -> Horizon {
    return Horizon(self_.g0.w);
}

fn point_at_infinity_bulk(self_: PointAtInfinity) -> PointAtInfinity {
    return self_;
}

fn round_point_bulk(self_: RoundPoint) -> Infinity {
    return Infinity(self_.g1.y);
}

fn sphere_bulk(self_: Sphere) -> Horizon {
    return Horizon(self_.g1.y);
}

fn translator_bulk(self_: Translator) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn circle_round_bulk(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(0.0, 0.0, 0.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn dipole_round_bulk(self_: Dipole) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g1, vec4<f32>(0.0));
}

fn magnitude_round_bulk(self_: Magnitude) -> Scalar {
    return Scalar(self_.g0.x);
}

fn multi_vector_round_bulk(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(1.0, 0.0), self_.g1, vec2<f32>(0.0), vec3<f32>(0.0), self_.g4, vec4<f32>(0.0), self_.g6 * vec4<f32>(0.0, 0.0, 0.0, 1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_round_bulk(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0, vec2<f32>(0.0));
}

fn scalar_round_bulk(self_: Scalar) -> Scalar {
    return self_;
}

fn circle_round_weight(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn dipole_round_weight(self_: Dipole) -> Dipole {
    return Dipole(self_.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_round_weight(self_: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(0.0), self_.g2 * vec2<f32>(1.0, 0.0), self_.g3, vec3<f32>(0.0), vec4<f32>(0.0), self_.g6 * vec4<f32>(1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g10 * vec2<f32>(1.0, 0.0));
}

fn origin_round_weight(self_: Origin) -> Origin {
    return self_;
}

fn round_point_round_weight(self_: RoundPoint) -> Origin {
    return Origin(self_.g1.x);
}

fn sphere_round_weight(self_: Sphere) -> Sphere {
    return Sphere(vec3<f32>(0.0), self_.g1 * vec2<f32>(1.0, 0.0));
}

fn anti_scalar_weight(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn circle_weight(self_: Circle) -> LineAtOrigin {
    return LineAtOrigin(self_.g1);
}

fn dipole_weight(self_: Dipole) -> PointAtOrigin {
    return PointAtOrigin(self_.g2.w);
}

fn flat_point_weight(self_: FlatPoint) -> PointAtOrigin {
    return PointAtOrigin(self_.g0.w);
}

fn flector_weight(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(0.0, 0.0, 0.0, 1.0), self_.g1 * vec4<f32>(1.0, 1.0, 1.0, 0.0));
}

fn line_weight(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(self_.g0);
}

fn line_at_origin_weight(self_: LineAtOrigin) -> LineAtOrigin {
    return self_;
}

fn magnitude_weight(self_: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.y);
}

fn motor_weight(self_: Motor) -> Rotor {
    return Rotor(self_.g0);
}

fn multi_vector_weight(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(0.0, 1.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g5 * vec4<f32>(0.0, 0.0, 0.0, 1.0), vec4<f32>(0.0), self_.g7, vec3<f32>(0.0), self_.g9, vec2<f32>(0.0));
}

fn plane_weight(self_: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn plane_at_origin_weight(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return self_;
}

fn point_at_origin_weight(self_: PointAtOrigin) -> PointAtOrigin {
    return self_;
}

fn rotor_weight(self_: Rotor) -> Rotor {
    return self_;
}

fn sphere_weight(self_: Sphere) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0);
}

fn translator_weight(self_: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn anti_scalar_anti_dual(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0);
}

fn circle_anti_dual(self_: Circle) -> Dipole {
    return Dipole(vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), self_.g1 * vec3<f32>(-1.0), vec4<f32>(-self_.g2.x, -self_.g2.y, -self_.g2.z, self_.g0.w));
}

fn dipole_anti_dual(self_: Dipole) -> Circle {
    return Circle(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, -self_.g2.w), self_.g1, vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z));
}

fn flat_point_anti_dual(self_: FlatPoint) -> Circle {
    return Circle(vec4<f32>(0.0, 0.0, 0.0, -self_.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn flector_anti_dual(self_: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z), vec2<f32>(0.0, -self_.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, -self_.g0.w), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_anti_dual(self_: Horizon) -> Infinity {
    return Infinity(-self_.g0);
}

fn infinity_anti_dual(self_: Infinity) -> Horizon {
    return Horizon(self_.g0);
}

fn line_anti_dual(self_: Line) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(-1.0), vec4<f32>(-self_.g1.x, -self_.g1.y, -self_.g1.z, 0.0));
}

fn line_at_infinity_anti_dual(self_: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_anti_dual(self_: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(-1.0), vec4<f32>(0.0));
}

fn magnitude_anti_dual(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx * vec2<f32>(1.0, -1.0));
}

fn motor_anti_dual(self_: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(-self_.g1.x, -self_.g1.y, -self_.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_anti_dual(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(1.0, -1.0), self_.g9, self_.g10 * vec2<f32>(-1.0), vec3<f32>(-self_.g6.x, self_.g6.y, self_.g6.z), self_.g7 * vec3<f32>(-1.0), vec4<f32>(-self_.g8.x, -self_.g8.y, -self_.g8.z, self_.g6.w), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, -self_.g5.w), self_.g4, vec3<f32>(self_.g5.x, self_.g5.y, self_.g5.z), self_.g1 * vec3<f32>(-1.0), self_.g2);
}

fn origin_anti_dual(self_: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0, 0.0));
}

fn plane_anti_dual(self_: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), vec2<f32>(0.0, -self_.g0.w));
}

fn plane_at_origin_anti_dual(self_: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(self_.g0, vec2<f32>(0.0));
}

fn point_at_infinity_anti_dual(self_: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0);
}

fn point_at_origin_anti_dual(self_: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(0.0, 0.0, 0.0, -self_.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn rotor_anti_dual(self_: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_anti_dual(self_: RoundPoint) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(-1.0), self_.g1);
}

fn scalar_anti_dual(self_: Scalar) -> AntiScalar {
    return AntiScalar(-self_.g0);
}

fn sphere_anti_dual(self_: Sphere) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1 * vec2<f32>(-1.0));
}

fn translator_anti_dual(self_: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(-self_.g0.x, -self_.g0.y, -self_.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_anti_reversal(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(-self_.g0);
}

fn circle_anti_reversal(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g1 * vec3<f32>(1.0, -1.0, 1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn dipole_anti_reversal(self_: Dipole) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g2 * vec4<f32>(-1.0));
}

fn flat_point_anti_reversal(self_: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(-1.0));
}

fn flector_anti_reversal(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn horizon_anti_reversal(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0);
}

fn infinity_anti_reversal(self_: Infinity) -> Infinity {
    return Infinity(self_.g0);
}

fn line_anti_reversal(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_infinity_anti_reversal(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_origin_anti_reversal(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn magnitude_anti_reversal(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(1.0, -1.0));
}

fn motor_anti_reversal(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn multi_vector_anti_reversal(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(1.0, -1.0), self_.g1, self_.g2, self_.g3 * vec3<f32>(-1.0), self_.g4 * vec3<f32>(-1.0), self_.g5 * vec4<f32>(-1.0), self_.g6 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g7 * vec3<f32>(1.0, -1.0, 1.0), self_.g8 * vec3<f32>(-1.0, 1.0, -1.0), self_.g9 * vec3<f32>(-1.0, 1.0, -1.0), self_.g10 * vec2<f32>(1.0, -1.0));
}

fn origin_anti_reversal(self_: Origin) -> Origin {
    return Origin(self_.g0);
}

fn plane_anti_reversal(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn plane_at_origin_anti_reversal(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn point_at_infinity_anti_reversal(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_at_origin_anti_reversal(self_: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(-self_.g0);
}

fn rotor_anti_reversal(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn round_point_anti_reversal(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1);
}

fn scalar_anti_reversal(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn sphere_anti_reversal(self_: Sphere) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec2<f32>(1.0, -1.0));
}

fn translator_anti_reversal(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn anti_scalar_automorphism(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn circle_automorphism(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g1 * vec3<f32>(1.0, -1.0, 1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn dipole_automorphism(self_: Dipole) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2);
}

fn flat_point_automorphism(self_: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0);
}

fn flector_automorphism(self_: Flector) -> Flector {
    return Flector(self_.g0, self_.g1 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn horizon_automorphism(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0);
}

fn infinity_automorphism(self_: Infinity) -> Infinity {
    return Infinity(-self_.g0);
}

fn line_automorphism(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_infinity_automorphism(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_origin_automorphism(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn magnitude_automorphism(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_automorphism(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn multi_vector_automorphism(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 * vec3<f32>(-1.0), self_.g2 * vec2<f32>(-1.0), self_.g3, self_.g4, self_.g5, self_.g6 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g7 * vec3<f32>(1.0, -1.0, 1.0), self_.g8 * vec3<f32>(-1.0, 1.0, -1.0), self_.g9 * vec3<f32>(-1.0, 1.0, -1.0), self_.g10 * vec2<f32>(1.0, -1.0));
}

fn origin_automorphism(self_: Origin) -> Origin {
    return Origin(-self_.g0);
}

fn plane_automorphism(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn plane_at_origin_automorphism(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn point_at_infinity_automorphism(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0);
}

fn point_at_origin_automorphism(self_: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0);
}

fn rotor_automorphism(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn round_point_automorphism(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec2<f32>(-1.0));
}

fn scalar_automorphism(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn sphere_automorphism(self_: Sphere) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec2<f32>(1.0, -1.0));
}

fn translator_automorphism(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn anti_scalar_conjugation(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn circle_conjugation(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0), self_.g2 * vec3<f32>(1.0, -1.0, 1.0));
}

fn dipole_conjugation(self_: Dipole) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g2 * vec4<f32>(-1.0));
}

fn flat_point_conjugation(self_: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(-1.0));
}

fn flector_conjugation(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn horizon_conjugation(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0);
}

fn infinity_conjugation(self_: Infinity) -> Infinity {
    return Infinity(-self_.g0);
}

fn line_conjugation(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec3<f32>(1.0, -1.0, 1.0));
}

fn line_at_infinity_conjugation(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn line_at_origin_conjugation(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn magnitude_conjugation(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_conjugation(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0), self_.g1 * vec3<f32>(1.0, -1.0, 1.0));
}

fn multi_vector_conjugation(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 * vec3<f32>(-1.0), self_.g2 * vec2<f32>(-1.0), self_.g3 * vec3<f32>(-1.0), self_.g4 * vec3<f32>(-1.0), self_.g5 * vec4<f32>(-1.0), self_.g6 * vec4<f32>(-1.0, 1.0, -1.0, 1.0), self_.g7 * vec3<f32>(-1.0, 1.0, -1.0), self_.g8 * vec3<f32>(1.0, -1.0, 1.0), self_.g9 * vec3<f32>(-1.0, 1.0, -1.0), self_.g10 * vec2<f32>(1.0, -1.0));
}

fn origin_conjugation(self_: Origin) -> Origin {
    return Origin(-self_.g0);
}

fn plane_conjugation(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn plane_at_origin_conjugation(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn point_at_infinity_conjugation(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_at_origin_conjugation(self_: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(-self_.g0);
}

fn rotor_conjugation(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn round_point_conjugation(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec2<f32>(-1.0));
}

fn scalar_conjugation(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn sphere_conjugation(self_: Sphere) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec2<f32>(1.0, -1.0));
}

fn translator_conjugation(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn anti_scalar_double_complement(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn circle_double_complement(self_: Circle) -> Circle {
    return Circle(self_.g0, self_.g1, self_.g2);
}

fn dipole_double_complement(self_: Dipole) -> Dipole {
    return Dipole(self_.g0, self_.g1, self_.g2);
}

fn flat_point_double_complement(self_: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0);
}

fn flector_double_complement(self_: Flector) -> Flector {
    return Flector(self_.g0, self_.g1);
}

fn horizon_double_complement(self_: Horizon) -> Horizon {
    return Horizon(self_.g0);
}

fn infinity_double_complement(self_: Infinity) -> Infinity {
    return Infinity(self_.g0);
}

fn line_double_complement(self_: Line) -> Line {
    return Line(self_.g0, self_.g1);
}

fn line_at_infinity_double_complement(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0);
}

fn line_at_origin_double_complement(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0);
}

fn magnitude_double_complement(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_double_complement(self_: Motor) -> Motor {
    return Motor(self_.g0, self_.g1);
}

fn multi_vector_double_complement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4, self_.g5, self_.g6, self_.g7, self_.g8, self_.g9, self_.g10);
}

fn origin_double_complement(self_: Origin) -> Origin {
    return Origin(self_.g0);
}

fn plane_double_complement(self_: Plane) -> Plane {
    return Plane(self_.g0);
}

fn plane_at_origin_double_complement(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0);
}

fn point_at_infinity_double_complement(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0);
}

fn point_at_origin_double_complement(self_: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(self_.g0);
}

fn rotor_double_complement(self_: Rotor) -> Rotor {
    return Rotor(self_.g0);
}

fn round_point_double_complement(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1);
}

fn scalar_double_complement(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn sphere_double_complement(self_: Sphere) -> Sphere {
    return Sphere(self_.g0, self_.g1);
}

fn translator_double_complement(self_: Translator) -> Translator {
    return Translator(self_.g0);
}

fn anti_scalar_dual(self_: AntiScalar) -> Scalar {
    return Scalar(-self_.g0);
}

fn circle_dual(self_: Circle) -> Dipole {
    return Dipole(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), self_.g1, vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, -self_.g0.w));
}

fn dipole_dual(self_: Dipole) -> Circle {
    return Circle(vec4<f32>(-self_.g0.x, -self_.g0.y, -self_.g0.z, self_.g2.w), self_.g1 * vec3<f32>(-1.0), vec3<f32>(-self_.g2.x, self_.g2.y, self_.g2.z));
}

fn flat_point_dual(self_: FlatPoint) -> Circle {
    return Circle(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w), vec3<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z));
}

fn flector_dual(self_: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(-self_.g1.x, self_.g1.y, self_.g1.z), vec2<f32>(0.0, self_.g1.w), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0.w), vec3<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_dual(self_: Horizon) -> Infinity {
    return Infinity(self_.g0);
}

fn infinity_dual(self_: Infinity) -> Horizon {
    return Horizon(-self_.g0);
}

fn line_dual(self_: Line) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0, vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, 0.0));
}

fn line_at_infinity_dual(self_: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0);
}

fn line_at_origin_dual(self_: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0, vec4<f32>(0.0));
}

fn magnitude_dual(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx * vec2<f32>(-1.0, 1.0));
}

fn motor_dual(self_: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(-self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_dual(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx * vec2<f32>(-1.0, 1.0), self_.g9 * vec3<f32>(-1.0), self_.g10, vec3<f32>(self_.g6.x, self_.g6.y, self_.g6.z), self_.g7, vec4<f32>(self_.g8.x, self_.g8.y, self_.g8.z, -self_.g6.w), vec4<f32>(-self_.g3.x, -self_.g3.y, -self_.g3.z, self_.g5.w), self_.g4 * vec3<f32>(-1.0), vec3<f32>(-self_.g5.x, self_.g5.y, self_.g5.z), self_.g1, self_.g2 * vec2<f32>(-1.0));
}

fn origin_dual(self_: Origin) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(-self_.g0, 0.0));
}

fn plane_dual(self_: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec2<f32>(0.0, self_.g0.w));
}

fn plane_at_origin_dual(self_: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(-1.0), vec2<f32>(0.0));
}

fn point_at_infinity_dual(self_: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_at_origin_dual(self_: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(0.0, 0.0, 0.0, self_.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn rotor_dual(self_: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(-self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_dual(self_: RoundPoint) -> Sphere {
    return Sphere(self_.g0, self_.g1 * vec2<f32>(-1.0));
}

fn scalar_dual(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn sphere_dual(self_: Sphere) -> RoundPoint {
    return RoundPoint(self_.g0 * vec3<f32>(-1.0), self_.g1);
}

fn translator_dual(self_: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(-self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_left_complement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0);
}

fn circle_left_complement(self_: Circle) -> Dipole {
    return Dipole(self_.g2 * vec3<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g0 * vec4<f32>(-1.0));
}

fn dipole_left_complement(self_: Dipole) -> Circle {
    return Circle(self_.g2 * vec4<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0));
}

fn flat_point_left_complement(self_: FlatPoint) -> Circle {
    return Circle(self_.g0 * vec4<f32>(-1.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn flector_left_complement(self_: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z), vec2<f32>(self_.g1.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(-1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_left_complement(self_: Horizon) -> Origin {
    return Origin(self_.g0);
}

fn infinity_left_complement(self_: Infinity) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0, 0.0));
}

fn line_left_complement(self_: Line) -> Dipole {
    return Dipole(self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0), vec4<f32>(0.0));
}

fn line_at_infinity_left_complement(self_: LineAtInfinity) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(-1.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_left_complement(self_: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(-1.0), vec4<f32>(0.0));
}

fn magnitude_left_complement(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx);
}

fn motor_left_complement(self_: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g1 * vec3<f32>(-1.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_left_complement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx, self_.g9, self_.g10.yx, self_.g8 * vec3<f32>(-1.0), self_.g7 * vec3<f32>(-1.0), self_.g6 * vec4<f32>(-1.0), self_.g5 * vec4<f32>(-1.0), self_.g4 * vec3<f32>(-1.0), self_.g3 * vec3<f32>(-1.0), self_.g1, self_.g2.yx);
}

fn origin_left_complement(self_: Origin) -> Horizon {
    return Horizon(self_.g0);
}

fn plane_left_complement(self_: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), vec2<f32>(self_.g0.w, 0.0));
}

fn plane_at_origin_left_complement(self_: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(self_.g0, vec2<f32>(0.0));
}

fn point_at_infinity_left_complement(self_: PointAtInfinity) -> Circle {
    return Circle(vec4<f32>(-self_.g0.x, -self_.g0.y, -self_.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn point_at_origin_left_complement(self_: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(0.0, 0.0, 0.0, -self_.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn rotor_left_complement(self_: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_left_complement(self_: RoundPoint) -> Sphere {
    return Sphere(self_.g0, self_.g1.yx);
}

fn scalar_left_complement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn sphere_left_complement(self_: Sphere) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1.yx);
}

fn translator_left_complement(self_: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn anti_scalar_reversal(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(-self_.g0);
}

fn circle_reversal(self_: Circle) -> Circle {
    return Circle(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g1 * vec3<f32>(1.0, -1.0, 1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn dipole_reversal(self_: Dipole) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g2 * vec4<f32>(-1.0));
}

fn flat_point_reversal(self_: FlatPoint) -> FlatPoint {
    return FlatPoint(self_.g0 * vec4<f32>(-1.0));
}

fn flector_reversal(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn horizon_reversal(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0);
}

fn infinity_reversal(self_: Infinity) -> Infinity {
    return Infinity(self_.g0);
}

fn line_reversal(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_infinity_reversal(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn line_at_origin_reversal(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn magnitude_reversal(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(1.0, -1.0));
}

fn motor_reversal(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g1 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn multi_vector_reversal(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(1.0, -1.0), self_.g1, self_.g2, self_.g3 * vec3<f32>(-1.0), self_.g4 * vec3<f32>(-1.0), self_.g5 * vec4<f32>(-1.0), self_.g6 * vec4<f32>(1.0, -1.0, 1.0, -1.0), self_.g7 * vec3<f32>(1.0, -1.0, 1.0), self_.g8 * vec3<f32>(-1.0, 1.0, -1.0), self_.g9 * vec3<f32>(-1.0, 1.0, -1.0), self_.g10 * vec2<f32>(1.0, -1.0));
}

fn origin_reversal(self_: Origin) -> Origin {
    return Origin(self_.g0);
}

fn plane_reversal(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn plane_at_origin_reversal(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn point_at_infinity_reversal(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_at_origin_reversal(self_: PointAtOrigin) -> PointAtOrigin {
    return PointAtOrigin(-self_.g0);
}

fn rotor_reversal(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn round_point_reversal(self_: RoundPoint) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1);
}

fn scalar_reversal(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn sphere_reversal(self_: Sphere) -> Sphere {
    return Sphere(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec2<f32>(1.0, -1.0));
}

fn translator_reversal(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn anti_scalar_right_complement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0);
}

fn circle_right_complement(self_: Circle) -> Dipole {
    return Dipole(self_.g2 * vec3<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g0 * vec4<f32>(-1.0));
}

fn dipole_right_complement(self_: Dipole) -> Circle {
    return Circle(self_.g2 * vec4<f32>(-1.0), self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0));
}

fn flat_point_right_complement(self_: FlatPoint) -> Circle {
    return Circle(self_.g0 * vec4<f32>(-1.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn flector_right_complement(self_: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z), vec2<f32>(self_.g1.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0), self_.g0 * vec4<f32>(-1.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn horizon_right_complement(self_: Horizon) -> Origin {
    return Origin(self_.g0);
}

fn infinity_right_complement(self_: Infinity) -> Sphere {
    return Sphere(vec3<f32>(0.0), vec2<f32>(self_.g0, 0.0));
}

fn line_right_complement(self_: Line) -> Dipole {
    return Dipole(self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0), vec4<f32>(0.0));
}

fn line_at_infinity_right_complement(self_: LineAtInfinity) -> Dipole {
    return Dipole(self_.g0 * vec3<f32>(-1.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_right_complement(self_: LineAtOrigin) -> Dipole {
    return Dipole(vec3<f32>(0.0), self_.g0 * vec3<f32>(-1.0), vec4<f32>(0.0));
}

fn magnitude_right_complement(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx);
}

fn motor_right_complement(self_: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), self_.g1 * vec3<f32>(-1.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn multi_vector_right_complement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx, self_.g9, self_.g10.yx, self_.g8 * vec3<f32>(-1.0), self_.g7 * vec3<f32>(-1.0), self_.g6 * vec4<f32>(-1.0), self_.g5 * vec4<f32>(-1.0), self_.g4 * vec3<f32>(-1.0), self_.g3 * vec3<f32>(-1.0), self_.g1, self_.g2.yx);
}

fn origin_right_complement(self_: Origin) -> Horizon {
    return Horizon(self_.g0);
}

fn plane_right_complement(self_: Plane) -> RoundPoint {
    return RoundPoint(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), vec2<f32>(self_.g0.w, 0.0));
}

fn plane_at_origin_right_complement(self_: PlaneAtOrigin) -> RoundPoint {
    return RoundPoint(self_.g0, vec2<f32>(0.0));
}

fn point_at_infinity_right_complement(self_: PointAtInfinity) -> Circle {
    return Circle(vec4<f32>(-self_.g0.x, -self_.g0.y, -self_.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn point_at_origin_right_complement(self_: PointAtOrigin) -> Circle {
    return Circle(vec4<f32>(0.0, 0.0, 0.0, -self_.g0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn rotor_right_complement(self_: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn round_point_right_complement(self_: RoundPoint) -> Sphere {
    return Sphere(self_.g0, self_.g1.yx);
}

fn scalar_right_complement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn sphere_right_complement(self_: Sphere) -> RoundPoint {
    return RoundPoint(self_.g0, self_.g1.yx);
}

fn translator_right_complement(self_: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w, 0.0), vec3<f32>(0.0), vec2<f32>(0.0), vec3<f32>(-self_.g0.x, self_.g0.y, self_.g0.z), vec3<f32>(0.0), vec4<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec2<f32>(0.0));
}

fn circle_left_bulk_dual(self_: Circle) -> Dipole {
    return line_at_infinity_left_complement(circle_bulk(self_));
}

fn dipole_left_bulk_dual(self_: Dipole) -> Circle {
    return point_at_infinity_left_complement(dipole_bulk(self_));
}

fn flat_point_left_bulk_dual(self_: FlatPoint) -> Circle {
    return point_at_infinity_left_complement(flat_point_bulk(self_));
}

fn flector_left_bulk_dual(self_: Flector) -> MultiVector {
    return flector_left_complement(flector_bulk(self_));
}

fn horizon_left_bulk_dual(self_: Horizon) -> Origin {
    return horizon_left_complement(horizon_bulk(self_));
}

fn infinity_left_bulk_dual(self_: Infinity) -> Sphere {
    return infinity_left_complement(infinity_bulk(self_));
}

fn line_left_bulk_dual(self_: Line) -> Dipole {
    return line_at_infinity_left_complement(line_bulk(self_));
}

fn line_at_infinity_left_bulk_dual(self_: LineAtInfinity) -> Dipole {
    return line_at_infinity_left_complement(line_at_infinity_bulk(self_));
}

fn motor_left_bulk_dual(self_: Motor) -> Dipole {
    return line_at_infinity_left_complement(motor_bulk(self_));
}

fn multi_vector_left_bulk_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_left_complement(multi_vector_bulk(self_));
}

fn plane_left_bulk_dual(self_: Plane) -> Origin {
    return horizon_left_complement(plane_bulk(self_));
}

fn point_at_infinity_left_bulk_dual(self_: PointAtInfinity) -> Circle {
    return point_at_infinity_left_complement(point_at_infinity_bulk(self_));
}

fn round_point_left_bulk_dual(self_: RoundPoint) -> Sphere {
    return infinity_left_complement(round_point_bulk(self_));
}

fn sphere_left_bulk_dual(self_: Sphere) -> Origin {
    return horizon_left_complement(sphere_bulk(self_));
}

fn translator_left_bulk_dual(self_: Translator) -> Dipole {
    return line_at_infinity_left_complement(translator_bulk(self_));
}

fn circle_left_round_bulk_dual(self_: Circle) -> Dipole {
    return circle_left_complement(circle_round_bulk(self_));
}

fn dipole_left_round_bulk_dual(self_: Dipole) -> Circle {
    return dipole_left_complement(dipole_round_bulk(self_));
}

fn magnitude_left_round_bulk_dual(self_: Magnitude) -> AntiScalar {
    return scalar_left_complement(magnitude_round_bulk(self_));
}

fn multi_vector_left_round_bulk_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_left_complement(multi_vector_round_bulk(self_));
}

fn round_point_left_round_bulk_dual(self_: RoundPoint) -> Sphere {
    return round_point_left_complement(round_point_round_bulk(self_));
}

fn scalar_left_round_bulk_dual(self_: Scalar) -> AntiScalar {
    return scalar_left_complement(scalar_round_bulk(self_));
}

fn circle_left_round_weight_dual(self_: Circle) -> Dipole {
    return circle_left_complement(circle_round_weight(self_));
}

fn dipole_left_round_weight_dual(self_: Dipole) -> Circle {
    return dipole_left_complement(dipole_round_weight(self_));
}

fn multi_vector_left_round_weight_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_left_complement(multi_vector_round_weight(self_));
}

fn origin_left_round_weight_dual(self_: Origin) -> Horizon {
    return origin_left_complement(origin_round_weight(self_));
}

fn round_point_left_round_weight_dual(self_: RoundPoint) -> Horizon {
    return origin_left_complement(round_point_round_weight(self_));
}

fn sphere_left_round_weight_dual(self_: Sphere) -> RoundPoint {
    return sphere_left_complement(sphere_round_weight(self_));
}

fn anti_scalar_left_weight_dual(self_: AntiScalar) -> Scalar {
    return anti_scalar_left_complement(anti_scalar_weight(self_));
}

fn circle_left_weight_dual(self_: Circle) -> Dipole {
    return line_at_origin_left_complement(circle_weight(self_));
}

fn dipole_left_weight_dual(self_: Dipole) -> Circle {
    return point_at_origin_left_complement(dipole_weight(self_));
}

fn flat_point_left_weight_dual(self_: FlatPoint) -> Circle {
    return point_at_origin_left_complement(flat_point_weight(self_));
}

fn flector_left_weight_dual(self_: Flector) -> MultiVector {
    return flector_left_complement(flector_weight(self_));
}

fn line_left_weight_dual(self_: Line) -> Dipole {
    return line_at_origin_left_complement(line_weight(self_));
}

fn line_at_origin_left_weight_dual(self_: LineAtOrigin) -> Dipole {
    return line_at_origin_left_complement(line_at_origin_weight(self_));
}

fn magnitude_left_weight_dual(self_: Magnitude) -> Scalar {
    return anti_scalar_left_complement(magnitude_weight(self_));
}

fn motor_left_weight_dual(self_: Motor) -> MultiVector {
    return rotor_left_complement(motor_weight(self_));
}

fn multi_vector_left_weight_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_left_complement(multi_vector_weight(self_));
}

fn plane_left_weight_dual(self_: Plane) -> RoundPoint {
    return plane_at_origin_left_complement(plane_weight(self_));
}

fn plane_at_origin_left_weight_dual(self_: PlaneAtOrigin) -> RoundPoint {
    return plane_at_origin_left_complement(plane_at_origin_weight(self_));
}

fn point_at_origin_left_weight_dual(self_: PointAtOrigin) -> Circle {
    return point_at_origin_left_complement(point_at_origin_weight(self_));
}

fn rotor_left_weight_dual(self_: Rotor) -> MultiVector {
    return rotor_left_complement(rotor_weight(self_));
}

fn sphere_left_weight_dual(self_: Sphere) -> RoundPoint {
    return plane_at_origin_left_complement(sphere_weight(self_));
}

fn translator_left_weight_dual(self_: Translator) -> Scalar {
    return anti_scalar_left_complement(translator_weight(self_));
}

fn circle_right_bulk_dual(self_: Circle) -> Dipole {
    return line_at_infinity_right_complement(circle_bulk(self_));
}

fn dipole_right_bulk_dual(self_: Dipole) -> Circle {
    return point_at_infinity_right_complement(dipole_bulk(self_));
}

fn flat_point_right_bulk_dual(self_: FlatPoint) -> Circle {
    return point_at_infinity_right_complement(flat_point_bulk(self_));
}

fn flector_right_bulk_dual(self_: Flector) -> MultiVector {
    return flector_right_complement(flector_bulk(self_));
}

fn horizon_right_bulk_dual(self_: Horizon) -> Origin {
    return horizon_right_complement(horizon_bulk(self_));
}

fn infinity_right_bulk_dual(self_: Infinity) -> Sphere {
    return infinity_right_complement(infinity_bulk(self_));
}

fn line_right_bulk_dual(self_: Line) -> Dipole {
    return line_at_infinity_right_complement(line_bulk(self_));
}

fn line_at_infinity_right_bulk_dual(self_: LineAtInfinity) -> Dipole {
    return line_at_infinity_right_complement(line_at_infinity_bulk(self_));
}

fn motor_right_bulk_dual(self_: Motor) -> Dipole {
    return line_at_infinity_right_complement(motor_bulk(self_));
}

fn multi_vector_right_bulk_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_right_complement(multi_vector_bulk(self_));
}

fn plane_right_bulk_dual(self_: Plane) -> Origin {
    return horizon_right_complement(plane_bulk(self_));
}

fn point_at_infinity_right_bulk_dual(self_: PointAtInfinity) -> Circle {
    return point_at_infinity_right_complement(point_at_infinity_bulk(self_));
}

fn round_point_right_bulk_dual(self_: RoundPoint) -> Sphere {
    return infinity_right_complement(round_point_bulk(self_));
}

fn sphere_right_bulk_dual(self_: Sphere) -> Origin {
    return horizon_right_complement(sphere_bulk(self_));
}

fn translator_right_bulk_dual(self_: Translator) -> Dipole {
    return line_at_infinity_right_complement(translator_bulk(self_));
}

fn circle_right_round_bulk_dual(self_: Circle) -> Dipole {
    return circle_right_complement(circle_round_bulk(self_));
}

fn dipole_right_round_bulk_dual(self_: Dipole) -> Circle {
    return dipole_right_complement(dipole_round_bulk(self_));
}

fn magnitude_right_round_bulk_dual(self_: Magnitude) -> AntiScalar {
    return scalar_right_complement(magnitude_round_bulk(self_));
}

fn multi_vector_right_round_bulk_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_right_complement(multi_vector_round_bulk(self_));
}

fn round_point_right_round_bulk_dual(self_: RoundPoint) -> Sphere {
    return round_point_right_complement(round_point_round_bulk(self_));
}

fn scalar_right_round_bulk_dual(self_: Scalar) -> AntiScalar {
    return scalar_right_complement(scalar_round_bulk(self_));
}

fn circle_right_round_weight_dual(self_: Circle) -> Dipole {
    return circle_right_complement(circle_round_weight(self_));
}

fn dipole_right_round_weight_dual(self_: Dipole) -> Circle {
    return dipole_right_complement(dipole_round_weight(self_));
}

fn multi_vector_right_round_weight_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_right_complement(multi_vector_round_weight(self_));
}

fn origin_right_round_weight_dual(self_: Origin) -> Horizon {
    return origin_right_complement(origin_round_weight(self_));
}

fn round_point_right_round_weight_dual(self_: RoundPoint) -> Horizon {
    return origin_right_complement(round_point_round_weight(self_));
}

fn sphere_right_round_weight_dual(self_: Sphere) -> RoundPoint {
    return sphere_right_complement(sphere_round_weight(self_));
}

fn anti_scalar_right_weight_dual(self_: AntiScalar) -> Scalar {
    return anti_scalar_right_complement(anti_scalar_weight(self_));
}

fn circle_right_weight_dual(self_: Circle) -> Dipole {
    return line_at_origin_right_complement(circle_weight(self_));
}

fn dipole_right_weight_dual(self_: Dipole) -> Circle {
    return point_at_origin_right_complement(dipole_weight(self_));
}

fn flat_point_right_weight_dual(self_: FlatPoint) -> Circle {
    return point_at_origin_right_complement(flat_point_weight(self_));
}

fn flector_right_weight_dual(self_: Flector) -> MultiVector {
    return flector_right_complement(flector_weight(self_));
}

fn line_right_weight_dual(self_: Line) -> Dipole {
    return line_at_origin_right_complement(line_weight(self_));
}

fn line_at_origin_right_weight_dual(self_: LineAtOrigin) -> Dipole {
    return line_at_origin_right_complement(line_at_origin_weight(self_));
}

fn magnitude_right_weight_dual(self_: Magnitude) -> Scalar {
    return anti_scalar_right_complement(magnitude_weight(self_));
}

fn motor_right_weight_dual(self_: Motor) -> MultiVector {
    return rotor_right_complement(motor_weight(self_));
}

fn multi_vector_right_weight_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_right_complement(multi_vector_weight(self_));
}

fn plane_right_weight_dual(self_: Plane) -> RoundPoint {
    return plane_at_origin_right_complement(plane_weight(self_));
}

fn plane_at_origin_right_weight_dual(self_: PlaneAtOrigin) -> RoundPoint {
    return plane_at_origin_right_complement(plane_at_origin_weight(self_));
}

fn point_at_origin_right_weight_dual(self_: PointAtOrigin) -> Circle {
    return point_at_origin_right_complement(point_at_origin_weight(self_));
}

fn rotor_right_weight_dual(self_: Rotor) -> MultiVector {
    return rotor_right_complement(rotor_weight(self_));
}

fn sphere_right_weight_dual(self_: Sphere) -> RoundPoint {
    return plane_at_origin_right_complement(sphere_weight(self_));
}

fn translator_right_weight_dual(self_: Translator) -> Scalar {
    return anti_scalar_right_complement(translator_weight(self_));
}

fn anti_scalar_anti_grade() -> i32 {
    return 0;
}

fn circle_anti_grade() -> i32 {
    return 2;
}

fn dipole_anti_grade() -> i32 {
    return 3;
}

fn flat_point_anti_grade() -> i32 {
    return 3;
}

fn horizon_anti_grade() -> i32 {
    return 1;
}

fn infinity_anti_grade() -> i32 {
    return 4;
}

fn line_anti_grade() -> i32 {
    return 2;
}

fn line_at_infinity_anti_grade() -> i32 {
    return 2;
}

fn line_at_origin_anti_grade() -> i32 {
    return 2;
}

fn origin_anti_grade() -> i32 {
    return 4;
}

fn plane_anti_grade() -> i32 {
    return 1;
}

fn plane_at_origin_anti_grade() -> i32 {
    return 1;
}

fn point_at_infinity_anti_grade() -> i32 {
    return 3;
}

fn point_at_origin_anti_grade() -> i32 {
    return 3;
}

fn round_point_anti_grade() -> i32 {
    return 4;
}

fn scalar_anti_grade() -> i32 {
    return 5;
}

fn sphere_anti_grade() -> i32 {
    return 1;
}

fn anti_scalar_grade() -> i32 {
    return 5;
}

fn circle_grade() -> i32 {
    return 3;
}

fn dipole_grade() -> i32 {
    return 2;
}

fn flat_point_grade() -> i32 {
    return 2;
}

fn horizon_grade() -> i32 {
    return 4;
}

fn infinity_grade() -> i32 {
    return 1;
}

fn line_grade() -> i32 {
    return 3;
}

fn line_at_infinity_grade() -> i32 {
    return 3;
}

fn line_at_origin_grade() -> i32 {
    return 3;
}

fn origin_grade() -> i32 {
    return 1;
}

fn plane_grade() -> i32 {
    return 4;
}

fn plane_at_origin_grade() -> i32 {
    return 4;
}

fn point_at_infinity_grade() -> i32 {
    return 2;
}

fn point_at_origin_grade() -> i32 {
    return 2;
}

fn round_point_grade() -> i32 {
    return 1;
}

fn scalar_grade() -> i32 {
    return 0;
}

fn sphere_grade() -> i32 {
    return 4;
}

fn anti_scalar_attitude(self_: AntiScalar) -> Horizon {
    return anti_scalar_horizon_anti_wedge(self_, horizon_one());
}

fn circle_attitude(self_: Circle) -> Dipole {
    return circle_horizon_anti_wedge(self_, horizon_one());
}

fn dipole_attitude(self_: Dipole) -> RoundPoint {
    return dipole_horizon_anti_wedge(self_, horizon_one());
}

fn flat_point_attitude(self_: FlatPoint) -> Infinity {
    return flat_point_horizon_anti_wedge(self_, horizon_one());
}

fn flector_attitude(self_: Flector) -> MultiVector {
    return flector_horizon_anti_wedge(self_, horizon_one());
}

fn line_attitude(self_: Line) -> PointAtInfinity {
    return line_horizon_anti_wedge(self_, horizon_one());
}

fn line_at_origin_attitude(self_: LineAtOrigin) -> PointAtInfinity {
    return line_at_origin_horizon_anti_wedge(self_, horizon_one());
}

fn magnitude_attitude(self_: Magnitude) -> Horizon {
    return magnitude_horizon_anti_wedge(self_, horizon_one());
}

fn motor_attitude(self_: Motor) -> Flector {
    return motor_horizon_anti_wedge(self_, horizon_one());
}

fn multi_vector_attitude(self_: MultiVector) -> MultiVector {
    return multi_vector_horizon_anti_wedge(self_, horizon_one());
}

fn origin_attitude(self_: Origin) -> Scalar {
    return origin_horizon_anti_wedge(self_, horizon_one());
}

fn plane_attitude(self_: Plane) -> LineAtInfinity {
    return plane_horizon_anti_wedge(self_, horizon_one());
}

fn plane_at_origin_attitude(self_: PlaneAtOrigin) -> LineAtInfinity {
    return plane_at_origin_horizon_anti_wedge(self_, horizon_one());
}

fn point_at_origin_attitude(self_: PointAtOrigin) -> Infinity {
    return point_at_origin_horizon_anti_wedge(self_, horizon_one());
}

fn rotor_attitude(self_: Rotor) -> Flector {
    return rotor_horizon_anti_wedge(self_, horizon_one());
}

fn round_point_attitude(self_: RoundPoint) -> Scalar {
    return round_point_horizon_anti_wedge(self_, horizon_one());
}

fn sphere_attitude(self_: Sphere) -> Circle {
    return sphere_horizon_anti_wedge(self_, horizon_one());
}

fn translator_attitude(self_: Translator) -> Horizon {
    return translator_horizon_anti_wedge(self_, horizon_one());
}

fn circle_carrier(self_: Circle) -> Plane {
    return circle_infinity_wedge(self_, infinity_one());
}

fn dipole_carrier(self_: Dipole) -> Line {
    return dipole_infinity_wedge(self_, infinity_one());
}

fn magnitude_carrier(self_: Magnitude) -> Infinity {
    return magnitude_infinity_wedge(self_, infinity_one());
}

fn multi_vector_carrier(self_: MultiVector) -> MultiVector {
    return multi_vector_infinity_wedge(self_, infinity_one());
}

fn origin_carrier(self_: Origin) -> PointAtOrigin {
    return origin_infinity_wedge(self_, infinity_one());
}

fn round_point_carrier(self_: RoundPoint) -> FlatPoint {
    return round_point_infinity_wedge(self_, infinity_one());
}

fn scalar_carrier(self_: Scalar) -> Infinity {
    return scalar_infinity_wedge(self_, infinity_one());
}

fn sphere_carrier(self_: Sphere) -> AntiScalar {
    return sphere_infinity_wedge(self_, infinity_one());
}

fn circle_co_carrier(self_: Circle) -> Line {
    return dipole_infinity_wedge(circle_anti_dual(self_), infinity_one());
}

fn dipole_co_carrier(self_: Dipole) -> Plane {
    return circle_infinity_wedge(dipole_anti_dual(self_), infinity_one());
}

fn magnitude_co_carrier(self_: Magnitude) -> Infinity {
    return magnitude_infinity_wedge(magnitude_anti_dual(self_), infinity_one());
}

fn multi_vector_co_carrier(self_: MultiVector) -> MultiVector {
    return multi_vector_infinity_wedge(multi_vector_anti_dual(self_), infinity_one());
}

fn origin_co_carrier(self_: Origin) -> AntiScalar {
    return sphere_infinity_wedge(origin_anti_dual(self_), infinity_one());
}

fn round_point_co_carrier(self_: RoundPoint) -> AntiScalar {
    return sphere_infinity_wedge(round_point_anti_dual(self_), infinity_one());
}

fn sphere_co_carrier(self_: Sphere) -> FlatPoint {
    return round_point_infinity_wedge(sphere_anti_dual(self_), infinity_one());
}

fn anti_scalar_sqrt(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(sqrt(self_.g0));
}

fn scalar_sqrt(self_: Scalar) -> Scalar {
    return Scalar(sqrt(self_.g0));
}

fn circle_center(self_: Circle) -> RoundPoint {
    return line_circle_anti_wedge(circle_co_carrier(self_), self_);
}

fn dipole_center(self_: Dipole) -> RoundPoint {
    return plane_dipole_anti_wedge(dipole_co_carrier(self_), self_);
}

fn magnitude_center(self_: Magnitude) -> Infinity {
    return infinity_magnitude_anti_wedge(magnitude_co_carrier(self_), self_);
}

fn multi_vector_center(self_: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(multi_vector_co_carrier(self_), self_);
}

fn origin_center(self_: Origin) -> Origin {
    return anti_scalar_origin_anti_wedge(origin_co_carrier(self_), self_);
}

fn round_point_center(self_: RoundPoint) -> RoundPoint {
    return anti_scalar_round_point_anti_wedge(round_point_co_carrier(self_), self_);
}

fn sphere_center(self_: Sphere) -> RoundPoint {
    return flat_point_sphere_anti_wedge(sphere_co_carrier(self_), self_);
}

fn circle_container(self_: Circle) -> Sphere {
    return circle_round_point_wedge(self_, plane_anti_dual(circle_carrier(self_)));
}

fn dipole_container(self_: Dipole) -> Sphere {
    return dipole_dipole_wedge(self_, line_anti_dual(dipole_carrier(self_)));
}

fn magnitude_container(self_: Magnitude) -> Horizon {
    return magnitude_horizon_wedge(self_, infinity_anti_dual(magnitude_carrier(self_)));
}

fn multi_vector_container(self_: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, multi_vector_anti_dual(multi_vector_carrier(self_)));
}

fn origin_container(self_: Origin) -> Sphere {
    return origin_circle_wedge(self_, point_at_origin_anti_dual(origin_carrier(self_)));
}

fn round_point_container(self_: RoundPoint) -> Sphere {
    return round_point_circle_wedge(self_, flat_point_anti_dual(round_point_carrier(self_)));
}

fn scalar_container(self_: Scalar) -> Horizon {
    return scalar_horizon_wedge(self_, infinity_anti_dual(scalar_carrier(self_)));
}

fn sphere_container(self_: Sphere) -> Sphere {
    return sphere_scalar_wedge(self_, anti_scalar_anti_dual(sphere_carrier(self_)));
}

fn circle_partner(self_: Circle) -> Circle {
    return sphere_plane_anti_wedge(sphere_neg(dipole_container(circle_right_bulk_dual(self_))), circle_carrier(self_));
}

fn dipole_partner(self_: Dipole) -> Dipole {
    return sphere_line_anti_wedge(sphere_neg(circle_container(dipole_right_bulk_dual(self_))), dipole_carrier(self_));
}

fn multi_vector_partner(self_: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(multi_vector_neg(multi_vector_container(multi_vector_right_bulk_dual(self_))), multi_vector_carrier(self_));
}

fn round_point_partner(self_: RoundPoint) -> RoundPoint {
    return sphere_flat_point_anti_wedge(sphere_neg(sphere_container(round_point_right_bulk_dual(self_))), round_point_carrier(self_));
}

fn sphere_partner(self_: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(sphere_neg(origin_container(sphere_right_bulk_dual(self_))), sphere_carrier(self_));
}

fn anti_scalar_bulk_norm_squared(self_: AntiScalar) -> Scalar {
    return anti_scalar_anti_scalar_dot(self_, self_);
}

fn circle_bulk_norm_squared(self_: Circle) -> Scalar {
    return circle_circle_dot(self_, self_);
}

fn dipole_bulk_norm_squared(self_: Dipole) -> Scalar {
    return dipole_dipole_dot(self_, self_);
}

fn flat_point_bulk_norm_squared(self_: FlatPoint) -> Scalar {
    return flat_point_flat_point_dot(self_, self_);
}

fn flector_bulk_norm_squared(self_: Flector) -> Scalar {
    return flector_flector_dot(self_, self_);
}

fn line_bulk_norm_squared(self_: Line) -> Scalar {
    return line_line_dot(self_, self_);
}

fn line_at_origin_bulk_norm_squared(self_: LineAtOrigin) -> Scalar {
    return line_at_origin_line_at_origin_dot(self_, self_);
}

fn magnitude_bulk_norm_squared(self_: Magnitude) -> Scalar {
    return magnitude_magnitude_dot(self_, self_);
}

fn motor_bulk_norm_squared(self_: Motor) -> Scalar {
    return motor_motor_dot(self_, self_);
}

fn multi_vector_bulk_norm_squared(self_: MultiVector) -> Scalar {
    return multi_vector_multi_vector_dot(self_, self_);
}

fn plane_bulk_norm_squared(self_: Plane) -> Scalar {
    return plane_plane_dot(self_, self_);
}

fn plane_at_origin_bulk_norm_squared(self_: PlaneAtOrigin) -> Scalar {
    return plane_at_origin_plane_at_origin_dot(self_, self_);
}

fn point_at_origin_bulk_norm_squared(self_: PointAtOrigin) -> Scalar {
    return point_at_origin_point_at_origin_dot(self_, self_);
}

fn rotor_bulk_norm_squared(self_: Rotor) -> Scalar {
    return rotor_rotor_dot(self_, self_);
}

fn round_point_bulk_norm_squared(self_: RoundPoint) -> Scalar {
    return round_point_round_point_dot(self_, self_);
}

fn scalar_bulk_norm_squared(self_: Scalar) -> Scalar {
    return scalar_scalar_dot(self_, self_);
}

fn sphere_bulk_norm_squared(self_: Sphere) -> Scalar {
    return sphere_sphere_dot(self_, self_);
}

fn translator_bulk_norm_squared(self_: Translator) -> Scalar {
    return translator_translator_dot(self_, self_);
}

fn anti_scalar_bulk_norm(self_: AntiScalar) -> Scalar {
    return scalar_sqrt(anti_scalar_anti_scalar_dot(self_, self_));
}

fn circle_bulk_norm(self_: Circle) -> Scalar {
    return scalar_sqrt(circle_circle_dot(self_, self_));
}

fn dipole_bulk_norm(self_: Dipole) -> Scalar {
    return scalar_sqrt(dipole_dipole_dot(self_, self_));
}

fn flat_point_bulk_norm(self_: FlatPoint) -> Scalar {
    return scalar_sqrt(flat_point_flat_point_dot(self_, self_));
}

fn flector_bulk_norm(self_: Flector) -> Scalar {
    return scalar_sqrt(flector_flector_dot(self_, self_));
}

fn line_bulk_norm(self_: Line) -> Scalar {
    return scalar_sqrt(line_line_dot(self_, self_));
}

fn line_at_origin_bulk_norm(self_: LineAtOrigin) -> Scalar {
    return scalar_sqrt(line_at_origin_line_at_origin_dot(self_, self_));
}

fn magnitude_bulk_norm(self_: Magnitude) -> Scalar {
    return scalar_sqrt(magnitude_magnitude_dot(self_, self_));
}

fn motor_bulk_norm(self_: Motor) -> Scalar {
    return scalar_sqrt(motor_motor_dot(self_, self_));
}

fn multi_vector_bulk_norm(self_: MultiVector) -> Scalar {
    return scalar_sqrt(multi_vector_multi_vector_dot(self_, self_));
}

fn plane_bulk_norm(self_: Plane) -> Scalar {
    return scalar_sqrt(plane_plane_dot(self_, self_));
}

fn plane_at_origin_bulk_norm(self_: PlaneAtOrigin) -> Scalar {
    return scalar_sqrt(plane_at_origin_plane_at_origin_dot(self_, self_));
}

fn point_at_origin_bulk_norm(self_: PointAtOrigin) -> Scalar {
    return scalar_sqrt(point_at_origin_point_at_origin_dot(self_, self_));
}

fn rotor_bulk_norm(self_: Rotor) -> Scalar {
    return scalar_sqrt(rotor_rotor_dot(self_, self_));
}

fn round_point_bulk_norm(self_: RoundPoint) -> Scalar {
    return scalar_sqrt(round_point_round_point_dot(self_, self_));
}

fn scalar_bulk_norm(self_: Scalar) -> Scalar {
    return scalar_sqrt(scalar_scalar_dot(self_, self_));
}

fn sphere_bulk_norm(self_: Sphere) -> Scalar {
    return scalar_sqrt(sphere_sphere_dot(self_, self_));
}

fn translator_bulk_norm(self_: Translator) -> Scalar {
    return scalar_sqrt(translator_translator_dot(self_, self_));
}

fn anti_scalar_weight_norm_squared(self_: AntiScalar) -> AntiScalar {
    return anti_scalar_anti_scalar_anti_dot(self_, self_);
}

fn circle_weight_norm_squared(self_: Circle) -> AntiScalar {
    return circle_circle_anti_dot(self_, self_);
}

fn dipole_weight_norm_squared(self_: Dipole) -> AntiScalar {
    return dipole_dipole_anti_dot(self_, self_);
}

fn flat_point_weight_norm_squared(self_: FlatPoint) -> AntiScalar {
    return flat_point_flat_point_anti_dot(self_, self_);
}

fn flector_weight_norm_squared(self_: Flector) -> AntiScalar {
    return flector_flector_anti_dot(self_, self_);
}

fn line_weight_norm_squared(self_: Line) -> AntiScalar {
    return line_line_anti_dot(self_, self_);
}

fn line_at_origin_weight_norm_squared(self_: LineAtOrigin) -> AntiScalar {
    return line_at_origin_line_at_origin_anti_dot(self_, self_);
}

fn magnitude_weight_norm_squared(self_: Magnitude) -> AntiScalar {
    return magnitude_magnitude_anti_dot(self_, self_);
}

fn motor_weight_norm_squared(self_: Motor) -> AntiScalar {
    return motor_motor_anti_dot(self_, self_);
}

fn multi_vector_weight_norm_squared(self_: MultiVector) -> AntiScalar {
    return multi_vector_multi_vector_anti_dot(self_, self_);
}

fn plane_weight_norm_squared(self_: Plane) -> AntiScalar {
    return plane_plane_anti_dot(self_, self_);
}

fn plane_at_origin_weight_norm_squared(self_: PlaneAtOrigin) -> AntiScalar {
    return plane_at_origin_plane_at_origin_anti_dot(self_, self_);
}

fn point_at_origin_weight_norm_squared(self_: PointAtOrigin) -> AntiScalar {
    return point_at_origin_point_at_origin_anti_dot(self_, self_);
}

fn rotor_weight_norm_squared(self_: Rotor) -> AntiScalar {
    return rotor_rotor_anti_dot(self_, self_);
}

fn round_point_weight_norm_squared(self_: RoundPoint) -> AntiScalar {
    return round_point_round_point_anti_dot(self_, self_);
}

fn scalar_weight_norm_squared(self_: Scalar) -> AntiScalar {
    return scalar_scalar_anti_dot(self_, self_);
}

fn sphere_weight_norm_squared(self_: Sphere) -> AntiScalar {
    return sphere_sphere_anti_dot(self_, self_);
}

fn translator_weight_norm_squared(self_: Translator) -> AntiScalar {
    return translator_translator_anti_dot(self_, self_);
}

fn anti_scalar_weight_norm(self_: AntiScalar) -> AntiScalar {
    return anti_scalar_sqrt(anti_scalar_anti_scalar_anti_dot(self_, self_));
}

fn circle_weight_norm(self_: Circle) -> AntiScalar {
    return anti_scalar_sqrt(circle_circle_anti_dot(self_, self_));
}

fn dipole_weight_norm(self_: Dipole) -> AntiScalar {
    return anti_scalar_sqrt(dipole_dipole_anti_dot(self_, self_));
}

fn flat_point_weight_norm(self_: FlatPoint) -> AntiScalar {
    return anti_scalar_sqrt(flat_point_flat_point_anti_dot(self_, self_));
}

fn flector_weight_norm(self_: Flector) -> AntiScalar {
    return anti_scalar_sqrt(flector_flector_anti_dot(self_, self_));
}

fn line_weight_norm(self_: Line) -> AntiScalar {
    return anti_scalar_sqrt(line_line_anti_dot(self_, self_));
}

fn line_at_origin_weight_norm(self_: LineAtOrigin) -> AntiScalar {
    return anti_scalar_sqrt(line_at_origin_line_at_origin_anti_dot(self_, self_));
}

fn magnitude_weight_norm(self_: Magnitude) -> AntiScalar {
    return anti_scalar_sqrt(magnitude_magnitude_anti_dot(self_, self_));
}

fn motor_weight_norm(self_: Motor) -> AntiScalar {
    return anti_scalar_sqrt(motor_motor_anti_dot(self_, self_));
}

fn multi_vector_weight_norm(self_: MultiVector) -> AntiScalar {
    return anti_scalar_sqrt(multi_vector_multi_vector_anti_dot(self_, self_));
}

fn plane_weight_norm(self_: Plane) -> AntiScalar {
    return anti_scalar_sqrt(plane_plane_anti_dot(self_, self_));
}

fn plane_at_origin_weight_norm(self_: PlaneAtOrigin) -> AntiScalar {
    return anti_scalar_sqrt(plane_at_origin_plane_at_origin_anti_dot(self_, self_));
}

fn point_at_origin_weight_norm(self_: PointAtOrigin) -> AntiScalar {
    return anti_scalar_sqrt(point_at_origin_point_at_origin_anti_dot(self_, self_));
}

fn rotor_weight_norm(self_: Rotor) -> AntiScalar {
    return anti_scalar_sqrt(rotor_rotor_anti_dot(self_, self_));
}

fn round_point_weight_norm(self_: RoundPoint) -> AntiScalar {
    return anti_scalar_sqrt(round_point_round_point_anti_dot(self_, self_));
}

fn scalar_weight_norm(self_: Scalar) -> AntiScalar {
    return anti_scalar_sqrt(scalar_scalar_anti_dot(self_, self_));
}

fn sphere_weight_norm(self_: Sphere) -> AntiScalar {
    return anti_scalar_sqrt(sphere_sphere_anti_dot(self_, self_));
}

fn translator_weight_norm(self_: Translator) -> AntiScalar {
    return anti_scalar_sqrt(translator_translator_anti_dot(self_, self_));
}

fn anti_scalar_geometric_norm(self_: AntiScalar) -> Magnitude {
    return scalar_anti_scalar_add(anti_scalar_bulk_norm(self_), anti_scalar_weight_norm(self_));
}

fn circle_geometric_norm(self_: Circle) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(self_), circle_weight_norm(self_));
}

fn dipole_geometric_norm(self_: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(self_), dipole_weight_norm(self_));
}

fn flat_point_geometric_norm(self_: FlatPoint) -> Magnitude {
    return scalar_anti_scalar_add(flat_point_bulk_norm(self_), flat_point_weight_norm(self_));
}

fn flector_geometric_norm(self_: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(self_), flector_weight_norm(self_));
}

fn line_geometric_norm(self_: Line) -> Magnitude {
    return scalar_anti_scalar_add(line_bulk_norm(self_), line_weight_norm(self_));
}

fn line_at_origin_geometric_norm(self_: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(line_at_origin_bulk_norm(self_), line_at_origin_weight_norm(self_));
}

fn magnitude_geometric_norm(self_: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(magnitude_bulk_norm(self_), magnitude_weight_norm(self_));
}

fn motor_geometric_norm(self_: Motor) -> Magnitude {
    return scalar_anti_scalar_add(motor_bulk_norm(self_), motor_weight_norm(self_));
}

fn multi_vector_geometric_norm(self_: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(self_), multi_vector_weight_norm(self_));
}

fn plane_geometric_norm(self_: Plane) -> Magnitude {
    return scalar_anti_scalar_add(plane_bulk_norm(self_), plane_weight_norm(self_));
}

fn plane_at_origin_geometric_norm(self_: PlaneAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(plane_at_origin_bulk_norm(self_), plane_at_origin_weight_norm(self_));
}

fn point_at_origin_geometric_norm(self_: PointAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(point_at_origin_bulk_norm(self_), point_at_origin_weight_norm(self_));
}

fn rotor_geometric_norm(self_: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(rotor_bulk_norm(self_), rotor_weight_norm(self_));
}

fn round_point_geometric_norm(self_: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(round_point_bulk_norm(self_), round_point_weight_norm(self_));
}

fn scalar_geometric_norm(self_: Scalar) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(self_), scalar_weight_norm(self_));
}

fn sphere_geometric_norm(self_: Sphere) -> Magnitude {
    return scalar_anti_scalar_add(sphere_bulk_norm(self_), sphere_weight_norm(self_));
}

fn translator_geometric_norm(self_: Translator) -> Magnitude {
    return scalar_anti_scalar_add(translator_bulk_norm(self_), translator_weight_norm(self_));
}

fn anti_scalar_unitized_norm_squared(self_: AntiScalar) -> f32 {
    return anti_scalar_bulk_norm_squared(self_).g0 / anti_scalar_weight_norm_squared(self_).g0;
}

fn circle_unitized_norm_squared(self_: Circle) -> f32 {
    return circle_bulk_norm_squared(self_).g0 / circle_weight_norm_squared(self_).g0;
}

fn dipole_unitized_norm_squared(self_: Dipole) -> f32 {
    return dipole_bulk_norm_squared(self_).g0 / dipole_weight_norm_squared(self_).g0;
}

fn flat_point_unitized_norm_squared(self_: FlatPoint) -> f32 {
    return flat_point_bulk_norm_squared(self_).g0 / flat_point_weight_norm_squared(self_).g0;
}

fn flector_unitized_norm_squared(self_: Flector) -> f32 {
    return flector_bulk_norm_squared(self_).g0 / flector_weight_norm_squared(self_).g0;
}

fn line_unitized_norm_squared(self_: Line) -> f32 {
    return line_bulk_norm_squared(self_).g0 / line_weight_norm_squared(self_).g0;
}

fn line_at_origin_unitized_norm_squared(self_: LineAtOrigin) -> f32 {
    return line_at_origin_bulk_norm_squared(self_).g0 / line_at_origin_weight_norm_squared(self_).g0;
}

fn magnitude_unitized_norm_squared(self_: Magnitude) -> f32 {
    return magnitude_bulk_norm_squared(self_).g0 / magnitude_weight_norm_squared(self_).g0;
}

fn motor_unitized_norm_squared(self_: Motor) -> f32 {
    return motor_bulk_norm_squared(self_).g0 / motor_weight_norm_squared(self_).g0;
}

fn multi_vector_unitized_norm_squared(self_: MultiVector) -> f32 {
    return multi_vector_bulk_norm_squared(self_).g0 / multi_vector_weight_norm_squared(self_).g0;
}

fn plane_unitized_norm_squared(self_: Plane) -> f32 {
    return plane_bulk_norm_squared(self_).g0 / plane_weight_norm_squared(self_).g0;
}

fn plane_at_origin_unitized_norm_squared(self_: PlaneAtOrigin) -> f32 {
    return plane_at_origin_bulk_norm_squared(self_).g0 / plane_at_origin_weight_norm_squared(self_).g0;
}

fn point_at_origin_unitized_norm_squared(self_: PointAtOrigin) -> f32 {
    return point_at_origin_bulk_norm_squared(self_).g0 / point_at_origin_weight_norm_squared(self_).g0;
}

fn rotor_unitized_norm_squared(self_: Rotor) -> f32 {
    return rotor_bulk_norm_squared(self_).g0 / rotor_weight_norm_squared(self_).g0;
}

fn round_point_unitized_norm_squared(self_: RoundPoint) -> f32 {
    return round_point_bulk_norm_squared(self_).g0 / round_point_weight_norm_squared(self_).g0;
}

fn scalar_unitized_norm_squared(self_: Scalar) -> f32 {
    return scalar_bulk_norm_squared(self_).g0 / scalar_weight_norm_squared(self_).g0;
}

fn sphere_unitized_norm_squared(self_: Sphere) -> f32 {
    return sphere_bulk_norm_squared(self_).g0 / sphere_weight_norm_squared(self_).g0;
}

fn translator_unitized_norm_squared(self_: Translator) -> f32 {
    return translator_bulk_norm_squared(self_).g0 / translator_weight_norm_squared(self_).g0;
}

fn anti_scalar_unitized_norm(self_: AntiScalar) -> f32 {
    return sqrt(anti_scalar_unitized_norm_squared(self_));
}

fn circle_unitized_norm(self_: Circle) -> f32 {
    return sqrt(circle_unitized_norm_squared(self_));
}

fn dipole_unitized_norm(self_: Dipole) -> f32 {
    return sqrt(dipole_unitized_norm_squared(self_));
}

fn flat_point_unitized_norm(self_: FlatPoint) -> f32 {
    return sqrt(flat_point_unitized_norm_squared(self_));
}

fn flector_unitized_norm(self_: Flector) -> f32 {
    return sqrt(flector_unitized_norm_squared(self_));
}

fn line_unitized_norm(self_: Line) -> f32 {
    return sqrt(line_unitized_norm_squared(self_));
}

fn line_at_origin_unitized_norm(self_: LineAtOrigin) -> f32 {
    return sqrt(line_at_origin_unitized_norm_squared(self_));
}

fn magnitude_unitized_norm(self_: Magnitude) -> f32 {
    return sqrt(magnitude_unitized_norm_squared(self_));
}

fn motor_unitized_norm(self_: Motor) -> f32 {
    return sqrt(motor_unitized_norm_squared(self_));
}

fn multi_vector_unitized_norm(self_: MultiVector) -> f32 {
    return sqrt(multi_vector_unitized_norm_squared(self_));
}

fn plane_unitized_norm(self_: Plane) -> f32 {
    return sqrt(plane_unitized_norm_squared(self_));
}

fn plane_at_origin_unitized_norm(self_: PlaneAtOrigin) -> f32 {
    return sqrt(plane_at_origin_unitized_norm_squared(self_));
}

fn point_at_origin_unitized_norm(self_: PointAtOrigin) -> f32 {
    return sqrt(point_at_origin_unitized_norm_squared(self_));
}

fn rotor_unitized_norm(self_: Rotor) -> f32 {
    return sqrt(rotor_unitized_norm_squared(self_));
}

fn round_point_unitized_norm(self_: RoundPoint) -> f32 {
    return sqrt(round_point_unitized_norm_squared(self_));
}

fn scalar_unitized_norm(self_: Scalar) -> f32 {
    return sqrt(scalar_unitized_norm_squared(self_));
}

fn sphere_unitized_norm(self_: Sphere) -> f32 {
    return sqrt(sphere_unitized_norm_squared(self_));
}

fn translator_unitized_norm(self_: Translator) -> f32 {
    return sqrt(translator_unitized_norm_squared(self_));
}

fn circle_center_bulk_norm_squared(self_: Circle) -> Scalar {
    let round_bulk: RoundPoint = round_point_round_bulk(circle_center(self_));
    return round_point_round_point_dot(round_bulk, round_bulk);
}

fn dipole_center_bulk_norm_squared(self_: Dipole) -> Scalar {
    let round_bulk: RoundPoint = round_point_round_bulk(dipole_center(self_));
    return round_point_round_point_dot(round_bulk, round_bulk);
}

fn round_point_center_bulk_norm_squared(self_: RoundPoint) -> Scalar {
    let round_bulk: RoundPoint = round_point_round_bulk(round_point_center(self_));
    return round_point_round_point_dot(round_bulk, round_bulk);
}

fn sphere_center_bulk_norm_squared(self_: Sphere) -> Scalar {
    let round_bulk: RoundPoint = round_point_round_bulk(sphere_center(self_));
    return round_point_round_point_dot(round_bulk, round_bulk);
}

fn circle_center_bulk_norm(self_: Circle) -> Scalar {
    return scalar_sqrt(circle_center_bulk_norm_squared(self_));
}

fn dipole_center_bulk_norm(self_: Dipole) -> Scalar {
    return scalar_sqrt(dipole_center_bulk_norm_squared(self_));
}

fn round_point_center_bulk_norm(self_: RoundPoint) -> Scalar {
    return scalar_sqrt(round_point_center_bulk_norm_squared(self_));
}

fn sphere_center_bulk_norm(self_: Sphere) -> Scalar {
    return scalar_sqrt(sphere_center_bulk_norm_squared(self_));
}

fn anti_scalar_unitize(self_: AntiScalar) -> AntiScalar {
    return anti_scalar_scalar_geometric_product(self_, Scalar(1.0 / anti_scalar_weight_norm(self_).g0));
}

fn circle_unitize(self_: Circle) -> Circle {
    return circle_scalar_geometric_product(self_, Scalar(1.0 / circle_weight_norm(self_).g0));
}

fn dipole_unitize(self_: Dipole) -> Dipole {
    return dipole_scalar_geometric_product(self_, Scalar(1.0 / dipole_weight_norm(self_).g0));
}

fn flat_point_unitize(self_: FlatPoint) -> FlatPoint {
    return flat_point_scalar_geometric_product(self_, Scalar(1.0 / flat_point_weight_norm(self_).g0));
}

fn flector_unitize(self_: Flector) -> Flector {
    return flector_scalar_geometric_product(self_, Scalar(1.0 / flector_weight_norm(self_).g0));
}

fn line_unitize(self_: Line) -> Line {
    return line_scalar_geometric_product(self_, Scalar(1.0 / line_weight_norm(self_).g0));
}

fn line_at_origin_unitize(self_: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_scalar_geometric_product(self_, Scalar(1.0 / line_at_origin_weight_norm(self_).g0));
}

fn magnitude_unitize(self_: Magnitude) -> Magnitude {
    return magnitude_scalar_geometric_product(self_, Scalar(1.0 / magnitude_weight_norm(self_).g0));
}

fn motor_unitize(self_: Motor) -> Motor {
    return motor_scalar_geometric_product(self_, Scalar(1.0 / motor_weight_norm(self_).g0));
}

fn multi_vector_unitize(self_: MultiVector) -> MultiVector {
    return multi_vector_scalar_geometric_product(self_, Scalar(1.0 / multi_vector_weight_norm(self_).g0));
}

fn plane_unitize(self_: Plane) -> Plane {
    return plane_scalar_geometric_product(self_, Scalar(1.0 / plane_weight_norm(self_).g0));
}

fn plane_at_origin_unitize(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_scalar_geometric_product(self_, Scalar(1.0 / plane_at_origin_weight_norm(self_).g0));
}

fn point_at_origin_unitize(self_: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_scalar_geometric_product(self_, Scalar(1.0 / point_at_origin_weight_norm(self_).g0));
}

fn rotor_unitize(self_: Rotor) -> Rotor {
    return rotor_scalar_geometric_product(self_, Scalar(1.0 / rotor_weight_norm(self_).g0));
}

fn round_point_unitize(self_: RoundPoint) -> RoundPoint {
    return round_point_scalar_geometric_product(self_, Scalar(1.0 / round_point_weight_norm(self_).g0));
}

fn scalar_unitize(self_: Scalar) -> Scalar {
    return scalar_scalar_geometric_product(self_, Scalar(1.0 / scalar_weight_norm(self_).g0));
}

fn sphere_unitize(self_: Sphere) -> Sphere {
    return sphere_scalar_geometric_product(self_, Scalar(1.0 / sphere_weight_norm(self_).g0));
}

fn translator_unitize(self_: Translator) -> Translator {
    return translator_scalar_geometric_product(self_, Scalar(1.0 / translator_weight_norm(self_).g0));
}

fn anti_scalar_circle_sandwich(self_: AntiScalar, other: Circle) -> Circle {
    return circle_anti_scalar_geometric_anti_product(anti_scalar_circle_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_dipole_sandwich(self_: AntiScalar, other: Dipole) -> Dipole {
    return dipole_anti_scalar_geometric_anti_product(anti_scalar_dipole_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_flat_point_sandwich(self_: AntiScalar, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_geometric_anti_product(anti_scalar_flat_point_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_flector_sandwich(self_: AntiScalar, other: Flector) -> Flector {
    return flector_anti_scalar_geometric_anti_product(anti_scalar_flector_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_horizon_sandwich(self_: AntiScalar, other: Horizon) -> Horizon {
    return horizon_anti_scalar_geometric_anti_product(anti_scalar_horizon_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_infinity_sandwich(self_: AntiScalar, other: Infinity) -> Infinity {
    return infinity_anti_scalar_geometric_anti_product(anti_scalar_infinity_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_line_sandwich(self_: AntiScalar, other: Line) -> Line {
    return line_anti_scalar_geometric_anti_product(anti_scalar_line_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_line_at_infinity_sandwich(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_geometric_anti_product(anti_scalar_line_at_infinity_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_line_at_origin_sandwich(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_geometric_anti_product(anti_scalar_line_at_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_motor_sandwich(self_: AntiScalar, other: Motor) -> Motor {
    return motor_anti_scalar_geometric_anti_product(anti_scalar_motor_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_multi_vector_sandwich(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return multi_vector_anti_scalar_geometric_anti_product(anti_scalar_multi_vector_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_origin_sandwich(self_: AntiScalar, other: Origin) -> Origin {
    return origin_anti_scalar_geometric_anti_product(anti_scalar_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_plane_sandwich(self_: AntiScalar, other: Plane) -> Plane {
    return plane_anti_scalar_geometric_anti_product(anti_scalar_plane_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_plane_at_origin_sandwich(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_geometric_anti_product(anti_scalar_plane_at_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_point_at_infinity_sandwich(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_geometric_anti_product(anti_scalar_point_at_infinity_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_point_at_origin_sandwich(self_: AntiScalar, other: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_anti_scalar_geometric_anti_product(anti_scalar_point_at_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_rotor_sandwich(self_: AntiScalar, other: Rotor) -> Rotor {
    return rotor_anti_scalar_geometric_anti_product(anti_scalar_rotor_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_round_point_sandwich(self_: AntiScalar, other: RoundPoint) -> RoundPoint {
    return round_point_anti_scalar_geometric_anti_product(anti_scalar_round_point_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_sphere_sandwich(self_: AntiScalar, other: Sphere) -> Sphere {
    return sphere_anti_scalar_geometric_anti_product(anti_scalar_sphere_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_translator_sandwich(self_: AntiScalar, other: Translator) -> Translator {
    return translator_anti_scalar_geometric_anti_product(anti_scalar_translator_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn circle_circle_sandwich(self_: Circle, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_circle_geometric_anti_product(circle_circle_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_dipole_sandwich(self_: Circle, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_circle_geometric_anti_product(circle_dipole_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_flat_point_sandwich(self_: Circle, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_circle_geometric_anti_product(circle_flat_point_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_flector_sandwich(self_: Circle, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_circle_geometric_anti_product(circle_flector_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_horizon_sandwich(self_: Circle, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_circle_geometric_anti_product(circle_horizon_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_infinity_sandwich(self_: Circle, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_circle_geometric_anti_product(circle_infinity_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_line_sandwich(self_: Circle, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_circle_geometric_anti_product(circle_line_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_line_at_infinity_sandwich(self_: Circle, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_circle_geometric_anti_product(circle_line_at_infinity_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_line_at_origin_sandwich(self_: Circle, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_circle_geometric_anti_product(circle_line_at_origin_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_motor_sandwich(self_: Circle, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_circle_geometric_anti_product(circle_motor_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_multi_vector_sandwich(self_: Circle, other: MultiVector) -> MultiVector {
    return multi_vector_circle_geometric_anti_product(circle_multi_vector_geometric_anti_product(self_, other), circle_anti_reversal(self_));
}

fn circle_origin_sandwich(self_: Circle, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_circle_geometric_anti_product(circle_origin_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_plane_sandwich(self_: Circle, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_circle_geometric_anti_product(circle_plane_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_plane_at_origin_sandwich(self_: Circle, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_circle_geometric_anti_product(circle_plane_at_origin_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_point_at_infinity_sandwich(self_: Circle, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_circle_geometric_anti_product(circle_point_at_infinity_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_point_at_origin_sandwich(self_: Circle, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_circle_geometric_anti_product(circle_point_at_origin_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_rotor_sandwich(self_: Circle, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_circle_geometric_anti_product(circle_rotor_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_round_point_sandwich(self_: Circle, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_circle_geometric_anti_product(circle_round_point_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_sphere_sandwich(self_: Circle, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_circle_geometric_anti_product(circle_sphere_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn circle_translator_sandwich(self_: Circle, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_circle_geometric_anti_product(circle_translator_geometric_anti_product(self_, other), circle_anti_reversal(self_)));
}

fn dipole_circle_sandwich(self_: Dipole, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_dipole_geometric_anti_product(dipole_circle_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_dipole_sandwich(self_: Dipole, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_dipole_geometric_anti_product(dipole_dipole_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_flat_point_sandwich(self_: Dipole, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_dipole_geometric_anti_product(dipole_flat_point_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_flector_sandwich(self_: Dipole, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_dipole_geometric_anti_product(dipole_flector_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_horizon_sandwich(self_: Dipole, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_dipole_geometric_anti_product(dipole_horizon_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_infinity_sandwich(self_: Dipole, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_dipole_geometric_anti_product(dipole_infinity_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_line_sandwich(self_: Dipole, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_dipole_geometric_anti_product(dipole_line_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_line_at_infinity_sandwich(self_: Dipole, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_dipole_geometric_anti_product(dipole_line_at_infinity_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_line_at_origin_sandwich(self_: Dipole, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_dipole_geometric_anti_product(dipole_line_at_origin_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_motor_sandwich(self_: Dipole, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_dipole_geometric_anti_product(dipole_motor_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_multi_vector_sandwich(self_: Dipole, other: MultiVector) -> MultiVector {
    return multi_vector_dipole_geometric_anti_product(dipole_multi_vector_geometric_anti_product(self_, other), dipole_anti_reversal(self_));
}

fn dipole_origin_sandwich(self_: Dipole, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_dipole_geometric_anti_product(dipole_origin_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_plane_sandwich(self_: Dipole, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_dipole_geometric_anti_product(dipole_plane_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_plane_at_origin_sandwich(self_: Dipole, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_dipole_geometric_anti_product(dipole_plane_at_origin_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_point_at_infinity_sandwich(self_: Dipole, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_dipole_geometric_anti_product(dipole_point_at_infinity_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_point_at_origin_sandwich(self_: Dipole, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_dipole_geometric_anti_product(dipole_point_at_origin_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_rotor_sandwich(self_: Dipole, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_dipole_geometric_anti_product(dipole_rotor_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_round_point_sandwich(self_: Dipole, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_dipole_geometric_anti_product(dipole_round_point_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_sphere_sandwich(self_: Dipole, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_dipole_geometric_anti_product(dipole_sphere_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn dipole_translator_sandwich(self_: Dipole, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_dipole_geometric_anti_product(dipole_translator_geometric_anti_product(self_, other), dipole_anti_reversal(self_)));
}

fn flat_point_circle_sandwich(self_: FlatPoint, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_flat_point_geometric_anti_product(flat_point_circle_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_dipole_sandwich(self_: FlatPoint, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_flat_point_geometric_anti_product(flat_point_dipole_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_flat_point_sandwich(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return translator_flat_point_geometric_anti_product(flat_point_flat_point_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_flector_sandwich(self_: FlatPoint, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_flat_point_geometric_anti_product(flat_point_flector_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_horizon_sandwich(self_: FlatPoint, other: Horizon) -> Horizon {
    return infinity_flat_point_geometric_anti_product(flat_point_horizon_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_infinity_sandwich(self_: FlatPoint, other: Infinity) -> Infinity {
    return horizon_flat_point_geometric_anti_product(flat_point_infinity_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_line_sandwich(self_: FlatPoint, other: Line) -> Line {
    return multi_vector_line_into(flector_flat_point_geometric_anti_product(flat_point_line_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_line_at_infinity_sandwich(self_: FlatPoint, other: LineAtInfinity) -> LineAtInfinity {
    return point_at_infinity_flat_point_geometric_anti_product(flat_point_line_at_infinity_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_line_at_origin_sandwich(self_: FlatPoint, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_flat_point_geometric_anti_product(flat_point_line_at_origin_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_motor_sandwich(self_: FlatPoint, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_flat_point_geometric_anti_product(flat_point_motor_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_multi_vector_sandwich(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return multi_vector_flat_point_geometric_anti_product(flat_point_multi_vector_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_origin_sandwich(self_: FlatPoint, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_flat_point_geometric_anti_product(flat_point_origin_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_plane_sandwich(self_: FlatPoint, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_flat_point_geometric_anti_product(flat_point_plane_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_plane_at_origin_sandwich(self_: FlatPoint, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_flat_point_geometric_anti_product(flat_point_plane_at_origin_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_point_at_infinity_sandwich(self_: FlatPoint, other: PointAtInfinity) -> PointAtInfinity {
    return line_at_infinity_flat_point_geometric_anti_product(flat_point_point_at_infinity_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_point_at_origin_sandwich(self_: FlatPoint, other: PointAtOrigin) -> FlatPoint {
    return translator_flat_point_geometric_anti_product(flat_point_point_at_origin_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flat_point_rotor_sandwich(self_: FlatPoint, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_flat_point_geometric_anti_product(flat_point_rotor_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_round_point_sandwich(self_: FlatPoint, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_flat_point_geometric_anti_product(flat_point_round_point_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_sphere_sandwich(self_: FlatPoint, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_flat_point_geometric_anti_product(flat_point_sphere_geometric_anti_product(self_, other), flat_point_anti_reversal(self_)));
}

fn flat_point_translator_sandwich(self_: FlatPoint, other: Translator) -> Translator {
    return flat_point_flat_point_geometric_anti_product(flat_point_translator_geometric_anti_product(self_, other), flat_point_anti_reversal(self_));
}

fn flector_circle_sandwich(self_: Flector, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_flector_geometric_anti_product(flector_circle_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_dipole_sandwich(self_: Flector, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_flector_geometric_anti_product(flector_dipole_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_flat_point_sandwich(self_: Flector, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_flector_geometric_anti_product(flector_flat_point_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_flector_sandwich(self_: Flector, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_flector_geometric_anti_product(flector_flector_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_horizon_sandwich(self_: Flector, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_flector_geometric_anti_product(flector_horizon_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_infinity_sandwich(self_: Flector, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(flector_flector_geometric_anti_product(flector_infinity_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_line_sandwich(self_: Flector, other: Line) -> Line {
    return multi_vector_line_into(flector_flector_geometric_anti_product(flector_line_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_line_at_infinity_sandwich(self_: Flector, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(flector_flector_geometric_anti_product(flector_line_at_infinity_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_line_at_origin_sandwich(self_: Flector, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_flector_geometric_anti_product(flector_line_at_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_motor_sandwich(self_: Flector, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_flector_geometric_anti_product(flector_motor_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_multi_vector_sandwich(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_flector_geometric_anti_product(flector_multi_vector_geometric_anti_product(self_, other), flector_anti_reversal(self_));
}

fn flector_origin_sandwich(self_: Flector, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_flector_geometric_anti_product(flector_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_plane_sandwich(self_: Flector, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_flector_geometric_anti_product(flector_plane_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_plane_at_origin_sandwich(self_: Flector, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_flector_geometric_anti_product(flector_plane_at_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_point_at_infinity_sandwich(self_: Flector, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_flector_geometric_anti_product(flector_point_at_infinity_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_point_at_origin_sandwich(self_: Flector, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_flector_geometric_anti_product(flector_point_at_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_rotor_sandwich(self_: Flector, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_flector_geometric_anti_product(flector_rotor_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_round_point_sandwich(self_: Flector, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_flector_geometric_anti_product(flector_round_point_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_sphere_sandwich(self_: Flector, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_flector_geometric_anti_product(flector_sphere_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_translator_sandwich(self_: Flector, other: Translator) -> Motor {
    return multi_vector_motor_into(flector_flector_geometric_anti_product(flector_translator_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn horizon_circle_sandwich(self_: Horizon, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_horizon_geometric_anti_product(horizon_circle_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_dipole_sandwich(self_: Horizon, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_horizon_geometric_anti_product(horizon_dipole_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_flector_sandwich(self_: Horizon, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_horizon_geometric_anti_product(horizon_flector_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_motor_sandwich(self_: Horizon, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_horizon_geometric_anti_product(horizon_motor_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_multi_vector_sandwich(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_horizon_geometric_anti_product(horizon_multi_vector_geometric_anti_product(self_, other), horizon_anti_reversal(self_));
}

fn horizon_origin_sandwich(self_: Horizon, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_horizon_geometric_anti_product(horizon_origin_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_rotor_sandwich(self_: Horizon, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_horizon_geometric_anti_product(horizon_rotor_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_round_point_sandwich(self_: Horizon, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_horizon_geometric_anti_product(horizon_round_point_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_sphere_sandwich(self_: Horizon, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_horizon_geometric_anti_product(horizon_sphere_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn infinity_circle_sandwich(self_: Infinity, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_infinity_geometric_anti_product(infinity_circle_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn infinity_dipole_sandwich(self_: Infinity, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_infinity_geometric_anti_product(infinity_dipole_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn infinity_flector_sandwich(self_: Infinity, other: Flector) -> Flector {
    return flector_infinity_geometric_anti_product(infinity_flector_geometric_anti_product(self_, other), infinity_anti_reversal(self_));
}

fn infinity_motor_sandwich(self_: Infinity, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_infinity_geometric_anti_product(infinity_motor_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn infinity_multi_vector_sandwich(self_: Infinity, other: MultiVector) -> MultiVector {
    return multi_vector_infinity_geometric_anti_product(infinity_multi_vector_geometric_anti_product(self_, other), infinity_anti_reversal(self_));
}

fn infinity_origin_sandwich(self_: Infinity, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_infinity_geometric_anti_product(infinity_origin_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn infinity_rotor_sandwich(self_: Infinity, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_infinity_geometric_anti_product(infinity_rotor_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn infinity_round_point_sandwich(self_: Infinity, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_infinity_geometric_anti_product(infinity_round_point_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn infinity_sphere_sandwich(self_: Infinity, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_infinity_geometric_anti_product(infinity_sphere_geometric_anti_product(self_, other), infinity_anti_reversal(self_)));
}

fn line_circle_sandwich(self_: Line, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_line_geometric_anti_product(line_circle_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_dipole_sandwich(self_: Line, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_line_geometric_anti_product(line_dipole_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_flat_point_sandwich(self_: Line, other: FlatPoint) -> FlatPoint {
    return flector_flat_point_into(flector_line_geometric_anti_product(line_flat_point_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_flector_sandwich(self_: Line, other: Flector) -> Flector {
    return flector_line_geometric_anti_product(line_flector_geometric_anti_product(self_, other), line_anti_reversal(self_));
}

fn line_horizon_sandwich(self_: Line, other: Horizon) -> Plane {
    return flector_plane_into(point_at_infinity_line_geometric_anti_product(line_horizon_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_infinity_sandwich(self_: Line, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(line_at_infinity_line_geometric_anti_product(line_infinity_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_line_sandwich(self_: Line, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_line_geometric_anti_product(line_line_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_line_at_infinity_sandwich(self_: Line, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_line_geometric_anti_product(line_line_at_infinity_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_line_at_origin_sandwich(self_: Line, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_line_geometric_anti_product(line_line_at_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_motor_sandwich(self_: Line, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_geometric_anti_product(line_motor_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_multi_vector_sandwich(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_line_geometric_anti_product(line_multi_vector_geometric_anti_product(self_, other), line_anti_reversal(self_));
}

fn line_origin_sandwich(self_: Line, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_line_geometric_anti_product(line_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_plane_sandwich(self_: Line, other: Plane) -> Plane {
    return flector_plane_into(flector_line_geometric_anti_product(line_plane_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_plane_at_origin_sandwich(self_: Line, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_line_geometric_anti_product(line_plane_at_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_point_at_infinity_sandwich(self_: Line, other: PointAtInfinity) -> FlatPoint {
    return flector_flat_point_into(flector_line_geometric_anti_product(line_point_at_infinity_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_point_at_origin_sandwich(self_: Line, other: PointAtOrigin) -> FlatPoint {
    return flector_flat_point_into(flector_line_geometric_anti_product(line_point_at_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_rotor_sandwich(self_: Line, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_geometric_anti_product(line_rotor_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_round_point_sandwich(self_: Line, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_line_geometric_anti_product(line_round_point_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_sphere_sandwich(self_: Line, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_line_geometric_anti_product(line_sphere_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_translator_sandwich(self_: Line, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_line_geometric_anti_product(line_translator_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_at_infinity_circle_sandwich(self_: LineAtInfinity, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_circle_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_dipole_sandwich(self_: LineAtInfinity, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_dipole_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_flector_sandwich(self_: LineAtInfinity, other: Flector) -> Flector {
    return flector_line_at_infinity_geometric_anti_product(line_at_infinity_flector_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_));
}

fn line_at_infinity_line_sandwich(self_: LineAtInfinity, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_line_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_line_at_origin_sandwich(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_line_at_origin_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_motor_sandwich(self_: LineAtInfinity, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_motor_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_multi_vector_sandwich(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_multi_vector_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_));
}

fn line_at_infinity_origin_sandwich(self_: LineAtInfinity, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_origin_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_plane_sandwich(self_: LineAtInfinity, other: Plane) -> Plane {
    return flector_plane_into(flector_line_at_infinity_geometric_anti_product(line_at_infinity_plane_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_plane_at_origin_sandwich(self_: LineAtInfinity, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_line_at_infinity_geometric_anti_product(line_at_infinity_plane_at_origin_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_rotor_sandwich(self_: LineAtInfinity, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_rotor_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_round_point_sandwich(self_: LineAtInfinity, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_round_point_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_sphere_sandwich(self_: LineAtInfinity, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_sphere_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_origin_circle_sandwich(self_: LineAtOrigin, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_circle_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_dipole_sandwich(self_: LineAtOrigin, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_dipole_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_flat_point_sandwich(self_: LineAtOrigin, other: FlatPoint) -> FlatPoint {
    return flector_flat_point_into(flector_line_at_origin_geometric_anti_product(line_at_origin_flat_point_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_flector_sandwich(self_: LineAtOrigin, other: Flector) -> Flector {
    return flector_line_at_origin_geometric_anti_product(line_at_origin_flector_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_horizon_sandwich(self_: LineAtOrigin, other: Horizon) -> Plane {
    return flector_plane_into(point_at_infinity_line_at_origin_geometric_anti_product(line_at_origin_horizon_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_infinity_sandwich(self_: LineAtOrigin, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(line_at_infinity_line_at_origin_geometric_anti_product(line_at_origin_infinity_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_line_sandwich(self_: LineAtOrigin, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_line_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_line_at_infinity_sandwich(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_line_at_infinity_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_line_at_origin_sandwich(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return rotor_line_at_origin_geometric_anti_product(line_at_origin_line_at_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_motor_sandwich(self_: LineAtOrigin, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_motor_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_multi_vector_sandwich(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_line_at_origin_geometric_anti_product(line_at_origin_multi_vector_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_origin_sandwich(self_: LineAtOrigin, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(circle_line_at_origin_geometric_anti_product(line_at_origin_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_plane_sandwich(self_: LineAtOrigin, other: Plane) -> Plane {
    return flector_plane_into(flector_line_at_origin_geometric_anti_product(line_at_origin_plane_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_plane_at_origin_sandwich(self_: LineAtOrigin, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_line_at_origin_geometric_anti_product(line_at_origin_plane_at_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_point_at_infinity_sandwich(self_: LineAtOrigin, other: PointAtInfinity) -> FlatPoint {
    return flector_flat_point_into(flector_line_at_origin_geometric_anti_product(line_at_origin_point_at_infinity_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_point_at_origin_sandwich(self_: LineAtOrigin, other: PointAtOrigin) -> FlatPoint {
    return flector_flat_point_into(plane_at_origin_line_at_origin_geometric_anti_product(line_at_origin_point_at_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_rotor_sandwich(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return rotor_line_at_origin_geometric_anti_product(line_at_origin_rotor_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_round_point_sandwich(self_: LineAtOrigin, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_round_point_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_sphere_sandwich(self_: LineAtOrigin, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_sphere_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_translator_sandwich(self_: LineAtOrigin, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_translator_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn magnitude_circle_sandwich(self_: Magnitude, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_magnitude_geometric_anti_product(magnitude_circle_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_dipole_sandwich(self_: Magnitude, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_magnitude_geometric_anti_product(magnitude_dipole_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_flat_point_sandwich(self_: Magnitude, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_magnitude_geometric_anti_product(magnitude_flat_point_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_flector_sandwich(self_: Magnitude, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_magnitude_geometric_anti_product(magnitude_flector_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_horizon_sandwich(self_: Magnitude, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_magnitude_geometric_anti_product(magnitude_horizon_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_infinity_sandwich(self_: Magnitude, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_magnitude_geometric_anti_product(magnitude_infinity_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_line_sandwich(self_: Magnitude, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_magnitude_geometric_anti_product(magnitude_line_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_line_at_infinity_sandwich(self_: Magnitude, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_magnitude_geometric_anti_product(magnitude_line_at_infinity_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_line_at_origin_sandwich(self_: Magnitude, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_magnitude_geometric_anti_product(magnitude_line_at_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_motor_sandwich(self_: Magnitude, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_magnitude_geometric_anti_product(magnitude_motor_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_multi_vector_sandwich(self_: Magnitude, other: MultiVector) -> MultiVector {
    return multi_vector_magnitude_geometric_anti_product(magnitude_multi_vector_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_origin_sandwich(self_: Magnitude, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_magnitude_geometric_anti_product(magnitude_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_plane_sandwich(self_: Magnitude, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_magnitude_geometric_anti_product(magnitude_plane_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_plane_at_origin_sandwich(self_: Magnitude, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_magnitude_geometric_anti_product(magnitude_plane_at_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_point_at_infinity_sandwich(self_: Magnitude, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_magnitude_geometric_anti_product(magnitude_point_at_infinity_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_point_at_origin_sandwich(self_: Magnitude, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_magnitude_geometric_anti_product(magnitude_point_at_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_rotor_sandwich(self_: Magnitude, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_magnitude_geometric_anti_product(magnitude_rotor_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_round_point_sandwich(self_: Magnitude, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_magnitude_geometric_anti_product(magnitude_round_point_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_sphere_sandwich(self_: Magnitude, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_magnitude_geometric_anti_product(magnitude_sphere_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_translator_sandwich(self_: Magnitude, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_magnitude_geometric_anti_product(magnitude_translator_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn motor_circle_sandwich(self_: Motor, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_motor_geometric_anti_product(motor_circle_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_dipole_sandwich(self_: Motor, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_motor_geometric_anti_product(motor_dipole_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_flat_point_sandwich(self_: Motor, other: FlatPoint) -> FlatPoint {
    return flector_flat_point_into(flector_motor_geometric_anti_product(motor_flat_point_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_flector_sandwich(self_: Motor, other: Flector) -> Flector {
    return flector_motor_geometric_anti_product(motor_flector_geometric_anti_product(self_, other), motor_anti_reversal(self_));
}

fn motor_horizon_sandwich(self_: Motor, other: Horizon) -> Plane {
    return flector_plane_into(flector_motor_geometric_anti_product(motor_horizon_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_infinity_sandwich(self_: Motor, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_motor_geometric_anti_product(motor_infinity_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_line_sandwich(self_: Motor, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_motor_geometric_anti_product(motor_line_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_line_at_infinity_sandwich(self_: Motor, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_motor_geometric_anti_product(motor_line_at_infinity_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_line_at_origin_sandwich(self_: Motor, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_motor_geometric_anti_product(motor_line_at_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_motor_sandwich(self_: Motor, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_motor_geometric_anti_product(motor_motor_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_multi_vector_sandwich(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_motor_geometric_anti_product(motor_multi_vector_geometric_anti_product(self_, other), motor_anti_reversal(self_));
}

fn motor_origin_sandwich(self_: Motor, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_motor_geometric_anti_product(motor_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_plane_sandwich(self_: Motor, other: Plane) -> Plane {
    return flector_plane_into(flector_motor_geometric_anti_product(motor_plane_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_plane_at_origin_sandwich(self_: Motor, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_motor_geometric_anti_product(motor_plane_at_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_point_at_infinity_sandwich(self_: Motor, other: PointAtInfinity) -> FlatPoint {
    return flector_flat_point_into(flector_motor_geometric_anti_product(motor_point_at_infinity_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_point_at_origin_sandwich(self_: Motor, other: PointAtOrigin) -> FlatPoint {
    return flector_flat_point_into(flector_motor_geometric_anti_product(motor_point_at_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_rotor_sandwich(self_: Motor, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_motor_geometric_anti_product(motor_rotor_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_round_point_sandwich(self_: Motor, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_motor_geometric_anti_product(motor_round_point_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_sphere_sandwich(self_: Motor, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_motor_geometric_anti_product(motor_sphere_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_translator_sandwich(self_: Motor, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_motor_geometric_anti_product(motor_translator_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn multi_vector_circle_sandwich(self_: MultiVector, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_circle_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_dipole_sandwich(self_: MultiVector, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_dipole_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_flat_point_sandwich(self_: MultiVector, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_flat_point_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_flector_sandwich(self_: MultiVector, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_flector_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_horizon_sandwich(self_: MultiVector, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_horizon_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_infinity_sandwich(self_: MultiVector, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_infinity_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_line_sandwich(self_: MultiVector, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_line_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_line_at_infinity_sandwich(self_: MultiVector, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_line_at_infinity_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_line_at_origin_sandwich(self_: MultiVector, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_line_at_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_motor_sandwich(self_: MultiVector, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_motor_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_multi_vector_sandwich(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_geometric_anti_product(multi_vector_multi_vector_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_));
}

fn multi_vector_origin_sandwich(self_: MultiVector, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_plane_sandwich(self_: MultiVector, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_plane_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_plane_at_origin_sandwich(self_: MultiVector, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_plane_at_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_point_at_infinity_sandwich(self_: MultiVector, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_point_at_infinity_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_point_at_origin_sandwich(self_: MultiVector, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_point_at_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_rotor_sandwich(self_: MultiVector, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_rotor_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_round_point_sandwich(self_: MultiVector, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_round_point_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_sphere_sandwich(self_: MultiVector, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_sphere_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_translator_sandwich(self_: MultiVector, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_translator_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn origin_circle_sandwich(self_: Origin, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_origin_geometric_anti_product(origin_circle_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_dipole_sandwich(self_: Origin, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_origin_geometric_anti_product(origin_dipole_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_flat_point_sandwich(self_: Origin, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_origin_geometric_anti_product(origin_flat_point_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_flector_sandwich(self_: Origin, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_origin_geometric_anti_product(origin_flector_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_horizon_sandwich(self_: Origin, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_origin_geometric_anti_product(origin_horizon_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_infinity_sandwich(self_: Origin, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_origin_geometric_anti_product(origin_infinity_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_line_sandwich(self_: Origin, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_origin_geometric_anti_product(origin_line_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_line_at_infinity_sandwich(self_: Origin, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_origin_geometric_anti_product(origin_line_at_infinity_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_line_at_origin_sandwich(self_: Origin, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(circle_origin_geometric_anti_product(origin_line_at_origin_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_motor_sandwich(self_: Origin, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_origin_geometric_anti_product(origin_motor_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_multi_vector_sandwich(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_origin_geometric_anti_product(origin_multi_vector_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_plane_sandwich(self_: Origin, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_origin_geometric_anti_product(origin_plane_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_plane_at_origin_sandwich(self_: Origin, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(dipole_origin_geometric_anti_product(origin_plane_at_origin_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_point_at_infinity_sandwich(self_: Origin, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_origin_geometric_anti_product(origin_point_at_infinity_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_point_at_origin_sandwich(self_: Origin, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(sphere_origin_geometric_anti_product(origin_point_at_origin_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_rotor_sandwich(self_: Origin, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_origin_geometric_anti_product(origin_rotor_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_round_point_sandwich(self_: Origin, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_origin_geometric_anti_product(origin_round_point_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_sphere_sandwich(self_: Origin, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_origin_geometric_anti_product(origin_sphere_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_translator_sandwich(self_: Origin, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_origin_geometric_anti_product(origin_translator_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn plane_circle_sandwich(self_: Plane, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_plane_geometric_anti_product(plane_circle_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_dipole_sandwich(self_: Plane, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_plane_geometric_anti_product(plane_dipole_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_flat_point_sandwich(self_: Plane, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_plane_geometric_anti_product(plane_flat_point_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_flector_sandwich(self_: Plane, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_plane_geometric_anti_product(plane_flector_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_horizon_sandwich(self_: Plane, other: Horizon) -> Plane {
    return flector_plane_into(line_at_infinity_plane_geometric_anti_product(plane_horizon_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_infinity_sandwich(self_: Plane, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(point_at_infinity_plane_geometric_anti_product(plane_infinity_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_line_sandwich(self_: Plane, other: Line) -> Line {
    return multi_vector_line_into(flector_plane_geometric_anti_product(plane_line_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_line_at_infinity_sandwich(self_: Plane, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(flector_plane_geometric_anti_product(plane_line_at_infinity_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_line_at_origin_sandwich(self_: Plane, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_plane_geometric_anti_product(plane_line_at_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_motor_sandwich(self_: Plane, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_plane_geometric_anti_product(plane_motor_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_multi_vector_sandwich(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_plane_geometric_anti_product(plane_multi_vector_geometric_anti_product(self_, other), plane_anti_reversal(self_));
}

fn plane_origin_sandwich(self_: Plane, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_plane_geometric_anti_product(plane_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_plane_sandwich(self_: Plane, other: Plane) -> Plane {
    return flector_plane_into(motor_plane_geometric_anti_product(plane_plane_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_plane_at_origin_sandwich(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(motor_plane_geometric_anti_product(plane_plane_at_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_point_at_infinity_sandwich(self_: Plane, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_plane_geometric_anti_product(plane_point_at_infinity_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_point_at_origin_sandwich(self_: Plane, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_plane_geometric_anti_product(plane_point_at_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_rotor_sandwich(self_: Plane, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_plane_geometric_anti_product(plane_rotor_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_round_point_sandwich(self_: Plane, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_plane_geometric_anti_product(plane_round_point_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_sphere_sandwich(self_: Plane, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_plane_geometric_anti_product(plane_sphere_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_translator_sandwich(self_: Plane, other: Translator) -> Motor {
    return multi_vector_motor_into(flector_plane_geometric_anti_product(plane_translator_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_at_origin_circle_sandwich(self_: PlaneAtOrigin, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_circle_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_dipole_sandwich(self_: PlaneAtOrigin, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_dipole_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_flat_point_sandwich(self_: PlaneAtOrigin, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_flat_point_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_flector_sandwich(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_flector_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_horizon_sandwich(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return flector_plane_into(line_at_infinity_plane_at_origin_geometric_anti_product(plane_at_origin_horizon_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_infinity_sandwich(self_: PlaneAtOrigin, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(point_at_infinity_plane_at_origin_geometric_anti_product(plane_at_origin_infinity_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_line_sandwich(self_: PlaneAtOrigin, other: Line) -> Line {
    return multi_vector_line_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_line_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_line_at_infinity_sandwich(self_: PlaneAtOrigin, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_line_at_infinity_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_line_at_origin_sandwich(self_: PlaneAtOrigin, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_line_at_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_motor_sandwich(self_: PlaneAtOrigin, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_motor_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_multi_vector_sandwich(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_multi_vector_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_));
}

fn plane_at_origin_origin_sandwich(self_: PlaneAtOrigin, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(dipole_plane_at_origin_geometric_anti_product(plane_at_origin_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_plane_sandwich(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return flector_plane_into(motor_plane_at_origin_geometric_anti_product(plane_at_origin_plane_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_plane_at_origin_sandwich(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(rotor_plane_at_origin_geometric_anti_product(plane_at_origin_plane_at_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_point_at_infinity_sandwich(self_: PlaneAtOrigin, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_point_at_infinity_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_point_at_origin_sandwich(self_: PlaneAtOrigin, other: PointAtOrigin) -> FlatPoint {
    return flector_flat_point_into(line_at_origin_plane_at_origin_geometric_anti_product(plane_at_origin_point_at_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_rotor_sandwich(self_: PlaneAtOrigin, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_rotor_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_round_point_sandwich(self_: PlaneAtOrigin, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_round_point_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_sphere_sandwich(self_: PlaneAtOrigin, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_sphere_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_translator_sandwich(self_: PlaneAtOrigin, other: Translator) -> Motor {
    return multi_vector_motor_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_translator_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn point_at_infinity_circle_sandwich(self_: PointAtInfinity, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_circle_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_dipole_sandwich(self_: PointAtInfinity, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_dipole_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_flector_sandwich(self_: PointAtInfinity, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_flector_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_line_sandwich(self_: PointAtInfinity, other: Line) -> Line {
    return multi_vector_line_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_line_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_line_at_origin_sandwich(self_: PointAtInfinity, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_line_at_origin_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_motor_sandwich(self_: PointAtInfinity, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_motor_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_multi_vector_sandwich(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_multi_vector_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_));
}

fn point_at_infinity_origin_sandwich(self_: PointAtInfinity, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_origin_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_plane_sandwich(self_: PointAtInfinity, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_plane_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_plane_at_origin_sandwich(self_: PointAtInfinity, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_plane_at_origin_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_rotor_sandwich(self_: PointAtInfinity, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_rotor_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_round_point_sandwich(self_: PointAtInfinity, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_round_point_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_sphere_sandwich(self_: PointAtInfinity, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_sphere_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_origin_circle_sandwich(self_: PointAtOrigin, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_point_at_origin_geometric_anti_product(point_at_origin_circle_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_dipole_sandwich(self_: PointAtOrigin, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_point_at_origin_geometric_anti_product(point_at_origin_dipole_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_flat_point_sandwich(self_: PointAtOrigin, other: FlatPoint) -> FlatPoint {
    return translator_point_at_origin_geometric_anti_product(point_at_origin_flat_point_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_flector_sandwich(self_: PointAtOrigin, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_point_at_origin_geometric_anti_product(point_at_origin_flector_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_horizon_sandwich(self_: PointAtOrigin, other: Horizon) -> Horizon {
    return infinity_point_at_origin_geometric_anti_product(point_at_origin_horizon_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_infinity_sandwich(self_: PointAtOrigin, other: Infinity) -> Infinity {
    return horizon_point_at_origin_geometric_anti_product(point_at_origin_infinity_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_line_sandwich(self_: PointAtOrigin, other: Line) -> Line {
    return multi_vector_line_into(flector_point_at_origin_geometric_anti_product(point_at_origin_line_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_line_at_infinity_sandwich(self_: PointAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return point_at_infinity_point_at_origin_geometric_anti_product(point_at_origin_line_at_infinity_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_line_at_origin_sandwich(self_: PointAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return plane_at_origin_point_at_origin_geometric_anti_product(point_at_origin_line_at_origin_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_motor_sandwich(self_: PointAtOrigin, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_point_at_origin_geometric_anti_product(point_at_origin_motor_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_multi_vector_sandwich(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_point_at_origin_geometric_anti_product(point_at_origin_multi_vector_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_origin_sandwich(self_: PointAtOrigin, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(sphere_point_at_origin_geometric_anti_product(point_at_origin_origin_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_plane_sandwich(self_: PointAtOrigin, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_point_at_origin_geometric_anti_product(point_at_origin_plane_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_plane_at_origin_sandwich(self_: PointAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return line_at_origin_point_at_origin_geometric_anti_product(point_at_origin_plane_at_origin_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_point_at_infinity_sandwich(self_: PointAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return line_at_infinity_point_at_origin_geometric_anti_product(point_at_origin_point_at_infinity_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_point_at_origin_sandwich(self_: PointAtOrigin, other: PointAtOrigin) -> PointAtOrigin {
    return anti_scalar_point_at_origin_geometric_anti_product(point_at_origin_point_at_origin_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn point_at_origin_rotor_sandwich(self_: PointAtOrigin, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_point_at_origin_geometric_anti_product(point_at_origin_rotor_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_round_point_sandwich(self_: PointAtOrigin, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_point_at_origin_geometric_anti_product(point_at_origin_round_point_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_sphere_sandwich(self_: PointAtOrigin, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_point_at_origin_geometric_anti_product(point_at_origin_sphere_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_)));
}

fn point_at_origin_translator_sandwich(self_: PointAtOrigin, other: Translator) -> Translator {
    return flat_point_point_at_origin_geometric_anti_product(point_at_origin_translator_geometric_anti_product(self_, other), point_at_origin_anti_reversal(self_));
}

fn rotor_circle_sandwich(self_: Rotor, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_rotor_geometric_anti_product(rotor_circle_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_dipole_sandwich(self_: Rotor, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_rotor_geometric_anti_product(rotor_dipole_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_flat_point_sandwich(self_: Rotor, other: FlatPoint) -> FlatPoint {
    return flector_flat_point_into(flector_rotor_geometric_anti_product(rotor_flat_point_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_flector_sandwich(self_: Rotor, other: Flector) -> Flector {
    return flector_rotor_geometric_anti_product(rotor_flector_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_horizon_sandwich(self_: Rotor, other: Horizon) -> Plane {
    return flector_plane_into(flector_rotor_geometric_anti_product(rotor_horizon_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_infinity_sandwich(self_: Rotor, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_rotor_geometric_anti_product(rotor_infinity_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_line_sandwich(self_: Rotor, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_rotor_geometric_anti_product(rotor_line_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_line_at_infinity_sandwich(self_: Rotor, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_rotor_geometric_anti_product(rotor_line_at_infinity_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_line_at_origin_sandwich(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return rotor_rotor_geometric_anti_product(rotor_line_at_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_motor_sandwich(self_: Rotor, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_rotor_geometric_anti_product(rotor_motor_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_multi_vector_sandwich(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_rotor_geometric_anti_product(rotor_multi_vector_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_origin_sandwich(self_: Rotor, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_rotor_geometric_anti_product(rotor_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_plane_sandwich(self_: Rotor, other: Plane) -> Plane {
    return flector_plane_into(flector_rotor_geometric_anti_product(rotor_plane_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_plane_at_origin_sandwich(self_: Rotor, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_rotor_geometric_anti_product(rotor_plane_at_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_point_at_infinity_sandwich(self_: Rotor, other: PointAtInfinity) -> FlatPoint {
    return flector_flat_point_into(flector_rotor_geometric_anti_product(rotor_point_at_infinity_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_point_at_origin_sandwich(self_: Rotor, other: PointAtOrigin) -> FlatPoint {
    return flector_flat_point_into(flector_rotor_geometric_anti_product(rotor_point_at_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_rotor_sandwich(self_: Rotor, other: Rotor) -> Rotor {
    return rotor_rotor_geometric_anti_product(rotor_rotor_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_round_point_sandwich(self_: Rotor, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_rotor_geometric_anti_product(rotor_round_point_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_sphere_sandwich(self_: Rotor, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_rotor_geometric_anti_product(rotor_sphere_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_translator_sandwich(self_: Rotor, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_rotor_geometric_anti_product(rotor_translator_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn round_point_circle_sandwich(self_: RoundPoint, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_round_point_geometric_anti_product(round_point_circle_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_dipole_sandwich(self_: RoundPoint, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_round_point_geometric_anti_product(round_point_dipole_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_flat_point_sandwich(self_: RoundPoint, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_round_point_geometric_anti_product(round_point_flat_point_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_flector_sandwich(self_: RoundPoint, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_round_point_geometric_anti_product(round_point_flector_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_horizon_sandwich(self_: RoundPoint, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_round_point_geometric_anti_product(round_point_horizon_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_infinity_sandwich(self_: RoundPoint, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_round_point_geometric_anti_product(round_point_infinity_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_line_sandwich(self_: RoundPoint, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_round_point_geometric_anti_product(round_point_line_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_line_at_infinity_sandwich(self_: RoundPoint, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_round_point_geometric_anti_product(round_point_line_at_infinity_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_line_at_origin_sandwich(self_: RoundPoint, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_round_point_geometric_anti_product(round_point_line_at_origin_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_motor_sandwich(self_: RoundPoint, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_round_point_geometric_anti_product(round_point_motor_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_multi_vector_sandwich(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return multi_vector_round_point_geometric_anti_product(round_point_multi_vector_geometric_anti_product(self_, other), round_point_anti_reversal(self_));
}

fn round_point_origin_sandwich(self_: RoundPoint, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_round_point_geometric_anti_product(round_point_origin_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_plane_sandwich(self_: RoundPoint, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_round_point_geometric_anti_product(round_point_plane_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_plane_at_origin_sandwich(self_: RoundPoint, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_round_point_geometric_anti_product(round_point_plane_at_origin_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_point_at_infinity_sandwich(self_: RoundPoint, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_round_point_geometric_anti_product(round_point_point_at_infinity_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_point_at_origin_sandwich(self_: RoundPoint, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_round_point_geometric_anti_product(round_point_point_at_origin_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_rotor_sandwich(self_: RoundPoint, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_round_point_geometric_anti_product(round_point_rotor_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_round_point_sandwich(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_round_point_geometric_anti_product(round_point_round_point_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_sphere_sandwich(self_: RoundPoint, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_round_point_geometric_anti_product(round_point_sphere_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn round_point_translator_sandwich(self_: RoundPoint, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_round_point_geometric_anti_product(round_point_translator_geometric_anti_product(self_, other), round_point_anti_reversal(self_)));
}

fn scalar_circle_sandwich(self_: Scalar, other: Circle) -> Circle {
    return dipole_scalar_geometric_anti_product(scalar_circle_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_dipole_sandwich(self_: Scalar, other: Dipole) -> Dipole {
    return circle_scalar_geometric_anti_product(scalar_dipole_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_flat_point_sandwich(self_: Scalar, other: FlatPoint) -> FlatPoint {
    return dipole_flat_point_into(circle_scalar_geometric_anti_product(scalar_flat_point_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_flector_sandwich(self_: Scalar, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_scalar_geometric_anti_product(scalar_flector_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_horizon_sandwich(self_: Scalar, other: Horizon) -> Horizon {
    return infinity_scalar_geometric_anti_product(scalar_horizon_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_infinity_sandwich(self_: Scalar, other: Infinity) -> Infinity {
    return horizon_scalar_geometric_anti_product(scalar_infinity_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_line_sandwich(self_: Scalar, other: Line) -> Line {
    return circle_line_into(dipole_scalar_geometric_anti_product(scalar_line_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_line_at_infinity_sandwich(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return point_at_infinity_scalar_geometric_anti_product(scalar_line_at_infinity_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_line_at_origin_sandwich(self_: Scalar, other: LineAtOrigin) -> Line {
    return circle_line_into(dipole_scalar_geometric_anti_product(scalar_line_at_origin_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_motor_sandwich(self_: Scalar, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_scalar_geometric_anti_product(scalar_motor_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_multi_vector_sandwich(self_: Scalar, other: MultiVector) -> MultiVector {
    return multi_vector_scalar_geometric_anti_product(scalar_multi_vector_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_origin_sandwich(self_: Scalar, other: Origin) -> RoundPoint {
    return sphere_scalar_geometric_anti_product(scalar_origin_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_plane_sandwich(self_: Scalar, other: Plane) -> Plane {
    return sphere_plane_into(round_point_scalar_geometric_anti_product(scalar_plane_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_plane_at_origin_sandwich(self_: Scalar, other: PlaneAtOrigin) -> Plane {
    return sphere_plane_into(round_point_scalar_geometric_anti_product(scalar_plane_at_origin_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_point_at_infinity_sandwich(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return line_at_infinity_scalar_geometric_anti_product(scalar_point_at_infinity_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_point_at_origin_sandwich(self_: Scalar, other: PointAtOrigin) -> FlatPoint {
    return dipole_flat_point_into(circle_scalar_geometric_anti_product(scalar_point_at_origin_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_rotor_sandwich(self_: Scalar, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_scalar_geometric_anti_product(scalar_rotor_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_round_point_sandwich(self_: Scalar, other: RoundPoint) -> RoundPoint {
    return sphere_scalar_geometric_anti_product(scalar_round_point_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_sphere_sandwich(self_: Scalar, other: Sphere) -> Sphere {
    return round_point_scalar_geometric_anti_product(scalar_sphere_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_translator_sandwich(self_: Scalar, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_scalar_geometric_anti_product(scalar_translator_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn sphere_circle_sandwich(self_: Sphere, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_sphere_geometric_anti_product(sphere_circle_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_dipole_sandwich(self_: Sphere, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_sphere_geometric_anti_product(sphere_dipole_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_flat_point_sandwich(self_: Sphere, other: FlatPoint) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_sphere_geometric_anti_product(sphere_flat_point_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_flector_sandwich(self_: Sphere, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_sphere_geometric_anti_product(sphere_flector_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_horizon_sandwich(self_: Sphere, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_sphere_geometric_anti_product(sphere_horizon_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_infinity_sandwich(self_: Sphere, other: Infinity) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_sphere_geometric_anti_product(sphere_infinity_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_line_sandwich(self_: Sphere, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_sphere_geometric_anti_product(sphere_line_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_line_at_infinity_sandwich(self_: Sphere, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_sphere_geometric_anti_product(sphere_line_at_infinity_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_line_at_origin_sandwich(self_: Sphere, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_sphere_geometric_anti_product(sphere_line_at_origin_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_motor_sandwich(self_: Sphere, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_sphere_geometric_anti_product(sphere_motor_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_multi_vector_sandwich(self_: Sphere, other: MultiVector) -> MultiVector {
    return multi_vector_sphere_geometric_anti_product(sphere_multi_vector_geometric_anti_product(self_, other), sphere_anti_reversal(self_));
}

fn sphere_origin_sandwich(self_: Sphere, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_sphere_geometric_anti_product(sphere_origin_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_plane_sandwich(self_: Sphere, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_sphere_geometric_anti_product(sphere_plane_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_plane_at_origin_sandwich(self_: Sphere, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_sphere_geometric_anti_product(sphere_plane_at_origin_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_point_at_infinity_sandwich(self_: Sphere, other: PointAtInfinity) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_sphere_geometric_anti_product(sphere_point_at_infinity_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_point_at_origin_sandwich(self_: Sphere, other: PointAtOrigin) -> FlatPoint {
    return multi_vector_flat_point_into(multi_vector_sphere_geometric_anti_product(sphere_point_at_origin_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_rotor_sandwich(self_: Sphere, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_sphere_geometric_anti_product(sphere_rotor_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_round_point_sandwich(self_: Sphere, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_sphere_geometric_anti_product(sphere_round_point_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_sphere_sandwich(self_: Sphere, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_sphere_geometric_anti_product(sphere_sphere_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn sphere_translator_sandwich(self_: Sphere, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_sphere_geometric_anti_product(sphere_translator_geometric_anti_product(self_, other), sphere_anti_reversal(self_)));
}

fn translator_circle_sandwich(self_: Translator, other: Circle) -> Circle {
    return multi_vector_circle_into(multi_vector_translator_geometric_anti_product(translator_circle_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_dipole_sandwich(self_: Translator, other: Dipole) -> Dipole {
    return multi_vector_dipole_into(multi_vector_translator_geometric_anti_product(translator_dipole_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_flat_point_sandwich(self_: Translator, other: FlatPoint) -> FlatPoint {
    return flat_point_translator_geometric_anti_product(translator_flat_point_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_flector_sandwich(self_: Translator, other: Flector) -> Flector {
    return flector_translator_geometric_anti_product(translator_flector_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_horizon_sandwich(self_: Translator, other: Horizon) -> Horizon {
    return horizon_translator_geometric_anti_product(translator_horizon_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_infinity_sandwich(self_: Translator, other: Infinity) -> Infinity {
    return infinity_translator_geometric_anti_product(translator_infinity_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_line_sandwich(self_: Translator, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_translator_geometric_anti_product(translator_line_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_line_at_infinity_sandwich(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_translator_geometric_anti_product(translator_line_at_infinity_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_line_at_origin_sandwich(self_: Translator, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_translator_geometric_anti_product(translator_line_at_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_motor_sandwich(self_: Translator, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_translator_geometric_anti_product(translator_motor_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_multi_vector_sandwich(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_translator_geometric_anti_product(translator_multi_vector_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_origin_sandwich(self_: Translator, other: Origin) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_translator_geometric_anti_product(translator_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_plane_sandwich(self_: Translator, other: Plane) -> Plane {
    return flector_plane_into(flector_translator_geometric_anti_product(translator_plane_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_plane_at_origin_sandwich(self_: Translator, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_translator_geometric_anti_product(translator_plane_at_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_point_at_infinity_sandwich(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_translator_geometric_anti_product(translator_point_at_infinity_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_point_at_origin_sandwich(self_: Translator, other: PointAtOrigin) -> FlatPoint {
    return flat_point_translator_geometric_anti_product(translator_point_at_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_rotor_sandwich(self_: Translator, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_translator_geometric_anti_product(translator_rotor_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_round_point_sandwich(self_: Translator, other: RoundPoint) -> RoundPoint {
    return multi_vector_round_point_into(multi_vector_translator_geometric_anti_product(translator_round_point_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_sphere_sandwich(self_: Translator, other: Sphere) -> Sphere {
    return multi_vector_sphere_into(multi_vector_translator_geometric_anti_product(translator_sphere_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_translator_sandwich(self_: Translator, other: Translator) -> Translator {
    return translator_translator_geometric_anti_product(translator_translator_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn plane_circle_reflect(self_: Plane, other: Circle) -> Circle {
    return plane_circle_sandwich(plane_unitize(self_), other);
}

fn plane_dipole_reflect(self_: Plane, other: Dipole) -> Dipole {
    return plane_dipole_sandwich(plane_unitize(self_), other);
}

fn plane_flat_point_reflect(self_: Plane, other: FlatPoint) -> FlatPoint {
    return plane_flat_point_sandwich(plane_unitize(self_), other);
}

fn plane_flector_reflect(self_: Plane, other: Flector) -> Flector {
    return plane_flector_sandwich(plane_unitize(self_), other);
}

fn plane_horizon_reflect(self_: Plane, other: Horizon) -> Plane {
    return plane_horizon_sandwich(plane_unitize(self_), other);
}

fn plane_infinity_reflect(self_: Plane, other: Infinity) -> RoundPoint {
    return plane_infinity_sandwich(plane_unitize(self_), other);
}

fn plane_line_reflect(self_: Plane, other: Line) -> Line {
    return plane_line_sandwich(plane_unitize(self_), other);
}

fn plane_line_at_infinity_reflect(self_: Plane, other: LineAtInfinity) -> Line {
    return plane_line_at_infinity_sandwich(plane_unitize(self_), other);
}

fn plane_line_at_origin_reflect(self_: Plane, other: LineAtOrigin) -> Line {
    return plane_line_at_origin_sandwich(plane_unitize(self_), other);
}

fn plane_motor_reflect(self_: Plane, other: Motor) -> Motor {
    return plane_motor_sandwich(plane_unitize(self_), other);
}

fn plane_multi_vector_reflect(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_sandwich(plane_unitize(self_), other);
}

fn plane_origin_reflect(self_: Plane, other: Origin) -> RoundPoint {
    return plane_origin_sandwich(plane_unitize(self_), other);
}

fn plane_plane_reflect(self_: Plane, other: Plane) -> Plane {
    return plane_plane_sandwich(plane_unitize(self_), other);
}

fn plane_plane_at_origin_reflect(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return plane_plane_at_origin_sandwich(plane_unitize(self_), other);
}

fn plane_point_at_infinity_reflect(self_: Plane, other: PointAtInfinity) -> FlatPoint {
    return plane_point_at_infinity_sandwich(plane_unitize(self_), other);
}

fn plane_point_at_origin_reflect(self_: Plane, other: PointAtOrigin) -> FlatPoint {
    return plane_point_at_origin_sandwich(plane_unitize(self_), other);
}

fn plane_rotor_reflect(self_: Plane, other: Rotor) -> Motor {
    return plane_rotor_sandwich(plane_unitize(self_), other);
}

fn plane_round_point_reflect(self_: Plane, other: RoundPoint) -> RoundPoint {
    return plane_round_point_sandwich(plane_unitize(self_), other);
}

fn plane_sphere_reflect(self_: Plane, other: Sphere) -> Sphere {
    return plane_sphere_sandwich(plane_unitize(self_), other);
}

fn plane_translator_reflect(self_: Plane, other: Translator) -> Motor {
    return plane_translator_sandwich(plane_unitize(self_), other);
}

fn circle_circle_bulk_contraction(self_: Circle, other: Circle) -> Scalar {
    return circle_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn circle_dipole_bulk_contraction(self_: Circle, other: Dipole) -> RoundPoint {
    return circle_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn circle_flat_point_bulk_contraction(self_: Circle, other: FlatPoint) -> RoundPoint {
    return circle_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn circle_flector_bulk_contraction(self_: Circle, other: Flector) -> MultiVector {
    return circle_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn circle_infinity_bulk_contraction(self_: Circle, other: Infinity) -> Dipole {
    return circle_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn circle_line_bulk_contraction(self_: Circle, other: Line) -> Scalar {
    return circle_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn circle_line_at_infinity_bulk_contraction(self_: Circle, other: LineAtInfinity) -> Scalar {
    return circle_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn circle_motor_bulk_contraction(self_: Circle, other: Motor) -> Scalar {
    return circle_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn circle_multi_vector_bulk_contraction(self_: Circle, other: MultiVector) -> MultiVector {
    return circle_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn circle_point_at_infinity_bulk_contraction(self_: Circle, other: PointAtInfinity) -> RoundPoint {
    return circle_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn circle_round_point_bulk_contraction(self_: Circle, other: RoundPoint) -> Dipole {
    return circle_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn circle_translator_bulk_contraction(self_: Circle, other: Translator) -> Scalar {
    return circle_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn dipole_dipole_bulk_contraction(self_: Dipole, other: Dipole) -> Scalar {
    return dipole_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn dipole_flat_point_bulk_contraction(self_: Dipole, other: FlatPoint) -> Scalar {
    return dipole_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn dipole_flector_bulk_contraction(self_: Dipole, other: Flector) -> MultiVector {
    return dipole_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn dipole_infinity_bulk_contraction(self_: Dipole, other: Infinity) -> RoundPoint {
    return dipole_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn dipole_multi_vector_bulk_contraction(self_: Dipole, other: MultiVector) -> MultiVector {
    return dipole_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn dipole_point_at_infinity_bulk_contraction(self_: Dipole, other: PointAtInfinity) -> Scalar {
    return dipole_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn dipole_round_point_bulk_contraction(self_: Dipole, other: RoundPoint) -> RoundPoint {
    return dipole_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn flat_point_dipole_bulk_contraction(self_: FlatPoint, other: Dipole) -> Scalar {
    return flat_point_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn flat_point_flat_point_bulk_contraction(self_: FlatPoint, other: FlatPoint) -> Scalar {
    return flat_point_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn flat_point_flector_bulk_contraction(self_: FlatPoint, other: Flector) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn flat_point_infinity_bulk_contraction(self_: FlatPoint, other: Infinity) -> RoundPoint {
    return flat_point_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn flat_point_multi_vector_bulk_contraction(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn flat_point_point_at_infinity_bulk_contraction(self_: FlatPoint, other: PointAtInfinity) -> Scalar {
    return flat_point_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn flat_point_round_point_bulk_contraction(self_: FlatPoint, other: RoundPoint) -> RoundPoint {
    return flat_point_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn flector_circle_bulk_contraction(self_: Flector, other: Circle) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn flector_dipole_bulk_contraction(self_: Flector, other: Dipole) -> MultiVector {
    return flector_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn flector_flat_point_bulk_contraction(self_: Flector, other: FlatPoint) -> MultiVector {
    return flector_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn flector_flector_bulk_contraction(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn flector_horizon_bulk_contraction(self_: Flector, other: Horizon) -> Scalar {
    return flector_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn flector_infinity_bulk_contraction(self_: Flector, other: Infinity) -> MultiVector {
    return flector_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn flector_line_bulk_contraction(self_: Flector, other: Line) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn flector_line_at_infinity_bulk_contraction(self_: Flector, other: LineAtInfinity) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn flector_motor_bulk_contraction(self_: Flector, other: Motor) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn flector_multi_vector_bulk_contraction(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn flector_plane_bulk_contraction(self_: Flector, other: Plane) -> Scalar {
    return flector_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn flector_point_at_infinity_bulk_contraction(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return flector_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn flector_round_point_bulk_contraction(self_: Flector, other: RoundPoint) -> MultiVector {
    return flector_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn flector_sphere_bulk_contraction(self_: Flector, other: Sphere) -> Scalar {
    return flector_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn flector_translator_bulk_contraction(self_: Flector, other: Translator) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn horizon_circle_bulk_contraction(self_: Horizon, other: Circle) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn horizon_dipole_bulk_contraction(self_: Horizon, other: Dipole) -> Dipole {
    return horizon_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn horizon_flat_point_bulk_contraction(self_: Horizon, other: FlatPoint) -> Dipole {
    return horizon_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn horizon_flector_bulk_contraction(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn horizon_horizon_bulk_contraction(self_: Horizon, other: Horizon) -> Scalar {
    return horizon_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn horizon_infinity_bulk_contraction(self_: Horizon, other: Infinity) -> Circle {
    return horizon_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn horizon_line_bulk_contraction(self_: Horizon, other: Line) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn horizon_line_at_infinity_bulk_contraction(self_: Horizon, other: LineAtInfinity) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn horizon_motor_bulk_contraction(self_: Horizon, other: Motor) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn horizon_multi_vector_bulk_contraction(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn horizon_plane_bulk_contraction(self_: Horizon, other: Plane) -> Scalar {
    return horizon_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn horizon_point_at_infinity_bulk_contraction(self_: Horizon, other: PointAtInfinity) -> Dipole {
    return horizon_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn horizon_round_point_bulk_contraction(self_: Horizon, other: RoundPoint) -> Circle {
    return horizon_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn horizon_sphere_bulk_contraction(self_: Horizon, other: Sphere) -> Scalar {
    return horizon_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn horizon_translator_bulk_contraction(self_: Horizon, other: Translator) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn infinity_flector_bulk_contraction(self_: Infinity, other: Flector) -> MultiVector {
    return infinity_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn infinity_infinity_bulk_contraction(self_: Infinity, other: Infinity) -> Scalar {
    return infinity_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn infinity_multi_vector_bulk_contraction(self_: Infinity, other: MultiVector) -> MultiVector {
    return infinity_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn infinity_round_point_bulk_contraction(self_: Infinity, other: RoundPoint) -> Scalar {
    return infinity_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn line_circle_bulk_contraction(self_: Line, other: Circle) -> Scalar {
    return line_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn line_dipole_bulk_contraction(self_: Line, other: Dipole) -> RoundPoint {
    return line_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn line_flat_point_bulk_contraction(self_: Line, other: FlatPoint) -> RoundPoint {
    return line_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn line_flector_bulk_contraction(self_: Line, other: Flector) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn line_infinity_bulk_contraction(self_: Line, other: Infinity) -> Dipole {
    return line_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn line_line_bulk_contraction(self_: Line, other: Line) -> Scalar {
    return line_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn line_line_at_infinity_bulk_contraction(self_: Line, other: LineAtInfinity) -> Scalar {
    return line_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_motor_bulk_contraction(self_: Line, other: Motor) -> Scalar {
    return line_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn line_multi_vector_bulk_contraction(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_point_at_infinity_bulk_contraction(self_: Line, other: PointAtInfinity) -> RoundPoint {
    return line_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn line_round_point_bulk_contraction(self_: Line, other: RoundPoint) -> Dipole {
    return line_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn line_translator_bulk_contraction(self_: Line, other: Translator) -> Scalar {
    return line_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_infinity_circle_bulk_contraction(self_: LineAtInfinity, other: Circle) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn line_at_infinity_dipole_bulk_contraction(self_: LineAtInfinity, other: Dipole) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn line_at_infinity_flat_point_bulk_contraction(self_: LineAtInfinity, other: FlatPoint) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn line_at_infinity_flector_bulk_contraction(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_infinity_infinity_bulk_contraction(self_: LineAtInfinity, other: Infinity) -> Dipole {
    return line_at_infinity_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn line_at_infinity_line_bulk_contraction(self_: LineAtInfinity, other: Line) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn line_at_infinity_line_at_infinity_bulk_contraction(self_: LineAtInfinity, other: LineAtInfinity) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_at_infinity_motor_bulk_contraction(self_: LineAtInfinity, other: Motor) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn line_at_infinity_multi_vector_bulk_contraction(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_infinity_point_at_infinity_bulk_contraction(self_: LineAtInfinity, other: PointAtInfinity) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn line_at_infinity_round_point_bulk_contraction(self_: LineAtInfinity, other: RoundPoint) -> Dipole {
    return line_at_infinity_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn line_at_infinity_translator_bulk_contraction(self_: LineAtInfinity, other: Translator) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_origin_circle_bulk_contraction(self_: LineAtOrigin, other: Circle) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn line_at_origin_dipole_bulk_contraction(self_: LineAtOrigin, other: Dipole) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn line_at_origin_flat_point_bulk_contraction(self_: LineAtOrigin, other: FlatPoint) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn line_at_origin_flector_bulk_contraction(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_origin_infinity_bulk_contraction(self_: LineAtOrigin, other: Infinity) -> Dipole {
    return line_at_origin_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn line_at_origin_line_bulk_contraction(self_: LineAtOrigin, other: Line) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn line_at_origin_line_at_infinity_bulk_contraction(self_: LineAtOrigin, other: LineAtInfinity) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_at_origin_motor_bulk_contraction(self_: LineAtOrigin, other: Motor) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn line_at_origin_multi_vector_bulk_contraction(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_origin_point_at_infinity_bulk_contraction(self_: LineAtOrigin, other: PointAtInfinity) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn line_at_origin_round_point_bulk_contraction(self_: LineAtOrigin, other: RoundPoint) -> Dipole {
    return line_at_origin_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn line_at_origin_translator_bulk_contraction(self_: LineAtOrigin, other: Translator) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn motor_circle_bulk_contraction(self_: Motor, other: Circle) -> MultiVector {
    return motor_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn motor_dipole_bulk_contraction(self_: Motor, other: Dipole) -> MultiVector {
    return motor_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn motor_flat_point_bulk_contraction(self_: Motor, other: FlatPoint) -> MultiVector {
    return motor_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn motor_flector_bulk_contraction(self_: Motor, other: Flector) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn motor_horizon_bulk_contraction(self_: Motor, other: Horizon) -> Origin {
    return motor_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn motor_infinity_bulk_contraction(self_: Motor, other: Infinity) -> MultiVector {
    return motor_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn motor_line_bulk_contraction(self_: Motor, other: Line) -> MultiVector {
    return motor_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn motor_line_at_infinity_bulk_contraction(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return motor_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn motor_motor_bulk_contraction(self_: Motor, other: Motor) -> MultiVector {
    return motor_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn motor_multi_vector_bulk_contraction(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn motor_plane_bulk_contraction(self_: Motor, other: Plane) -> Origin {
    return motor_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn motor_point_at_infinity_bulk_contraction(self_: Motor, other: PointAtInfinity) -> MultiVector {
    return motor_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn motor_round_point_bulk_contraction(self_: Motor, other: RoundPoint) -> MultiVector {
    return motor_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn motor_sphere_bulk_contraction(self_: Motor, other: Sphere) -> Origin {
    return motor_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn motor_translator_bulk_contraction(self_: Motor, other: Translator) -> MultiVector {
    return motor_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn multi_vector_circle_bulk_contraction(self_: MultiVector, other: Circle) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn multi_vector_dipole_bulk_contraction(self_: MultiVector, other: Dipole) -> MultiVector {
    return multi_vector_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn multi_vector_flat_point_bulk_contraction(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return multi_vector_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn multi_vector_flector_bulk_contraction(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn multi_vector_horizon_bulk_contraction(self_: MultiVector, other: Horizon) -> MultiVector {
    return multi_vector_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn multi_vector_infinity_bulk_contraction(self_: MultiVector, other: Infinity) -> MultiVector {
    return multi_vector_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn multi_vector_line_bulk_contraction(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn multi_vector_line_at_infinity_bulk_contraction(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn multi_vector_motor_bulk_contraction(self_: MultiVector, other: Motor) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn multi_vector_multi_vector_bulk_contraction(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn multi_vector_plane_bulk_contraction(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn multi_vector_point_at_infinity_bulk_contraction(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multi_vector_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn multi_vector_round_point_bulk_contraction(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return multi_vector_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn multi_vector_sphere_bulk_contraction(self_: MultiVector, other: Sphere) -> MultiVector {
    return multi_vector_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn multi_vector_translator_bulk_contraction(self_: MultiVector, other: Translator) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn origin_flector_bulk_contraction(self_: Origin, other: Flector) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn origin_infinity_bulk_contraction(self_: Origin, other: Infinity) -> Scalar {
    return origin_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn origin_multi_vector_bulk_contraction(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn origin_round_point_bulk_contraction(self_: Origin, other: RoundPoint) -> Scalar {
    return origin_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn plane_circle_bulk_contraction(self_: Plane, other: Circle) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn plane_dipole_bulk_contraction(self_: Plane, other: Dipole) -> Dipole {
    return plane_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn plane_flat_point_bulk_contraction(self_: Plane, other: FlatPoint) -> Dipole {
    return plane_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn plane_flector_bulk_contraction(self_: Plane, other: Flector) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_horizon_bulk_contraction(self_: Plane, other: Horizon) -> Scalar {
    return plane_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn plane_infinity_bulk_contraction(self_: Plane, other: Infinity) -> Circle {
    return plane_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn plane_line_bulk_contraction(self_: Plane, other: Line) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn plane_line_at_infinity_bulk_contraction(self_: Plane, other: LineAtInfinity) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn plane_motor_bulk_contraction(self_: Plane, other: Motor) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn plane_multi_vector_bulk_contraction(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_plane_bulk_contraction(self_: Plane, other: Plane) -> Scalar {
    return plane_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn plane_point_at_infinity_bulk_contraction(self_: Plane, other: PointAtInfinity) -> Dipole {
    return plane_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn plane_round_point_bulk_contraction(self_: Plane, other: RoundPoint) -> Circle {
    return plane_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn plane_sphere_bulk_contraction(self_: Plane, other: Sphere) -> Scalar {
    return plane_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn plane_translator_bulk_contraction(self_: Plane, other: Translator) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn plane_at_origin_circle_bulk_contraction(self_: PlaneAtOrigin, other: Circle) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn plane_at_origin_dipole_bulk_contraction(self_: PlaneAtOrigin, other: Dipole) -> Dipole {
    return plane_at_origin_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn plane_at_origin_flat_point_bulk_contraction(self_: PlaneAtOrigin, other: FlatPoint) -> Dipole {
    return plane_at_origin_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn plane_at_origin_flector_bulk_contraction(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_at_origin_infinity_bulk_contraction(self_: PlaneAtOrigin, other: Infinity) -> Circle {
    return plane_at_origin_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn plane_at_origin_line_bulk_contraction(self_: PlaneAtOrigin, other: Line) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn plane_at_origin_line_at_infinity_bulk_contraction(self_: PlaneAtOrigin, other: LineAtInfinity) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn plane_at_origin_motor_bulk_contraction(self_: PlaneAtOrigin, other: Motor) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn plane_at_origin_multi_vector_bulk_contraction(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_at_origin_point_at_infinity_bulk_contraction(self_: PlaneAtOrigin, other: PointAtInfinity) -> Dipole {
    return plane_at_origin_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn plane_at_origin_round_point_bulk_contraction(self_: PlaneAtOrigin, other: RoundPoint) -> Circle {
    return plane_at_origin_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn plane_at_origin_translator_bulk_contraction(self_: PlaneAtOrigin, other: Translator) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn point_at_infinity_dipole_bulk_contraction(self_: PointAtInfinity, other: Dipole) -> Scalar {
    return point_at_infinity_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn point_at_infinity_flat_point_bulk_contraction(self_: PointAtInfinity, other: FlatPoint) -> Scalar {
    return point_at_infinity_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn point_at_infinity_flector_bulk_contraction(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn point_at_infinity_infinity_bulk_contraction(self_: PointAtInfinity, other: Infinity) -> RoundPoint {
    return point_at_infinity_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn point_at_infinity_multi_vector_bulk_contraction(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_infinity_point_at_infinity_bulk_contraction(self_: PointAtInfinity, other: PointAtInfinity) -> Scalar {
    return point_at_infinity_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_at_infinity_round_point_bulk_contraction(self_: PointAtInfinity, other: RoundPoint) -> RoundPoint {
    return point_at_infinity_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn point_at_origin_dipole_bulk_contraction(self_: PointAtOrigin, other: Dipole) -> Scalar {
    return point_at_origin_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn point_at_origin_flat_point_bulk_contraction(self_: PointAtOrigin, other: FlatPoint) -> Scalar {
    return point_at_origin_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn point_at_origin_flector_bulk_contraction(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn point_at_origin_infinity_bulk_contraction(self_: PointAtOrigin, other: Infinity) -> RoundPoint {
    return point_at_origin_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn point_at_origin_multi_vector_bulk_contraction(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_origin_point_at_infinity_bulk_contraction(self_: PointAtOrigin, other: PointAtInfinity) -> Scalar {
    return point_at_origin_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_at_origin_round_point_bulk_contraction(self_: PointAtOrigin, other: RoundPoint) -> RoundPoint {
    return point_at_origin_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn rotor_circle_bulk_contraction(self_: Rotor, other: Circle) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn rotor_dipole_bulk_contraction(self_: Rotor, other: Dipole) -> MultiVector {
    return rotor_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn rotor_flat_point_bulk_contraction(self_: Rotor, other: FlatPoint) -> MultiVector {
    return rotor_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn rotor_flector_bulk_contraction(self_: Rotor, other: Flector) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn rotor_horizon_bulk_contraction(self_: Rotor, other: Horizon) -> Origin {
    return rotor_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn rotor_infinity_bulk_contraction(self_: Rotor, other: Infinity) -> MultiVector {
    return rotor_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn rotor_line_bulk_contraction(self_: Rotor, other: Line) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn rotor_line_at_infinity_bulk_contraction(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn rotor_motor_bulk_contraction(self_: Rotor, other: Motor) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn rotor_multi_vector_bulk_contraction(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn rotor_plane_bulk_contraction(self_: Rotor, other: Plane) -> Origin {
    return rotor_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn rotor_point_at_infinity_bulk_contraction(self_: Rotor, other: PointAtInfinity) -> MultiVector {
    return rotor_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn rotor_round_point_bulk_contraction(self_: Rotor, other: RoundPoint) -> MultiVector {
    return rotor_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn rotor_sphere_bulk_contraction(self_: Rotor, other: Sphere) -> Origin {
    return rotor_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn rotor_translator_bulk_contraction(self_: Rotor, other: Translator) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn round_point_flector_bulk_contraction(self_: RoundPoint, other: Flector) -> MultiVector {
    return round_point_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn round_point_infinity_bulk_contraction(self_: RoundPoint, other: Infinity) -> Scalar {
    return round_point_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn round_point_multi_vector_bulk_contraction(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return round_point_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn round_point_round_point_bulk_contraction(self_: RoundPoint, other: RoundPoint) -> Scalar {
    return round_point_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn sphere_circle_bulk_contraction(self_: Sphere, other: Circle) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn sphere_dipole_bulk_contraction(self_: Sphere, other: Dipole) -> Dipole {
    return sphere_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn sphere_flat_point_bulk_contraction(self_: Sphere, other: FlatPoint) -> Dipole {
    return sphere_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn sphere_flector_bulk_contraction(self_: Sphere, other: Flector) -> MultiVector {
    return sphere_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn sphere_horizon_bulk_contraction(self_: Sphere, other: Horizon) -> Scalar {
    return sphere_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn sphere_infinity_bulk_contraction(self_: Sphere, other: Infinity) -> Circle {
    return sphere_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn sphere_line_bulk_contraction(self_: Sphere, other: Line) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn sphere_line_at_infinity_bulk_contraction(self_: Sphere, other: LineAtInfinity) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn sphere_motor_bulk_contraction(self_: Sphere, other: Motor) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn sphere_multi_vector_bulk_contraction(self_: Sphere, other: MultiVector) -> MultiVector {
    return sphere_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn sphere_plane_bulk_contraction(self_: Sphere, other: Plane) -> Scalar {
    return sphere_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn sphere_point_at_infinity_bulk_contraction(self_: Sphere, other: PointAtInfinity) -> Dipole {
    return sphere_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn sphere_round_point_bulk_contraction(self_: Sphere, other: RoundPoint) -> Circle {
    return sphere_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn sphere_sphere_bulk_contraction(self_: Sphere, other: Sphere) -> Scalar {
    return sphere_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn sphere_translator_bulk_contraction(self_: Sphere, other: Translator) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn translator_circle_bulk_contraction(self_: Translator, other: Circle) -> MultiVector {
    return translator_dipole_anti_wedge(self_, circle_right_bulk_dual(other));
}

fn translator_dipole_bulk_contraction(self_: Translator, other: Dipole) -> MultiVector {
    return translator_circle_anti_wedge(self_, dipole_right_bulk_dual(other));
}

fn translator_flat_point_bulk_contraction(self_: Translator, other: FlatPoint) -> MultiVector {
    return translator_circle_anti_wedge(self_, flat_point_right_bulk_dual(other));
}

fn translator_flector_bulk_contraction(self_: Translator, other: Flector) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn translator_horizon_bulk_contraction(self_: Translator, other: Horizon) -> Origin {
    return translator_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn translator_infinity_bulk_contraction(self_: Translator, other: Infinity) -> MultiVector {
    return translator_sphere_anti_wedge(self_, infinity_right_bulk_dual(other));
}

fn translator_line_bulk_contraction(self_: Translator, other: Line) -> MultiVector {
    return translator_dipole_anti_wedge(self_, line_right_bulk_dual(other));
}

fn translator_line_at_infinity_bulk_contraction(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return translator_dipole_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn translator_motor_bulk_contraction(self_: Translator, other: Motor) -> MultiVector {
    return translator_dipole_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn translator_multi_vector_bulk_contraction(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn translator_plane_bulk_contraction(self_: Translator, other: Plane) -> Origin {
    return translator_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn translator_point_at_infinity_bulk_contraction(self_: Translator, other: PointAtInfinity) -> MultiVector {
    return translator_circle_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn translator_round_point_bulk_contraction(self_: Translator, other: RoundPoint) -> MultiVector {
    return translator_sphere_anti_wedge(self_, round_point_right_bulk_dual(other));
}

fn translator_sphere_bulk_contraction(self_: Translator, other: Sphere) -> Origin {
    return translator_origin_anti_wedge(self_, sphere_right_bulk_dual(other));
}

fn translator_translator_bulk_contraction(self_: Translator, other: Translator) -> MultiVector {
    return translator_dipole_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn circle_circle_weight_contraction(self_: Circle, other: Circle) -> Scalar {
    return circle_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn circle_dipole_weight_contraction(self_: Circle, other: Dipole) -> RoundPoint {
    return circle_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn circle_flat_point_weight_contraction(self_: Circle, other: FlatPoint) -> RoundPoint {
    return circle_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn circle_flector_weight_contraction(self_: Circle, other: Flector) -> MultiVector {
    return circle_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn circle_line_weight_contraction(self_: Circle, other: Line) -> Scalar {
    return circle_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn circle_line_at_origin_weight_contraction(self_: Circle, other: LineAtOrigin) -> Scalar {
    return circle_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn circle_motor_weight_contraction(self_: Circle, other: Motor) -> MultiVector {
    return circle_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn circle_multi_vector_weight_contraction(self_: Circle, other: MultiVector) -> MultiVector {
    return circle_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn circle_point_at_origin_weight_contraction(self_: Circle, other: PointAtOrigin) -> RoundPoint {
    return circle_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn circle_rotor_weight_contraction(self_: Circle, other: Rotor) -> MultiVector {
    return circle_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn dipole_dipole_weight_contraction(self_: Dipole, other: Dipole) -> Scalar {
    return dipole_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn dipole_flat_point_weight_contraction(self_: Dipole, other: FlatPoint) -> Scalar {
    return dipole_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn dipole_flector_weight_contraction(self_: Dipole, other: Flector) -> MultiVector {
    return dipole_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn dipole_motor_weight_contraction(self_: Dipole, other: Motor) -> MultiVector {
    return dipole_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn dipole_multi_vector_weight_contraction(self_: Dipole, other: MultiVector) -> MultiVector {
    return dipole_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn dipole_point_at_origin_weight_contraction(self_: Dipole, other: PointAtOrigin) -> Scalar {
    return dipole_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn dipole_rotor_weight_contraction(self_: Dipole, other: Rotor) -> MultiVector {
    return dipole_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn flat_point_dipole_weight_contraction(self_: FlatPoint, other: Dipole) -> Scalar {
    return flat_point_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn flat_point_flat_point_weight_contraction(self_: FlatPoint, other: FlatPoint) -> Scalar {
    return flat_point_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn flat_point_flector_weight_contraction(self_: FlatPoint, other: Flector) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn flat_point_motor_weight_contraction(self_: FlatPoint, other: Motor) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn flat_point_multi_vector_weight_contraction(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn flat_point_point_at_origin_weight_contraction(self_: FlatPoint, other: PointAtOrigin) -> Scalar {
    return flat_point_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn flat_point_rotor_weight_contraction(self_: FlatPoint, other: Rotor) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn flector_circle_weight_contraction(self_: Flector, other: Circle) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn flector_dipole_weight_contraction(self_: Flector, other: Dipole) -> MultiVector {
    return flector_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn flector_flat_point_weight_contraction(self_: Flector, other: FlatPoint) -> MultiVector {
    return flector_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn flector_flector_weight_contraction(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn flector_line_weight_contraction(self_: Flector, other: Line) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn flector_line_at_origin_weight_contraction(self_: Flector, other: LineAtOrigin) -> RoundPoint {
    return flector_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn flector_motor_weight_contraction(self_: Flector, other: Motor) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn flector_multi_vector_weight_contraction(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn flector_plane_weight_contraction(self_: Flector, other: Plane) -> Scalar {
    return flector_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn flector_plane_at_origin_weight_contraction(self_: Flector, other: PlaneAtOrigin) -> Scalar {
    return flector_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn flector_point_at_origin_weight_contraction(self_: Flector, other: PointAtOrigin) -> MultiVector {
    return flector_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn flector_rotor_weight_contraction(self_: Flector, other: Rotor) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn flector_sphere_weight_contraction(self_: Flector, other: Sphere) -> Scalar {
    return flector_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn horizon_circle_weight_contraction(self_: Horizon, other: Circle) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn horizon_dipole_weight_contraction(self_: Horizon, other: Dipole) -> Dipole {
    return horizon_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn horizon_flat_point_weight_contraction(self_: Horizon, other: FlatPoint) -> Dipole {
    return horizon_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn horizon_flector_weight_contraction(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn horizon_line_weight_contraction(self_: Horizon, other: Line) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn horizon_line_at_origin_weight_contraction(self_: Horizon, other: LineAtOrigin) -> RoundPoint {
    return horizon_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn horizon_motor_weight_contraction(self_: Horizon, other: Motor) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn horizon_multi_vector_weight_contraction(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn horizon_plane_weight_contraction(self_: Horizon, other: Plane) -> Scalar {
    return horizon_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn horizon_plane_at_origin_weight_contraction(self_: Horizon, other: PlaneAtOrigin) -> Scalar {
    return horizon_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn horizon_point_at_origin_weight_contraction(self_: Horizon, other: PointAtOrigin) -> Dipole {
    return horizon_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn horizon_rotor_weight_contraction(self_: Horizon, other: Rotor) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn horizon_sphere_weight_contraction(self_: Horizon, other: Sphere) -> Scalar {
    return horizon_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn infinity_flector_weight_contraction(self_: Infinity, other: Flector) -> MultiVector {
    return infinity_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn infinity_motor_weight_contraction(self_: Infinity, other: Motor) -> MultiVector {
    return infinity_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn infinity_multi_vector_weight_contraction(self_: Infinity, other: MultiVector) -> MultiVector {
    return infinity_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn infinity_rotor_weight_contraction(self_: Infinity, other: Rotor) -> MultiVector {
    return infinity_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn line_circle_weight_contraction(self_: Line, other: Circle) -> Scalar {
    return line_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn line_dipole_weight_contraction(self_: Line, other: Dipole) -> RoundPoint {
    return line_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn line_flat_point_weight_contraction(self_: Line, other: FlatPoint) -> RoundPoint {
    return line_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn line_flector_weight_contraction(self_: Line, other: Flector) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn line_line_weight_contraction(self_: Line, other: Line) -> Scalar {
    return line_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn line_line_at_origin_weight_contraction(self_: Line, other: LineAtOrigin) -> Scalar {
    return line_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_motor_weight_contraction(self_: Line, other: Motor) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn line_multi_vector_weight_contraction(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_point_at_origin_weight_contraction(self_: Line, other: PointAtOrigin) -> RoundPoint {
    return line_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn line_rotor_weight_contraction(self_: Line, other: Rotor) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn line_at_infinity_circle_weight_contraction(self_: LineAtInfinity, other: Circle) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn line_at_infinity_dipole_weight_contraction(self_: LineAtInfinity, other: Dipole) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn line_at_infinity_flat_point_weight_contraction(self_: LineAtInfinity, other: FlatPoint) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn line_at_infinity_flector_weight_contraction(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_infinity_line_weight_contraction(self_: LineAtInfinity, other: Line) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn line_at_infinity_line_at_origin_weight_contraction(self_: LineAtInfinity, other: LineAtOrigin) -> Scalar {
    return line_at_infinity_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_at_infinity_motor_weight_contraction(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn line_at_infinity_multi_vector_weight_contraction(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_infinity_point_at_origin_weight_contraction(self_: LineAtInfinity, other: PointAtOrigin) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn line_at_infinity_rotor_weight_contraction(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn line_at_origin_circle_weight_contraction(self_: LineAtOrigin, other: Circle) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn line_at_origin_dipole_weight_contraction(self_: LineAtOrigin, other: Dipole) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn line_at_origin_flat_point_weight_contraction(self_: LineAtOrigin, other: FlatPoint) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn line_at_origin_flector_weight_contraction(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_origin_line_weight_contraction(self_: LineAtOrigin, other: Line) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn line_at_origin_line_at_origin_weight_contraction(self_: LineAtOrigin, other: LineAtOrigin) -> Scalar {
    return line_at_origin_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_at_origin_motor_weight_contraction(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn line_at_origin_multi_vector_weight_contraction(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_origin_point_at_origin_weight_contraction(self_: LineAtOrigin, other: PointAtOrigin) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn line_at_origin_rotor_weight_contraction(self_: LineAtOrigin, other: Rotor) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn motor_circle_weight_contraction(self_: Motor, other: Circle) -> MultiVector {
    return motor_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn motor_dipole_weight_contraction(self_: Motor, other: Dipole) -> MultiVector {
    return motor_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn motor_flat_point_weight_contraction(self_: Motor, other: FlatPoint) -> MultiVector {
    return motor_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn motor_flector_weight_contraction(self_: Motor, other: Flector) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn motor_line_weight_contraction(self_: Motor, other: Line) -> MultiVector {
    return motor_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn motor_line_at_origin_weight_contraction(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return motor_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn motor_motor_weight_contraction(self_: Motor, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn motor_multi_vector_weight_contraction(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn motor_plane_weight_contraction(self_: Motor, other: Plane) -> RoundPoint {
    return motor_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn motor_plane_at_origin_weight_contraction(self_: Motor, other: PlaneAtOrigin) -> RoundPoint {
    return motor_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn motor_point_at_origin_weight_contraction(self_: Motor, other: PointAtOrigin) -> MultiVector {
    return motor_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn motor_rotor_weight_contraction(self_: Motor, other: Rotor) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn motor_sphere_weight_contraction(self_: Motor, other: Sphere) -> RoundPoint {
    return motor_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn motor_translator_weight_contraction(self_: Motor, other: Translator) -> Scalar {
    return motor_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn multi_vector_circle_weight_contraction(self_: MultiVector, other: Circle) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn multi_vector_dipole_weight_contraction(self_: MultiVector, other: Dipole) -> MultiVector {
    return multi_vector_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn multi_vector_flat_point_weight_contraction(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return multi_vector_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn multi_vector_flector_weight_contraction(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn multi_vector_line_weight_contraction(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn multi_vector_line_at_origin_weight_contraction(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multi_vector_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn multi_vector_motor_weight_contraction(self_: MultiVector, other: Motor) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn multi_vector_multi_vector_weight_contraction(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn multi_vector_plane_weight_contraction(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn multi_vector_plane_at_origin_weight_contraction(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multi_vector_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn multi_vector_point_at_origin_weight_contraction(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return multi_vector_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn multi_vector_rotor_weight_contraction(self_: MultiVector, other: Rotor) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn multi_vector_sphere_weight_contraction(self_: MultiVector, other: Sphere) -> MultiVector {
    return multi_vector_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn multi_vector_translator_weight_contraction(self_: MultiVector, other: Translator) -> Scalar {
    return multi_vector_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn origin_flector_weight_contraction(self_: Origin, other: Flector) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn origin_motor_weight_contraction(self_: Origin, other: Motor) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn origin_multi_vector_weight_contraction(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn origin_rotor_weight_contraction(self_: Origin, other: Rotor) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn plane_circle_weight_contraction(self_: Plane, other: Circle) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn plane_dipole_weight_contraction(self_: Plane, other: Dipole) -> Dipole {
    return plane_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn plane_flat_point_weight_contraction(self_: Plane, other: FlatPoint) -> Dipole {
    return plane_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn plane_flector_weight_contraction(self_: Plane, other: Flector) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn plane_line_weight_contraction(self_: Plane, other: Line) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn plane_line_at_origin_weight_contraction(self_: Plane, other: LineAtOrigin) -> RoundPoint {
    return plane_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn plane_motor_weight_contraction(self_: Plane, other: Motor) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn plane_multi_vector_weight_contraction(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_plane_weight_contraction(self_: Plane, other: Plane) -> Scalar {
    return plane_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn plane_plane_at_origin_weight_contraction(self_: Plane, other: PlaneAtOrigin) -> Scalar {
    return plane_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_point_at_origin_weight_contraction(self_: Plane, other: PointAtOrigin) -> Dipole {
    return plane_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn plane_rotor_weight_contraction(self_: Plane, other: Rotor) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn plane_sphere_weight_contraction(self_: Plane, other: Sphere) -> Scalar {
    return plane_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn plane_at_origin_circle_weight_contraction(self_: PlaneAtOrigin, other: Circle) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn plane_at_origin_dipole_weight_contraction(self_: PlaneAtOrigin, other: Dipole) -> Dipole {
    return plane_at_origin_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn plane_at_origin_flat_point_weight_contraction(self_: PlaneAtOrigin, other: FlatPoint) -> Dipole {
    return plane_at_origin_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn plane_at_origin_flector_weight_contraction(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn plane_at_origin_line_weight_contraction(self_: PlaneAtOrigin, other: Line) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn plane_at_origin_line_at_origin_weight_contraction(self_: PlaneAtOrigin, other: LineAtOrigin) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn plane_at_origin_motor_weight_contraction(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn plane_at_origin_multi_vector_weight_contraction(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_at_origin_plane_weight_contraction(self_: PlaneAtOrigin, other: Plane) -> Scalar {
    return plane_at_origin_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn plane_at_origin_plane_at_origin_weight_contraction(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Scalar {
    return plane_at_origin_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_at_origin_point_at_origin_weight_contraction(self_: PlaneAtOrigin, other: PointAtOrigin) -> Dipole {
    return plane_at_origin_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn plane_at_origin_rotor_weight_contraction(self_: PlaneAtOrigin, other: Rotor) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn plane_at_origin_sphere_weight_contraction(self_: PlaneAtOrigin, other: Sphere) -> Scalar {
    return plane_at_origin_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn point_at_infinity_dipole_weight_contraction(self_: PointAtInfinity, other: Dipole) -> Scalar {
    return point_at_infinity_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn point_at_infinity_flat_point_weight_contraction(self_: PointAtInfinity, other: FlatPoint) -> Scalar {
    return point_at_infinity_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn point_at_infinity_flector_weight_contraction(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn point_at_infinity_motor_weight_contraction(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn point_at_infinity_multi_vector_weight_contraction(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_at_infinity_point_at_origin_weight_contraction(self_: PointAtInfinity, other: PointAtOrigin) -> Scalar {
    return point_at_infinity_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn point_at_infinity_rotor_weight_contraction(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn point_at_origin_dipole_weight_contraction(self_: PointAtOrigin, other: Dipole) -> Scalar {
    return point_at_origin_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn point_at_origin_flat_point_weight_contraction(self_: PointAtOrigin, other: FlatPoint) -> Scalar {
    return point_at_origin_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn point_at_origin_flector_weight_contraction(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn point_at_origin_motor_weight_contraction(self_: PointAtOrigin, other: Motor) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn point_at_origin_multi_vector_weight_contraction(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_at_origin_point_at_origin_weight_contraction(self_: PointAtOrigin, other: PointAtOrigin) -> Scalar {
    return point_at_origin_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn point_at_origin_rotor_weight_contraction(self_: PointAtOrigin, other: Rotor) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn rotor_circle_weight_contraction(self_: Rotor, other: Circle) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn rotor_dipole_weight_contraction(self_: Rotor, other: Dipole) -> MultiVector {
    return rotor_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn rotor_flat_point_weight_contraction(self_: Rotor, other: FlatPoint) -> MultiVector {
    return rotor_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn rotor_flector_weight_contraction(self_: Rotor, other: Flector) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn rotor_line_weight_contraction(self_: Rotor, other: Line) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn rotor_line_at_origin_weight_contraction(self_: Rotor, other: LineAtOrigin) -> MultiVector {
    return rotor_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn rotor_motor_weight_contraction(self_: Rotor, other: Motor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn rotor_multi_vector_weight_contraction(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn rotor_plane_weight_contraction(self_: Rotor, other: Plane) -> RoundPoint {
    return rotor_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn rotor_plane_at_origin_weight_contraction(self_: Rotor, other: PlaneAtOrigin) -> RoundPoint {
    return rotor_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn rotor_point_at_origin_weight_contraction(self_: Rotor, other: PointAtOrigin) -> MultiVector {
    return rotor_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn rotor_rotor_weight_contraction(self_: Rotor, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn rotor_sphere_weight_contraction(self_: Rotor, other: Sphere) -> RoundPoint {
    return rotor_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn rotor_translator_weight_contraction(self_: Rotor, other: Translator) -> Scalar {
    return rotor_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn round_point_flector_weight_contraction(self_: RoundPoint, other: Flector) -> MultiVector {
    return round_point_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn round_point_motor_weight_contraction(self_: RoundPoint, other: Motor) -> MultiVector {
    return round_point_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn round_point_multi_vector_weight_contraction(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return round_point_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn round_point_rotor_weight_contraction(self_: RoundPoint, other: Rotor) -> MultiVector {
    return round_point_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn sphere_circle_weight_contraction(self_: Sphere, other: Circle) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn sphere_dipole_weight_contraction(self_: Sphere, other: Dipole) -> Dipole {
    return sphere_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn sphere_flat_point_weight_contraction(self_: Sphere, other: FlatPoint) -> Dipole {
    return sphere_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn sphere_flector_weight_contraction(self_: Sphere, other: Flector) -> MultiVector {
    return sphere_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn sphere_line_weight_contraction(self_: Sphere, other: Line) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn sphere_line_at_origin_weight_contraction(self_: Sphere, other: LineAtOrigin) -> RoundPoint {
    return sphere_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn sphere_motor_weight_contraction(self_: Sphere, other: Motor) -> MultiVector {
    return sphere_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn sphere_multi_vector_weight_contraction(self_: Sphere, other: MultiVector) -> MultiVector {
    return sphere_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn sphere_plane_weight_contraction(self_: Sphere, other: Plane) -> Scalar {
    return sphere_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn sphere_plane_at_origin_weight_contraction(self_: Sphere, other: PlaneAtOrigin) -> Scalar {
    return sphere_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn sphere_point_at_origin_weight_contraction(self_: Sphere, other: PointAtOrigin) -> Dipole {
    return sphere_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn sphere_rotor_weight_contraction(self_: Sphere, other: Rotor) -> MultiVector {
    return sphere_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn sphere_sphere_weight_contraction(self_: Sphere, other: Sphere) -> Scalar {
    return sphere_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn translator_circle_weight_contraction(self_: Translator, other: Circle) -> MultiVector {
    return translator_dipole_anti_wedge(self_, circle_right_weight_dual(other));
}

fn translator_dipole_weight_contraction(self_: Translator, other: Dipole) -> MultiVector {
    return translator_circle_anti_wedge(self_, dipole_right_weight_dual(other));
}

fn translator_flat_point_weight_contraction(self_: Translator, other: FlatPoint) -> MultiVector {
    return translator_circle_anti_wedge(self_, flat_point_right_weight_dual(other));
}

fn translator_flector_weight_contraction(self_: Translator, other: Flector) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn translator_line_weight_contraction(self_: Translator, other: Line) -> MultiVector {
    return translator_dipole_anti_wedge(self_, line_right_weight_dual(other));
}

fn translator_line_at_origin_weight_contraction(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return translator_dipole_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn translator_motor_weight_contraction(self_: Translator, other: Motor) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, motor_right_weight_dual(other));
}

fn translator_multi_vector_weight_contraction(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn translator_plane_weight_contraction(self_: Translator, other: Plane) -> RoundPoint {
    return translator_round_point_anti_wedge(self_, plane_right_weight_dual(other));
}

fn translator_plane_at_origin_weight_contraction(self_: Translator, other: PlaneAtOrigin) -> RoundPoint {
    return translator_round_point_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn translator_point_at_origin_weight_contraction(self_: Translator, other: PointAtOrigin) -> MultiVector {
    return translator_circle_anti_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn translator_rotor_weight_contraction(self_: Translator, other: Rotor) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, rotor_right_weight_dual(other));
}

fn translator_sphere_weight_contraction(self_: Translator, other: Sphere) -> RoundPoint {
    return translator_round_point_anti_wedge(self_, sphere_right_weight_dual(other));
}

fn translator_translator_weight_contraction(self_: Translator, other: Translator) -> Scalar {
    return translator_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn circle_circle_bulk_expansion(self_: Circle, other: Circle) -> AntiScalar {
    return circle_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn circle_flector_bulk_expansion(self_: Circle, other: Flector) -> MultiVector {
    return circle_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn circle_horizon_bulk_expansion(self_: Circle, other: Horizon) -> Sphere {
    return circle_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn circle_line_bulk_expansion(self_: Circle, other: Line) -> AntiScalar {
    return circle_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn circle_line_at_infinity_bulk_expansion(self_: Circle, other: LineAtInfinity) -> AntiScalar {
    return circle_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn circle_motor_bulk_expansion(self_: Circle, other: Motor) -> AntiScalar {
    return circle_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn circle_multi_vector_bulk_expansion(self_: Circle, other: MultiVector) -> MultiVector {
    return circle_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn circle_plane_bulk_expansion(self_: Circle, other: Plane) -> Sphere {
    return circle_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn circle_sphere_bulk_expansion(self_: Circle, other: Sphere) -> Sphere {
    return circle_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn circle_translator_bulk_expansion(self_: Circle, other: Translator) -> AntiScalar {
    return circle_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn dipole_circle_bulk_expansion(self_: Dipole, other: Circle) -> Sphere {
    return dipole_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn dipole_dipole_bulk_expansion(self_: Dipole, other: Dipole) -> AntiScalar {
    return dipole_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn dipole_flat_point_bulk_expansion(self_: Dipole, other: FlatPoint) -> AntiScalar {
    return dipole_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn dipole_flector_bulk_expansion(self_: Dipole, other: Flector) -> MultiVector {
    return dipole_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn dipole_horizon_bulk_expansion(self_: Dipole, other: Horizon) -> Circle {
    return dipole_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn dipole_line_bulk_expansion(self_: Dipole, other: Line) -> Sphere {
    return dipole_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn dipole_line_at_infinity_bulk_expansion(self_: Dipole, other: LineAtInfinity) -> Sphere {
    return dipole_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn dipole_motor_bulk_expansion(self_: Dipole, other: Motor) -> Sphere {
    return dipole_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn dipole_multi_vector_bulk_expansion(self_: Dipole, other: MultiVector) -> MultiVector {
    return dipole_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn dipole_plane_bulk_expansion(self_: Dipole, other: Plane) -> Circle {
    return dipole_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn dipole_point_at_infinity_bulk_expansion(self_: Dipole, other: PointAtInfinity) -> AntiScalar {
    return dipole_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn dipole_sphere_bulk_expansion(self_: Dipole, other: Sphere) -> Circle {
    return dipole_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn dipole_translator_bulk_expansion(self_: Dipole, other: Translator) -> Sphere {
    return dipole_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn flat_point_circle_bulk_expansion(self_: FlatPoint, other: Circle) -> Plane {
    return flat_point_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn flat_point_dipole_bulk_expansion(self_: FlatPoint, other: Dipole) -> AntiScalar {
    return flat_point_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn flat_point_flat_point_bulk_expansion(self_: FlatPoint, other: FlatPoint) -> AntiScalar {
    return flat_point_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn flat_point_flector_bulk_expansion(self_: FlatPoint, other: Flector) -> MultiVector {
    return flat_point_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn flat_point_horizon_bulk_expansion(self_: FlatPoint, other: Horizon) -> LineAtOrigin {
    return flat_point_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn flat_point_line_bulk_expansion(self_: FlatPoint, other: Line) -> Plane {
    return flat_point_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn flat_point_line_at_infinity_bulk_expansion(self_: FlatPoint, other: LineAtInfinity) -> Plane {
    return flat_point_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn flat_point_motor_bulk_expansion(self_: FlatPoint, other: Motor) -> Plane {
    return flat_point_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn flat_point_multi_vector_bulk_expansion(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return flat_point_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn flat_point_plane_bulk_expansion(self_: FlatPoint, other: Plane) -> LineAtOrigin {
    return flat_point_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn flat_point_point_at_infinity_bulk_expansion(self_: FlatPoint, other: PointAtInfinity) -> AntiScalar {
    return flat_point_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn flat_point_sphere_bulk_expansion(self_: FlatPoint, other: Sphere) -> LineAtOrigin {
    return flat_point_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn flat_point_translator_bulk_expansion(self_: FlatPoint, other: Translator) -> Plane {
    return flat_point_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn flector_circle_bulk_expansion(self_: Flector, other: Circle) -> Plane {
    return flector_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn flector_dipole_bulk_expansion(self_: Flector, other: Dipole) -> AntiScalar {
    return flector_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn flector_flat_point_bulk_expansion(self_: Flector, other: FlatPoint) -> AntiScalar {
    return flector_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn flector_flector_bulk_expansion(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn flector_horizon_bulk_expansion(self_: Flector, other: Horizon) -> Rotor {
    return flector_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn flector_line_bulk_expansion(self_: Flector, other: Line) -> Plane {
    return flector_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn flector_line_at_infinity_bulk_expansion(self_: Flector, other: LineAtInfinity) -> Plane {
    return flector_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn flector_motor_bulk_expansion(self_: Flector, other: Motor) -> Plane {
    return flector_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn flector_multi_vector_bulk_expansion(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn flector_plane_bulk_expansion(self_: Flector, other: Plane) -> Rotor {
    return flector_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn flector_point_at_infinity_bulk_expansion(self_: Flector, other: PointAtInfinity) -> AntiScalar {
    return flector_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn flector_sphere_bulk_expansion(self_: Flector, other: Sphere) -> Rotor {
    return flector_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn flector_translator_bulk_expansion(self_: Flector, other: Translator) -> Plane {
    return flector_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn horizon_flector_bulk_expansion(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn horizon_horizon_bulk_expansion(self_: Horizon, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn horizon_multi_vector_bulk_expansion(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn horizon_plane_bulk_expansion(self_: Horizon, other: Plane) -> AntiScalar {
    return horizon_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn horizon_sphere_bulk_expansion(self_: Horizon, other: Sphere) -> AntiScalar {
    return horizon_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn infinity_circle_bulk_expansion(self_: Infinity, other: Circle) -> Line {
    return infinity_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn infinity_dipole_bulk_expansion(self_: Infinity, other: Dipole) -> Plane {
    return infinity_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn infinity_flat_point_bulk_expansion(self_: Infinity, other: FlatPoint) -> Plane {
    return infinity_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn infinity_flector_bulk_expansion(self_: Infinity, other: Flector) -> MultiVector {
    return infinity_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn infinity_horizon_bulk_expansion(self_: Infinity, other: Horizon) -> PointAtOrigin {
    return infinity_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn infinity_infinity_bulk_expansion(self_: Infinity, other: Infinity) -> AntiScalar {
    return infinity_sphere_wedge(self_, infinity_right_bulk_dual(other));
}

fn infinity_line_bulk_expansion(self_: Infinity, other: Line) -> Line {
    return infinity_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn infinity_line_at_infinity_bulk_expansion(self_: Infinity, other: LineAtInfinity) -> Line {
    return infinity_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn infinity_motor_bulk_expansion(self_: Infinity, other: Motor) -> Line {
    return infinity_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn infinity_multi_vector_bulk_expansion(self_: Infinity, other: MultiVector) -> MultiVector {
    return infinity_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn infinity_plane_bulk_expansion(self_: Infinity, other: Plane) -> PointAtOrigin {
    return infinity_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn infinity_point_at_infinity_bulk_expansion(self_: Infinity, other: PointAtInfinity) -> Plane {
    return infinity_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn infinity_round_point_bulk_expansion(self_: Infinity, other: RoundPoint) -> AntiScalar {
    return infinity_sphere_wedge(self_, round_point_right_bulk_dual(other));
}

fn infinity_sphere_bulk_expansion(self_: Infinity, other: Sphere) -> PointAtOrigin {
    return infinity_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn infinity_translator_bulk_expansion(self_: Infinity, other: Translator) -> Line {
    return infinity_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn line_circle_bulk_expansion(self_: Line, other: Circle) -> AntiScalar {
    return line_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn line_flector_bulk_expansion(self_: Line, other: Flector) -> MultiVector {
    return line_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn line_horizon_bulk_expansion(self_: Line, other: Horizon) -> PlaneAtOrigin {
    return line_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn line_line_bulk_expansion(self_: Line, other: Line) -> AntiScalar {
    return line_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn line_line_at_infinity_bulk_expansion(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return line_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_motor_bulk_expansion(self_: Line, other: Motor) -> AntiScalar {
    return line_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn line_multi_vector_bulk_expansion(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_plane_bulk_expansion(self_: Line, other: Plane) -> PlaneAtOrigin {
    return line_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn line_sphere_bulk_expansion(self_: Line, other: Sphere) -> PlaneAtOrigin {
    return line_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn line_translator_bulk_expansion(self_: Line, other: Translator) -> AntiScalar {
    return line_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_infinity_circle_bulk_expansion(self_: LineAtInfinity, other: Circle) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn line_at_infinity_flector_bulk_expansion(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_infinity_horizon_bulk_expansion(self_: LineAtInfinity, other: Horizon) -> PlaneAtOrigin {
    return line_at_infinity_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn line_at_infinity_line_bulk_expansion(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn line_at_infinity_line_at_infinity_bulk_expansion(self_: LineAtInfinity, other: LineAtInfinity) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_at_infinity_motor_bulk_expansion(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn line_at_infinity_multi_vector_bulk_expansion(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_infinity_plane_bulk_expansion(self_: LineAtInfinity, other: Plane) -> PlaneAtOrigin {
    return line_at_infinity_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn line_at_infinity_sphere_bulk_expansion(self_: LineAtInfinity, other: Sphere) -> PlaneAtOrigin {
    return line_at_infinity_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn line_at_infinity_translator_bulk_expansion(self_: LineAtInfinity, other: Translator) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_origin_circle_bulk_expansion(self_: LineAtOrigin, other: Circle) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn line_at_origin_flector_bulk_expansion(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_origin_line_bulk_expansion(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn line_at_origin_line_at_infinity_bulk_expansion(self_: LineAtOrigin, other: LineAtInfinity) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_at_origin_motor_bulk_expansion(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn line_at_origin_multi_vector_bulk_expansion(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_origin_translator_bulk_expansion(self_: LineAtOrigin, other: Translator) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn motor_circle_bulk_expansion(self_: Motor, other: Circle) -> AntiScalar {
    return motor_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn motor_flector_bulk_expansion(self_: Motor, other: Flector) -> MultiVector {
    return motor_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn motor_horizon_bulk_expansion(self_: Motor, other: Horizon) -> PlaneAtOrigin {
    return motor_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn motor_line_bulk_expansion(self_: Motor, other: Line) -> AntiScalar {
    return motor_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn motor_line_at_infinity_bulk_expansion(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return motor_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn motor_motor_bulk_expansion(self_: Motor, other: Motor) -> AntiScalar {
    return motor_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn motor_multi_vector_bulk_expansion(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn motor_plane_bulk_expansion(self_: Motor, other: Plane) -> PlaneAtOrigin {
    return motor_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn motor_sphere_bulk_expansion(self_: Motor, other: Sphere) -> PlaneAtOrigin {
    return motor_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn motor_translator_bulk_expansion(self_: Motor, other: Translator) -> AntiScalar {
    return motor_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn multi_vector_circle_bulk_expansion(self_: MultiVector, other: Circle) -> MultiVector {
    return multi_vector_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn multi_vector_dipole_bulk_expansion(self_: MultiVector, other: Dipole) -> MultiVector {
    return multi_vector_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn multi_vector_flat_point_bulk_expansion(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return multi_vector_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn multi_vector_flector_bulk_expansion(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn multi_vector_horizon_bulk_expansion(self_: MultiVector, other: Horizon) -> MultiVector {
    return multi_vector_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn multi_vector_infinity_bulk_expansion(self_: MultiVector, other: Infinity) -> MultiVector {
    return multi_vector_sphere_wedge(self_, infinity_right_bulk_dual(other));
}

fn multi_vector_line_bulk_expansion(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn multi_vector_line_at_infinity_bulk_expansion(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multi_vector_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn multi_vector_motor_bulk_expansion(self_: MultiVector, other: Motor) -> MultiVector {
    return multi_vector_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn multi_vector_multi_vector_bulk_expansion(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn multi_vector_plane_bulk_expansion(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn multi_vector_point_at_infinity_bulk_expansion(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multi_vector_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn multi_vector_round_point_bulk_expansion(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return multi_vector_sphere_wedge(self_, round_point_right_bulk_dual(other));
}

fn multi_vector_sphere_bulk_expansion(self_: MultiVector, other: Sphere) -> MultiVector {
    return multi_vector_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn multi_vector_translator_bulk_expansion(self_: MultiVector, other: Translator) -> MultiVector {
    return multi_vector_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn origin_circle_bulk_expansion(self_: Origin, other: Circle) -> Circle {
    return origin_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn origin_dipole_bulk_expansion(self_: Origin, other: Dipole) -> Sphere {
    return origin_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn origin_flat_point_bulk_expansion(self_: Origin, other: FlatPoint) -> Sphere {
    return origin_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn origin_flector_bulk_expansion(self_: Origin, other: Flector) -> MultiVector {
    return origin_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn origin_infinity_bulk_expansion(self_: Origin, other: Infinity) -> AntiScalar {
    return origin_sphere_wedge(self_, infinity_right_bulk_dual(other));
}

fn origin_line_bulk_expansion(self_: Origin, other: Line) -> Circle {
    return origin_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn origin_line_at_infinity_bulk_expansion(self_: Origin, other: LineAtInfinity) -> Circle {
    return origin_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn origin_motor_bulk_expansion(self_: Origin, other: Motor) -> Circle {
    return origin_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn origin_multi_vector_bulk_expansion(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn origin_point_at_infinity_bulk_expansion(self_: Origin, other: PointAtInfinity) -> Sphere {
    return origin_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn origin_round_point_bulk_expansion(self_: Origin, other: RoundPoint) -> AntiScalar {
    return origin_sphere_wedge(self_, round_point_right_bulk_dual(other));
}

fn origin_translator_bulk_expansion(self_: Origin, other: Translator) -> Circle {
    return origin_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn plane_flector_bulk_expansion(self_: Plane, other: Flector) -> MultiVector {
    return plane_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_horizon_bulk_expansion(self_: Plane, other: Horizon) -> AntiScalar {
    return plane_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn plane_multi_vector_bulk_expansion(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_plane_bulk_expansion(self_: Plane, other: Plane) -> AntiScalar {
    return plane_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn plane_sphere_bulk_expansion(self_: Plane, other: Sphere) -> AntiScalar {
    return plane_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn plane_at_origin_flector_bulk_expansion(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_at_origin_multi_vector_bulk_expansion(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_infinity_circle_bulk_expansion(self_: PointAtInfinity, other: Circle) -> Plane {
    return point_at_infinity_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn point_at_infinity_dipole_bulk_expansion(self_: PointAtInfinity, other: Dipole) -> AntiScalar {
    return point_at_infinity_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn point_at_infinity_flat_point_bulk_expansion(self_: PointAtInfinity, other: FlatPoint) -> AntiScalar {
    return point_at_infinity_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn point_at_infinity_flector_bulk_expansion(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn point_at_infinity_horizon_bulk_expansion(self_: PointAtInfinity, other: Horizon) -> LineAtOrigin {
    return point_at_infinity_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn point_at_infinity_line_bulk_expansion(self_: PointAtInfinity, other: Line) -> Plane {
    return point_at_infinity_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn point_at_infinity_line_at_infinity_bulk_expansion(self_: PointAtInfinity, other: LineAtInfinity) -> Plane {
    return point_at_infinity_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn point_at_infinity_motor_bulk_expansion(self_: PointAtInfinity, other: Motor) -> Plane {
    return point_at_infinity_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn point_at_infinity_multi_vector_bulk_expansion(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_infinity_plane_bulk_expansion(self_: PointAtInfinity, other: Plane) -> LineAtOrigin {
    return point_at_infinity_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn point_at_infinity_point_at_infinity_bulk_expansion(self_: PointAtInfinity, other: PointAtInfinity) -> AntiScalar {
    return point_at_infinity_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_at_infinity_sphere_bulk_expansion(self_: PointAtInfinity, other: Sphere) -> LineAtOrigin {
    return point_at_infinity_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn point_at_infinity_translator_bulk_expansion(self_: PointAtInfinity, other: Translator) -> Plane {
    return point_at_infinity_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn point_at_origin_circle_bulk_expansion(self_: PointAtOrigin, other: Circle) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn point_at_origin_dipole_bulk_expansion(self_: PointAtOrigin, other: Dipole) -> AntiScalar {
    return point_at_origin_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn point_at_origin_flat_point_bulk_expansion(self_: PointAtOrigin, other: FlatPoint) -> AntiScalar {
    return point_at_origin_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn point_at_origin_flector_bulk_expansion(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return point_at_origin_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn point_at_origin_line_bulk_expansion(self_: PointAtOrigin, other: Line) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn point_at_origin_line_at_infinity_bulk_expansion(self_: PointAtOrigin, other: LineAtInfinity) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn point_at_origin_motor_bulk_expansion(self_: PointAtOrigin, other: Motor) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn point_at_origin_multi_vector_bulk_expansion(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return point_at_origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_origin_point_at_infinity_bulk_expansion(self_: PointAtOrigin, other: PointAtInfinity) -> AntiScalar {
    return point_at_origin_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_at_origin_translator_bulk_expansion(self_: PointAtOrigin, other: Translator) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn rotor_circle_bulk_expansion(self_: Rotor, other: Circle) -> AntiScalar {
    return rotor_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn rotor_flector_bulk_expansion(self_: Rotor, other: Flector) -> MultiVector {
    return rotor_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn rotor_line_bulk_expansion(self_: Rotor, other: Line) -> AntiScalar {
    return rotor_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn rotor_line_at_infinity_bulk_expansion(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return rotor_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn rotor_motor_bulk_expansion(self_: Rotor, other: Motor) -> AntiScalar {
    return rotor_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn rotor_multi_vector_bulk_expansion(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn rotor_translator_bulk_expansion(self_: Rotor, other: Translator) -> AntiScalar {
    return rotor_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn round_point_circle_bulk_expansion(self_: RoundPoint, other: Circle) -> Circle {
    return round_point_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn round_point_dipole_bulk_expansion(self_: RoundPoint, other: Dipole) -> Sphere {
    return round_point_circle_wedge(self_, dipole_right_bulk_dual(other));
}

fn round_point_flat_point_bulk_expansion(self_: RoundPoint, other: FlatPoint) -> Sphere {
    return round_point_circle_wedge(self_, flat_point_right_bulk_dual(other));
}

fn round_point_flector_bulk_expansion(self_: RoundPoint, other: Flector) -> MultiVector {
    return round_point_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn round_point_horizon_bulk_expansion(self_: RoundPoint, other: Horizon) -> Dipole {
    return round_point_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn round_point_infinity_bulk_expansion(self_: RoundPoint, other: Infinity) -> AntiScalar {
    return round_point_sphere_wedge(self_, infinity_right_bulk_dual(other));
}

fn round_point_line_bulk_expansion(self_: RoundPoint, other: Line) -> Circle {
    return round_point_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn round_point_line_at_infinity_bulk_expansion(self_: RoundPoint, other: LineAtInfinity) -> Circle {
    return round_point_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn round_point_motor_bulk_expansion(self_: RoundPoint, other: Motor) -> Circle {
    return round_point_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn round_point_multi_vector_bulk_expansion(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return round_point_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn round_point_plane_bulk_expansion(self_: RoundPoint, other: Plane) -> Dipole {
    return round_point_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn round_point_point_at_infinity_bulk_expansion(self_: RoundPoint, other: PointAtInfinity) -> Sphere {
    return round_point_circle_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn round_point_round_point_bulk_expansion(self_: RoundPoint, other: RoundPoint) -> AntiScalar {
    return round_point_sphere_wedge(self_, round_point_right_bulk_dual(other));
}

fn round_point_sphere_bulk_expansion(self_: RoundPoint, other: Sphere) -> Dipole {
    return round_point_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn round_point_translator_bulk_expansion(self_: RoundPoint, other: Translator) -> Circle {
    return round_point_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn sphere_flector_bulk_expansion(self_: Sphere, other: Flector) -> MultiVector {
    return sphere_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn sphere_horizon_bulk_expansion(self_: Sphere, other: Horizon) -> AntiScalar {
    return sphere_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn sphere_multi_vector_bulk_expansion(self_: Sphere, other: MultiVector) -> MultiVector {
    return sphere_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn sphere_plane_bulk_expansion(self_: Sphere, other: Plane) -> AntiScalar {
    return sphere_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn sphere_sphere_bulk_expansion(self_: Sphere, other: Sphere) -> AntiScalar {
    return sphere_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn translator_circle_bulk_expansion(self_: Translator, other: Circle) -> AntiScalar {
    return translator_dipole_wedge(self_, circle_right_bulk_dual(other));
}

fn translator_flector_bulk_expansion(self_: Translator, other: Flector) -> MultiVector {
    return translator_multi_vector_wedge(self_, flector_right_bulk_dual(other));
}

fn translator_horizon_bulk_expansion(self_: Translator, other: Horizon) -> PlaneAtOrigin {
    return translator_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn translator_line_bulk_expansion(self_: Translator, other: Line) -> AntiScalar {
    return translator_dipole_wedge(self_, line_right_bulk_dual(other));
}

fn translator_line_at_infinity_bulk_expansion(self_: Translator, other: LineAtInfinity) -> AntiScalar {
    return translator_dipole_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn translator_motor_bulk_expansion(self_: Translator, other: Motor) -> AntiScalar {
    return translator_dipole_wedge(self_, motor_right_bulk_dual(other));
}

fn translator_multi_vector_bulk_expansion(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn translator_plane_bulk_expansion(self_: Translator, other: Plane) -> PlaneAtOrigin {
    return translator_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn translator_sphere_bulk_expansion(self_: Translator, other: Sphere) -> PlaneAtOrigin {
    return translator_origin_wedge(self_, sphere_right_bulk_dual(other));
}

fn translator_translator_bulk_expansion(self_: Translator, other: Translator) -> AntiScalar {
    return translator_dipole_wedge(self_, translator_right_bulk_dual(other));
}

fn circle_circle_weight_expansion(self_: Circle, other: Circle) -> AntiScalar {
    return circle_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn circle_flector_weight_expansion(self_: Circle, other: Flector) -> MultiVector {
    return circle_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn circle_line_weight_expansion(self_: Circle, other: Line) -> AntiScalar {
    return circle_dipole_wedge(self_, line_right_weight_dual(other));
}

fn circle_line_at_origin_weight_expansion(self_: Circle, other: LineAtOrigin) -> AntiScalar {
    return circle_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn circle_motor_weight_expansion(self_: Circle, other: Motor) -> MultiVector {
    return circle_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn circle_multi_vector_weight_expansion(self_: Circle, other: MultiVector) -> MultiVector {
    return circle_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn circle_plane_weight_expansion(self_: Circle, other: Plane) -> Sphere {
    return circle_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn circle_plane_at_origin_weight_expansion(self_: Circle, other: PlaneAtOrigin) -> Sphere {
    return circle_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn circle_rotor_weight_expansion(self_: Circle, other: Rotor) -> MultiVector {
    return circle_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn circle_sphere_weight_expansion(self_: Circle, other: Sphere) -> Sphere {
    return circle_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn circle_translator_weight_expansion(self_: Circle, other: Translator) -> Circle {
    return circle_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn dipole_circle_weight_expansion(self_: Dipole, other: Circle) -> Sphere {
    return dipole_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn dipole_dipole_weight_expansion(self_: Dipole, other: Dipole) -> AntiScalar {
    return dipole_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn dipole_flat_point_weight_expansion(self_: Dipole, other: FlatPoint) -> AntiScalar {
    return dipole_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn dipole_flector_weight_expansion(self_: Dipole, other: Flector) -> MultiVector {
    return dipole_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn dipole_line_weight_expansion(self_: Dipole, other: Line) -> Sphere {
    return dipole_dipole_wedge(self_, line_right_weight_dual(other));
}

fn dipole_line_at_origin_weight_expansion(self_: Dipole, other: LineAtOrigin) -> Sphere {
    return dipole_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn dipole_motor_weight_expansion(self_: Dipole, other: Motor) -> MultiVector {
    return dipole_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn dipole_multi_vector_weight_expansion(self_: Dipole, other: MultiVector) -> MultiVector {
    return dipole_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn dipole_plane_weight_expansion(self_: Dipole, other: Plane) -> Circle {
    return dipole_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn dipole_plane_at_origin_weight_expansion(self_: Dipole, other: PlaneAtOrigin) -> Circle {
    return dipole_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn dipole_point_at_origin_weight_expansion(self_: Dipole, other: PointAtOrigin) -> AntiScalar {
    return dipole_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn dipole_rotor_weight_expansion(self_: Dipole, other: Rotor) -> MultiVector {
    return dipole_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn dipole_sphere_weight_expansion(self_: Dipole, other: Sphere) -> Circle {
    return dipole_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn dipole_translator_weight_expansion(self_: Dipole, other: Translator) -> Dipole {
    return dipole_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn flat_point_circle_weight_expansion(self_: FlatPoint, other: Circle) -> Plane {
    return flat_point_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn flat_point_dipole_weight_expansion(self_: FlatPoint, other: Dipole) -> AntiScalar {
    return flat_point_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn flat_point_flat_point_weight_expansion(self_: FlatPoint, other: FlatPoint) -> AntiScalar {
    return flat_point_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn flat_point_flector_weight_expansion(self_: FlatPoint, other: Flector) -> MultiVector {
    return flat_point_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn flat_point_line_weight_expansion(self_: FlatPoint, other: Line) -> Plane {
    return flat_point_dipole_wedge(self_, line_right_weight_dual(other));
}

fn flat_point_line_at_origin_weight_expansion(self_: FlatPoint, other: LineAtOrigin) -> Plane {
    return flat_point_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn flat_point_motor_weight_expansion(self_: FlatPoint, other: Motor) -> MultiVector {
    return flat_point_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn flat_point_multi_vector_weight_expansion(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return flat_point_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn flat_point_plane_weight_expansion(self_: FlatPoint, other: Plane) -> Line {
    return flat_point_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn flat_point_plane_at_origin_weight_expansion(self_: FlatPoint, other: PlaneAtOrigin) -> Line {
    return flat_point_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn flat_point_point_at_origin_weight_expansion(self_: FlatPoint, other: PointAtOrigin) -> AntiScalar {
    return flat_point_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn flat_point_rotor_weight_expansion(self_: FlatPoint, other: Rotor) -> MultiVector {
    return flat_point_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn flat_point_sphere_weight_expansion(self_: FlatPoint, other: Sphere) -> Line {
    return flat_point_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn flat_point_translator_weight_expansion(self_: FlatPoint, other: Translator) -> FlatPoint {
    return flat_point_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn flector_circle_weight_expansion(self_: Flector, other: Circle) -> Plane {
    return flector_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn flector_dipole_weight_expansion(self_: Flector, other: Dipole) -> AntiScalar {
    return flector_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn flector_flat_point_weight_expansion(self_: Flector, other: FlatPoint) -> AntiScalar {
    return flector_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn flector_flector_weight_expansion(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn flector_line_weight_expansion(self_: Flector, other: Line) -> Plane {
    return flector_dipole_wedge(self_, line_right_weight_dual(other));
}

fn flector_line_at_origin_weight_expansion(self_: Flector, other: LineAtOrigin) -> Plane {
    return flector_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn flector_motor_weight_expansion(self_: Flector, other: Motor) -> MultiVector {
    return flector_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn flector_multi_vector_weight_expansion(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn flector_plane_weight_expansion(self_: Flector, other: Plane) -> Motor {
    return flector_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn flector_plane_at_origin_weight_expansion(self_: Flector, other: PlaneAtOrigin) -> Motor {
    return flector_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn flector_point_at_origin_weight_expansion(self_: Flector, other: PointAtOrigin) -> AntiScalar {
    return flector_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn flector_rotor_weight_expansion(self_: Flector, other: Rotor) -> MultiVector {
    return flector_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn flector_sphere_weight_expansion(self_: Flector, other: Sphere) -> Motor {
    return flector_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn flector_translator_weight_expansion(self_: Flector, other: Translator) -> Flector {
    return flector_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn horizon_flector_weight_expansion(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn horizon_motor_weight_expansion(self_: Horizon, other: Motor) -> MultiVector {
    return horizon_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn horizon_multi_vector_weight_expansion(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn horizon_plane_weight_expansion(self_: Horizon, other: Plane) -> AntiScalar {
    return horizon_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn horizon_plane_at_origin_weight_expansion(self_: Horizon, other: PlaneAtOrigin) -> AntiScalar {
    return horizon_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn horizon_rotor_weight_expansion(self_: Horizon, other: Rotor) -> MultiVector {
    return horizon_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn horizon_sphere_weight_expansion(self_: Horizon, other: Sphere) -> AntiScalar {
    return horizon_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn horizon_translator_weight_expansion(self_: Horizon, other: Translator) -> Horizon {
    return horizon_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn infinity_circle_weight_expansion(self_: Infinity, other: Circle) -> Line {
    return infinity_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn infinity_dipole_weight_expansion(self_: Infinity, other: Dipole) -> Plane {
    return infinity_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn infinity_flat_point_weight_expansion(self_: Infinity, other: FlatPoint) -> Plane {
    return infinity_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn infinity_flector_weight_expansion(self_: Infinity, other: Flector) -> MultiVector {
    return infinity_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn infinity_line_weight_expansion(self_: Infinity, other: Line) -> Line {
    return infinity_dipole_wedge(self_, line_right_weight_dual(other));
}

fn infinity_line_at_origin_weight_expansion(self_: Infinity, other: LineAtOrigin) -> Line {
    return infinity_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn infinity_motor_weight_expansion(self_: Infinity, other: Motor) -> MultiVector {
    return infinity_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn infinity_multi_vector_weight_expansion(self_: Infinity, other: MultiVector) -> MultiVector {
    return infinity_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn infinity_plane_weight_expansion(self_: Infinity, other: Plane) -> FlatPoint {
    return infinity_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn infinity_plane_at_origin_weight_expansion(self_: Infinity, other: PlaneAtOrigin) -> FlatPoint {
    return infinity_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn infinity_point_at_origin_weight_expansion(self_: Infinity, other: PointAtOrigin) -> Plane {
    return infinity_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn infinity_rotor_weight_expansion(self_: Infinity, other: Rotor) -> MultiVector {
    return infinity_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn infinity_sphere_weight_expansion(self_: Infinity, other: Sphere) -> FlatPoint {
    return infinity_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn infinity_translator_weight_expansion(self_: Infinity, other: Translator) -> Infinity {
    return infinity_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn line_circle_weight_expansion(self_: Line, other: Circle) -> AntiScalar {
    return line_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn line_flector_weight_expansion(self_: Line, other: Flector) -> MultiVector {
    return line_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn line_line_weight_expansion(self_: Line, other: Line) -> AntiScalar {
    return line_dipole_wedge(self_, line_right_weight_dual(other));
}

fn line_line_at_origin_weight_expansion(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return line_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_motor_weight_expansion(self_: Line, other: Motor) -> MultiVector {
    return line_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn line_multi_vector_weight_expansion(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_plane_weight_expansion(self_: Line, other: Plane) -> Plane {
    return line_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn line_plane_at_origin_weight_expansion(self_: Line, other: PlaneAtOrigin) -> Plane {
    return line_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn line_rotor_weight_expansion(self_: Line, other: Rotor) -> MultiVector {
    return line_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn line_sphere_weight_expansion(self_: Line, other: Sphere) -> Plane {
    return line_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn line_translator_weight_expansion(self_: Line, other: Translator) -> Line {
    return line_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn line_at_infinity_circle_weight_expansion(self_: LineAtInfinity, other: Circle) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn line_at_infinity_flector_weight_expansion(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_infinity_line_weight_expansion(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, line_right_weight_dual(other));
}

fn line_at_infinity_line_at_origin_weight_expansion(self_: LineAtInfinity, other: LineAtOrigin) -> AntiScalar {
    return line_at_infinity_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_at_infinity_motor_weight_expansion(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn line_at_infinity_multi_vector_weight_expansion(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_infinity_plane_weight_expansion(self_: LineAtInfinity, other: Plane) -> Plane {
    return line_at_infinity_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn line_at_infinity_plane_at_origin_weight_expansion(self_: LineAtInfinity, other: PlaneAtOrigin) -> Plane {
    return line_at_infinity_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn line_at_infinity_rotor_weight_expansion(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn line_at_infinity_sphere_weight_expansion(self_: LineAtInfinity, other: Sphere) -> Plane {
    return line_at_infinity_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn line_at_infinity_translator_weight_expansion(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn line_at_origin_circle_weight_expansion(self_: LineAtOrigin, other: Circle) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn line_at_origin_flector_weight_expansion(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_origin_line_weight_expansion(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, line_right_weight_dual(other));
}

fn line_at_origin_line_at_origin_weight_expansion(self_: LineAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return line_at_origin_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_at_origin_motor_weight_expansion(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn line_at_origin_multi_vector_weight_expansion(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_origin_plane_weight_expansion(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return line_at_origin_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn line_at_origin_plane_at_origin_weight_expansion(self_: LineAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return line_at_origin_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn line_at_origin_rotor_weight_expansion(self_: LineAtOrigin, other: Rotor) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn line_at_origin_sphere_weight_expansion(self_: LineAtOrigin, other: Sphere) -> PlaneAtOrigin {
    return line_at_origin_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn line_at_origin_translator_weight_expansion(self_: LineAtOrigin, other: Translator) -> LineAtOrigin {
    return line_at_origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn motor_circle_weight_expansion(self_: Motor, other: Circle) -> AntiScalar {
    return motor_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn motor_flector_weight_expansion(self_: Motor, other: Flector) -> MultiVector {
    return motor_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn motor_line_weight_expansion(self_: Motor, other: Line) -> AntiScalar {
    return motor_dipole_wedge(self_, line_right_weight_dual(other));
}

fn motor_line_at_origin_weight_expansion(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return motor_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn motor_motor_weight_expansion(self_: Motor, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn motor_multi_vector_weight_expansion(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn motor_plane_weight_expansion(self_: Motor, other: Plane) -> Plane {
    return motor_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn motor_plane_at_origin_weight_expansion(self_: Motor, other: PlaneAtOrigin) -> Plane {
    return motor_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn motor_rotor_weight_expansion(self_: Motor, other: Rotor) -> MultiVector {
    return motor_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn motor_sphere_weight_expansion(self_: Motor, other: Sphere) -> Plane {
    return motor_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn motor_translator_weight_expansion(self_: Motor, other: Translator) -> Motor {
    return motor_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn multi_vector_circle_weight_expansion(self_: MultiVector, other: Circle) -> MultiVector {
    return multi_vector_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn multi_vector_dipole_weight_expansion(self_: MultiVector, other: Dipole) -> MultiVector {
    return multi_vector_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn multi_vector_flat_point_weight_expansion(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return multi_vector_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn multi_vector_flector_weight_expansion(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn multi_vector_line_weight_expansion(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_dipole_wedge(self_, line_right_weight_dual(other));
}

fn multi_vector_line_at_origin_weight_expansion(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multi_vector_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn multi_vector_motor_weight_expansion(self_: MultiVector, other: Motor) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn multi_vector_multi_vector_weight_expansion(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn multi_vector_plane_weight_expansion(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn multi_vector_plane_at_origin_weight_expansion(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multi_vector_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn multi_vector_point_at_origin_weight_expansion(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return multi_vector_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn multi_vector_rotor_weight_expansion(self_: MultiVector, other: Rotor) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn multi_vector_sphere_weight_expansion(self_: MultiVector, other: Sphere) -> MultiVector {
    return multi_vector_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn multi_vector_translator_weight_expansion(self_: MultiVector, other: Translator) -> MultiVector {
    return multi_vector_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn origin_circle_weight_expansion(self_: Origin, other: Circle) -> Circle {
    return origin_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn origin_dipole_weight_expansion(self_: Origin, other: Dipole) -> Sphere {
    return origin_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn origin_flat_point_weight_expansion(self_: Origin, other: FlatPoint) -> Sphere {
    return origin_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn origin_flector_weight_expansion(self_: Origin, other: Flector) -> MultiVector {
    return origin_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn origin_line_weight_expansion(self_: Origin, other: Line) -> Circle {
    return origin_dipole_wedge(self_, line_right_weight_dual(other));
}

fn origin_line_at_origin_weight_expansion(self_: Origin, other: LineAtOrigin) -> Circle {
    return origin_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn origin_motor_weight_expansion(self_: Origin, other: Motor) -> MultiVector {
    return origin_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn origin_multi_vector_weight_expansion(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn origin_plane_weight_expansion(self_: Origin, other: Plane) -> Dipole {
    return origin_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn origin_plane_at_origin_weight_expansion(self_: Origin, other: PlaneAtOrigin) -> Dipole {
    return origin_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn origin_point_at_origin_weight_expansion(self_: Origin, other: PointAtOrigin) -> Sphere {
    return origin_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn origin_rotor_weight_expansion(self_: Origin, other: Rotor) -> MultiVector {
    return origin_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn origin_sphere_weight_expansion(self_: Origin, other: Sphere) -> Dipole {
    return origin_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn origin_translator_weight_expansion(self_: Origin, other: Translator) -> Origin {
    return origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn plane_flector_weight_expansion(self_: Plane, other: Flector) -> MultiVector {
    return plane_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn plane_motor_weight_expansion(self_: Plane, other: Motor) -> MultiVector {
    return plane_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn plane_multi_vector_weight_expansion(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_plane_weight_expansion(self_: Plane, other: Plane) -> AntiScalar {
    return plane_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn plane_plane_at_origin_weight_expansion(self_: Plane, other: PlaneAtOrigin) -> AntiScalar {
    return plane_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_rotor_weight_expansion(self_: Plane, other: Rotor) -> MultiVector {
    return plane_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn plane_sphere_weight_expansion(self_: Plane, other: Sphere) -> AntiScalar {
    return plane_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn plane_translator_weight_expansion(self_: Plane, other: Translator) -> Plane {
    return plane_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn plane_at_origin_flector_weight_expansion(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn plane_at_origin_motor_weight_expansion(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn plane_at_origin_multi_vector_weight_expansion(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_at_origin_plane_weight_expansion(self_: PlaneAtOrigin, other: Plane) -> AntiScalar {
    return plane_at_origin_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn plane_at_origin_plane_at_origin_weight_expansion(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return plane_at_origin_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_at_origin_rotor_weight_expansion(self_: PlaneAtOrigin, other: Rotor) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn plane_at_origin_sphere_weight_expansion(self_: PlaneAtOrigin, other: Sphere) -> AntiScalar {
    return plane_at_origin_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn plane_at_origin_translator_weight_expansion(self_: PlaneAtOrigin, other: Translator) -> PlaneAtOrigin {
    return plane_at_origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn point_at_infinity_circle_weight_expansion(self_: PointAtInfinity, other: Circle) -> Plane {
    return point_at_infinity_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn point_at_infinity_dipole_weight_expansion(self_: PointAtInfinity, other: Dipole) -> AntiScalar {
    return point_at_infinity_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn point_at_infinity_flat_point_weight_expansion(self_: PointAtInfinity, other: FlatPoint) -> AntiScalar {
    return point_at_infinity_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn point_at_infinity_flector_weight_expansion(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn point_at_infinity_line_weight_expansion(self_: PointAtInfinity, other: Line) -> Plane {
    return point_at_infinity_dipole_wedge(self_, line_right_weight_dual(other));
}

fn point_at_infinity_line_at_origin_weight_expansion(self_: PointAtInfinity, other: LineAtOrigin) -> Plane {
    return point_at_infinity_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn point_at_infinity_motor_weight_expansion(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn point_at_infinity_multi_vector_weight_expansion(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_at_infinity_plane_weight_expansion(self_: PointAtInfinity, other: Plane) -> Line {
    return point_at_infinity_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn point_at_infinity_plane_at_origin_weight_expansion(self_: PointAtInfinity, other: PlaneAtOrigin) -> Line {
    return point_at_infinity_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn point_at_infinity_point_at_origin_weight_expansion(self_: PointAtInfinity, other: PointAtOrigin) -> AntiScalar {
    return point_at_infinity_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn point_at_infinity_rotor_weight_expansion(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn point_at_infinity_sphere_weight_expansion(self_: PointAtInfinity, other: Sphere) -> Line {
    return point_at_infinity_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn point_at_infinity_translator_weight_expansion(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn point_at_origin_circle_weight_expansion(self_: PointAtOrigin, other: Circle) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn point_at_origin_dipole_weight_expansion(self_: PointAtOrigin, other: Dipole) -> AntiScalar {
    return point_at_origin_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn point_at_origin_flat_point_weight_expansion(self_: PointAtOrigin, other: FlatPoint) -> AntiScalar {
    return point_at_origin_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn point_at_origin_flector_weight_expansion(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return point_at_origin_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn point_at_origin_line_weight_expansion(self_: PointAtOrigin, other: Line) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, line_right_weight_dual(other));
}

fn point_at_origin_line_at_origin_weight_expansion(self_: PointAtOrigin, other: LineAtOrigin) -> PlaneAtOrigin {
    return point_at_origin_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn point_at_origin_motor_weight_expansion(self_: PointAtOrigin, other: Motor) -> MultiVector {
    return point_at_origin_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn point_at_origin_multi_vector_weight_expansion(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return point_at_origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_at_origin_plane_weight_expansion(self_: PointAtOrigin, other: Plane) -> LineAtOrigin {
    return point_at_origin_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn point_at_origin_plane_at_origin_weight_expansion(self_: PointAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return point_at_origin_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn point_at_origin_point_at_origin_weight_expansion(self_: PointAtOrigin, other: PointAtOrigin) -> AntiScalar {
    return point_at_origin_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn point_at_origin_rotor_weight_expansion(self_: PointAtOrigin, other: Rotor) -> MultiVector {
    return point_at_origin_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn point_at_origin_sphere_weight_expansion(self_: PointAtOrigin, other: Sphere) -> LineAtOrigin {
    return point_at_origin_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn point_at_origin_translator_weight_expansion(self_: PointAtOrigin, other: Translator) -> PointAtOrigin {
    return point_at_origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn rotor_circle_weight_expansion(self_: Rotor, other: Circle) -> AntiScalar {
    return rotor_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn rotor_flector_weight_expansion(self_: Rotor, other: Flector) -> MultiVector {
    return rotor_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn rotor_line_weight_expansion(self_: Rotor, other: Line) -> AntiScalar {
    return rotor_dipole_wedge(self_, line_right_weight_dual(other));
}

fn rotor_line_at_origin_weight_expansion(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return rotor_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn rotor_motor_weight_expansion(self_: Rotor, other: Motor) -> MultiVector {
    return rotor_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn rotor_multi_vector_weight_expansion(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn rotor_plane_weight_expansion(self_: Rotor, other: Plane) -> PlaneAtOrigin {
    return rotor_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn rotor_plane_at_origin_weight_expansion(self_: Rotor, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return rotor_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn rotor_rotor_weight_expansion(self_: Rotor, other: Rotor) -> MultiVector {
    return rotor_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn rotor_sphere_weight_expansion(self_: Rotor, other: Sphere) -> PlaneAtOrigin {
    return rotor_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn rotor_translator_weight_expansion(self_: Rotor, other: Translator) -> Rotor {
    return rotor_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn round_point_circle_weight_expansion(self_: RoundPoint, other: Circle) -> Circle {
    return round_point_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn round_point_dipole_weight_expansion(self_: RoundPoint, other: Dipole) -> Sphere {
    return round_point_circle_wedge(self_, dipole_right_weight_dual(other));
}

fn round_point_flat_point_weight_expansion(self_: RoundPoint, other: FlatPoint) -> Sphere {
    return round_point_circle_wedge(self_, flat_point_right_weight_dual(other));
}

fn round_point_flector_weight_expansion(self_: RoundPoint, other: Flector) -> MultiVector {
    return round_point_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn round_point_line_weight_expansion(self_: RoundPoint, other: Line) -> Circle {
    return round_point_dipole_wedge(self_, line_right_weight_dual(other));
}

fn round_point_line_at_origin_weight_expansion(self_: RoundPoint, other: LineAtOrigin) -> Circle {
    return round_point_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn round_point_motor_weight_expansion(self_: RoundPoint, other: Motor) -> MultiVector {
    return round_point_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn round_point_multi_vector_weight_expansion(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return round_point_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn round_point_plane_weight_expansion(self_: RoundPoint, other: Plane) -> Dipole {
    return round_point_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn round_point_plane_at_origin_weight_expansion(self_: RoundPoint, other: PlaneAtOrigin) -> Dipole {
    return round_point_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn round_point_point_at_origin_weight_expansion(self_: RoundPoint, other: PointAtOrigin) -> Sphere {
    return round_point_circle_wedge(self_, point_at_origin_right_weight_dual(other));
}

fn round_point_rotor_weight_expansion(self_: RoundPoint, other: Rotor) -> MultiVector {
    return round_point_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn round_point_sphere_weight_expansion(self_: RoundPoint, other: Sphere) -> Dipole {
    return round_point_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn round_point_translator_weight_expansion(self_: RoundPoint, other: Translator) -> RoundPoint {
    return round_point_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn sphere_flector_weight_expansion(self_: Sphere, other: Flector) -> MultiVector {
    return sphere_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn sphere_motor_weight_expansion(self_: Sphere, other: Motor) -> MultiVector {
    return sphere_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn sphere_multi_vector_weight_expansion(self_: Sphere, other: MultiVector) -> MultiVector {
    return sphere_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn sphere_plane_weight_expansion(self_: Sphere, other: Plane) -> AntiScalar {
    return sphere_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn sphere_plane_at_origin_weight_expansion(self_: Sphere, other: PlaneAtOrigin) -> AntiScalar {
    return sphere_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn sphere_rotor_weight_expansion(self_: Sphere, other: Rotor) -> MultiVector {
    return sphere_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn sphere_sphere_weight_expansion(self_: Sphere, other: Sphere) -> AntiScalar {
    return sphere_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn sphere_translator_weight_expansion(self_: Sphere, other: Translator) -> Sphere {
    return sphere_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn translator_circle_weight_expansion(self_: Translator, other: Circle) -> AntiScalar {
    return translator_dipole_wedge(self_, circle_right_weight_dual(other));
}

fn translator_flector_weight_expansion(self_: Translator, other: Flector) -> MultiVector {
    return translator_multi_vector_wedge(self_, flector_right_weight_dual(other));
}

fn translator_line_weight_expansion(self_: Translator, other: Line) -> AntiScalar {
    return translator_dipole_wedge(self_, line_right_weight_dual(other));
}

fn translator_line_at_origin_weight_expansion(self_: Translator, other: LineAtOrigin) -> AntiScalar {
    return translator_dipole_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn translator_motor_weight_expansion(self_: Translator, other: Motor) -> MultiVector {
    return translator_multi_vector_wedge(self_, motor_right_weight_dual(other));
}

fn translator_multi_vector_weight_expansion(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn translator_plane_weight_expansion(self_: Translator, other: Plane) -> Plane {
    return translator_round_point_wedge(self_, plane_right_weight_dual(other));
}

fn translator_plane_at_origin_weight_expansion(self_: Translator, other: PlaneAtOrigin) -> Plane {
    return translator_round_point_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn translator_rotor_weight_expansion(self_: Translator, other: Rotor) -> MultiVector {
    return translator_multi_vector_wedge(self_, rotor_right_weight_dual(other));
}

fn translator_sphere_weight_expansion(self_: Translator, other: Sphere) -> Plane {
    return translator_round_point_wedge(self_, sphere_right_weight_dual(other));
}

fn translator_translator_weight_expansion(self_: Translator, other: Translator) -> Translator {
    return translator_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn circle_circle_anti_project_via_horizon_onto(self_: Circle, other: Circle) -> Circle {
    return circle_scalar_wedge(other, circle_circle_bulk_contraction(self_, other));
}

fn circle_dipole_anti_project_via_horizon_onto(self_: Circle, other: Dipole) -> Circle {
    return dipole_round_point_wedge(other, circle_dipole_bulk_contraction(self_, other));
}

fn circle_flat_point_anti_project_via_horizon_onto(self_: Circle, other: FlatPoint) -> Line {
    return flat_point_round_point_wedge(other, circle_flat_point_bulk_contraction(self_, other));
}

fn circle_flector_anti_project_via_horizon_onto(self_: Circle, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, circle_flector_bulk_contraction(self_, other));
}

fn circle_infinity_anti_project_via_horizon_onto(self_: Circle, other: Infinity) -> Line {
    return infinity_dipole_wedge(other, circle_infinity_bulk_contraction(self_, other));
}

fn circle_line_anti_project_via_horizon_onto(self_: Circle, other: Line) -> Line {
    return line_scalar_wedge(other, circle_line_bulk_contraction(self_, other));
}

fn circle_line_at_infinity_anti_project_via_horizon_onto(self_: Circle, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(other, circle_line_at_infinity_bulk_contraction(self_, other));
}

fn circle_motor_anti_project_via_horizon_onto(self_: Circle, other: Motor) -> Motor {
    return motor_scalar_wedge(other, circle_motor_bulk_contraction(self_, other));
}

fn circle_multi_vector_anti_project_via_horizon_onto(self_: Circle, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, circle_multi_vector_bulk_contraction(self_, other));
}

fn circle_point_at_infinity_anti_project_via_horizon_onto(self_: Circle, other: PointAtInfinity) -> Line {
    return point_at_infinity_round_point_wedge(other, circle_point_at_infinity_bulk_contraction(self_, other));
}

fn circle_round_point_anti_project_via_horizon_onto(self_: Circle, other: RoundPoint) -> Circle {
    return round_point_dipole_wedge(other, circle_round_point_bulk_contraction(self_, other));
}

fn circle_translator_anti_project_via_horizon_onto(self_: Circle, other: Translator) -> Translator {
    return translator_scalar_wedge(other, circle_translator_bulk_contraction(self_, other));
}

fn dipole_dipole_anti_project_via_horizon_onto(self_: Dipole, other: Dipole) -> Dipole {
    return dipole_scalar_wedge(other, dipole_dipole_bulk_contraction(self_, other));
}

fn dipole_flat_point_anti_project_via_horizon_onto(self_: Dipole, other: FlatPoint) -> FlatPoint {
    return flat_point_scalar_wedge(other, dipole_flat_point_bulk_contraction(self_, other));
}

fn dipole_flector_anti_project_via_horizon_onto(self_: Dipole, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, dipole_flector_bulk_contraction(self_, other));
}

fn dipole_infinity_anti_project_via_horizon_onto(self_: Dipole, other: Infinity) -> FlatPoint {
    return infinity_round_point_wedge(other, dipole_infinity_bulk_contraction(self_, other));
}

fn dipole_multi_vector_anti_project_via_horizon_onto(self_: Dipole, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, dipole_multi_vector_bulk_contraction(self_, other));
}

fn dipole_point_at_infinity_anti_project_via_horizon_onto(self_: Dipole, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(other, dipole_point_at_infinity_bulk_contraction(self_, other));
}

fn dipole_round_point_anti_project_via_horizon_onto(self_: Dipole, other: RoundPoint) -> Dipole {
    return round_point_round_point_wedge(other, dipole_round_point_bulk_contraction(self_, other));
}

fn flat_point_dipole_anti_project_via_horizon_onto(self_: FlatPoint, other: Dipole) -> Dipole {
    return dipole_scalar_wedge(other, flat_point_dipole_bulk_contraction(self_, other));
}

fn flat_point_flat_point_anti_project_via_horizon_onto(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return flat_point_scalar_wedge(other, flat_point_flat_point_bulk_contraction(self_, other));
}

fn flat_point_flector_anti_project_via_horizon_onto(self_: FlatPoint, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, flat_point_flector_bulk_contraction(self_, other));
}

fn flat_point_infinity_anti_project_via_horizon_onto(self_: FlatPoint, other: Infinity) -> FlatPoint {
    return infinity_round_point_wedge(other, flat_point_infinity_bulk_contraction(self_, other));
}

fn flat_point_multi_vector_anti_project_via_horizon_onto(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, flat_point_multi_vector_bulk_contraction(self_, other));
}

fn flat_point_point_at_infinity_anti_project_via_horizon_onto(self_: FlatPoint, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(other, flat_point_point_at_infinity_bulk_contraction(self_, other));
}

fn flat_point_round_point_anti_project_via_horizon_onto(self_: FlatPoint, other: RoundPoint) -> Dipole {
    return round_point_round_point_wedge(other, flat_point_round_point_bulk_contraction(self_, other));
}

fn flector_circle_anti_project_via_horizon_onto(self_: Flector, other: Circle) -> Sphere {
    return circle_round_point_wedge(other, flector_circle_bulk_contraction(self_, other));
}

fn flector_dipole_anti_project_via_horizon_onto(self_: Flector, other: Dipole) -> MultiVector {
    return dipole_multi_vector_wedge(other, flector_dipole_bulk_contraction(self_, other));
}

fn flector_flat_point_anti_project_via_horizon_onto(self_: Flector, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_wedge(other, flector_flat_point_bulk_contraction(self_, other));
}

fn flector_flector_anti_project_via_horizon_onto(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, flector_flector_bulk_contraction(self_, other));
}

fn flector_horizon_anti_project_via_horizon_onto(self_: Flector, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, flector_horizon_bulk_contraction(self_, other));
}

fn flector_infinity_anti_project_via_horizon_onto(self_: Flector, other: Infinity) -> MultiVector {
    return infinity_multi_vector_wedge(other, flector_infinity_bulk_contraction(self_, other));
}

fn flector_line_anti_project_via_horizon_onto(self_: Flector, other: Line) -> Plane {
    return line_round_point_wedge(other, flector_line_bulk_contraction(self_, other));
}

fn flector_line_at_infinity_anti_project_via_horizon_onto(self_: Flector, other: LineAtInfinity) -> Plane {
    return line_at_infinity_round_point_wedge(other, flector_line_at_infinity_bulk_contraction(self_, other));
}

fn flector_motor_anti_project_via_horizon_onto(self_: Flector, other: Motor) -> Plane {
    return motor_round_point_wedge(other, flector_motor_bulk_contraction(self_, other));
}

fn flector_multi_vector_anti_project_via_horizon_onto(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, flector_multi_vector_bulk_contraction(self_, other));
}

fn flector_plane_anti_project_via_horizon_onto(self_: Flector, other: Plane) -> Plane {
    return plane_scalar_wedge(other, flector_plane_bulk_contraction(self_, other));
}

fn flector_point_at_infinity_anti_project_via_horizon_onto(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, flector_point_at_infinity_bulk_contraction(self_, other));
}

fn flector_round_point_anti_project_via_horizon_onto(self_: Flector, other: RoundPoint) -> MultiVector {
    return round_point_multi_vector_wedge(other, flector_round_point_bulk_contraction(self_, other));
}

fn flector_sphere_anti_project_via_horizon_onto(self_: Flector, other: Sphere) -> Sphere {
    return sphere_scalar_wedge(other, flector_sphere_bulk_contraction(self_, other));
}

fn flector_translator_anti_project_via_horizon_onto(self_: Flector, other: Translator) -> Plane {
    return translator_round_point_wedge(other, flector_translator_bulk_contraction(self_, other));
}

fn horizon_circle_anti_project_via_horizon_onto(self_: Horizon, other: Circle) -> Sphere {
    return circle_round_point_wedge(other, horizon_circle_bulk_contraction(self_, other));
}

fn horizon_dipole_anti_project_via_horizon_onto(self_: Horizon, other: Dipole) -> Sphere {
    return dipole_dipole_wedge(other, horizon_dipole_bulk_contraction(self_, other));
}

fn horizon_flat_point_anti_project_via_horizon_onto(self_: Horizon, other: FlatPoint) -> Plane {
    return flat_point_dipole_wedge(other, horizon_flat_point_bulk_contraction(self_, other));
}

fn horizon_flector_anti_project_via_horizon_onto(self_: Horizon, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, horizon_flector_bulk_contraction(self_, other));
}

fn horizon_horizon_anti_project_via_horizon_onto(self_: Horizon, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, horizon_horizon_bulk_contraction(self_, other));
}

fn horizon_infinity_anti_project_via_horizon_onto(self_: Horizon, other: Infinity) -> Plane {
    return infinity_circle_wedge(other, horizon_infinity_bulk_contraction(self_, other));
}

fn horizon_line_anti_project_via_horizon_onto(self_: Horizon, other: Line) -> Plane {
    return line_round_point_wedge(other, horizon_line_bulk_contraction(self_, other));
}

fn horizon_line_at_infinity_anti_project_via_horizon_onto(self_: Horizon, other: LineAtInfinity) -> Plane {
    return line_at_infinity_round_point_wedge(other, horizon_line_at_infinity_bulk_contraction(self_, other));
}

fn horizon_motor_anti_project_via_horizon_onto(self_: Horizon, other: Motor) -> Plane {
    return motor_round_point_wedge(other, horizon_motor_bulk_contraction(self_, other));
}

fn horizon_multi_vector_anti_project_via_horizon_onto(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, horizon_multi_vector_bulk_contraction(self_, other));
}

fn horizon_plane_anti_project_via_horizon_onto(self_: Horizon, other: Plane) -> Plane {
    return plane_scalar_wedge(other, horizon_plane_bulk_contraction(self_, other));
}

fn horizon_point_at_infinity_anti_project_via_horizon_onto(self_: Horizon, other: PointAtInfinity) -> Plane {
    return point_at_infinity_dipole_wedge(other, horizon_point_at_infinity_bulk_contraction(self_, other));
}

fn horizon_round_point_anti_project_via_horizon_onto(self_: Horizon, other: RoundPoint) -> Sphere {
    return round_point_circle_wedge(other, horizon_round_point_bulk_contraction(self_, other));
}

fn horizon_sphere_anti_project_via_horizon_onto(self_: Horizon, other: Sphere) -> Sphere {
    return sphere_scalar_wedge(other, horizon_sphere_bulk_contraction(self_, other));
}

fn horizon_translator_anti_project_via_horizon_onto(self_: Horizon, other: Translator) -> Plane {
    return translator_round_point_wedge(other, horizon_translator_bulk_contraction(self_, other));
}

fn infinity_flector_anti_project_via_horizon_onto(self_: Infinity, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, infinity_flector_bulk_contraction(self_, other));
}

fn infinity_infinity_anti_project_via_horizon_onto(self_: Infinity, other: Infinity) -> Infinity {
    return infinity_scalar_wedge(other, infinity_infinity_bulk_contraction(self_, other));
}

fn infinity_multi_vector_anti_project_via_horizon_onto(self_: Infinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, infinity_multi_vector_bulk_contraction(self_, other));
}

fn infinity_round_point_anti_project_via_horizon_onto(self_: Infinity, other: RoundPoint) -> RoundPoint {
    return round_point_scalar_wedge(other, infinity_round_point_bulk_contraction(self_, other));
}

fn line_circle_anti_project_via_horizon_onto(self_: Line, other: Circle) -> Circle {
    return circle_scalar_wedge(other, line_circle_bulk_contraction(self_, other));
}

fn line_dipole_anti_project_via_horizon_onto(self_: Line, other: Dipole) -> Circle {
    return dipole_round_point_wedge(other, line_dipole_bulk_contraction(self_, other));
}

fn line_flat_point_anti_project_via_horizon_onto(self_: Line, other: FlatPoint) -> Line {
    return flat_point_round_point_wedge(other, line_flat_point_bulk_contraction(self_, other));
}

fn line_flector_anti_project_via_horizon_onto(self_: Line, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, line_flector_bulk_contraction(self_, other));
}

fn line_infinity_anti_project_via_horizon_onto(self_: Line, other: Infinity) -> Line {
    return infinity_dipole_wedge(other, line_infinity_bulk_contraction(self_, other));
}

fn line_line_anti_project_via_horizon_onto(self_: Line, other: Line) -> Line {
    return line_scalar_wedge(other, line_line_bulk_contraction(self_, other));
}

fn line_line_at_infinity_anti_project_via_horizon_onto(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(other, line_line_at_infinity_bulk_contraction(self_, other));
}

fn line_motor_anti_project_via_horizon_onto(self_: Line, other: Motor) -> Motor {
    return motor_scalar_wedge(other, line_motor_bulk_contraction(self_, other));
}

fn line_multi_vector_anti_project_via_horizon_onto(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, line_multi_vector_bulk_contraction(self_, other));
}

fn line_point_at_infinity_anti_project_via_horizon_onto(self_: Line, other: PointAtInfinity) -> Line {
    return point_at_infinity_round_point_wedge(other, line_point_at_infinity_bulk_contraction(self_, other));
}

fn line_round_point_anti_project_via_horizon_onto(self_: Line, other: RoundPoint) -> Circle {
    return round_point_dipole_wedge(other, line_round_point_bulk_contraction(self_, other));
}

fn line_translator_anti_project_via_horizon_onto(self_: Line, other: Translator) -> Translator {
    return translator_scalar_wedge(other, line_translator_bulk_contraction(self_, other));
}

fn line_at_infinity_circle_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Circle) -> Circle {
    return circle_scalar_wedge(other, line_at_infinity_circle_bulk_contraction(self_, other));
}

fn line_at_infinity_dipole_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Dipole) -> Circle {
    return dipole_round_point_wedge(other, line_at_infinity_dipole_bulk_contraction(self_, other));
}

fn line_at_infinity_flat_point_anti_project_via_horizon_onto(self_: LineAtInfinity, other: FlatPoint) -> Line {
    return flat_point_round_point_wedge(other, line_at_infinity_flat_point_bulk_contraction(self_, other));
}

fn line_at_infinity_flector_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, line_at_infinity_flector_bulk_contraction(self_, other));
}

fn line_at_infinity_infinity_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Infinity) -> Line {
    return infinity_dipole_wedge(other, line_at_infinity_infinity_bulk_contraction(self_, other));
}

fn line_at_infinity_line_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Line) -> Line {
    return line_scalar_wedge(other, line_at_infinity_line_bulk_contraction(self_, other));
}

fn line_at_infinity_line_at_infinity_anti_project_via_horizon_onto(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(other, line_at_infinity_line_at_infinity_bulk_contraction(self_, other));
}

fn line_at_infinity_motor_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Motor) -> Motor {
    return motor_scalar_wedge(other, line_at_infinity_motor_bulk_contraction(self_, other));
}

fn line_at_infinity_multi_vector_anti_project_via_horizon_onto(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, line_at_infinity_multi_vector_bulk_contraction(self_, other));
}

fn line_at_infinity_point_at_infinity_anti_project_via_horizon_onto(self_: LineAtInfinity, other: PointAtInfinity) -> Line {
    return point_at_infinity_round_point_wedge(other, line_at_infinity_point_at_infinity_bulk_contraction(self_, other));
}

fn line_at_infinity_round_point_anti_project_via_horizon_onto(self_: LineAtInfinity, other: RoundPoint) -> Circle {
    return round_point_dipole_wedge(other, line_at_infinity_round_point_bulk_contraction(self_, other));
}

fn line_at_infinity_translator_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Translator) -> Translator {
    return translator_scalar_wedge(other, line_at_infinity_translator_bulk_contraction(self_, other));
}

fn line_at_origin_circle_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Circle) -> Circle {
    return circle_scalar_wedge(other, line_at_origin_circle_bulk_contraction(self_, other));
}

fn line_at_origin_dipole_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Dipole) -> Circle {
    return dipole_round_point_wedge(other, line_at_origin_dipole_bulk_contraction(self_, other));
}

fn line_at_origin_flat_point_anti_project_via_horizon_onto(self_: LineAtOrigin, other: FlatPoint) -> Line {
    return flat_point_round_point_wedge(other, line_at_origin_flat_point_bulk_contraction(self_, other));
}

fn line_at_origin_flector_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, line_at_origin_flector_bulk_contraction(self_, other));
}

fn line_at_origin_infinity_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Infinity) -> Line {
    return infinity_dipole_wedge(other, line_at_origin_infinity_bulk_contraction(self_, other));
}

fn line_at_origin_line_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Line) -> Line {
    return line_scalar_wedge(other, line_at_origin_line_bulk_contraction(self_, other));
}

fn line_at_origin_line_at_infinity_anti_project_via_horizon_onto(self_: LineAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(other, line_at_origin_line_at_infinity_bulk_contraction(self_, other));
}

fn line_at_origin_motor_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Motor) -> Motor {
    return motor_scalar_wedge(other, line_at_origin_motor_bulk_contraction(self_, other));
}

fn line_at_origin_multi_vector_anti_project_via_horizon_onto(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, line_at_origin_multi_vector_bulk_contraction(self_, other));
}

fn line_at_origin_point_at_infinity_anti_project_via_horizon_onto(self_: LineAtOrigin, other: PointAtInfinity) -> Line {
    return point_at_infinity_round_point_wedge(other, line_at_origin_point_at_infinity_bulk_contraction(self_, other));
}

fn line_at_origin_round_point_anti_project_via_horizon_onto(self_: LineAtOrigin, other: RoundPoint) -> Circle {
    return round_point_dipole_wedge(other, line_at_origin_round_point_bulk_contraction(self_, other));
}

fn line_at_origin_translator_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Translator) -> Translator {
    return translator_scalar_wedge(other, line_at_origin_translator_bulk_contraction(self_, other));
}

fn motor_circle_anti_project_via_horizon_onto(self_: Motor, other: Circle) -> MultiVector {
    return circle_multi_vector_wedge(other, motor_circle_bulk_contraction(self_, other));
}

fn motor_dipole_anti_project_via_horizon_onto(self_: Motor, other: Dipole) -> MultiVector {
    return dipole_multi_vector_wedge(other, motor_dipole_bulk_contraction(self_, other));
}

fn motor_flat_point_anti_project_via_horizon_onto(self_: Motor, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_wedge(other, motor_flat_point_bulk_contraction(self_, other));
}

fn motor_flector_anti_project_via_horizon_onto(self_: Motor, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, motor_flector_bulk_contraction(self_, other));
}

fn motor_horizon_anti_project_via_horizon_onto(self_: Motor, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(other, motor_horizon_bulk_contraction(self_, other));
}

fn motor_infinity_anti_project_via_horizon_onto(self_: Motor, other: Infinity) -> MultiVector {
    return infinity_multi_vector_wedge(other, motor_infinity_bulk_contraction(self_, other));
}

fn motor_line_anti_project_via_horizon_onto(self_: Motor, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, motor_line_bulk_contraction(self_, other));
}

fn motor_line_at_infinity_anti_project_via_horizon_onto(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, motor_line_at_infinity_bulk_contraction(self_, other));
}

fn motor_motor_anti_project_via_horizon_onto(self_: Motor, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, motor_motor_bulk_contraction(self_, other));
}

fn motor_multi_vector_anti_project_via_horizon_onto(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, motor_multi_vector_bulk_contraction(self_, other));
}

fn motor_plane_anti_project_via_horizon_onto(self_: Motor, other: Plane) -> AntiScalar {
    return plane_origin_wedge(other, motor_plane_bulk_contraction(self_, other));
}

fn motor_point_at_infinity_anti_project_via_horizon_onto(self_: Motor, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, motor_point_at_infinity_bulk_contraction(self_, other));
}

fn motor_round_point_anti_project_via_horizon_onto(self_: Motor, other: RoundPoint) -> MultiVector {
    return round_point_multi_vector_wedge(other, motor_round_point_bulk_contraction(self_, other));
}

fn motor_sphere_anti_project_via_horizon_onto(self_: Motor, other: Sphere) -> AntiScalar {
    return sphere_origin_wedge(other, motor_sphere_bulk_contraction(self_, other));
}

fn motor_translator_anti_project_via_horizon_onto(self_: Motor, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, motor_translator_bulk_contraction(self_, other));
}

fn multi_vector_circle_anti_project_via_horizon_onto(self_: MultiVector, other: Circle) -> MultiVector {
    return circle_multi_vector_wedge(other, multi_vector_circle_bulk_contraction(self_, other));
}

fn multi_vector_dipole_anti_project_via_horizon_onto(self_: MultiVector, other: Dipole) -> MultiVector {
    return dipole_multi_vector_wedge(other, multi_vector_dipole_bulk_contraction(self_, other));
}

fn multi_vector_flat_point_anti_project_via_horizon_onto(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_wedge(other, multi_vector_flat_point_bulk_contraction(self_, other));
}

fn multi_vector_flector_anti_project_via_horizon_onto(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, multi_vector_flector_bulk_contraction(self_, other));
}

fn multi_vector_horizon_anti_project_via_horizon_onto(self_: MultiVector, other: Horizon) -> MultiVector {
    return horizon_multi_vector_wedge(other, multi_vector_horizon_bulk_contraction(self_, other));
}

fn multi_vector_infinity_anti_project_via_horizon_onto(self_: MultiVector, other: Infinity) -> MultiVector {
    return infinity_multi_vector_wedge(other, multi_vector_infinity_bulk_contraction(self_, other));
}

fn multi_vector_line_anti_project_via_horizon_onto(self_: MultiVector, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, multi_vector_line_bulk_contraction(self_, other));
}

fn multi_vector_line_at_infinity_anti_project_via_horizon_onto(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, multi_vector_line_at_infinity_bulk_contraction(self_, other));
}

fn multi_vector_motor_anti_project_via_horizon_onto(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, multi_vector_motor_bulk_contraction(self_, other));
}

fn multi_vector_multi_vector_anti_project_via_horizon_onto(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, multi_vector_multi_vector_bulk_contraction(self_, other));
}

fn multi_vector_plane_anti_project_via_horizon_onto(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_multi_vector_wedge(other, multi_vector_plane_bulk_contraction(self_, other));
}

fn multi_vector_point_at_infinity_anti_project_via_horizon_onto(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, multi_vector_point_at_infinity_bulk_contraction(self_, other));
}

fn multi_vector_round_point_anti_project_via_horizon_onto(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return round_point_multi_vector_wedge(other, multi_vector_round_point_bulk_contraction(self_, other));
}

fn multi_vector_sphere_anti_project_via_horizon_onto(self_: MultiVector, other: Sphere) -> MultiVector {
    return sphere_multi_vector_wedge(other, multi_vector_sphere_bulk_contraction(self_, other));
}

fn multi_vector_translator_anti_project_via_horizon_onto(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, multi_vector_translator_bulk_contraction(self_, other));
}

fn origin_flector_anti_project_via_horizon_onto(self_: Origin, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, origin_flector_bulk_contraction(self_, other));
}

fn origin_infinity_anti_project_via_horizon_onto(self_: Origin, other: Infinity) -> Infinity {
    return infinity_scalar_wedge(other, origin_infinity_bulk_contraction(self_, other));
}

fn origin_multi_vector_anti_project_via_horizon_onto(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, origin_multi_vector_bulk_contraction(self_, other));
}

fn origin_round_point_anti_project_via_horizon_onto(self_: Origin, other: RoundPoint) -> RoundPoint {
    return round_point_scalar_wedge(other, origin_round_point_bulk_contraction(self_, other));
}

fn plane_circle_anti_project_via_horizon_onto(self_: Plane, other: Circle) -> Sphere {
    return circle_round_point_wedge(other, plane_circle_bulk_contraction(self_, other));
}

fn plane_dipole_anti_project_via_horizon_onto(self_: Plane, other: Dipole) -> Sphere {
    return dipole_dipole_wedge(other, plane_dipole_bulk_contraction(self_, other));
}

fn plane_flat_point_anti_project_via_horizon_onto(self_: Plane, other: FlatPoint) -> Plane {
    return flat_point_dipole_wedge(other, plane_flat_point_bulk_contraction(self_, other));
}

fn plane_flector_anti_project_via_horizon_onto(self_: Plane, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, plane_flector_bulk_contraction(self_, other));
}

fn plane_horizon_anti_project_via_horizon_onto(self_: Plane, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, plane_horizon_bulk_contraction(self_, other));
}

fn plane_infinity_anti_project_via_horizon_onto(self_: Plane, other: Infinity) -> Plane {
    return infinity_circle_wedge(other, plane_infinity_bulk_contraction(self_, other));
}

fn plane_line_anti_project_via_horizon_onto(self_: Plane, other: Line) -> Plane {
    return line_round_point_wedge(other, plane_line_bulk_contraction(self_, other));
}

fn plane_line_at_infinity_anti_project_via_horizon_onto(self_: Plane, other: LineAtInfinity) -> Plane {
    return line_at_infinity_round_point_wedge(other, plane_line_at_infinity_bulk_contraction(self_, other));
}

fn plane_motor_anti_project_via_horizon_onto(self_: Plane, other: Motor) -> Plane {
    return motor_round_point_wedge(other, plane_motor_bulk_contraction(self_, other));
}

fn plane_multi_vector_anti_project_via_horizon_onto(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, plane_multi_vector_bulk_contraction(self_, other));
}

fn plane_plane_anti_project_via_horizon_onto(self_: Plane, other: Plane) -> Plane {
    return plane_scalar_wedge(other, plane_plane_bulk_contraction(self_, other));
}

fn plane_point_at_infinity_anti_project_via_horizon_onto(self_: Plane, other: PointAtInfinity) -> Plane {
    return point_at_infinity_dipole_wedge(other, plane_point_at_infinity_bulk_contraction(self_, other));
}

fn plane_round_point_anti_project_via_horizon_onto(self_: Plane, other: RoundPoint) -> Sphere {
    return round_point_circle_wedge(other, plane_round_point_bulk_contraction(self_, other));
}

fn plane_sphere_anti_project_via_horizon_onto(self_: Plane, other: Sphere) -> Sphere {
    return sphere_scalar_wedge(other, plane_sphere_bulk_contraction(self_, other));
}

fn plane_translator_anti_project_via_horizon_onto(self_: Plane, other: Translator) -> Plane {
    return translator_round_point_wedge(other, plane_translator_bulk_contraction(self_, other));
}

fn plane_at_origin_circle_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Circle) -> Sphere {
    return circle_round_point_wedge(other, plane_at_origin_circle_bulk_contraction(self_, other));
}

fn plane_at_origin_dipole_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Dipole) -> Sphere {
    return dipole_dipole_wedge(other, plane_at_origin_dipole_bulk_contraction(self_, other));
}

fn plane_at_origin_flat_point_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: FlatPoint) -> Plane {
    return flat_point_dipole_wedge(other, plane_at_origin_flat_point_bulk_contraction(self_, other));
}

fn plane_at_origin_flector_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, plane_at_origin_flector_bulk_contraction(self_, other));
}

fn plane_at_origin_infinity_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Infinity) -> Plane {
    return infinity_circle_wedge(other, plane_at_origin_infinity_bulk_contraction(self_, other));
}

fn plane_at_origin_line_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Line) -> Plane {
    return line_round_point_wedge(other, plane_at_origin_line_bulk_contraction(self_, other));
}

fn plane_at_origin_line_at_infinity_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: LineAtInfinity) -> Plane {
    return line_at_infinity_round_point_wedge(other, plane_at_origin_line_at_infinity_bulk_contraction(self_, other));
}

fn plane_at_origin_motor_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Motor) -> Plane {
    return motor_round_point_wedge(other, plane_at_origin_motor_bulk_contraction(self_, other));
}

fn plane_at_origin_multi_vector_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, plane_at_origin_multi_vector_bulk_contraction(self_, other));
}

fn plane_at_origin_point_at_infinity_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: PointAtInfinity) -> Plane {
    return point_at_infinity_dipole_wedge(other, plane_at_origin_point_at_infinity_bulk_contraction(self_, other));
}

fn plane_at_origin_round_point_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: RoundPoint) -> Sphere {
    return round_point_circle_wedge(other, plane_at_origin_round_point_bulk_contraction(self_, other));
}

fn plane_at_origin_translator_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Translator) -> Plane {
    return translator_round_point_wedge(other, plane_at_origin_translator_bulk_contraction(self_, other));
}

fn point_at_infinity_dipole_anti_project_via_horizon_onto(self_: PointAtInfinity, other: Dipole) -> Dipole {
    return dipole_scalar_wedge(other, point_at_infinity_dipole_bulk_contraction(self_, other));
}

fn point_at_infinity_flat_point_anti_project_via_horizon_onto(self_: PointAtInfinity, other: FlatPoint) -> FlatPoint {
    return flat_point_scalar_wedge(other, point_at_infinity_flat_point_bulk_contraction(self_, other));
}

fn point_at_infinity_flector_anti_project_via_horizon_onto(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, point_at_infinity_flector_bulk_contraction(self_, other));
}

fn point_at_infinity_infinity_anti_project_via_horizon_onto(self_: PointAtInfinity, other: Infinity) -> FlatPoint {
    return infinity_round_point_wedge(other, point_at_infinity_infinity_bulk_contraction(self_, other));
}

fn point_at_infinity_multi_vector_anti_project_via_horizon_onto(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, point_at_infinity_multi_vector_bulk_contraction(self_, other));
}

fn point_at_infinity_point_at_infinity_anti_project_via_horizon_onto(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(other, point_at_infinity_point_at_infinity_bulk_contraction(self_, other));
}

fn point_at_infinity_round_point_anti_project_via_horizon_onto(self_: PointAtInfinity, other: RoundPoint) -> Dipole {
    return round_point_round_point_wedge(other, point_at_infinity_round_point_bulk_contraction(self_, other));
}

fn point_at_origin_dipole_anti_project_via_horizon_onto(self_: PointAtOrigin, other: Dipole) -> Dipole {
    return dipole_scalar_wedge(other, point_at_origin_dipole_bulk_contraction(self_, other));
}

fn point_at_origin_flat_point_anti_project_via_horizon_onto(self_: PointAtOrigin, other: FlatPoint) -> FlatPoint {
    return flat_point_scalar_wedge(other, point_at_origin_flat_point_bulk_contraction(self_, other));
}

fn point_at_origin_flector_anti_project_via_horizon_onto(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, point_at_origin_flector_bulk_contraction(self_, other));
}

fn point_at_origin_infinity_anti_project_via_horizon_onto(self_: PointAtOrigin, other: Infinity) -> FlatPoint {
    return infinity_round_point_wedge(other, point_at_origin_infinity_bulk_contraction(self_, other));
}

fn point_at_origin_multi_vector_anti_project_via_horizon_onto(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, point_at_origin_multi_vector_bulk_contraction(self_, other));
}

fn point_at_origin_point_at_infinity_anti_project_via_horizon_onto(self_: PointAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(other, point_at_origin_point_at_infinity_bulk_contraction(self_, other));
}

fn point_at_origin_round_point_anti_project_via_horizon_onto(self_: PointAtOrigin, other: RoundPoint) -> Dipole {
    return round_point_round_point_wedge(other, point_at_origin_round_point_bulk_contraction(self_, other));
}

fn rotor_circle_anti_project_via_horizon_onto(self_: Rotor, other: Circle) -> MultiVector {
    return circle_multi_vector_wedge(other, rotor_circle_bulk_contraction(self_, other));
}

fn rotor_dipole_anti_project_via_horizon_onto(self_: Rotor, other: Dipole) -> MultiVector {
    return dipole_multi_vector_wedge(other, rotor_dipole_bulk_contraction(self_, other));
}

fn rotor_flat_point_anti_project_via_horizon_onto(self_: Rotor, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_wedge(other, rotor_flat_point_bulk_contraction(self_, other));
}

fn rotor_flector_anti_project_via_horizon_onto(self_: Rotor, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, rotor_flector_bulk_contraction(self_, other));
}

fn rotor_horizon_anti_project_via_horizon_onto(self_: Rotor, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(other, rotor_horizon_bulk_contraction(self_, other));
}

fn rotor_infinity_anti_project_via_horizon_onto(self_: Rotor, other: Infinity) -> MultiVector {
    return infinity_multi_vector_wedge(other, rotor_infinity_bulk_contraction(self_, other));
}

fn rotor_line_anti_project_via_horizon_onto(self_: Rotor, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, rotor_line_bulk_contraction(self_, other));
}

fn rotor_line_at_infinity_anti_project_via_horizon_onto(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, rotor_line_at_infinity_bulk_contraction(self_, other));
}

fn rotor_motor_anti_project_via_horizon_onto(self_: Rotor, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, rotor_motor_bulk_contraction(self_, other));
}

fn rotor_multi_vector_anti_project_via_horizon_onto(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, rotor_multi_vector_bulk_contraction(self_, other));
}

fn rotor_plane_anti_project_via_horizon_onto(self_: Rotor, other: Plane) -> AntiScalar {
    return plane_origin_wedge(other, rotor_plane_bulk_contraction(self_, other));
}

fn rotor_point_at_infinity_anti_project_via_horizon_onto(self_: Rotor, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, rotor_point_at_infinity_bulk_contraction(self_, other));
}

fn rotor_round_point_anti_project_via_horizon_onto(self_: Rotor, other: RoundPoint) -> MultiVector {
    return round_point_multi_vector_wedge(other, rotor_round_point_bulk_contraction(self_, other));
}

fn rotor_sphere_anti_project_via_horizon_onto(self_: Rotor, other: Sphere) -> AntiScalar {
    return sphere_origin_wedge(other, rotor_sphere_bulk_contraction(self_, other));
}

fn rotor_translator_anti_project_via_horizon_onto(self_: Rotor, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, rotor_translator_bulk_contraction(self_, other));
}

fn round_point_flector_anti_project_via_horizon_onto(self_: RoundPoint, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, round_point_flector_bulk_contraction(self_, other));
}

fn round_point_infinity_anti_project_via_horizon_onto(self_: RoundPoint, other: Infinity) -> Infinity {
    return infinity_scalar_wedge(other, round_point_infinity_bulk_contraction(self_, other));
}

fn round_point_multi_vector_anti_project_via_horizon_onto(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, round_point_multi_vector_bulk_contraction(self_, other));
}

fn round_point_round_point_anti_project_via_horizon_onto(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return round_point_scalar_wedge(other, round_point_round_point_bulk_contraction(self_, other));
}

fn sphere_circle_anti_project_via_horizon_onto(self_: Sphere, other: Circle) -> Sphere {
    return circle_round_point_wedge(other, sphere_circle_bulk_contraction(self_, other));
}

fn sphere_dipole_anti_project_via_horizon_onto(self_: Sphere, other: Dipole) -> Sphere {
    return dipole_dipole_wedge(other, sphere_dipole_bulk_contraction(self_, other));
}

fn sphere_flat_point_anti_project_via_horizon_onto(self_: Sphere, other: FlatPoint) -> Plane {
    return flat_point_dipole_wedge(other, sphere_flat_point_bulk_contraction(self_, other));
}

fn sphere_flector_anti_project_via_horizon_onto(self_: Sphere, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, sphere_flector_bulk_contraction(self_, other));
}

fn sphere_horizon_anti_project_via_horizon_onto(self_: Sphere, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, sphere_horizon_bulk_contraction(self_, other));
}

fn sphere_infinity_anti_project_via_horizon_onto(self_: Sphere, other: Infinity) -> Plane {
    return infinity_circle_wedge(other, sphere_infinity_bulk_contraction(self_, other));
}

fn sphere_line_anti_project_via_horizon_onto(self_: Sphere, other: Line) -> Plane {
    return line_round_point_wedge(other, sphere_line_bulk_contraction(self_, other));
}

fn sphere_line_at_infinity_anti_project_via_horizon_onto(self_: Sphere, other: LineAtInfinity) -> Plane {
    return line_at_infinity_round_point_wedge(other, sphere_line_at_infinity_bulk_contraction(self_, other));
}

fn sphere_motor_anti_project_via_horizon_onto(self_: Sphere, other: Motor) -> Plane {
    return motor_round_point_wedge(other, sphere_motor_bulk_contraction(self_, other));
}

fn sphere_multi_vector_anti_project_via_horizon_onto(self_: Sphere, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, sphere_multi_vector_bulk_contraction(self_, other));
}

fn sphere_plane_anti_project_via_horizon_onto(self_: Sphere, other: Plane) -> Plane {
    return plane_scalar_wedge(other, sphere_plane_bulk_contraction(self_, other));
}

fn sphere_point_at_infinity_anti_project_via_horizon_onto(self_: Sphere, other: PointAtInfinity) -> Plane {
    return point_at_infinity_dipole_wedge(other, sphere_point_at_infinity_bulk_contraction(self_, other));
}

fn sphere_round_point_anti_project_via_horizon_onto(self_: Sphere, other: RoundPoint) -> Sphere {
    return round_point_circle_wedge(other, sphere_round_point_bulk_contraction(self_, other));
}

fn sphere_sphere_anti_project_via_horizon_onto(self_: Sphere, other: Sphere) -> Sphere {
    return sphere_scalar_wedge(other, sphere_sphere_bulk_contraction(self_, other));
}

fn sphere_translator_anti_project_via_horizon_onto(self_: Sphere, other: Translator) -> Plane {
    return translator_round_point_wedge(other, sphere_translator_bulk_contraction(self_, other));
}

fn translator_circle_anti_project_via_horizon_onto(self_: Translator, other: Circle) -> MultiVector {
    return circle_multi_vector_wedge(other, translator_circle_bulk_contraction(self_, other));
}

fn translator_dipole_anti_project_via_horizon_onto(self_: Translator, other: Dipole) -> MultiVector {
    return dipole_multi_vector_wedge(other, translator_dipole_bulk_contraction(self_, other));
}

fn translator_flat_point_anti_project_via_horizon_onto(self_: Translator, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_wedge(other, translator_flat_point_bulk_contraction(self_, other));
}

fn translator_flector_anti_project_via_horizon_onto(self_: Translator, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, translator_flector_bulk_contraction(self_, other));
}

fn translator_horizon_anti_project_via_horizon_onto(self_: Translator, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(other, translator_horizon_bulk_contraction(self_, other));
}

fn translator_infinity_anti_project_via_horizon_onto(self_: Translator, other: Infinity) -> MultiVector {
    return infinity_multi_vector_wedge(other, translator_infinity_bulk_contraction(self_, other));
}

fn translator_line_anti_project_via_horizon_onto(self_: Translator, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, translator_line_bulk_contraction(self_, other));
}

fn translator_line_at_infinity_anti_project_via_horizon_onto(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, translator_line_at_infinity_bulk_contraction(self_, other));
}

fn translator_motor_anti_project_via_horizon_onto(self_: Translator, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, translator_motor_bulk_contraction(self_, other));
}

fn translator_multi_vector_anti_project_via_horizon_onto(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, translator_multi_vector_bulk_contraction(self_, other));
}

fn translator_plane_anti_project_via_horizon_onto(self_: Translator, other: Plane) -> AntiScalar {
    return plane_origin_wedge(other, translator_plane_bulk_contraction(self_, other));
}

fn translator_point_at_infinity_anti_project_via_horizon_onto(self_: Translator, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, translator_point_at_infinity_bulk_contraction(self_, other));
}

fn translator_round_point_anti_project_via_horizon_onto(self_: Translator, other: RoundPoint) -> MultiVector {
    return round_point_multi_vector_wedge(other, translator_round_point_bulk_contraction(self_, other));
}

fn translator_sphere_anti_project_via_horizon_onto(self_: Translator, other: Sphere) -> AntiScalar {
    return sphere_origin_wedge(other, translator_sphere_bulk_contraction(self_, other));
}

fn translator_translator_anti_project_via_horizon_onto(self_: Translator, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, translator_translator_bulk_contraction(self_, other));
}

fn circle_circle_project_orthogonally_onto(self_: Circle, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, circle_circle_weight_expansion(self_, other));
}

fn circle_flector_project_orthogonally_onto(self_: Circle, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, circle_flector_weight_expansion(self_, other));
}

fn circle_line_project_orthogonally_onto(self_: Circle, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, circle_line_weight_expansion(self_, other));
}

fn circle_line_at_origin_project_orthogonally_onto(self_: Circle, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, circle_line_at_origin_weight_expansion(self_, other));
}

fn circle_motor_project_orthogonally_onto(self_: Circle, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, circle_motor_weight_expansion(self_, other));
}

fn circle_multi_vector_project_orthogonally_onto(self_: Circle, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, circle_multi_vector_weight_expansion(self_, other));
}

fn circle_plane_project_orthogonally_onto(self_: Circle, other: Plane) -> Circle {
    return plane_sphere_anti_wedge(other, circle_plane_weight_expansion(self_, other));
}

fn circle_plane_at_origin_project_orthogonally_onto(self_: Circle, other: PlaneAtOrigin) -> Circle {
    return plane_at_origin_sphere_anti_wedge(other, circle_plane_at_origin_weight_expansion(self_, other));
}

fn circle_rotor_project_orthogonally_onto(self_: Circle, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, circle_rotor_weight_expansion(self_, other));
}

fn circle_sphere_project_orthogonally_onto(self_: Circle, other: Sphere) -> Circle {
    return sphere_sphere_anti_wedge(other, circle_sphere_weight_expansion(self_, other));
}

fn circle_translator_project_orthogonally_onto(self_: Circle, other: Translator) -> MultiVector {
    return translator_circle_anti_wedge(other, circle_translator_weight_expansion(self_, other));
}

fn dipole_circle_project_orthogonally_onto(self_: Dipole, other: Circle) -> Dipole {
    return circle_sphere_anti_wedge(other, dipole_circle_weight_expansion(self_, other));
}

fn dipole_dipole_project_orthogonally_onto(self_: Dipole, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, dipole_dipole_weight_expansion(self_, other));
}

fn dipole_flat_point_project_orthogonally_onto(self_: Dipole, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, dipole_flat_point_weight_expansion(self_, other));
}

fn dipole_flector_project_orthogonally_onto(self_: Dipole, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, dipole_flector_weight_expansion(self_, other));
}

fn dipole_line_project_orthogonally_onto(self_: Dipole, other: Line) -> Dipole {
    return line_sphere_anti_wedge(other, dipole_line_weight_expansion(self_, other));
}

fn dipole_line_at_origin_project_orthogonally_onto(self_: Dipole, other: LineAtOrigin) -> Dipole {
    return line_at_origin_sphere_anti_wedge(other, dipole_line_at_origin_weight_expansion(self_, other));
}

fn dipole_motor_project_orthogonally_onto(self_: Dipole, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, dipole_motor_weight_expansion(self_, other));
}

fn dipole_multi_vector_project_orthogonally_onto(self_: Dipole, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, dipole_multi_vector_weight_expansion(self_, other));
}

fn dipole_plane_project_orthogonally_onto(self_: Dipole, other: Plane) -> Dipole {
    return plane_circle_anti_wedge(other, dipole_plane_weight_expansion(self_, other));
}

fn dipole_plane_at_origin_project_orthogonally_onto(self_: Dipole, other: PlaneAtOrigin) -> Dipole {
    return plane_at_origin_circle_anti_wedge(other, dipole_plane_at_origin_weight_expansion(self_, other));
}

fn dipole_point_at_origin_project_orthogonally_onto(self_: Dipole, other: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_anti_scalar_anti_wedge(other, dipole_point_at_origin_weight_expansion(self_, other));
}

fn dipole_rotor_project_orthogonally_onto(self_: Dipole, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, dipole_rotor_weight_expansion(self_, other));
}

fn dipole_sphere_project_orthogonally_onto(self_: Dipole, other: Sphere) -> Dipole {
    return sphere_circle_anti_wedge(other, dipole_sphere_weight_expansion(self_, other));
}

fn dipole_translator_project_orthogonally_onto(self_: Dipole, other: Translator) -> MultiVector {
    return translator_dipole_anti_wedge(other, dipole_translator_weight_expansion(self_, other));
}

fn flat_point_circle_project_orthogonally_onto(self_: FlatPoint, other: Circle) -> Dipole {
    return circle_plane_anti_wedge(other, flat_point_circle_weight_expansion(self_, other));
}

fn flat_point_dipole_project_orthogonally_onto(self_: FlatPoint, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, flat_point_dipole_weight_expansion(self_, other));
}

fn flat_point_flat_point_project_orthogonally_onto(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, flat_point_flat_point_weight_expansion(self_, other));
}

fn flat_point_flector_project_orthogonally_onto(self_: FlatPoint, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, flat_point_flector_weight_expansion(self_, other));
}

fn flat_point_line_project_orthogonally_onto(self_: FlatPoint, other: Line) -> FlatPoint {
    return line_plane_anti_wedge(other, flat_point_line_weight_expansion(self_, other));
}

fn flat_point_line_at_origin_project_orthogonally_onto(self_: FlatPoint, other: LineAtOrigin) -> FlatPoint {
    return line_at_origin_plane_anti_wedge(other, flat_point_line_at_origin_weight_expansion(self_, other));
}

fn flat_point_motor_project_orthogonally_onto(self_: FlatPoint, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, flat_point_motor_weight_expansion(self_, other));
}

fn flat_point_multi_vector_project_orthogonally_onto(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, flat_point_multi_vector_weight_expansion(self_, other));
}

fn flat_point_plane_project_orthogonally_onto(self_: FlatPoint, other: Plane) -> FlatPoint {
    return plane_line_anti_wedge(other, flat_point_plane_weight_expansion(self_, other));
}

fn flat_point_plane_at_origin_project_orthogonally_onto(self_: FlatPoint, other: PlaneAtOrigin) -> FlatPoint {
    return plane_at_origin_line_anti_wedge(other, flat_point_plane_at_origin_weight_expansion(self_, other));
}

fn flat_point_point_at_origin_project_orthogonally_onto(self_: FlatPoint, other: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_anti_scalar_anti_wedge(other, flat_point_point_at_origin_weight_expansion(self_, other));
}

fn flat_point_rotor_project_orthogonally_onto(self_: FlatPoint, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, flat_point_rotor_weight_expansion(self_, other));
}

fn flat_point_sphere_project_orthogonally_onto(self_: FlatPoint, other: Sphere) -> Dipole {
    return sphere_line_anti_wedge(other, flat_point_sphere_weight_expansion(self_, other));
}

fn flat_point_translator_project_orthogonally_onto(self_: FlatPoint, other: Translator) -> FlatPoint {
    return translator_flat_point_anti_wedge(other, flat_point_translator_weight_expansion(self_, other));
}

fn flector_circle_project_orthogonally_onto(self_: Flector, other: Circle) -> Dipole {
    return circle_plane_anti_wedge(other, flector_circle_weight_expansion(self_, other));
}

fn flector_dipole_project_orthogonally_onto(self_: Flector, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, flector_dipole_weight_expansion(self_, other));
}

fn flector_flat_point_project_orthogonally_onto(self_: Flector, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, flector_flat_point_weight_expansion(self_, other));
}

fn flector_flector_project_orthogonally_onto(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, flector_flector_weight_expansion(self_, other));
}

fn flector_line_project_orthogonally_onto(self_: Flector, other: Line) -> FlatPoint {
    return line_plane_anti_wedge(other, flector_line_weight_expansion(self_, other));
}

fn flector_line_at_origin_project_orthogonally_onto(self_: Flector, other: LineAtOrigin) -> FlatPoint {
    return line_at_origin_plane_anti_wedge(other, flector_line_at_origin_weight_expansion(self_, other));
}

fn flector_motor_project_orthogonally_onto(self_: Flector, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, flector_motor_weight_expansion(self_, other));
}

fn flector_multi_vector_project_orthogonally_onto(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, flector_multi_vector_weight_expansion(self_, other));
}

fn flector_plane_project_orthogonally_onto(self_: Flector, other: Plane) -> Flector {
    return plane_motor_anti_wedge(other, flector_plane_weight_expansion(self_, other));
}

fn flector_plane_at_origin_project_orthogonally_onto(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return plane_at_origin_motor_anti_wedge(other, flector_plane_at_origin_weight_expansion(self_, other));
}

fn flector_point_at_origin_project_orthogonally_onto(self_: Flector, other: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_anti_scalar_anti_wedge(other, flector_point_at_origin_weight_expansion(self_, other));
}

fn flector_rotor_project_orthogonally_onto(self_: Flector, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, flector_rotor_weight_expansion(self_, other));
}

fn flector_sphere_project_orthogonally_onto(self_: Flector, other: Sphere) -> MultiVector {
    return sphere_motor_anti_wedge(other, flector_sphere_weight_expansion(self_, other));
}

fn flector_translator_project_orthogonally_onto(self_: Flector, other: Translator) -> Flector {
    return translator_flector_anti_wedge(other, flector_translator_weight_expansion(self_, other));
}

fn horizon_flector_project_orthogonally_onto(self_: Horizon, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, horizon_flector_weight_expansion(self_, other));
}

fn horizon_motor_project_orthogonally_onto(self_: Horizon, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, horizon_motor_weight_expansion(self_, other));
}

fn horizon_multi_vector_project_orthogonally_onto(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, horizon_multi_vector_weight_expansion(self_, other));
}

fn horizon_plane_project_orthogonally_onto(self_: Horizon, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, horizon_plane_weight_expansion(self_, other));
}

fn horizon_plane_at_origin_project_orthogonally_onto(self_: Horizon, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_anti_wedge(other, horizon_plane_at_origin_weight_expansion(self_, other));
}

fn horizon_rotor_project_orthogonally_onto(self_: Horizon, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, horizon_rotor_weight_expansion(self_, other));
}

fn horizon_sphere_project_orthogonally_onto(self_: Horizon, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, horizon_sphere_weight_expansion(self_, other));
}

fn horizon_translator_project_orthogonally_onto(self_: Horizon, other: Translator) -> Horizon {
    return translator_horizon_anti_wedge(other, horizon_translator_weight_expansion(self_, other));
}

fn infinity_circle_project_orthogonally_onto(self_: Infinity, other: Circle) -> RoundPoint {
    return circle_line_anti_wedge(other, infinity_circle_weight_expansion(self_, other));
}

fn infinity_dipole_project_orthogonally_onto(self_: Infinity, other: Dipole) -> RoundPoint {
    return dipole_plane_anti_wedge(other, infinity_dipole_weight_expansion(self_, other));
}

fn infinity_flat_point_project_orthogonally_onto(self_: Infinity, other: FlatPoint) -> Infinity {
    return flat_point_plane_anti_wedge(other, infinity_flat_point_weight_expansion(self_, other));
}

fn infinity_flector_project_orthogonally_onto(self_: Infinity, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, infinity_flector_weight_expansion(self_, other));
}

fn infinity_line_project_orthogonally_onto(self_: Infinity, other: Line) -> Infinity {
    return line_line_anti_wedge(other, infinity_line_weight_expansion(self_, other));
}

fn infinity_line_at_origin_project_orthogonally_onto(self_: Infinity, other: LineAtOrigin) -> Infinity {
    return line_at_origin_line_anti_wedge(other, infinity_line_at_origin_weight_expansion(self_, other));
}

fn infinity_motor_project_orthogonally_onto(self_: Infinity, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, infinity_motor_weight_expansion(self_, other));
}

fn infinity_multi_vector_project_orthogonally_onto(self_: Infinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, infinity_multi_vector_weight_expansion(self_, other));
}

fn infinity_plane_project_orthogonally_onto(self_: Infinity, other: Plane) -> Infinity {
    return plane_flat_point_anti_wedge(other, infinity_plane_weight_expansion(self_, other));
}

fn infinity_plane_at_origin_project_orthogonally_onto(self_: Infinity, other: PlaneAtOrigin) -> Infinity {
    return plane_at_origin_flat_point_anti_wedge(other, infinity_plane_at_origin_weight_expansion(self_, other));
}

fn infinity_point_at_origin_project_orthogonally_onto(self_: Infinity, other: PointAtOrigin) -> Infinity {
    return point_at_origin_plane_anti_wedge(other, infinity_point_at_origin_weight_expansion(self_, other));
}

fn infinity_rotor_project_orthogonally_onto(self_: Infinity, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, infinity_rotor_weight_expansion(self_, other));
}

fn infinity_sphere_project_orthogonally_onto(self_: Infinity, other: Sphere) -> RoundPoint {
    return sphere_flat_point_anti_wedge(other, infinity_sphere_weight_expansion(self_, other));
}

fn infinity_translator_project_orthogonally_onto(self_: Infinity, other: Translator) -> Infinity {
    return translator_infinity_anti_wedge(other, infinity_translator_weight_expansion(self_, other));
}

fn line_circle_project_orthogonally_onto(self_: Line, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, line_circle_weight_expansion(self_, other));
}

fn line_flector_project_orthogonally_onto(self_: Line, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, line_flector_weight_expansion(self_, other));
}

fn line_line_project_orthogonally_onto(self_: Line, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_line_weight_expansion(self_, other));
}

fn line_line_at_origin_project_orthogonally_onto(self_: Line, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, line_line_at_origin_weight_expansion(self_, other));
}

fn line_motor_project_orthogonally_onto(self_: Line, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, line_motor_weight_expansion(self_, other));
}

fn line_multi_vector_project_orthogonally_onto(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_multi_vector_weight_expansion(self_, other));
}

fn line_plane_project_orthogonally_onto(self_: Line, other: Plane) -> Line {
    return plane_plane_anti_wedge(other, line_plane_weight_expansion(self_, other));
}

fn line_plane_at_origin_project_orthogonally_onto(self_: Line, other: PlaneAtOrigin) -> Line {
    return plane_at_origin_plane_anti_wedge(other, line_plane_at_origin_weight_expansion(self_, other));
}

fn line_rotor_project_orthogonally_onto(self_: Line, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, line_rotor_weight_expansion(self_, other));
}

fn line_sphere_project_orthogonally_onto(self_: Line, other: Sphere) -> Circle {
    return sphere_plane_anti_wedge(other, line_sphere_weight_expansion(self_, other));
}

fn line_translator_project_orthogonally_onto(self_: Line, other: Translator) -> MultiVector {
    return translator_line_anti_wedge(other, line_translator_weight_expansion(self_, other));
}

fn line_at_infinity_circle_project_orthogonally_onto(self_: LineAtInfinity, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, line_at_infinity_circle_weight_expansion(self_, other));
}

fn line_at_infinity_flector_project_orthogonally_onto(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, line_at_infinity_flector_weight_expansion(self_, other));
}

fn line_at_infinity_line_project_orthogonally_onto(self_: LineAtInfinity, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_at_infinity_line_weight_expansion(self_, other));
}

fn line_at_infinity_line_at_origin_project_orthogonally_onto(self_: LineAtInfinity, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, line_at_infinity_line_at_origin_weight_expansion(self_, other));
}

fn line_at_infinity_motor_project_orthogonally_onto(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, line_at_infinity_motor_weight_expansion(self_, other));
}

fn line_at_infinity_multi_vector_project_orthogonally_onto(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_infinity_multi_vector_weight_expansion(self_, other));
}

fn line_at_infinity_plane_project_orthogonally_onto(self_: LineAtInfinity, other: Plane) -> Line {
    return plane_plane_anti_wedge(other, line_at_infinity_plane_weight_expansion(self_, other));
}

fn line_at_infinity_plane_at_origin_project_orthogonally_onto(self_: LineAtInfinity, other: PlaneAtOrigin) -> Line {
    return plane_at_origin_plane_anti_wedge(other, line_at_infinity_plane_at_origin_weight_expansion(self_, other));
}

fn line_at_infinity_rotor_project_orthogonally_onto(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, line_at_infinity_rotor_weight_expansion(self_, other));
}

fn line_at_infinity_sphere_project_orthogonally_onto(self_: LineAtInfinity, other: Sphere) -> Circle {
    return sphere_plane_anti_wedge(other, line_at_infinity_sphere_weight_expansion(self_, other));
}

fn line_at_infinity_translator_project_orthogonally_onto(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return translator_line_at_infinity_anti_wedge(other, line_at_infinity_translator_weight_expansion(self_, other));
}

fn line_at_origin_circle_project_orthogonally_onto(self_: LineAtOrigin, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, line_at_origin_circle_weight_expansion(self_, other));
}

fn line_at_origin_flector_project_orthogonally_onto(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, line_at_origin_flector_weight_expansion(self_, other));
}

fn line_at_origin_line_project_orthogonally_onto(self_: LineAtOrigin, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_at_origin_line_weight_expansion(self_, other));
}

fn line_at_origin_line_at_origin_project_orthogonally_onto(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, line_at_origin_line_at_origin_weight_expansion(self_, other));
}

fn line_at_origin_motor_project_orthogonally_onto(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, line_at_origin_motor_weight_expansion(self_, other));
}

fn line_at_origin_multi_vector_project_orthogonally_onto(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_origin_multi_vector_weight_expansion(self_, other));
}

fn line_at_origin_plane_project_orthogonally_onto(self_: LineAtOrigin, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, line_at_origin_plane_weight_expansion(self_, other));
}

fn line_at_origin_plane_at_origin_project_orthogonally_onto(self_: LineAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return plane_at_origin_plane_at_origin_anti_wedge(other, line_at_origin_plane_at_origin_weight_expansion(self_, other));
}

fn line_at_origin_rotor_project_orthogonally_onto(self_: LineAtOrigin, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, line_at_origin_rotor_weight_expansion(self_, other));
}

fn line_at_origin_sphere_project_orthogonally_onto(self_: LineAtOrigin, other: Sphere) -> Circle {
    return sphere_plane_at_origin_anti_wedge(other, line_at_origin_sphere_weight_expansion(self_, other));
}

fn line_at_origin_translator_project_orthogonally_onto(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return translator_line_at_origin_anti_wedge(other, line_at_origin_translator_weight_expansion(self_, other));
}

fn motor_circle_project_orthogonally_onto(self_: Motor, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, motor_circle_weight_expansion(self_, other));
}

fn motor_flector_project_orthogonally_onto(self_: Motor, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, motor_flector_weight_expansion(self_, other));
}

fn motor_line_project_orthogonally_onto(self_: Motor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, motor_line_weight_expansion(self_, other));
}

fn motor_line_at_origin_project_orthogonally_onto(self_: Motor, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, motor_line_at_origin_weight_expansion(self_, other));
}

fn motor_motor_project_orthogonally_onto(self_: Motor, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, motor_motor_weight_expansion(self_, other));
}

fn motor_multi_vector_project_orthogonally_onto(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, motor_multi_vector_weight_expansion(self_, other));
}

fn motor_plane_project_orthogonally_onto(self_: Motor, other: Plane) -> Line {
    return plane_plane_anti_wedge(other, motor_plane_weight_expansion(self_, other));
}

fn motor_plane_at_origin_project_orthogonally_onto(self_: Motor, other: PlaneAtOrigin) -> Line {
    return plane_at_origin_plane_anti_wedge(other, motor_plane_at_origin_weight_expansion(self_, other));
}

fn motor_rotor_project_orthogonally_onto(self_: Motor, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, motor_rotor_weight_expansion(self_, other));
}

fn motor_sphere_project_orthogonally_onto(self_: Motor, other: Sphere) -> Circle {
    return sphere_plane_anti_wedge(other, motor_sphere_weight_expansion(self_, other));
}

fn motor_translator_project_orthogonally_onto(self_: Motor, other: Translator) -> MultiVector {
    return translator_motor_anti_wedge(other, motor_translator_weight_expansion(self_, other));
}

fn multi_vector_circle_project_orthogonally_onto(self_: MultiVector, other: Circle) -> MultiVector {
    return circle_multi_vector_anti_wedge(other, multi_vector_circle_weight_expansion(self_, other));
}

fn multi_vector_dipole_project_orthogonally_onto(self_: MultiVector, other: Dipole) -> MultiVector {
    return dipole_multi_vector_anti_wedge(other, multi_vector_dipole_weight_expansion(self_, other));
}

fn multi_vector_flat_point_project_orthogonally_onto(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(other, multi_vector_flat_point_weight_expansion(self_, other));
}

fn multi_vector_flector_project_orthogonally_onto(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, multi_vector_flector_weight_expansion(self_, other));
}

fn multi_vector_line_project_orthogonally_onto(self_: MultiVector, other: Line) -> MultiVector {
    return line_multi_vector_anti_wedge(other, multi_vector_line_weight_expansion(self_, other));
}

fn multi_vector_line_at_origin_project_orthogonally_onto(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(other, multi_vector_line_at_origin_weight_expansion(self_, other));
}

fn multi_vector_motor_project_orthogonally_onto(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, multi_vector_motor_weight_expansion(self_, other));
}

fn multi_vector_multi_vector_project_orthogonally_onto(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, multi_vector_multi_vector_weight_expansion(self_, other));
}

fn multi_vector_plane_project_orthogonally_onto(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_multi_vector_anti_wedge(other, multi_vector_plane_weight_expansion(self_, other));
}

fn multi_vector_plane_at_origin_project_orthogonally_onto(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(other, multi_vector_plane_at_origin_weight_expansion(self_, other));
}

fn multi_vector_point_at_origin_project_orthogonally_onto(self_: MultiVector, other: PointAtOrigin) -> MultiVector {
    return point_at_origin_multi_vector_anti_wedge(other, multi_vector_point_at_origin_weight_expansion(self_, other));
}

fn multi_vector_rotor_project_orthogonally_onto(self_: MultiVector, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, multi_vector_rotor_weight_expansion(self_, other));
}

fn multi_vector_sphere_project_orthogonally_onto(self_: MultiVector, other: Sphere) -> MultiVector {
    return sphere_multi_vector_anti_wedge(other, multi_vector_sphere_weight_expansion(self_, other));
}

fn multi_vector_translator_project_orthogonally_onto(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_multi_vector_anti_wedge(other, multi_vector_translator_weight_expansion(self_, other));
}

fn origin_circle_project_orthogonally_onto(self_: Origin, other: Circle) -> RoundPoint {
    return circle_circle_anti_wedge(other, origin_circle_weight_expansion(self_, other));
}

fn origin_dipole_project_orthogonally_onto(self_: Origin, other: Dipole) -> RoundPoint {
    return dipole_sphere_anti_wedge(other, origin_dipole_weight_expansion(self_, other));
}

fn origin_flat_point_project_orthogonally_onto(self_: Origin, other: FlatPoint) -> RoundPoint {
    return flat_point_sphere_anti_wedge(other, origin_flat_point_weight_expansion(self_, other));
}

fn origin_flector_project_orthogonally_onto(self_: Origin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, origin_flector_weight_expansion(self_, other));
}

fn origin_line_project_orthogonally_onto(self_: Origin, other: Line) -> RoundPoint {
    return line_circle_anti_wedge(other, origin_line_weight_expansion(self_, other));
}

fn origin_line_at_origin_project_orthogonally_onto(self_: Origin, other: LineAtOrigin) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(other, origin_line_at_origin_weight_expansion(self_, other));
}

fn origin_motor_project_orthogonally_onto(self_: Origin, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, origin_motor_weight_expansion(self_, other));
}

fn origin_multi_vector_project_orthogonally_onto(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, origin_multi_vector_weight_expansion(self_, other));
}

fn origin_plane_project_orthogonally_onto(self_: Origin, other: Plane) -> RoundPoint {
    return plane_dipole_anti_wedge(other, origin_plane_weight_expansion(self_, other));
}

fn origin_plane_at_origin_project_orthogonally_onto(self_: Origin, other: PlaneAtOrigin) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(other, origin_plane_at_origin_weight_expansion(self_, other));
}

fn origin_point_at_origin_project_orthogonally_onto(self_: Origin, other: PointAtOrigin) -> RoundPoint {
    return point_at_origin_sphere_anti_wedge(other, origin_point_at_origin_weight_expansion(self_, other));
}

fn origin_rotor_project_orthogonally_onto(self_: Origin, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, origin_rotor_weight_expansion(self_, other));
}

fn origin_sphere_project_orthogonally_onto(self_: Origin, other: Sphere) -> RoundPoint {
    return sphere_dipole_anti_wedge(other, origin_sphere_weight_expansion(self_, other));
}

fn origin_translator_project_orthogonally_onto(self_: Origin, other: Translator) -> Origin {
    return translator_origin_anti_wedge(other, origin_translator_weight_expansion(self_, other));
}

fn plane_flector_project_orthogonally_onto(self_: Plane, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, plane_flector_weight_expansion(self_, other));
}

fn plane_motor_project_orthogonally_onto(self_: Plane, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, plane_motor_weight_expansion(self_, other));
}

fn plane_multi_vector_project_orthogonally_onto(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_multi_vector_weight_expansion(self_, other));
}

fn plane_plane_project_orthogonally_onto(self_: Plane, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, plane_plane_weight_expansion(self_, other));
}

fn plane_plane_at_origin_project_orthogonally_onto(self_: Plane, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_anti_wedge(other, plane_plane_at_origin_weight_expansion(self_, other));
}

fn plane_rotor_project_orthogonally_onto(self_: Plane, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, plane_rotor_weight_expansion(self_, other));
}

fn plane_sphere_project_orthogonally_onto(self_: Plane, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, plane_sphere_weight_expansion(self_, other));
}

fn plane_translator_project_orthogonally_onto(self_: Plane, other: Translator) -> Flector {
    return translator_plane_anti_wedge(other, plane_translator_weight_expansion(self_, other));
}

fn plane_at_origin_flector_project_orthogonally_onto(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, plane_at_origin_flector_weight_expansion(self_, other));
}

fn plane_at_origin_motor_project_orthogonally_onto(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, plane_at_origin_motor_weight_expansion(self_, other));
}

fn plane_at_origin_multi_vector_project_orthogonally_onto(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_at_origin_multi_vector_weight_expansion(self_, other));
}

fn plane_at_origin_plane_project_orthogonally_onto(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, plane_at_origin_plane_weight_expansion(self_, other));
}

fn plane_at_origin_plane_at_origin_project_orthogonally_onto(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_anti_wedge(other, plane_at_origin_plane_at_origin_weight_expansion(self_, other));
}

fn plane_at_origin_rotor_project_orthogonally_onto(self_: PlaneAtOrigin, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, plane_at_origin_rotor_weight_expansion(self_, other));
}

fn plane_at_origin_sphere_project_orthogonally_onto(self_: PlaneAtOrigin, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, plane_at_origin_sphere_weight_expansion(self_, other));
}

fn plane_at_origin_translator_project_orthogonally_onto(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return translator_plane_at_origin_anti_wedge(other, plane_at_origin_translator_weight_expansion(self_, other));
}

fn point_at_infinity_circle_project_orthogonally_onto(self_: PointAtInfinity, other: Circle) -> Dipole {
    return circle_plane_anti_wedge(other, point_at_infinity_circle_weight_expansion(self_, other));
}

fn point_at_infinity_dipole_project_orthogonally_onto(self_: PointAtInfinity, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, point_at_infinity_dipole_weight_expansion(self_, other));
}

fn point_at_infinity_flat_point_project_orthogonally_onto(self_: PointAtInfinity, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, point_at_infinity_flat_point_weight_expansion(self_, other));
}

fn point_at_infinity_flector_project_orthogonally_onto(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, point_at_infinity_flector_weight_expansion(self_, other));
}

fn point_at_infinity_line_project_orthogonally_onto(self_: PointAtInfinity, other: Line) -> FlatPoint {
    return line_plane_anti_wedge(other, point_at_infinity_line_weight_expansion(self_, other));
}

fn point_at_infinity_line_at_origin_project_orthogonally_onto(self_: PointAtInfinity, other: LineAtOrigin) -> FlatPoint {
    return line_at_origin_plane_anti_wedge(other, point_at_infinity_line_at_origin_weight_expansion(self_, other));
}

fn point_at_infinity_motor_project_orthogonally_onto(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, point_at_infinity_motor_weight_expansion(self_, other));
}

fn point_at_infinity_multi_vector_project_orthogonally_onto(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_at_infinity_multi_vector_weight_expansion(self_, other));
}

fn point_at_infinity_plane_project_orthogonally_onto(self_: PointAtInfinity, other: Plane) -> FlatPoint {
    return plane_line_anti_wedge(other, point_at_infinity_plane_weight_expansion(self_, other));
}

fn point_at_infinity_plane_at_origin_project_orthogonally_onto(self_: PointAtInfinity, other: PlaneAtOrigin) -> FlatPoint {
    return plane_at_origin_line_anti_wedge(other, point_at_infinity_plane_at_origin_weight_expansion(self_, other));
}

fn point_at_infinity_point_at_origin_project_orthogonally_onto(self_: PointAtInfinity, other: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_anti_scalar_anti_wedge(other, point_at_infinity_point_at_origin_weight_expansion(self_, other));
}

fn point_at_infinity_rotor_project_orthogonally_onto(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, point_at_infinity_rotor_weight_expansion(self_, other));
}

fn point_at_infinity_sphere_project_orthogonally_onto(self_: PointAtInfinity, other: Sphere) -> Dipole {
    return sphere_line_anti_wedge(other, point_at_infinity_sphere_weight_expansion(self_, other));
}

fn point_at_infinity_translator_project_orthogonally_onto(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return translator_point_at_infinity_anti_wedge(other, point_at_infinity_translator_weight_expansion(self_, other));
}

fn point_at_origin_circle_project_orthogonally_onto(self_: PointAtOrigin, other: Circle) -> Dipole {
    return circle_plane_at_origin_anti_wedge(other, point_at_origin_circle_weight_expansion(self_, other));
}

fn point_at_origin_dipole_project_orthogonally_onto(self_: PointAtOrigin, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, point_at_origin_dipole_weight_expansion(self_, other));
}

fn point_at_origin_flat_point_project_orthogonally_onto(self_: PointAtOrigin, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, point_at_origin_flat_point_weight_expansion(self_, other));
}

fn point_at_origin_flector_project_orthogonally_onto(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, point_at_origin_flector_weight_expansion(self_, other));
}

fn point_at_origin_line_project_orthogonally_onto(self_: PointAtOrigin, other: Line) -> FlatPoint {
    return line_plane_at_origin_anti_wedge(other, point_at_origin_line_weight_expansion(self_, other));
}

fn point_at_origin_line_at_origin_project_orthogonally_onto(self_: PointAtOrigin, other: LineAtOrigin) -> PointAtOrigin {
    return line_at_origin_plane_at_origin_anti_wedge(other, point_at_origin_line_at_origin_weight_expansion(self_, other));
}

fn point_at_origin_motor_project_orthogonally_onto(self_: PointAtOrigin, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, point_at_origin_motor_weight_expansion(self_, other));
}

fn point_at_origin_multi_vector_project_orthogonally_onto(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_at_origin_multi_vector_weight_expansion(self_, other));
}

fn point_at_origin_plane_project_orthogonally_onto(self_: PointAtOrigin, other: Plane) -> FlatPoint {
    return plane_line_at_origin_anti_wedge(other, point_at_origin_plane_weight_expansion(self_, other));
}

fn point_at_origin_plane_at_origin_project_orthogonally_onto(self_: PointAtOrigin, other: PlaneAtOrigin) -> PointAtOrigin {
    return plane_at_origin_line_at_origin_anti_wedge(other, point_at_origin_plane_at_origin_weight_expansion(self_, other));
}

fn point_at_origin_point_at_origin_project_orthogonally_onto(self_: PointAtOrigin, other: PointAtOrigin) -> PointAtOrigin {
    return point_at_origin_anti_scalar_anti_wedge(other, point_at_origin_point_at_origin_weight_expansion(self_, other));
}

fn point_at_origin_rotor_project_orthogonally_onto(self_: PointAtOrigin, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, point_at_origin_rotor_weight_expansion(self_, other));
}

fn point_at_origin_sphere_project_orthogonally_onto(self_: PointAtOrigin, other: Sphere) -> Dipole {
    return sphere_line_at_origin_anti_wedge(other, point_at_origin_sphere_weight_expansion(self_, other));
}

fn point_at_origin_translator_project_orthogonally_onto(self_: PointAtOrigin, other: Translator) -> PointAtOrigin {
    return translator_point_at_origin_anti_wedge(other, point_at_origin_translator_weight_expansion(self_, other));
}

fn rotor_circle_project_orthogonally_onto(self_: Rotor, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, rotor_circle_weight_expansion(self_, other));
}

fn rotor_flector_project_orthogonally_onto(self_: Rotor, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, rotor_flector_weight_expansion(self_, other));
}

fn rotor_line_project_orthogonally_onto(self_: Rotor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, rotor_line_weight_expansion(self_, other));
}

fn rotor_line_at_origin_project_orthogonally_onto(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, rotor_line_at_origin_weight_expansion(self_, other));
}

fn rotor_motor_project_orthogonally_onto(self_: Rotor, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, rotor_motor_weight_expansion(self_, other));
}

fn rotor_multi_vector_project_orthogonally_onto(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, rotor_multi_vector_weight_expansion(self_, other));
}

fn rotor_plane_project_orthogonally_onto(self_: Rotor, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, rotor_plane_weight_expansion(self_, other));
}

fn rotor_plane_at_origin_project_orthogonally_onto(self_: Rotor, other: PlaneAtOrigin) -> LineAtOrigin {
    return plane_at_origin_plane_at_origin_anti_wedge(other, rotor_plane_at_origin_weight_expansion(self_, other));
}

fn rotor_rotor_project_orthogonally_onto(self_: Rotor, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, rotor_rotor_weight_expansion(self_, other));
}

fn rotor_sphere_project_orthogonally_onto(self_: Rotor, other: Sphere) -> Circle {
    return sphere_plane_at_origin_anti_wedge(other, rotor_sphere_weight_expansion(self_, other));
}

fn rotor_translator_project_orthogonally_onto(self_: Rotor, other: Translator) -> MultiVector {
    return translator_rotor_anti_wedge(other, rotor_translator_weight_expansion(self_, other));
}

fn round_point_circle_project_orthogonally_onto(self_: RoundPoint, other: Circle) -> RoundPoint {
    return circle_circle_anti_wedge(other, round_point_circle_weight_expansion(self_, other));
}

fn round_point_dipole_project_orthogonally_onto(self_: RoundPoint, other: Dipole) -> RoundPoint {
    return dipole_sphere_anti_wedge(other, round_point_dipole_weight_expansion(self_, other));
}

fn round_point_flat_point_project_orthogonally_onto(self_: RoundPoint, other: FlatPoint) -> RoundPoint {
    return flat_point_sphere_anti_wedge(other, round_point_flat_point_weight_expansion(self_, other));
}

fn round_point_flector_project_orthogonally_onto(self_: RoundPoint, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, round_point_flector_weight_expansion(self_, other));
}

fn round_point_line_project_orthogonally_onto(self_: RoundPoint, other: Line) -> RoundPoint {
    return line_circle_anti_wedge(other, round_point_line_weight_expansion(self_, other));
}

fn round_point_line_at_origin_project_orthogonally_onto(self_: RoundPoint, other: LineAtOrigin) -> RoundPoint {
    return line_at_origin_circle_anti_wedge(other, round_point_line_at_origin_weight_expansion(self_, other));
}

fn round_point_motor_project_orthogonally_onto(self_: RoundPoint, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, round_point_motor_weight_expansion(self_, other));
}

fn round_point_multi_vector_project_orthogonally_onto(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, round_point_multi_vector_weight_expansion(self_, other));
}

fn round_point_plane_project_orthogonally_onto(self_: RoundPoint, other: Plane) -> RoundPoint {
    return plane_dipole_anti_wedge(other, round_point_plane_weight_expansion(self_, other));
}

fn round_point_plane_at_origin_project_orthogonally_onto(self_: RoundPoint, other: PlaneAtOrigin) -> RoundPoint {
    return plane_at_origin_dipole_anti_wedge(other, round_point_plane_at_origin_weight_expansion(self_, other));
}

fn round_point_point_at_origin_project_orthogonally_onto(self_: RoundPoint, other: PointAtOrigin) -> RoundPoint {
    return point_at_origin_sphere_anti_wedge(other, round_point_point_at_origin_weight_expansion(self_, other));
}

fn round_point_rotor_project_orthogonally_onto(self_: RoundPoint, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, round_point_rotor_weight_expansion(self_, other));
}

fn round_point_sphere_project_orthogonally_onto(self_: RoundPoint, other: Sphere) -> RoundPoint {
    return sphere_dipole_anti_wedge(other, round_point_sphere_weight_expansion(self_, other));
}

fn round_point_translator_project_orthogonally_onto(self_: RoundPoint, other: Translator) -> RoundPoint {
    return translator_round_point_anti_wedge(other, round_point_translator_weight_expansion(self_, other));
}

fn sphere_flector_project_orthogonally_onto(self_: Sphere, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, sphere_flector_weight_expansion(self_, other));
}

fn sphere_motor_project_orthogonally_onto(self_: Sphere, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, sphere_motor_weight_expansion(self_, other));
}

fn sphere_multi_vector_project_orthogonally_onto(self_: Sphere, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, sphere_multi_vector_weight_expansion(self_, other));
}

fn sphere_plane_project_orthogonally_onto(self_: Sphere, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, sphere_plane_weight_expansion(self_, other));
}

fn sphere_plane_at_origin_project_orthogonally_onto(self_: Sphere, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_anti_wedge(other, sphere_plane_at_origin_weight_expansion(self_, other));
}

fn sphere_rotor_project_orthogonally_onto(self_: Sphere, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, sphere_rotor_weight_expansion(self_, other));
}

fn sphere_sphere_project_orthogonally_onto(self_: Sphere, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, sphere_sphere_weight_expansion(self_, other));
}

fn sphere_translator_project_orthogonally_onto(self_: Sphere, other: Translator) -> MultiVector {
    return translator_sphere_anti_wedge(other, sphere_translator_weight_expansion(self_, other));
}

fn translator_circle_project_orthogonally_onto(self_: Translator, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, translator_circle_weight_expansion(self_, other));
}

fn translator_flector_project_orthogonally_onto(self_: Translator, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, translator_flector_weight_expansion(self_, other));
}

fn translator_line_project_orthogonally_onto(self_: Translator, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, translator_line_weight_expansion(self_, other));
}

fn translator_line_at_origin_project_orthogonally_onto(self_: Translator, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, translator_line_at_origin_weight_expansion(self_, other));
}

fn translator_motor_project_orthogonally_onto(self_: Translator, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, translator_motor_weight_expansion(self_, other));
}

fn translator_multi_vector_project_orthogonally_onto(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, translator_multi_vector_weight_expansion(self_, other));
}

fn translator_plane_project_orthogonally_onto(self_: Translator, other: Plane) -> Line {
    return plane_plane_anti_wedge(other, translator_plane_weight_expansion(self_, other));
}

fn translator_plane_at_origin_project_orthogonally_onto(self_: Translator, other: PlaneAtOrigin) -> Line {
    return plane_at_origin_plane_anti_wedge(other, translator_plane_at_origin_weight_expansion(self_, other));
}

fn translator_rotor_project_orthogonally_onto(self_: Translator, other: Rotor) -> MultiVector {
    return rotor_multi_vector_anti_wedge(other, translator_rotor_weight_expansion(self_, other));
}

fn translator_sphere_project_orthogonally_onto(self_: Translator, other: Sphere) -> Circle {
    return sphere_plane_anti_wedge(other, translator_sphere_weight_expansion(self_, other));
}

fn translator_translator_project_orthogonally_onto(self_: Translator, other: Translator) -> Translator {
    return translator_translator_anti_wedge(other, translator_translator_weight_expansion(self_, other));
}

fn circle_circle_project_via_origin_onto(self_: Circle, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, circle_circle_bulk_expansion(self_, other));
}

fn circle_flector_project_via_origin_onto(self_: Circle, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, circle_flector_bulk_expansion(self_, other));
}

fn circle_horizon_project_via_origin_onto(self_: Circle, other: Horizon) -> Circle {
    return horizon_sphere_anti_wedge(other, circle_horizon_bulk_expansion(self_, other));
}

fn circle_line_project_via_origin_onto(self_: Circle, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, circle_line_bulk_expansion(self_, other));
}

fn circle_line_at_infinity_project_via_origin_onto(self_: Circle, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, circle_line_at_infinity_bulk_expansion(self_, other));
}

fn circle_motor_project_via_origin_onto(self_: Circle, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, circle_motor_bulk_expansion(self_, other));
}

fn circle_multi_vector_project_via_origin_onto(self_: Circle, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, circle_multi_vector_bulk_expansion(self_, other));
}

fn circle_plane_project_via_origin_onto(self_: Circle, other: Plane) -> Circle {
    return plane_sphere_anti_wedge(other, circle_plane_bulk_expansion(self_, other));
}

fn circle_sphere_project_via_origin_onto(self_: Circle, other: Sphere) -> Circle {
    return sphere_sphere_anti_wedge(other, circle_sphere_bulk_expansion(self_, other));
}

fn circle_translator_project_via_origin_onto(self_: Circle, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, circle_translator_bulk_expansion(self_, other));
}

fn dipole_circle_project_via_origin_onto(self_: Dipole, other: Circle) -> Dipole {
    return circle_sphere_anti_wedge(other, dipole_circle_bulk_expansion(self_, other));
}

fn dipole_dipole_project_via_origin_onto(self_: Dipole, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, dipole_dipole_bulk_expansion(self_, other));
}

fn dipole_flat_point_project_via_origin_onto(self_: Dipole, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, dipole_flat_point_bulk_expansion(self_, other));
}

fn dipole_flector_project_via_origin_onto(self_: Dipole, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, dipole_flector_bulk_expansion(self_, other));
}

fn dipole_horizon_project_via_origin_onto(self_: Dipole, other: Horizon) -> Dipole {
    return horizon_circle_anti_wedge(other, dipole_horizon_bulk_expansion(self_, other));
}

fn dipole_line_project_via_origin_onto(self_: Dipole, other: Line) -> Dipole {
    return line_sphere_anti_wedge(other, dipole_line_bulk_expansion(self_, other));
}

fn dipole_line_at_infinity_project_via_origin_onto(self_: Dipole, other: LineAtInfinity) -> Dipole {
    return line_at_infinity_sphere_anti_wedge(other, dipole_line_at_infinity_bulk_expansion(self_, other));
}

fn dipole_motor_project_via_origin_onto(self_: Dipole, other: Motor) -> MultiVector {
    return motor_sphere_anti_wedge(other, dipole_motor_bulk_expansion(self_, other));
}

fn dipole_multi_vector_project_via_origin_onto(self_: Dipole, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, dipole_multi_vector_bulk_expansion(self_, other));
}

fn dipole_plane_project_via_origin_onto(self_: Dipole, other: Plane) -> Dipole {
    return plane_circle_anti_wedge(other, dipole_plane_bulk_expansion(self_, other));
}

fn dipole_point_at_infinity_project_via_origin_onto(self_: Dipole, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, dipole_point_at_infinity_bulk_expansion(self_, other));
}

fn dipole_sphere_project_via_origin_onto(self_: Dipole, other: Sphere) -> Dipole {
    return sphere_circle_anti_wedge(other, dipole_sphere_bulk_expansion(self_, other));
}

fn dipole_translator_project_via_origin_onto(self_: Dipole, other: Translator) -> MultiVector {
    return translator_sphere_anti_wedge(other, dipole_translator_bulk_expansion(self_, other));
}

fn flat_point_circle_project_via_origin_onto(self_: FlatPoint, other: Circle) -> Dipole {
    return circle_plane_anti_wedge(other, flat_point_circle_bulk_expansion(self_, other));
}

fn flat_point_dipole_project_via_origin_onto(self_: FlatPoint, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, flat_point_dipole_bulk_expansion(self_, other));
}

fn flat_point_flat_point_project_via_origin_onto(self_: FlatPoint, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, flat_point_flat_point_bulk_expansion(self_, other));
}

fn flat_point_flector_project_via_origin_onto(self_: FlatPoint, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, flat_point_flector_bulk_expansion(self_, other));
}

fn flat_point_horizon_project_via_origin_onto(self_: FlatPoint, other: Horizon) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(other, flat_point_horizon_bulk_expansion(self_, other));
}

fn flat_point_line_project_via_origin_onto(self_: FlatPoint, other: Line) -> FlatPoint {
    return line_plane_anti_wedge(other, flat_point_line_bulk_expansion(self_, other));
}

fn flat_point_line_at_infinity_project_via_origin_onto(self_: FlatPoint, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_anti_wedge(other, flat_point_line_at_infinity_bulk_expansion(self_, other));
}

fn flat_point_motor_project_via_origin_onto(self_: FlatPoint, other: Motor) -> Flector {
    return motor_plane_anti_wedge(other, flat_point_motor_bulk_expansion(self_, other));
}

fn flat_point_multi_vector_project_via_origin_onto(self_: FlatPoint, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, flat_point_multi_vector_bulk_expansion(self_, other));
}

fn flat_point_plane_project_via_origin_onto(self_: FlatPoint, other: Plane) -> FlatPoint {
    return plane_line_at_origin_anti_wedge(other, flat_point_plane_bulk_expansion(self_, other));
}

fn flat_point_point_at_infinity_project_via_origin_onto(self_: FlatPoint, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, flat_point_point_at_infinity_bulk_expansion(self_, other));
}

fn flat_point_sphere_project_via_origin_onto(self_: FlatPoint, other: Sphere) -> Dipole {
    return sphere_line_at_origin_anti_wedge(other, flat_point_sphere_bulk_expansion(self_, other));
}

fn flat_point_translator_project_via_origin_onto(self_: FlatPoint, other: Translator) -> Flector {
    return translator_plane_anti_wedge(other, flat_point_translator_bulk_expansion(self_, other));
}

fn flector_circle_project_via_origin_onto(self_: Flector, other: Circle) -> Dipole {
    return circle_plane_anti_wedge(other, flector_circle_bulk_expansion(self_, other));
}

fn flector_dipole_project_via_origin_onto(self_: Flector, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, flector_dipole_bulk_expansion(self_, other));
}

fn flector_flat_point_project_via_origin_onto(self_: Flector, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, flector_flat_point_bulk_expansion(self_, other));
}

fn flector_flector_project_via_origin_onto(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, flector_flector_bulk_expansion(self_, other));
}

fn flector_horizon_project_via_origin_onto(self_: Flector, other: Horizon) -> Flector {
    return horizon_rotor_anti_wedge(other, flector_horizon_bulk_expansion(self_, other));
}

fn flector_line_project_via_origin_onto(self_: Flector, other: Line) -> FlatPoint {
    return line_plane_anti_wedge(other, flector_line_bulk_expansion(self_, other));
}

fn flector_line_at_infinity_project_via_origin_onto(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_anti_wedge(other, flector_line_at_infinity_bulk_expansion(self_, other));
}

fn flector_motor_project_via_origin_onto(self_: Flector, other: Motor) -> Flector {
    return motor_plane_anti_wedge(other, flector_motor_bulk_expansion(self_, other));
}

fn flector_multi_vector_project_via_origin_onto(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, flector_multi_vector_bulk_expansion(self_, other));
}

fn flector_plane_project_via_origin_onto(self_: Flector, other: Plane) -> Flector {
    return plane_rotor_anti_wedge(other, flector_plane_bulk_expansion(self_, other));
}

fn flector_point_at_infinity_project_via_origin_onto(self_: Flector, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, flector_point_at_infinity_bulk_expansion(self_, other));
}

fn flector_sphere_project_via_origin_onto(self_: Flector, other: Sphere) -> MultiVector {
    return sphere_rotor_anti_wedge(other, flector_sphere_bulk_expansion(self_, other));
}

fn flector_translator_project_via_origin_onto(self_: Flector, other: Translator) -> Flector {
    return translator_plane_anti_wedge(other, flector_translator_bulk_expansion(self_, other));
}

fn horizon_flector_project_via_origin_onto(self_: Horizon, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, horizon_flector_bulk_expansion(self_, other));
}

fn horizon_horizon_project_via_origin_onto(self_: Horizon, other: Horizon) -> Horizon {
    return horizon_anti_scalar_anti_wedge(other, horizon_horizon_bulk_expansion(self_, other));
}

fn horizon_multi_vector_project_via_origin_onto(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, horizon_multi_vector_bulk_expansion(self_, other));
}

fn horizon_plane_project_via_origin_onto(self_: Horizon, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, horizon_plane_bulk_expansion(self_, other));
}

fn horizon_sphere_project_via_origin_onto(self_: Horizon, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, horizon_sphere_bulk_expansion(self_, other));
}

fn infinity_circle_project_via_origin_onto(self_: Infinity, other: Circle) -> RoundPoint {
    return circle_line_anti_wedge(other, infinity_circle_bulk_expansion(self_, other));
}

fn infinity_dipole_project_via_origin_onto(self_: Infinity, other: Dipole) -> RoundPoint {
    return dipole_plane_anti_wedge(other, infinity_dipole_bulk_expansion(self_, other));
}

fn infinity_flat_point_project_via_origin_onto(self_: Infinity, other: FlatPoint) -> Infinity {
    return flat_point_plane_anti_wedge(other, infinity_flat_point_bulk_expansion(self_, other));
}

fn infinity_flector_project_via_origin_onto(self_: Infinity, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, infinity_flector_bulk_expansion(self_, other));
}

fn infinity_horizon_project_via_origin_onto(self_: Infinity, other: Horizon) -> Infinity {
    return horizon_point_at_origin_anti_wedge(other, infinity_horizon_bulk_expansion(self_, other));
}

fn infinity_infinity_project_via_origin_onto(self_: Infinity, other: Infinity) -> Infinity {
    return infinity_anti_scalar_anti_wedge(other, infinity_infinity_bulk_expansion(self_, other));
}

fn infinity_line_project_via_origin_onto(self_: Infinity, other: Line) -> Infinity {
    return line_line_anti_wedge(other, infinity_line_bulk_expansion(self_, other));
}

fn infinity_line_at_infinity_project_via_origin_onto(self_: Infinity, other: LineAtInfinity) -> Infinity {
    return line_at_infinity_line_anti_wedge(other, infinity_line_at_infinity_bulk_expansion(self_, other));
}

fn infinity_motor_project_via_origin_onto(self_: Infinity, other: Motor) -> MultiVector {
    return motor_line_anti_wedge(other, infinity_motor_bulk_expansion(self_, other));
}

fn infinity_multi_vector_project_via_origin_onto(self_: Infinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, infinity_multi_vector_bulk_expansion(self_, other));
}

fn infinity_plane_project_via_origin_onto(self_: Infinity, other: Plane) -> Infinity {
    return plane_point_at_origin_anti_wedge(other, infinity_plane_bulk_expansion(self_, other));
}

fn infinity_point_at_infinity_project_via_origin_onto(self_: Infinity, other: PointAtInfinity) -> Infinity {
    return point_at_infinity_plane_anti_wedge(other, infinity_point_at_infinity_bulk_expansion(self_, other));
}

fn infinity_round_point_project_via_origin_onto(self_: Infinity, other: RoundPoint) -> RoundPoint {
    return round_point_anti_scalar_anti_wedge(other, infinity_round_point_bulk_expansion(self_, other));
}

fn infinity_sphere_project_via_origin_onto(self_: Infinity, other: Sphere) -> RoundPoint {
    return sphere_point_at_origin_anti_wedge(other, infinity_sphere_bulk_expansion(self_, other));
}

fn infinity_translator_project_via_origin_onto(self_: Infinity, other: Translator) -> MultiVector {
    return translator_line_anti_wedge(other, infinity_translator_bulk_expansion(self_, other));
}

fn line_circle_project_via_origin_onto(self_: Line, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, line_circle_bulk_expansion(self_, other));
}

fn line_flector_project_via_origin_onto(self_: Line, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, line_flector_bulk_expansion(self_, other));
}

fn line_horizon_project_via_origin_onto(self_: Line, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, line_horizon_bulk_expansion(self_, other));
}

fn line_line_project_via_origin_onto(self_: Line, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_line_bulk_expansion(self_, other));
}

fn line_line_at_infinity_project_via_origin_onto(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, line_line_at_infinity_bulk_expansion(self_, other));
}

fn line_motor_project_via_origin_onto(self_: Line, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, line_motor_bulk_expansion(self_, other));
}

fn line_multi_vector_project_via_origin_onto(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_multi_vector_bulk_expansion(self_, other));
}

fn line_plane_project_via_origin_onto(self_: Line, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, line_plane_bulk_expansion(self_, other));
}

fn line_sphere_project_via_origin_onto(self_: Line, other: Sphere) -> Circle {
    return sphere_plane_at_origin_anti_wedge(other, line_sphere_bulk_expansion(self_, other));
}

fn line_translator_project_via_origin_onto(self_: Line, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, line_translator_bulk_expansion(self_, other));
}

fn line_at_infinity_circle_project_via_origin_onto(self_: LineAtInfinity, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, line_at_infinity_circle_bulk_expansion(self_, other));
}

fn line_at_infinity_flector_project_via_origin_onto(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, line_at_infinity_flector_bulk_expansion(self_, other));
}

fn line_at_infinity_horizon_project_via_origin_onto(self_: LineAtInfinity, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, line_at_infinity_horizon_bulk_expansion(self_, other));
}

fn line_at_infinity_line_project_via_origin_onto(self_: LineAtInfinity, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_at_infinity_line_bulk_expansion(self_, other));
}

fn line_at_infinity_line_at_infinity_project_via_origin_onto(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, line_at_infinity_line_at_infinity_bulk_expansion(self_, other));
}

fn line_at_infinity_motor_project_via_origin_onto(self_: LineAtInfinity, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, line_at_infinity_motor_bulk_expansion(self_, other));
}

fn line_at_infinity_multi_vector_project_via_origin_onto(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_infinity_multi_vector_bulk_expansion(self_, other));
}

fn line_at_infinity_plane_project_via_origin_onto(self_: LineAtInfinity, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, line_at_infinity_plane_bulk_expansion(self_, other));
}

fn line_at_infinity_sphere_project_via_origin_onto(self_: LineAtInfinity, other: Sphere) -> Circle {
    return sphere_plane_at_origin_anti_wedge(other, line_at_infinity_sphere_bulk_expansion(self_, other));
}

fn line_at_infinity_translator_project_via_origin_onto(self_: LineAtInfinity, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, line_at_infinity_translator_bulk_expansion(self_, other));
}

fn line_at_origin_circle_project_via_origin_onto(self_: LineAtOrigin, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, line_at_origin_circle_bulk_expansion(self_, other));
}

fn line_at_origin_flector_project_via_origin_onto(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, line_at_origin_flector_bulk_expansion(self_, other));
}

fn line_at_origin_line_project_via_origin_onto(self_: LineAtOrigin, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_at_origin_line_bulk_expansion(self_, other));
}

fn line_at_origin_line_at_infinity_project_via_origin_onto(self_: LineAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, line_at_origin_line_at_infinity_bulk_expansion(self_, other));
}

fn line_at_origin_motor_project_via_origin_onto(self_: LineAtOrigin, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, line_at_origin_motor_bulk_expansion(self_, other));
}

fn line_at_origin_multi_vector_project_via_origin_onto(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_origin_multi_vector_bulk_expansion(self_, other));
}

fn line_at_origin_translator_project_via_origin_onto(self_: LineAtOrigin, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, line_at_origin_translator_bulk_expansion(self_, other));
}

fn motor_circle_project_via_origin_onto(self_: Motor, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, motor_circle_bulk_expansion(self_, other));
}

fn motor_flector_project_via_origin_onto(self_: Motor, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, motor_flector_bulk_expansion(self_, other));
}

fn motor_horizon_project_via_origin_onto(self_: Motor, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, motor_horizon_bulk_expansion(self_, other));
}

fn motor_line_project_via_origin_onto(self_: Motor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, motor_line_bulk_expansion(self_, other));
}

fn motor_line_at_infinity_project_via_origin_onto(self_: Motor, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, motor_line_at_infinity_bulk_expansion(self_, other));
}

fn motor_motor_project_via_origin_onto(self_: Motor, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, motor_motor_bulk_expansion(self_, other));
}

fn motor_multi_vector_project_via_origin_onto(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, motor_multi_vector_bulk_expansion(self_, other));
}

fn motor_plane_project_via_origin_onto(self_: Motor, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, motor_plane_bulk_expansion(self_, other));
}

fn motor_sphere_project_via_origin_onto(self_: Motor, other: Sphere) -> Circle {
    return sphere_plane_at_origin_anti_wedge(other, motor_sphere_bulk_expansion(self_, other));
}

fn motor_translator_project_via_origin_onto(self_: Motor, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, motor_translator_bulk_expansion(self_, other));
}

fn multi_vector_circle_project_via_origin_onto(self_: MultiVector, other: Circle) -> MultiVector {
    return circle_multi_vector_anti_wedge(other, multi_vector_circle_bulk_expansion(self_, other));
}

fn multi_vector_dipole_project_via_origin_onto(self_: MultiVector, other: Dipole) -> MultiVector {
    return dipole_multi_vector_anti_wedge(other, multi_vector_dipole_bulk_expansion(self_, other));
}

fn multi_vector_flat_point_project_via_origin_onto(self_: MultiVector, other: FlatPoint) -> MultiVector {
    return flat_point_multi_vector_anti_wedge(other, multi_vector_flat_point_bulk_expansion(self_, other));
}

fn multi_vector_flector_project_via_origin_onto(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, multi_vector_flector_bulk_expansion(self_, other));
}

fn multi_vector_horizon_project_via_origin_onto(self_: MultiVector, other: Horizon) -> MultiVector {
    return horizon_multi_vector_anti_wedge(other, multi_vector_horizon_bulk_expansion(self_, other));
}

fn multi_vector_infinity_project_via_origin_onto(self_: MultiVector, other: Infinity) -> MultiVector {
    return infinity_multi_vector_anti_wedge(other, multi_vector_infinity_bulk_expansion(self_, other));
}

fn multi_vector_line_project_via_origin_onto(self_: MultiVector, other: Line) -> MultiVector {
    return line_multi_vector_anti_wedge(other, multi_vector_line_bulk_expansion(self_, other));
}

fn multi_vector_line_at_infinity_project_via_origin_onto(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(other, multi_vector_line_at_infinity_bulk_expansion(self_, other));
}

fn multi_vector_motor_project_via_origin_onto(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, multi_vector_motor_bulk_expansion(self_, other));
}

fn multi_vector_multi_vector_project_via_origin_onto(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, multi_vector_multi_vector_bulk_expansion(self_, other));
}

fn multi_vector_plane_project_via_origin_onto(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_multi_vector_anti_wedge(other, multi_vector_plane_bulk_expansion(self_, other));
}

fn multi_vector_point_at_infinity_project_via_origin_onto(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(other, multi_vector_point_at_infinity_bulk_expansion(self_, other));
}

fn multi_vector_round_point_project_via_origin_onto(self_: MultiVector, other: RoundPoint) -> MultiVector {
    return round_point_multi_vector_anti_wedge(other, multi_vector_round_point_bulk_expansion(self_, other));
}

fn multi_vector_sphere_project_via_origin_onto(self_: MultiVector, other: Sphere) -> MultiVector {
    return sphere_multi_vector_anti_wedge(other, multi_vector_sphere_bulk_expansion(self_, other));
}

fn multi_vector_translator_project_via_origin_onto(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_multi_vector_anti_wedge(other, multi_vector_translator_bulk_expansion(self_, other));
}

fn origin_circle_project_via_origin_onto(self_: Origin, other: Circle) -> RoundPoint {
    return circle_circle_anti_wedge(other, origin_circle_bulk_expansion(self_, other));
}

fn origin_dipole_project_via_origin_onto(self_: Origin, other: Dipole) -> RoundPoint {
    return dipole_sphere_anti_wedge(other, origin_dipole_bulk_expansion(self_, other));
}

fn origin_flat_point_project_via_origin_onto(self_: Origin, other: FlatPoint) -> RoundPoint {
    return flat_point_sphere_anti_wedge(other, origin_flat_point_bulk_expansion(self_, other));
}

fn origin_flector_project_via_origin_onto(self_: Origin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, origin_flector_bulk_expansion(self_, other));
}

fn origin_infinity_project_via_origin_onto(self_: Origin, other: Infinity) -> Infinity {
    return infinity_anti_scalar_anti_wedge(other, origin_infinity_bulk_expansion(self_, other));
}

fn origin_line_project_via_origin_onto(self_: Origin, other: Line) -> RoundPoint {
    return line_circle_anti_wedge(other, origin_line_bulk_expansion(self_, other));
}

fn origin_line_at_infinity_project_via_origin_onto(self_: Origin, other: LineAtInfinity) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(other, origin_line_at_infinity_bulk_expansion(self_, other));
}

fn origin_motor_project_via_origin_onto(self_: Origin, other: Motor) -> MultiVector {
    return motor_circle_anti_wedge(other, origin_motor_bulk_expansion(self_, other));
}

fn origin_multi_vector_project_via_origin_onto(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, origin_multi_vector_bulk_expansion(self_, other));
}

fn origin_point_at_infinity_project_via_origin_onto(self_: Origin, other: PointAtInfinity) -> RoundPoint {
    return point_at_infinity_sphere_anti_wedge(other, origin_point_at_infinity_bulk_expansion(self_, other));
}

fn origin_round_point_project_via_origin_onto(self_: Origin, other: RoundPoint) -> RoundPoint {
    return round_point_anti_scalar_anti_wedge(other, origin_round_point_bulk_expansion(self_, other));
}

fn origin_translator_project_via_origin_onto(self_: Origin, other: Translator) -> MultiVector {
    return translator_circle_anti_wedge(other, origin_translator_bulk_expansion(self_, other));
}

fn plane_flector_project_via_origin_onto(self_: Plane, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, plane_flector_bulk_expansion(self_, other));
}

fn plane_horizon_project_via_origin_onto(self_: Plane, other: Horizon) -> Horizon {
    return horizon_anti_scalar_anti_wedge(other, plane_horizon_bulk_expansion(self_, other));
}

fn plane_multi_vector_project_via_origin_onto(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_multi_vector_bulk_expansion(self_, other));
}

fn plane_plane_project_via_origin_onto(self_: Plane, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, plane_plane_bulk_expansion(self_, other));
}

fn plane_sphere_project_via_origin_onto(self_: Plane, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, plane_sphere_bulk_expansion(self_, other));
}

fn plane_at_origin_flector_project_via_origin_onto(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, plane_at_origin_flector_bulk_expansion(self_, other));
}

fn plane_at_origin_multi_vector_project_via_origin_onto(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_at_origin_multi_vector_bulk_expansion(self_, other));
}

fn point_at_infinity_circle_project_via_origin_onto(self_: PointAtInfinity, other: Circle) -> Dipole {
    return circle_plane_anti_wedge(other, point_at_infinity_circle_bulk_expansion(self_, other));
}

fn point_at_infinity_dipole_project_via_origin_onto(self_: PointAtInfinity, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, point_at_infinity_dipole_bulk_expansion(self_, other));
}

fn point_at_infinity_flat_point_project_via_origin_onto(self_: PointAtInfinity, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, point_at_infinity_flat_point_bulk_expansion(self_, other));
}

fn point_at_infinity_flector_project_via_origin_onto(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, point_at_infinity_flector_bulk_expansion(self_, other));
}

fn point_at_infinity_horizon_project_via_origin_onto(self_: PointAtInfinity, other: Horizon) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(other, point_at_infinity_horizon_bulk_expansion(self_, other));
}

fn point_at_infinity_line_project_via_origin_onto(self_: PointAtInfinity, other: Line) -> FlatPoint {
    return line_plane_anti_wedge(other, point_at_infinity_line_bulk_expansion(self_, other));
}

fn point_at_infinity_line_at_infinity_project_via_origin_onto(self_: PointAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_anti_wedge(other, point_at_infinity_line_at_infinity_bulk_expansion(self_, other));
}

fn point_at_infinity_motor_project_via_origin_onto(self_: PointAtInfinity, other: Motor) -> Flector {
    return motor_plane_anti_wedge(other, point_at_infinity_motor_bulk_expansion(self_, other));
}

fn point_at_infinity_multi_vector_project_via_origin_onto(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_at_infinity_multi_vector_bulk_expansion(self_, other));
}

fn point_at_infinity_plane_project_via_origin_onto(self_: PointAtInfinity, other: Plane) -> FlatPoint {
    return plane_line_at_origin_anti_wedge(other, point_at_infinity_plane_bulk_expansion(self_, other));
}

fn point_at_infinity_point_at_infinity_project_via_origin_onto(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, point_at_infinity_point_at_infinity_bulk_expansion(self_, other));
}

fn point_at_infinity_sphere_project_via_origin_onto(self_: PointAtInfinity, other: Sphere) -> Dipole {
    return sphere_line_at_origin_anti_wedge(other, point_at_infinity_sphere_bulk_expansion(self_, other));
}

fn point_at_infinity_translator_project_via_origin_onto(self_: PointAtInfinity, other: Translator) -> Flector {
    return translator_plane_anti_wedge(other, point_at_infinity_translator_bulk_expansion(self_, other));
}

fn point_at_origin_circle_project_via_origin_onto(self_: PointAtOrigin, other: Circle) -> Dipole {
    return circle_plane_at_origin_anti_wedge(other, point_at_origin_circle_bulk_expansion(self_, other));
}

fn point_at_origin_dipole_project_via_origin_onto(self_: PointAtOrigin, other: Dipole) -> Dipole {
    return dipole_anti_scalar_anti_wedge(other, point_at_origin_dipole_bulk_expansion(self_, other));
}

fn point_at_origin_flat_point_project_via_origin_onto(self_: PointAtOrigin, other: FlatPoint) -> FlatPoint {
    return flat_point_anti_scalar_anti_wedge(other, point_at_origin_flat_point_bulk_expansion(self_, other));
}

fn point_at_origin_flector_project_via_origin_onto(self_: PointAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, point_at_origin_flector_bulk_expansion(self_, other));
}

fn point_at_origin_line_project_via_origin_onto(self_: PointAtOrigin, other: Line) -> FlatPoint {
    return line_plane_at_origin_anti_wedge(other, point_at_origin_line_bulk_expansion(self_, other));
}

fn point_at_origin_line_at_infinity_project_via_origin_onto(self_: PointAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_at_origin_anti_wedge(other, point_at_origin_line_at_infinity_bulk_expansion(self_, other));
}

fn point_at_origin_motor_project_via_origin_onto(self_: PointAtOrigin, other: Motor) -> Flector {
    return motor_plane_at_origin_anti_wedge(other, point_at_origin_motor_bulk_expansion(self_, other));
}

fn point_at_origin_multi_vector_project_via_origin_onto(self_: PointAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_at_origin_multi_vector_bulk_expansion(self_, other));
}

fn point_at_origin_point_at_infinity_project_via_origin_onto(self_: PointAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, point_at_origin_point_at_infinity_bulk_expansion(self_, other));
}

fn point_at_origin_translator_project_via_origin_onto(self_: PointAtOrigin, other: Translator) -> Flector {
    return translator_plane_at_origin_anti_wedge(other, point_at_origin_translator_bulk_expansion(self_, other));
}

fn rotor_circle_project_via_origin_onto(self_: Rotor, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, rotor_circle_bulk_expansion(self_, other));
}

fn rotor_flector_project_via_origin_onto(self_: Rotor, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, rotor_flector_bulk_expansion(self_, other));
}

fn rotor_line_project_via_origin_onto(self_: Rotor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, rotor_line_bulk_expansion(self_, other));
}

fn rotor_line_at_infinity_project_via_origin_onto(self_: Rotor, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, rotor_line_at_infinity_bulk_expansion(self_, other));
}

fn rotor_motor_project_via_origin_onto(self_: Rotor, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, rotor_motor_bulk_expansion(self_, other));
}

fn rotor_multi_vector_project_via_origin_onto(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, rotor_multi_vector_bulk_expansion(self_, other));
}

fn rotor_translator_project_via_origin_onto(self_: Rotor, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, rotor_translator_bulk_expansion(self_, other));
}

fn round_point_circle_project_via_origin_onto(self_: RoundPoint, other: Circle) -> RoundPoint {
    return circle_circle_anti_wedge(other, round_point_circle_bulk_expansion(self_, other));
}

fn round_point_dipole_project_via_origin_onto(self_: RoundPoint, other: Dipole) -> RoundPoint {
    return dipole_sphere_anti_wedge(other, round_point_dipole_bulk_expansion(self_, other));
}

fn round_point_flat_point_project_via_origin_onto(self_: RoundPoint, other: FlatPoint) -> RoundPoint {
    return flat_point_sphere_anti_wedge(other, round_point_flat_point_bulk_expansion(self_, other));
}

fn round_point_flector_project_via_origin_onto(self_: RoundPoint, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, round_point_flector_bulk_expansion(self_, other));
}

fn round_point_horizon_project_via_origin_onto(self_: RoundPoint, other: Horizon) -> RoundPoint {
    return horizon_dipole_anti_wedge(other, round_point_horizon_bulk_expansion(self_, other));
}

fn round_point_infinity_project_via_origin_onto(self_: RoundPoint, other: Infinity) -> Infinity {
    return infinity_anti_scalar_anti_wedge(other, round_point_infinity_bulk_expansion(self_, other));
}

fn round_point_line_project_via_origin_onto(self_: RoundPoint, other: Line) -> RoundPoint {
    return line_circle_anti_wedge(other, round_point_line_bulk_expansion(self_, other));
}

fn round_point_line_at_infinity_project_via_origin_onto(self_: RoundPoint, other: LineAtInfinity) -> RoundPoint {
    return line_at_infinity_circle_anti_wedge(other, round_point_line_at_infinity_bulk_expansion(self_, other));
}

fn round_point_motor_project_via_origin_onto(self_: RoundPoint, other: Motor) -> MultiVector {
    return motor_circle_anti_wedge(other, round_point_motor_bulk_expansion(self_, other));
}

fn round_point_multi_vector_project_via_origin_onto(self_: RoundPoint, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, round_point_multi_vector_bulk_expansion(self_, other));
}

fn round_point_plane_project_via_origin_onto(self_: RoundPoint, other: Plane) -> RoundPoint {
    return plane_dipole_anti_wedge(other, round_point_plane_bulk_expansion(self_, other));
}

fn round_point_point_at_infinity_project_via_origin_onto(self_: RoundPoint, other: PointAtInfinity) -> RoundPoint {
    return point_at_infinity_sphere_anti_wedge(other, round_point_point_at_infinity_bulk_expansion(self_, other));
}

fn round_point_round_point_project_via_origin_onto(self_: RoundPoint, other: RoundPoint) -> RoundPoint {
    return round_point_anti_scalar_anti_wedge(other, round_point_round_point_bulk_expansion(self_, other));
}

fn round_point_sphere_project_via_origin_onto(self_: RoundPoint, other: Sphere) -> RoundPoint {
    return sphere_dipole_anti_wedge(other, round_point_sphere_bulk_expansion(self_, other));
}

fn round_point_translator_project_via_origin_onto(self_: RoundPoint, other: Translator) -> MultiVector {
    return translator_circle_anti_wedge(other, round_point_translator_bulk_expansion(self_, other));
}

fn sphere_flector_project_via_origin_onto(self_: Sphere, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, sphere_flector_bulk_expansion(self_, other));
}

fn sphere_horizon_project_via_origin_onto(self_: Sphere, other: Horizon) -> Horizon {
    return horizon_anti_scalar_anti_wedge(other, sphere_horizon_bulk_expansion(self_, other));
}

fn sphere_multi_vector_project_via_origin_onto(self_: Sphere, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, sphere_multi_vector_bulk_expansion(self_, other));
}

fn sphere_plane_project_via_origin_onto(self_: Sphere, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, sphere_plane_bulk_expansion(self_, other));
}

fn sphere_sphere_project_via_origin_onto(self_: Sphere, other: Sphere) -> Sphere {
    return sphere_anti_scalar_anti_wedge(other, sphere_sphere_bulk_expansion(self_, other));
}

fn translator_circle_project_via_origin_onto(self_: Translator, other: Circle) -> Circle {
    return circle_anti_scalar_anti_wedge(other, translator_circle_bulk_expansion(self_, other));
}

fn translator_flector_project_via_origin_onto(self_: Translator, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, translator_flector_bulk_expansion(self_, other));
}

fn translator_horizon_project_via_origin_onto(self_: Translator, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, translator_horizon_bulk_expansion(self_, other));
}

fn translator_line_project_via_origin_onto(self_: Translator, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, translator_line_bulk_expansion(self_, other));
}

fn translator_line_at_infinity_project_via_origin_onto(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, translator_line_at_infinity_bulk_expansion(self_, other));
}

fn translator_motor_project_via_origin_onto(self_: Translator, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, translator_motor_bulk_expansion(self_, other));
}

fn translator_multi_vector_project_via_origin_onto(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, translator_multi_vector_bulk_expansion(self_, other));
}

fn translator_plane_project_via_origin_onto(self_: Translator, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, translator_plane_bulk_expansion(self_, other));
}

fn translator_sphere_project_via_origin_onto(self_: Translator, other: Sphere) -> Circle {
    return sphere_plane_at_origin_anti_wedge(other, translator_sphere_bulk_expansion(self_, other));
}

fn translator_translator_project_via_origin_onto(self_: Translator, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, translator_translator_bulk_expansion(self_, other));
}

fn circle_circle_cosine_angle(self_: Circle, other: Circle) -> f32 {
    return circle_circle_weight_contraction(circle_unitize(self_), circle_unitize(other)).g0;
}

fn circle_dipole_cosine_angle(self_: Circle, other: Dipole) -> f32 {
    return round_point_bulk_norm(circle_dipole_weight_contraction(circle_unitize(self_), dipole_unitize(other))).g0;
}

fn circle_flat_point_cosine_angle(self_: Circle, other: FlatPoint) -> f32 {
    return round_point_bulk_norm(circle_flat_point_weight_contraction(circle_unitize(self_), flat_point_unitize(other))).g0;
}

fn circle_line_cosine_angle(self_: Circle, other: Line) -> f32 {
    return circle_line_weight_contraction(circle_unitize(self_), line_unitize(other)).g0;
}

fn circle_line_at_origin_cosine_angle(self_: Circle, other: LineAtOrigin) -> f32 {
    return circle_line_at_origin_weight_contraction(circle_unitize(self_), line_at_origin_unitize(other)).g0;
}

fn circle_point_at_origin_cosine_angle(self_: Circle, other: PointAtOrigin) -> f32 {
    return round_point_bulk_norm(circle_point_at_origin_weight_contraction(circle_unitize(self_), point_at_origin_unitize(other))).g0;
}

fn dipole_dipole_cosine_angle(self_: Dipole, other: Dipole) -> f32 {
    return dipole_dipole_weight_contraction(dipole_unitize(self_), dipole_unitize(other)).g0;
}

fn dipole_flat_point_cosine_angle(self_: Dipole, other: FlatPoint) -> f32 {
    return dipole_flat_point_weight_contraction(dipole_unitize(self_), flat_point_unitize(other)).g0;
}

fn dipole_point_at_origin_cosine_angle(self_: Dipole, other: PointAtOrigin) -> f32 {
    return dipole_point_at_origin_weight_contraction(dipole_unitize(self_), point_at_origin_unitize(other)).g0;
}

fn flat_point_dipole_cosine_angle(self_: FlatPoint, other: Dipole) -> f32 {
    return flat_point_dipole_weight_contraction(flat_point_unitize(self_), dipole_unitize(other)).g0;
}

fn flat_point_flat_point_cosine_angle(self_: FlatPoint, other: FlatPoint) -> f32 {
    return flat_point_flat_point_weight_contraction(flat_point_unitize(self_), flat_point_unitize(other)).g0;
}

fn flat_point_point_at_origin_cosine_angle(self_: FlatPoint, other: PointAtOrigin) -> f32 {
    return flat_point_point_at_origin_weight_contraction(flat_point_unitize(self_), point_at_origin_unitize(other)).g0;
}

fn line_circle_cosine_angle(self_: Line, other: Circle) -> f32 {
    return line_circle_weight_contraction(line_unitize(self_), circle_unitize(other)).g0;
}

fn line_dipole_cosine_angle(self_: Line, other: Dipole) -> f32 {
    return round_point_bulk_norm(line_dipole_weight_contraction(line_unitize(self_), dipole_unitize(other))).g0;
}

fn line_flat_point_cosine_angle(self_: Line, other: FlatPoint) -> f32 {
    return round_point_bulk_norm(line_flat_point_weight_contraction(line_unitize(self_), flat_point_unitize(other))).g0;
}

fn line_line_cosine_angle(self_: Line, other: Line) -> f32 {
    return line_line_weight_contraction(line_unitize(self_), line_unitize(other)).g0;
}

fn line_line_at_origin_cosine_angle(self_: Line, other: LineAtOrigin) -> f32 {
    return line_line_at_origin_weight_contraction(line_unitize(self_), line_at_origin_unitize(other)).g0;
}

fn line_point_at_origin_cosine_angle(self_: Line, other: PointAtOrigin) -> f32 {
    return round_point_bulk_norm(line_point_at_origin_weight_contraction(line_unitize(self_), point_at_origin_unitize(other))).g0;
}

fn line_at_origin_circle_cosine_angle(self_: LineAtOrigin, other: Circle) -> f32 {
    return line_at_origin_circle_weight_contraction(line_at_origin_unitize(self_), circle_unitize(other)).g0;
}

fn line_at_origin_dipole_cosine_angle(self_: LineAtOrigin, other: Dipole) -> f32 {
    return round_point_bulk_norm(line_at_origin_dipole_weight_contraction(line_at_origin_unitize(self_), dipole_unitize(other))).g0;
}

fn line_at_origin_flat_point_cosine_angle(self_: LineAtOrigin, other: FlatPoint) -> f32 {
    return round_point_bulk_norm(line_at_origin_flat_point_weight_contraction(line_at_origin_unitize(self_), flat_point_unitize(other))).g0;
}

fn line_at_origin_line_cosine_angle(self_: LineAtOrigin, other: Line) -> f32 {
    return line_at_origin_line_weight_contraction(line_at_origin_unitize(self_), line_unitize(other)).g0;
}

fn line_at_origin_line_at_origin_cosine_angle(self_: LineAtOrigin, other: LineAtOrigin) -> f32 {
    return line_at_origin_line_at_origin_weight_contraction(line_at_origin_unitize(self_), line_at_origin_unitize(other)).g0;
}

fn line_at_origin_point_at_origin_cosine_angle(self_: LineAtOrigin, other: PointAtOrigin) -> f32 {
    return round_point_bulk_norm(line_at_origin_point_at_origin_weight_contraction(line_at_origin_unitize(self_), point_at_origin_unitize(other))).g0;
}

fn plane_circle_cosine_angle(self_: Plane, other: Circle) -> f32 {
    return round_point_bulk_norm(plane_circle_weight_contraction(plane_unitize(self_), circle_unitize(other))).g0;
}

fn plane_dipole_cosine_angle(self_: Plane, other: Dipole) -> f32 {
    return dipole_bulk_norm(plane_dipole_weight_contraction(plane_unitize(self_), dipole_unitize(other))).g0;
}

fn plane_flat_point_cosine_angle(self_: Plane, other: FlatPoint) -> f32 {
    return dipole_bulk_norm(plane_flat_point_weight_contraction(plane_unitize(self_), flat_point_unitize(other))).g0;
}

fn plane_line_cosine_angle(self_: Plane, other: Line) -> f32 {
    return round_point_bulk_norm(plane_line_weight_contraction(plane_unitize(self_), line_unitize(other))).g0;
}

fn plane_line_at_origin_cosine_angle(self_: Plane, other: LineAtOrigin) -> f32 {
    return round_point_bulk_norm(plane_line_at_origin_weight_contraction(plane_unitize(self_), line_at_origin_unitize(other))).g0;
}

fn plane_plane_cosine_angle(self_: Plane, other: Plane) -> f32 {
    return plane_plane_weight_contraction(plane_unitize(self_), plane_unitize(other)).g0;
}

fn plane_plane_at_origin_cosine_angle(self_: Plane, other: PlaneAtOrigin) -> f32 {
    return plane_plane_at_origin_weight_contraction(plane_unitize(self_), plane_at_origin_unitize(other)).g0;
}

fn plane_point_at_origin_cosine_angle(self_: Plane, other: PointAtOrigin) -> f32 {
    return dipole_bulk_norm(plane_point_at_origin_weight_contraction(plane_unitize(self_), point_at_origin_unitize(other))).g0;
}

fn plane_sphere_cosine_angle(self_: Plane, other: Sphere) -> f32 {
    return plane_sphere_weight_contraction(plane_unitize(self_), sphere_unitize(other)).g0;
}

fn plane_at_origin_circle_cosine_angle(self_: PlaneAtOrigin, other: Circle) -> f32 {
    return round_point_bulk_norm(plane_at_origin_circle_weight_contraction(plane_at_origin_unitize(self_), circle_unitize(other))).g0;
}

fn plane_at_origin_dipole_cosine_angle(self_: PlaneAtOrigin, other: Dipole) -> f32 {
    return dipole_bulk_norm(plane_at_origin_dipole_weight_contraction(plane_at_origin_unitize(self_), dipole_unitize(other))).g0;
}

fn plane_at_origin_flat_point_cosine_angle(self_: PlaneAtOrigin, other: FlatPoint) -> f32 {
    return dipole_bulk_norm(plane_at_origin_flat_point_weight_contraction(plane_at_origin_unitize(self_), flat_point_unitize(other))).g0;
}

fn plane_at_origin_line_cosine_angle(self_: PlaneAtOrigin, other: Line) -> f32 {
    return round_point_bulk_norm(plane_at_origin_line_weight_contraction(plane_at_origin_unitize(self_), line_unitize(other))).g0;
}

fn plane_at_origin_line_at_origin_cosine_angle(self_: PlaneAtOrigin, other: LineAtOrigin) -> f32 {
    return round_point_bulk_norm(plane_at_origin_line_at_origin_weight_contraction(plane_at_origin_unitize(self_), line_at_origin_unitize(other))).g0;
}

fn plane_at_origin_plane_cosine_angle(self_: PlaneAtOrigin, other: Plane) -> f32 {
    return plane_at_origin_plane_weight_contraction(plane_at_origin_unitize(self_), plane_unitize(other)).g0;
}

fn plane_at_origin_plane_at_origin_cosine_angle(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> f32 {
    return plane_at_origin_plane_at_origin_weight_contraction(plane_at_origin_unitize(self_), plane_at_origin_unitize(other)).g0;
}

fn plane_at_origin_point_at_origin_cosine_angle(self_: PlaneAtOrigin, other: PointAtOrigin) -> f32 {
    return dipole_bulk_norm(plane_at_origin_point_at_origin_weight_contraction(plane_at_origin_unitize(self_), point_at_origin_unitize(other))).g0;
}

fn plane_at_origin_sphere_cosine_angle(self_: PlaneAtOrigin, other: Sphere) -> f32 {
    return plane_at_origin_sphere_weight_contraction(plane_at_origin_unitize(self_), sphere_unitize(other)).g0;
}

fn point_at_origin_dipole_cosine_angle(self_: PointAtOrigin, other: Dipole) -> f32 {
    return point_at_origin_dipole_weight_contraction(point_at_origin_unitize(self_), dipole_unitize(other)).g0;
}

fn point_at_origin_flat_point_cosine_angle(self_: PointAtOrigin, other: FlatPoint) -> f32 {
    return point_at_origin_flat_point_weight_contraction(point_at_origin_unitize(self_), flat_point_unitize(other)).g0;
}

fn point_at_origin_point_at_origin_cosine_angle(self_: PointAtOrigin, other: PointAtOrigin) -> f32 {
    return point_at_origin_point_at_origin_weight_contraction(point_at_origin_unitize(self_), point_at_origin_unitize(other)).g0;
}

fn sphere_circle_cosine_angle(self_: Sphere, other: Circle) -> f32 {
    return round_point_bulk_norm(sphere_circle_weight_contraction(sphere_unitize(self_), circle_unitize(other))).g0;
}

fn sphere_dipole_cosine_angle(self_: Sphere, other: Dipole) -> f32 {
    return dipole_bulk_norm(sphere_dipole_weight_contraction(sphere_unitize(self_), dipole_unitize(other))).g0;
}

fn sphere_flat_point_cosine_angle(self_: Sphere, other: FlatPoint) -> f32 {
    return dipole_bulk_norm(sphere_flat_point_weight_contraction(sphere_unitize(self_), flat_point_unitize(other))).g0;
}

fn sphere_line_cosine_angle(self_: Sphere, other: Line) -> f32 {
    return round_point_bulk_norm(sphere_line_weight_contraction(sphere_unitize(self_), line_unitize(other))).g0;
}

fn sphere_line_at_origin_cosine_angle(self_: Sphere, other: LineAtOrigin) -> f32 {
    return round_point_bulk_norm(sphere_line_at_origin_weight_contraction(sphere_unitize(self_), line_at_origin_unitize(other))).g0;
}

fn sphere_plane_cosine_angle(self_: Sphere, other: Plane) -> f32 {
    return sphere_plane_weight_contraction(sphere_unitize(self_), plane_unitize(other)).g0;
}

fn sphere_plane_at_origin_cosine_angle(self_: Sphere, other: PlaneAtOrigin) -> f32 {
    return sphere_plane_at_origin_weight_contraction(sphere_unitize(self_), plane_at_origin_unitize(other)).g0;
}

fn sphere_point_at_origin_cosine_angle(self_: Sphere, other: PointAtOrigin) -> f32 {
    return dipole_bulk_norm(sphere_point_at_origin_weight_contraction(sphere_unitize(self_), point_at_origin_unitize(other))).g0;
}

fn sphere_sphere_cosine_angle(self_: Sphere, other: Sphere) -> f32 {
    return sphere_sphere_weight_contraction(sphere_unitize(self_), sphere_unitize(other)).g0;
}

fn circle_multi_vector_distance(self_: Circle, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(circle_multi_vector_wedge(self_, other))), multi_vector_weight_norm(circle_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn circle_origin_distance(self_: Circle, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(circle_origin_wedge(self_, other))), circle_weight_norm(circle_scalar_wedge(self_, origin_attitude(other))));
}

fn circle_round_point_distance(self_: Circle, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(circle_round_point_wedge(self_, other))), circle_weight_norm(circle_scalar_wedge(self_, round_point_attitude(other))));
}

fn dipole_dipole_distance(self_: Dipole, other: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(dipole_dipole_wedge(self_, other))), circle_weight_norm(dipole_round_point_wedge(self_, dipole_attitude(other))));
}

fn dipole_multi_vector_distance(self_: Dipole, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(dipole_multi_vector_wedge(self_, other))), multi_vector_weight_norm(dipole_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn dipole_origin_distance(self_: Dipole, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(circle_attitude(dipole_origin_wedge(self_, other))), dipole_weight_norm(dipole_scalar_wedge(self_, origin_attitude(other))));
}

fn dipole_round_point_distance(self_: Dipole, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(circle_attitude(dipole_round_point_wedge(self_, other))), dipole_weight_norm(dipole_scalar_wedge(self_, round_point_attitude(other))));
}

fn flat_point_multi_vector_distance(self_: FlatPoint, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(flat_point_multi_vector_wedge(self_, other))), multi_vector_weight_norm(flat_point_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn flector_multi_vector_distance(self_: Flector, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(flector_multi_vector_wedge(self_, other))), multi_vector_weight_norm(flector_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn flector_origin_distance(self_: Flector, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(flector_origin_wedge(self_, other))), flector_weight_norm(flector_scalar_wedge(self_, origin_attitude(other))));
}

fn flector_round_point_distance(self_: Flector, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(flector_round_point_wedge(self_, other))), flector_weight_norm(flector_scalar_wedge(self_, round_point_attitude(other))));
}

fn horizon_multi_vector_distance(self_: Horizon, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(horizon_multi_vector_wedge(self_, other))), multi_vector_weight_norm(horizon_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn infinity_multi_vector_distance(self_: Infinity, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(infinity_multi_vector_wedge(self_, other))), multi_vector_weight_norm(infinity_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_multi_vector_distance(self_: Line, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(line_multi_vector_wedge(self_, other))), multi_vector_weight_norm(line_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_at_infinity_multi_vector_distance(self_: LineAtInfinity, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(line_at_infinity_multi_vector_wedge(self_, other))), multi_vector_weight_norm(line_at_infinity_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_at_origin_multi_vector_distance(self_: LineAtOrigin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(line_at_origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(line_at_origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn magnitude_circle_distance(self_: Magnitude, other: Circle) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(circle_attitude(magnitude_circle_wedge(self_, other))), dipole_weight_norm(magnitude_dipole_wedge(self_, circle_attitude(other))));
}

fn magnitude_dipole_distance(self_: Magnitude, other: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(round_point_bulk_norm(dipole_attitude(magnitude_dipole_wedge(self_, other))), round_point_weight_norm(magnitude_round_point_wedge(self_, dipole_attitude(other))));
}

fn magnitude_flector_distance(self_: Magnitude, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(flector_attitude(magnitude_flector_wedge(self_, other))), multi_vector_weight_norm(magnitude_multi_vector_wedge(self_, flector_attitude(other))));
}

fn magnitude_motor_distance(self_: Magnitude, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(magnitude_motor_wedge(self_, other))), flector_weight_norm(magnitude_flector_wedge(self_, motor_attitude(other))));
}

fn magnitude_multi_vector_distance(self_: Magnitude, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(magnitude_multi_vector_wedge(self_, other))), multi_vector_weight_norm(magnitude_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn magnitude_origin_distance(self_: Magnitude, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(origin_attitude(magnitude_origin_wedge(self_, other))), magnitude_weight_norm(magnitude_scalar_wedge(self_, origin_attitude(other))));
}

fn magnitude_rotor_distance(self_: Magnitude, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(magnitude_rotor_wedge(self_, other))), flector_weight_norm(magnitude_flector_wedge(self_, rotor_attitude(other))));
}

fn magnitude_round_point_distance(self_: Magnitude, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(round_point_attitude(magnitude_round_point_wedge(self_, other))), magnitude_weight_norm(magnitude_scalar_wedge(self_, round_point_attitude(other))));
}

fn magnitude_sphere_distance(self_: Magnitude, other: Sphere) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(magnitude_sphere_wedge(self_, other))), circle_weight_norm(magnitude_circle_wedge(self_, sphere_attitude(other))));
}

fn motor_multi_vector_distance(self_: Motor, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(motor_multi_vector_wedge(self_, other))), multi_vector_weight_norm(motor_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn multi_vector_circle_distance(self_: MultiVector, other: Circle) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_circle_wedge(self_, other))), multi_vector_weight_norm(multi_vector_dipole_wedge(self_, circle_attitude(other))));
}

fn multi_vector_dipole_distance(self_: MultiVector, other: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_dipole_wedge(self_, other))), multi_vector_weight_norm(multi_vector_round_point_wedge(self_, dipole_attitude(other))));
}

fn multi_vector_flat_point_distance(self_: MultiVector, other: FlatPoint) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_flat_point_wedge(self_, other))), multi_vector_weight_norm(multi_vector_infinity_wedge(self_, flat_point_attitude(other))));
}

fn multi_vector_flector_distance(self_: MultiVector, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_flector_wedge(self_, other))), multi_vector_weight_norm(multi_vector_multi_vector_wedge(self_, flector_attitude(other))));
}

fn multi_vector_line_distance(self_: MultiVector, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_line_wedge(self_, other))), multi_vector_weight_norm(multi_vector_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn multi_vector_line_at_origin_distance(self_: MultiVector, other: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_line_at_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_point_at_infinity_wedge(self_, line_at_origin_attitude(other))));
}

fn multi_vector_magnitude_distance(self_: MultiVector, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_magnitude_wedge(self_, other))), multi_vector_weight_norm(multi_vector_horizon_wedge(self_, magnitude_attitude(other))));
}

fn multi_vector_motor_distance(self_: MultiVector, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_motor_wedge(self_, other))), multi_vector_weight_norm(multi_vector_flector_wedge(self_, motor_attitude(other))));
}

fn multi_vector_multi_vector_distance(self_: MultiVector, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_multi_vector_wedge(self_, other))), multi_vector_weight_norm(multi_vector_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn multi_vector_origin_distance(self_: MultiVector, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_scalar_wedge(self_, origin_attitude(other))));
}

fn multi_vector_plane_distance(self_: MultiVector, other: Plane) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_plane_wedge(self_, other))), multi_vector_weight_norm(multi_vector_line_at_infinity_wedge(self_, plane_attitude(other))));
}

fn multi_vector_plane_at_origin_distance(self_: MultiVector, other: PlaneAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_plane_at_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_line_at_infinity_wedge(self_, plane_at_origin_attitude(other))));
}

fn multi_vector_point_at_origin_distance(self_: MultiVector, other: PointAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_point_at_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_infinity_wedge(self_, point_at_origin_attitude(other))));
}

fn multi_vector_rotor_distance(self_: MultiVector, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_rotor_wedge(self_, other))), multi_vector_weight_norm(multi_vector_flector_wedge(self_, rotor_attitude(other))));
}

fn multi_vector_round_point_distance(self_: MultiVector, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_round_point_wedge(self_, other))), multi_vector_weight_norm(multi_vector_scalar_wedge(self_, round_point_attitude(other))));
}

fn multi_vector_sphere_distance(self_: MultiVector, other: Sphere) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_sphere_wedge(self_, other))), multi_vector_weight_norm(multi_vector_circle_wedge(self_, sphere_attitude(other))));
}

fn multi_vector_translator_distance(self_: MultiVector, other: Translator) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_translator_wedge(self_, other))), multi_vector_weight_norm(multi_vector_horizon_wedge(self_, translator_attitude(other))));
}

fn origin_circle_distance(self_: Origin, other: Circle) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(origin_circle_wedge(self_, other))), circle_weight_norm(origin_dipole_wedge(self_, circle_attitude(other))));
}

fn origin_dipole_distance(self_: Origin, other: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(circle_attitude(origin_dipole_wedge(self_, other))), dipole_weight_norm(origin_round_point_wedge(self_, dipole_attitude(other))));
}

fn origin_flector_distance(self_: Origin, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(origin_flector_wedge(self_, other))), multi_vector_weight_norm(origin_multi_vector_wedge(self_, flector_attitude(other))));
}

fn origin_magnitude_distance(self_: Origin, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(origin_attitude(origin_magnitude_wedge(self_, other))), anti_scalar_weight_norm(origin_horizon_wedge(self_, magnitude_attitude(other))));
}

fn origin_multi_vector_distance(self_: Origin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn plane_multi_vector_distance(self_: Plane, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(plane_multi_vector_wedge(self_, other))), multi_vector_weight_norm(plane_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn plane_at_origin_multi_vector_distance(self_: PlaneAtOrigin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(plane_at_origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(plane_at_origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn point_at_infinity_multi_vector_distance(self_: PointAtInfinity, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(point_at_infinity_multi_vector_wedge(self_, other))), multi_vector_weight_norm(point_at_infinity_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn point_at_origin_multi_vector_distance(self_: PointAtOrigin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(point_at_origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(point_at_origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn rotor_multi_vector_distance(self_: Rotor, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(rotor_multi_vector_wedge(self_, other))), multi_vector_weight_norm(rotor_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn round_point_circle_distance(self_: RoundPoint, other: Circle) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(round_point_circle_wedge(self_, other))), circle_weight_norm(round_point_dipole_wedge(self_, circle_attitude(other))));
}

fn round_point_dipole_distance(self_: RoundPoint, other: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(circle_attitude(round_point_dipole_wedge(self_, other))), dipole_weight_norm(round_point_round_point_wedge(self_, dipole_attitude(other))));
}

fn round_point_flector_distance(self_: RoundPoint, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(round_point_flector_wedge(self_, other))), multi_vector_weight_norm(round_point_multi_vector_wedge(self_, flector_attitude(other))));
}

fn round_point_magnitude_distance(self_: RoundPoint, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(round_point_attitude(round_point_magnitude_wedge(self_, other))), anti_scalar_weight_norm(round_point_horizon_wedge(self_, magnitude_attitude(other))));
}

fn round_point_multi_vector_distance(self_: RoundPoint, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(round_point_multi_vector_wedge(self_, other))), multi_vector_weight_norm(round_point_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn round_point_origin_distance(self_: RoundPoint, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(round_point_bulk_norm(dipole_attitude(round_point_origin_wedge(self_, other))), round_point_weight_norm(round_point_scalar_wedge(self_, origin_attitude(other))));
}

fn round_point_round_point_distance(self_: RoundPoint, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(round_point_bulk_norm(dipole_attitude(round_point_round_point_wedge(self_, other))), round_point_weight_norm(round_point_scalar_wedge(self_, round_point_attitude(other))));
}

fn scalar_circle_distance(self_: Scalar, other: Circle) -> Magnitude {
    return scalar_anti_scalar_add(dipole_bulk_norm(circle_attitude(scalar_circle_wedge(self_, other))), dipole_weight_norm(scalar_dipole_wedge(self_, circle_attitude(other))));
}

fn scalar_dipole_distance(self_: Scalar, other: Dipole) -> Magnitude {
    return scalar_anti_scalar_add(round_point_bulk_norm(dipole_attitude(scalar_dipole_wedge(self_, other))), round_point_weight_norm(scalar_round_point_wedge(self_, dipole_attitude(other))));
}

fn scalar_flector_distance(self_: Scalar, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(flector_attitude(scalar_flector_wedge(self_, other))), multi_vector_weight_norm(scalar_multi_vector_wedge(self_, flector_attitude(other))));
}

fn scalar_motor_distance(self_: Scalar, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(scalar_motor_wedge(self_, other))), flector_weight_norm(scalar_flector_wedge(self_, motor_attitude(other))));
}

fn scalar_multi_vector_distance(self_: Scalar, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(scalar_multi_vector_wedge(self_, other))), multi_vector_weight_norm(scalar_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn scalar_origin_distance(self_: Scalar, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(origin_attitude(scalar_origin_wedge(self_, other))), scalar_weight_norm(scalar_scalar_wedge(self_, origin_attitude(other))));
}

fn scalar_rotor_distance(self_: Scalar, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(scalar_rotor_wedge(self_, other))), flector_weight_norm(scalar_flector_wedge(self_, rotor_attitude(other))));
}

fn scalar_round_point_distance(self_: Scalar, other: RoundPoint) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(round_point_attitude(scalar_round_point_wedge(self_, other))), scalar_weight_norm(scalar_scalar_wedge(self_, round_point_attitude(other))));
}

fn scalar_sphere_distance(self_: Scalar, other: Sphere) -> Magnitude {
    return scalar_anti_scalar_add(circle_bulk_norm(sphere_attitude(scalar_sphere_wedge(self_, other))), circle_weight_norm(scalar_circle_wedge(self_, sphere_attitude(other))));
}

fn sphere_multi_vector_distance(self_: Sphere, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(sphere_multi_vector_wedge(self_, other))), multi_vector_weight_norm(sphere_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn translator_multi_vector_distance(self_: Translator, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(translator_multi_vector_wedge(self_, other))), multi_vector_weight_norm(translator_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn circle_circle_sine_angle(self_: Circle, other: Circle) -> f32 {
    let cos: f32 = circle_circle_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn circle_dipole_sine_angle(self_: Circle, other: Dipole) -> f32 {
    let cos: f32 = circle_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn circle_flat_point_sine_angle(self_: Circle, other: FlatPoint) -> f32 {
    let cos: f32 = circle_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn circle_line_sine_angle(self_: Circle, other: Line) -> f32 {
    let cos: f32 = circle_line_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn circle_line_at_origin_sine_angle(self_: Circle, other: LineAtOrigin) -> f32 {
    let cos: f32 = circle_line_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn circle_point_at_origin_sine_angle(self_: Circle, other: PointAtOrigin) -> f32 {
    let cos: f32 = circle_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn dipole_dipole_sine_angle(self_: Dipole, other: Dipole) -> f32 {
    let cos: f32 = dipole_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn dipole_flat_point_sine_angle(self_: Dipole, other: FlatPoint) -> f32 {
    let cos: f32 = dipole_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn dipole_point_at_origin_sine_angle(self_: Dipole, other: PointAtOrigin) -> f32 {
    let cos: f32 = dipole_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn flat_point_dipole_sine_angle(self_: FlatPoint, other: Dipole) -> f32 {
    let cos: f32 = flat_point_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn flat_point_flat_point_sine_angle(self_: FlatPoint, other: FlatPoint) -> f32 {
    let cos: f32 = flat_point_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn flat_point_point_at_origin_sine_angle(self_: FlatPoint, other: PointAtOrigin) -> f32 {
    let cos: f32 = flat_point_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_circle_sine_angle(self_: Line, other: Circle) -> f32 {
    let cos: f32 = line_circle_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_dipole_sine_angle(self_: Line, other: Dipole) -> f32 {
    let cos: f32 = line_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_flat_point_sine_angle(self_: Line, other: FlatPoint) -> f32 {
    let cos: f32 = line_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_line_sine_angle(self_: Line, other: Line) -> f32 {
    let cos: f32 = line_line_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_line_at_origin_sine_angle(self_: Line, other: LineAtOrigin) -> f32 {
    let cos: f32 = line_line_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_point_at_origin_sine_angle(self_: Line, other: PointAtOrigin) -> f32 {
    let cos: f32 = line_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_at_origin_circle_sine_angle(self_: LineAtOrigin, other: Circle) -> f32 {
    let cos: f32 = line_at_origin_circle_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_at_origin_dipole_sine_angle(self_: LineAtOrigin, other: Dipole) -> f32 {
    let cos: f32 = line_at_origin_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_at_origin_flat_point_sine_angle(self_: LineAtOrigin, other: FlatPoint) -> f32 {
    let cos: f32 = line_at_origin_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_at_origin_line_sine_angle(self_: LineAtOrigin, other: Line) -> f32 {
    let cos: f32 = line_at_origin_line_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_at_origin_line_at_origin_sine_angle(self_: LineAtOrigin, other: LineAtOrigin) -> f32 {
    let cos: f32 = line_at_origin_line_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn line_at_origin_point_at_origin_sine_angle(self_: LineAtOrigin, other: PointAtOrigin) -> f32 {
    let cos: f32 = line_at_origin_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_circle_sine_angle(self_: Plane, other: Circle) -> f32 {
    let cos: f32 = plane_circle_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_dipole_sine_angle(self_: Plane, other: Dipole) -> f32 {
    let cos: f32 = plane_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_flat_point_sine_angle(self_: Plane, other: FlatPoint) -> f32 {
    let cos: f32 = plane_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_line_sine_angle(self_: Plane, other: Line) -> f32 {
    let cos: f32 = plane_line_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_line_at_origin_sine_angle(self_: Plane, other: LineAtOrigin) -> f32 {
    let cos: f32 = plane_line_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_plane_sine_angle(self_: Plane, other: Plane) -> f32 {
    let cos: f32 = plane_plane_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_plane_at_origin_sine_angle(self_: Plane, other: PlaneAtOrigin) -> f32 {
    let cos: f32 = plane_plane_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_point_at_origin_sine_angle(self_: Plane, other: PointAtOrigin) -> f32 {
    let cos: f32 = plane_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_sphere_sine_angle(self_: Plane, other: Sphere) -> f32 {
    let cos: f32 = plane_sphere_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_circle_sine_angle(self_: PlaneAtOrigin, other: Circle) -> f32 {
    let cos: f32 = plane_at_origin_circle_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_dipole_sine_angle(self_: PlaneAtOrigin, other: Dipole) -> f32 {
    let cos: f32 = plane_at_origin_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_flat_point_sine_angle(self_: PlaneAtOrigin, other: FlatPoint) -> f32 {
    let cos: f32 = plane_at_origin_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_line_sine_angle(self_: PlaneAtOrigin, other: Line) -> f32 {
    let cos: f32 = plane_at_origin_line_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_line_at_origin_sine_angle(self_: PlaneAtOrigin, other: LineAtOrigin) -> f32 {
    let cos: f32 = plane_at_origin_line_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_plane_sine_angle(self_: PlaneAtOrigin, other: Plane) -> f32 {
    let cos: f32 = plane_at_origin_plane_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_plane_at_origin_sine_angle(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> f32 {
    let cos: f32 = plane_at_origin_plane_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_point_at_origin_sine_angle(self_: PlaneAtOrigin, other: PointAtOrigin) -> f32 {
    let cos: f32 = plane_at_origin_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn plane_at_origin_sphere_sine_angle(self_: PlaneAtOrigin, other: Sphere) -> f32 {
    let cos: f32 = plane_at_origin_sphere_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn point_at_origin_dipole_sine_angle(self_: PointAtOrigin, other: Dipole) -> f32 {
    let cos: f32 = point_at_origin_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn point_at_origin_flat_point_sine_angle(self_: PointAtOrigin, other: FlatPoint) -> f32 {
    let cos: f32 = point_at_origin_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn point_at_origin_point_at_origin_sine_angle(self_: PointAtOrigin, other: PointAtOrigin) -> f32 {
    let cos: f32 = point_at_origin_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_circle_sine_angle(self_: Sphere, other: Circle) -> f32 {
    let cos: f32 = sphere_circle_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_dipole_sine_angle(self_: Sphere, other: Dipole) -> f32 {
    let cos: f32 = sphere_dipole_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_flat_point_sine_angle(self_: Sphere, other: FlatPoint) -> f32 {
    let cos: f32 = sphere_flat_point_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_line_sine_angle(self_: Sphere, other: Line) -> f32 {
    let cos: f32 = sphere_line_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_line_at_origin_sine_angle(self_: Sphere, other: LineAtOrigin) -> f32 {
    let cos: f32 = sphere_line_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_plane_sine_angle(self_: Sphere, other: Plane) -> f32 {
    let cos: f32 = sphere_plane_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_plane_at_origin_sine_angle(self_: Sphere, other: PlaneAtOrigin) -> f32 {
    let cos: f32 = sphere_plane_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_point_at_origin_sine_angle(self_: Sphere, other: PointAtOrigin) -> f32 {
    let cos: f32 = sphere_point_at_origin_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

fn sphere_sphere_sine_angle(self_: Sphere, other: Sphere) -> f32 {
    let cos: f32 = sphere_sphere_cosine_angle(self_, other);
    let cos_squared: f32 = cos * cos;
    let sub: f32 = 1.0 - cos_squared;
    return sqrt(sub);
}

