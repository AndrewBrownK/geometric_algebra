#define_import_path rga3d

//
// AUTO-GENERATED - DO NOT MODIFY
//
// To contribute to this file, see the adjacent codegen package.
// https://github.com/AndrewBrownK/projective_ga/
//

struct Scalar {
    // 1
     g0_: f32,
}

struct AntiScalar {
    // e1234
     g0_: f32,
}

struct DualNum {
    // 1, e1234
     g0_: vec2<f32>,
}

struct Point {
    // e1, e2, e3, e4
     g0_: vec4<f32>,
}

struct Origin {
    // e4
     g0_: f32,
}

struct PointAtInfinity {
    // e1, e2, e3
     g0_: vec3<f32>,
}

struct Line {
    // -e14, -e24, -e34
     g0_: vec3<f32>,
    // e23, -e13, e12
     g1_: vec3<f32>,
}

struct LineAtOrigin {
    // -e14, -e24, -e34
     g0_: vec3<f32>,
}

struct LineAtInfinity {
    // e23, -e13, e12
     g0_: vec3<f32>,
}

struct Plane {
    // e234, -e134, e124, -e123
     g0_: vec4<f32>,
}

struct PlaneAtOrigin {
    // e234, -e134, e124
     g0_: vec3<f32>,
}

struct Horizon {
    // -e123
     g0_: f32,
}

struct Motor {
    // -e14, -e24, -e34, e1234
     g0_: vec4<f32>,
    // e23, -e13, e12
     g1_: vec3<f32>,
}

struct Rotor {
    // -e14, -e24, -e34, e1234
     g0_: vec4<f32>,
}

struct Translator {
    // e23, -e13, e12, e1234
     g0_: vec4<f32>,
}

struct Flector {
    // e1, e2, e3, e4
     g0_: vec4<f32>,
    // e234, -e134, e124, -e123
     g1_: vec4<f32>,
}

struct Transflector {
    // e1, e2, e3
     g0_: vec3<f32>,
    // e234, -e134, e124, -e123
     g1_: vec4<f32>,
}

struct FlectorAtInfinity {
    // e1, e2, e3, -e123
     g0_: vec4<f32>,
}

struct MultiVector {
    // 1, e1234
     g0_: vec2<f32>,
    // e1, e2, e3, e4
     g1_: vec4<f32>,
    // -e14, -e24, -e34
     g2_: vec3<f32>,
    // e23, -e13, e12
     g3_: vec3<f32>,
    // e234, -e134, e124, -e123
     g4_: vec4<f32>,
}

struct MultiVectorAtOrigin {
    // e4, e1234
     g0_: vec2<f32>,
    // -e14, -e24, -e34
     g1_: vec3<f32>,
    // e234, -e134, e124
     g2_: vec3<f32>,
}

struct MultiVectorAtInfinity {
    // 1, -e123
     g0_: vec2<f32>,
    // e1, e2, e3
     g1_: vec3<f32>,
    // e23, -e13, e12
     g2_: vec3<f32>,
}

fn antiScalar_one() -> AntiScalar {
    return AntiScalar(0.0);
}

fn dualNum_one() -> DualNum {
    return DualNum(vec2<f32>(1.0, 0.0));
}

fn flector_one() -> Flector {
    return Flector(vec4<f32>(0.0), vec4<f32>(0.0));
}

fn flectorAtInfinity_one() -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0));
}

fn horizon_one() -> Horizon {
    return Horizon(0.0);
}

fn line_one() -> Line {
    return Line(vec3<f32>(0.0), vec3<f32>(0.0));
}

fn lineAtInfinity_one() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0));
}

fn lineAtOrigin_one() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0));
}

fn motor_one() -> Motor {
    return Motor(vec4<f32>(0.0), vec3<f32>(0.0));
}

fn multiVector_one() -> MultiVector {
    return MultiVector(vec2<f32>(1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVectorAtInfinity_one() -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(1.0, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn multiVectorAtOrigin_one() -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_one() -> Origin {
    return Origin(0.0);
}

fn plane_one() -> Plane {
    return Plane(vec4<f32>(0.0));
}

fn planeAtOrigin_one() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0));
}

fn point_one() -> Point {
    return Point(vec4<f32>(0.0));
}

fn pointAtInfinity_one() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0));
}

fn rotor_one() -> Rotor {
    return Rotor(vec4<f32>(0.0));
}

fn scalar_one() -> Scalar {
    return Scalar(1.0);
}

fn transflector_one() -> Transflector {
    return Transflector(vec3<f32>(0.0), vec4<f32>(0.0));
}

fn translator_one() -> Translator {
    return Translator(vec4<f32>(0.0));
}

fn antiScalar_unit() -> AntiScalar {
    return AntiScalar(1.0);
}

fn dualNum_unit() -> DualNum {
    return DualNum(vec2<f32>(1.0));
}

fn flector_unit() -> Flector {
    return Flector(vec4<f32>(1.0), vec4<f32>(1.0));
}

fn flectorAtInfinity_unit() -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(1.0));
}

fn horizon_unit() -> Horizon {
    return Horizon(1.0);
}

fn line_unit() -> Line {
    return Line(vec3<f32>(1.0), vec3<f32>(1.0));
}

fn lineAtInfinity_unit() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(1.0));
}

fn lineAtOrigin_unit() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(1.0));
}

fn motor_unit() -> Motor {
    return Motor(vec4<f32>(1.0), vec3<f32>(1.0));
}

fn multiVector_unit() -> MultiVector {
    return MultiVector(vec2<f32>(1.0), vec4<f32>(1.0), vec3<f32>(1.0), vec3<f32>(1.0), vec4<f32>(1.0));
}

fn multiVectorAtInfinity_unit() -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(1.0), vec3<f32>(1.0), vec3<f32>(1.0));
}

fn multiVectorAtOrigin_unit() -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(1.0), vec3<f32>(1.0), vec3<f32>(1.0));
}

fn origin_unit() -> Origin {
    return Origin(1.0);
}

fn plane_unit() -> Plane {
    return Plane(vec4<f32>(1.0));
}

fn planeAtOrigin_unit() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(1.0));
}

fn point_unit() -> Point {
    return Point(vec4<f32>(1.0));
}

fn pointAtInfinity_unit() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(1.0));
}

fn rotor_unit() -> Rotor {
    return Rotor(vec4<f32>(1.0));
}

fn scalar_unit() -> Scalar {
    return Scalar(1.0);
}

fn transflector_unit() -> Transflector {
    return Transflector(vec3<f32>(1.0), vec4<f32>(1.0));
}

fn translator_unit() -> Translator {
    return Translator(vec4<f32>(1.0));
}

fn antiScalar_zero() -> AntiScalar {
    return AntiScalar(0.0);
}

fn dualNum_zero() -> DualNum {
    return DualNum(vec2<f32>(0.0));
}

fn flector_zero() -> Flector {
    return Flector(vec4<f32>(0.0), vec4<f32>(0.0));
}

fn flectorAtInfinity_zero() -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0));
}

fn horizon_zero() -> Horizon {
    return Horizon(0.0);
}

fn line_zero() -> Line {
    return Line(vec3<f32>(0.0), vec3<f32>(0.0));
}

fn lineAtInfinity_zero() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0));
}

fn lineAtOrigin_zero() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0));
}

fn motor_zero() -> Motor {
    return Motor(vec4<f32>(0.0), vec3<f32>(0.0));
}

fn multiVector_zero() -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVectorAtInfinity_zero() -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn multiVectorAtOrigin_zero() -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_zero() -> Origin {
    return Origin(0.0);
}

fn plane_zero() -> Plane {
    return Plane(vec4<f32>(0.0));
}

fn planeAtOrigin_zero() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0));
}

fn point_zero() -> Point {
    return Point(vec4<f32>(0.0));
}

fn pointAtInfinity_zero() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0));
}

fn rotor_zero() -> Rotor {
    return Rotor(vec4<f32>(0.0));
}

fn scalar_zero() -> Scalar {
    return Scalar(0.0);
}

fn transflector_zero() -> Transflector {
    return Transflector(vec3<f32>(0.0), vec4<f32>(0.0));
}

fn translator_zero() -> Translator {
    return Translator(vec4<f32>(0.0));
}

fn antiScalar_neg(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(-self_.g0_);
}

fn dualNum_neg(self_: DualNum) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(-1.0));
}

fn flector_neg(self_: Flector) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0));
}

fn flectorAtInfinity_neg(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(-1.0));
}

fn horizon_neg(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0_);
}

fn line_neg(self_: Line) -> Line {
    return Line(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_neg(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_neg(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_neg(self_: Motor) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn multiVector_neg(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0), self_.g3_ * vec3<f32>(-1.0), self_.g4_ * vec4<f32>(-1.0));
}

fn multiVectorAtInfinity_neg(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0));
}

fn multiVectorAtOrigin_neg(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0));
}

fn origin_neg(self_: Origin) -> Origin {
    return Origin(-self_.g0_);
}

fn plane_neg(self_: Plane) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(-1.0));
}

fn planeAtOrigin_neg(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn point_neg(self_: Point) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn pointAtInfinity_neg(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn rotor_neg(self_: Rotor) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(-1.0));
}

fn scalar_neg(self_: Scalar) -> Scalar {
    return Scalar(-self_.g0_);
}

fn transflector_neg(self_: Transflector) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0));
}

fn translator_neg(self_: Translator) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(-1.0));
}

fn antiScalar_add_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ + other.g0_);
}

fn antiScalar_add_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(0.0, self_.g0_) + other.g0_);
}

fn antiScalar_add_flector(self_: AntiScalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), other.g1_);
}

fn antiScalar_add_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn antiScalar_add_horizon(self_: AntiScalar, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn antiScalar_add_line(self_: AntiScalar, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), other.g1_);
}

fn antiScalar_add_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn antiScalar_add_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn antiScalar_add_motor(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_, other.g1_);
}

fn antiScalar_add_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_) + other.g0_, other.g1_, other.g2_, other.g3_, other.g4_);
}

fn antiScalar_add_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_) + vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn antiScalar_add_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_) + other.g0_, other.g1_, other.g2_);
}

fn antiScalar_add_origin(self_: AntiScalar, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_) + vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn antiScalar_add_plane(self_: AntiScalar, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), other.g0_);
}

fn antiScalar_add_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_), vec3<f32>(0.0), other.g0_);
}

fn antiScalar_add_point(self_: AntiScalar, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn antiScalar_add_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn antiScalar_add_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_);
}

fn antiScalar_add_scalar(self_: AntiScalar, other: Scalar) -> DualNum {
    return DualNum(vec2<f32>(0.0, self_.g0_) + vec2<f32>(other.g0_, 0.0));
}

fn antiScalar_add_transflector(self_: AntiScalar, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), other.g1_);
}

fn antiScalar_add_translator(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_);
}

fn dualNum_add_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return DualNum(self_.g0_ + vec2<f32>(0.0, other.g0_));
}

fn dualNum_add_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(self_.g0_ + other.g0_);
}

fn dualNum_add_flector(self_: DualNum, other: Flector) -> MultiVector {
    return MultiVector(self_.g0_, other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), other.g1_);
}

fn dualNum_add_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn dualNum_add_horizon(self_: DualNum, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn dualNum_add_line(self_: DualNum, other: Line) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), other.g0_, other.g1_, vec4<f32>(0.0));
}

fn dualNum_add_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), other.g0_, vec4<f32>(0.0));
}

fn dualNum_add_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_add_motor(self_: DualNum, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0));
}

fn dualNum_add_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ + other.g0_, other.g1_, other.g2_, other.g3_, other.g4_);
}

fn dualNum_add_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn dualNum_add_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn dualNum_add_origin(self_: DualNum, other: Origin) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_add_plane(self_: DualNum, other: Plane) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), other.g0_);
}

fn dualNum_add_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn dualNum_add_point(self_: DualNum, other: Point) -> MultiVector {
    return MultiVector(self_.g0_, other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_add_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_add_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_add_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return DualNum(self_.g0_ + vec2<f32>(other.g0_, 0.0));
}

fn dualNum_add_transflector(self_: DualNum, other: Transflector) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), other.g1_);
}

fn dualNum_add_translator(self_: DualNum, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_add_antiScalar(self_: Flector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn flector_add_dualNum(self_: Flector, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn flector_add_flector(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0_ + other.g0_, self_.g1_ + other.g1_);
}

fn flector_add_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Flector {
    return Flector(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn flector_add_horizon(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g0_, self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn flector_add_line(self_: Flector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, other.g0_, other.g1_, self_.g1_);
}

fn flector_add_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0), other.g0_, self_.g1_);
}

fn flector_add_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, other.g0_, vec3<f32>(0.0), self_.g1_);
}

fn flector_add_motor(self_: Flector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, self_.g1_);
}

fn flector_add_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, self_.g0_ + other.g1_, other.g2_, other.g3_, self_.g1_ + other.g4_);
}

fn flector_add_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), self_.g0_ + vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn flector_add_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), self_.g1_ + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn flector_add_origin(self_: Flector, other: Origin) -> Flector {
    return Flector(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn flector_add_plane(self_: Flector, other: Plane) -> Flector {
    return Flector(self_.g0_, self_.g1_ + other.g0_);
}

fn flector_add_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0_, self_.g1_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_add_point(self_: Flector, other: Point) -> Flector {
    return Flector(self_.g0_ + other.g0_, self_.g1_);
}

fn flector_add_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_);
}

fn flector_add_rotor(self_: Flector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), self_.g1_);
}

fn flector_add_scalar(self_: Flector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn flector_add_transflector(self_: Flector, other: Transflector) -> Flector {
    return Flector(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ + other.g1_);
}

fn flector_add_translator(self_: Flector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_);
}

fn flectorAtInfinity_add_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_dualNum(self_: FlectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_flector(self_: FlectorAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + other.g1_);
}

fn flectorAtInfinity_add_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ + other.g0_);
}

fn flectorAtInfinity_add_horizon(self_: FlectorAtInfinity, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn flectorAtInfinity_add_line(self_: FlectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), other.g0_, other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.w), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), other.g0_);
}

fn flectorAtInfinity_add_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), other.g0_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_motor(self_: FlectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g1_, other.g2_, other.g3_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + other.g4_);
}

fn flectorAtInfinity_add_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.w) + other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g1_, other.g2_);
}

fn flectorAtInfinity_add_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn flectorAtInfinity_add_origin(self_: FlectorAtInfinity, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_plane(self_: FlectorAtInfinity, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + other.g0_);
}

fn flectorAtInfinity_add_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_add_point(self_: FlectorAtInfinity, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_add_rotor(self_: FlectorAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_add_scalar(self_: FlectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0));
}

fn flectorAtInfinity_add_transflector(self_: FlectorAtInfinity, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + other.g1_);
}

fn flectorAtInfinity_add_translator(self_: FlectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn horizon_add_antiScalar(self_: Horizon, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_dualNum(self_: Horizon, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_flector(self_: Horizon, other: Flector) -> Flector {
    return Flector(other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g1_);
}

fn horizon_add_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_);
}

fn horizon_add_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ + other.g0_);
}

fn horizon_add_line(self_: Horizon, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), other.g0_, other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_), vec3<f32>(0.0), other.g0_);
}

fn horizon_add_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), other.g0_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_motor(self_: Horizon, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, other.g1_, other.g2_, other.g3_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g4_);
}

fn horizon_add_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_) + other.g0_, other.g1_, other.g2_);
}

fn horizon_add_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn horizon_add_origin(self_: Horizon, other: Origin) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_plane(self_: Horizon, other: Plane) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_);
}

fn horizon_add_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_add_point(self_: Horizon, other: Point) -> Flector {
    return Flector(other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_add_rotor(self_: Horizon, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_add_scalar(self_: Horizon, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_) + vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn horizon_add_transflector(self_: Horizon, other: Transflector) -> Transflector {
    return Transflector(other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g1_);
}

fn horizon_add_translator(self_: Horizon, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn line_add_antiScalar(self_: Line, other: AntiScalar) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn line_add_dualNum(self_: Line, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_add_flector(self_: Line, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), other.g0_, self_.g0_, self_.g1_, other.g1_);
}

fn line_add_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, self_.g1_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn line_add_horizon(self_: Line, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn line_add_line(self_: Line, other: Line) -> Line {
    return Line(self_.g0_ + other.g0_, self_.g1_ + other.g1_);
}

fn line_add_lineAtInfinity(self_: Line, other: LineAtInfinity) -> Line {
    return Line(self_.g0_, self_.g1_ + other.g0_);
}

fn line_add_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Line {
    return Line(self_.g0_ + other.g0_, self_.g1_);
}

fn line_add_motor(self_: Line, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, self_.g1_ + other.g1_);
}

fn line_add_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, other.g1_, self_.g0_ + other.g2_, self_.g1_ + other.g3_, other.g4_);
}

fn line_add_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g0_, self_.g1_ + other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn line_add_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), self_.g0_ + other.g1_, self_.g1_, vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn line_add_origin(self_: Line, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_add_plane(self_: Line, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, other.g0_);
}

fn line_add_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn line_add_point(self_: Line, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), other.g0_, self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_add_pointAtInfinity(self_: Line, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_add_rotor(self_: Line, other: Rotor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, self_.g1_);
}

fn line_add_scalar(self_: Line, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_add_transflector(self_: Line, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, self_.g1_, other.g1_);
}

fn line_add_translator(self_: Line, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), self_.g1_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn lineAtInfinity_add_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn lineAtInfinity_add_dualNum(self_: LineAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0));
}

fn lineAtInfinity_add_flector(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), other.g0_, vec3<f32>(0.0), self_.g0_, other.g1_);
}

fn lineAtInfinity_add_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, other.g0_.w), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_);
}

fn lineAtInfinity_add_horizon(self_: LineAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), self_.g0_);
}

fn lineAtInfinity_add_line(self_: LineAtInfinity, other: Line) -> Line {
    return Line(other.g0_, self_.g0_ + other.g1_);
}

fn lineAtInfinity_add_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ + other.g0_);
}

fn lineAtInfinity_add_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return Line(other.g0_, self_.g0_);
}

fn lineAtInfinity_add_motor(self_: LineAtInfinity, other: Motor) -> Motor {
    return Motor(other.g0_, self_.g0_ + other.g1_);
}

fn lineAtInfinity_add_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, other.g1_, other.g2_, self_.g0_ + other.g3_, other.g4_);
}

fn lineAtInfinity_add_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(other.g0_, other.g1_, self_.g0_ + other.g2_);
}

fn lineAtInfinity_add_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, self_.g0_, vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn lineAtInfinity_add_origin(self_: LineAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0));
}

fn lineAtInfinity_add_plane(self_: LineAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_, other.g0_);
}

fn lineAtInfinity_add_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn lineAtInfinity_add_point(self_: LineAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), other.g0_, vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0));
}

fn lineAtInfinity_add_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), other.g0_, self_.g0_);
}

fn lineAtInfinity_add_rotor(self_: LineAtInfinity, other: Rotor) -> Motor {
    return Motor(other.g0_, self_.g0_);
}

fn lineAtInfinity_add_scalar(self_: LineAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), self_.g0_);
}

fn lineAtInfinity_add_transflector(self_: LineAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), self_.g0_, other.g1_);
}

fn lineAtInfinity_add_translator(self_: LineAtInfinity, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_);
}

fn lineAtOrigin_add_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn lineAtOrigin_add_dualNum(self_: LineAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_add_flector(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), other.g0_, self_.g0_, vec3<f32>(0.0), other.g1_);
}

fn lineAtOrigin_add_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn lineAtOrigin_add_horizon(self_: LineAtOrigin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn lineAtOrigin_add_line(self_: LineAtOrigin, other: Line) -> Line {
    return Line(self_.g0_ + other.g0_, other.g1_);
}

fn lineAtOrigin_add_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return Line(self_.g0_, other.g0_);
}

fn lineAtOrigin_add_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ + other.g0_);
}

fn lineAtOrigin_add_motor(self_: LineAtOrigin, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, other.g1_);
}

fn lineAtOrigin_add_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, other.g1_, self_.g0_ + other.g2_, other.g3_, other.g4_);
}

fn lineAtOrigin_add_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g0_, other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn lineAtOrigin_add_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(other.g0_, self_.g0_ + other.g1_, other.g2_);
}

fn lineAtOrigin_add_origin(self_: LineAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0));
}

fn lineAtOrigin_add_plane(self_: LineAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), other.g0_);
}

fn lineAtOrigin_add_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0), self_.g0_, other.g0_);
}

fn lineAtOrigin_add_point(self_: LineAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), other.g0_, self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_add_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_add_rotor(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_);
}

fn lineAtOrigin_add_scalar(self_: LineAtOrigin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_add_transflector(self_: LineAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, vec3<f32>(0.0), other.g1_);
}

fn lineAtOrigin_add_translator(self_: LineAtOrigin, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn motor_add_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn motor_add_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_add_flector(self_: Motor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, other.g1_);
}

fn motor_add_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn motor_add_horizon(self_: Motor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn motor_add_line(self_: Motor, other: Line) -> Motor {
    return Motor(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ + other.g1_);
}

fn motor_add_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0_, self_.g1_ + other.g0_);
}

fn motor_add_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> Motor {
    return Motor(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_);
}

fn motor_add_motor(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0_ + other.g0_, self_.g1_ + other.g1_);
}

fn motor_add_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + other.g0_, other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g2_, self_.g1_ + other.g3_, other.g4_);
}

fn motor_add_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_ + other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn motor_add_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g1_, self_.g1_, vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn motor_add_origin(self_: Motor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_add_plane(self_: Motor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, other.g0_);
}

fn motor_add_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn motor_add_point(self_: Motor, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_add_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_add_rotor(self_: Motor, other: Rotor) -> Motor {
    return Motor(self_.g0_ + other.g0_, self_.g1_);
}

fn motor_add_scalar(self_: Motor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_add_transflector(self_: Motor, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, other.g1_);
}

fn motor_add_translator(self_: Motor, other: Translator) -> Motor {
    return Motor(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), self_.g1_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn multiVector_add_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_), self_.g1_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_add_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(self_.g0_ + other.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_add_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ + other.g0_, self_.g2_, self_.g3_, self_.g4_ + other.g1_);
}

fn multiVector_add_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g2_, self_.g3_, self_.g4_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVector_add_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn multiVector_add_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_ + other.g0_, self_.g3_ + other.g1_, self_.g4_);
}

fn multiVector_add_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_ + other.g0_, self_.g4_);
}

fn multiVector_add_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_ + other.g0_, self_.g3_, self_.g4_);
}

fn multiVector_add_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.w), self_.g1_, self_.g2_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g3_ + other.g1_, self_.g4_);
}

fn multiVector_add_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ + other.g0_, self_.g1_ + other.g1_, self_.g2_ + other.g2_, self_.g3_ + other.g3_, self_.g4_ + other.g4_);
}

fn multiVector_add_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(other.g0_.x, 0.0), self_.g1_ + vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g2_, self_.g3_ + other.g2_, self_.g4_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn multiVector_add_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.y), self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), self_.g2_ + other.g1_, self_.g3_, self_.g4_ + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn multiVector_add_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_add_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_ + other.g0_);
}

fn multiVector_add_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_add_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ + other.g0_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_add_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_add_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.w), self_.g1_, self_.g2_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g3_, self_.g4_);
}

fn multiVector_add_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(other.g0_, 0.0), self_.g1_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_add_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g2_, self_.g3_, self_.g4_ + other.g1_);
}

fn multiVector_add_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ + vec2<f32>(0.0, other.g0_.w), self_.g1_, self_.g2_, self_.g3_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g4_);
}

fn multiVectorAtInfinity_add_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + other.g0_, vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) + other.g0_, vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) + other.g1_);
}

fn multiVectorAtInfinity_add_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ + vec2<f32>(0.0, other.g0_.w), self_.g1_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_);
}

fn multiVectorAtInfinity_add_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ + vec2<f32>(0.0, other.g0_), self_.g1_, self_.g2_);
}

fn multiVectorAtInfinity_add_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), other.g0_, self_.g2_ + other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_, self_.g1_, self_.g2_ + other.g0_);
}

fn multiVectorAtInfinity_add_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), other.g0_, self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_ + other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + other.g0_, vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) + other.g1_, other.g2_, self_.g2_ + other.g3_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) + other.g4_);
}

fn multiVectorAtInfinity_add_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ + other.g0_, self_.g1_ + other.g1_, self_.g2_ + other.g2_);
}

fn multiVectorAtInfinity_add_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn multiVectorAtInfinity_add_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) + other.g0_);
}

fn multiVectorAtInfinity_add_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVectorAtInfinity_add_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) + other.g0_, vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_, self_.g1_ + other.g0_, self_.g2_);
}

fn multiVectorAtInfinity_add_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_add_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ + vec2<f32>(other.g0_, 0.0), self_.g1_, self_.g2_);
}

fn multiVectorAtInfinity_add_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) + other.g1_);
}

fn multiVectorAtInfinity_add_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtOrigin_add_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ + vec2<f32>(0.0, other.g0_), self_.g1_, self_.g2_);
}

fn multiVectorAtOrigin_add_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) + other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + other.g0_, self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + other.g1_);
}

fn multiVectorAtOrigin_add_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVectorAtOrigin_add_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn multiVectorAtOrigin_add_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_ + other.g0_, other.g1_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, other.g0_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_, self_.g1_ + other.g0_, self_.g2_);
}

fn multiVectorAtOrigin_add_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) + other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + other.g1_, self_.g1_ + other.g2_, other.g3_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + other.g4_);
}

fn multiVectorAtOrigin_add_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) + vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g1_, other.g2_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn multiVectorAtOrigin_add_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ + other.g0_, self_.g1_ + other.g1_, self_.g2_ + other.g2_);
}

fn multiVectorAtOrigin_add_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ + vec2<f32>(other.g0_, 0.0), self_.g1_, self_.g2_);
}

fn multiVectorAtOrigin_add_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + other.g0_);
}

fn multiVectorAtOrigin_add_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_, self_.g1_, self_.g2_ + other.g0_);
}

fn multiVectorAtOrigin_add_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + other.g0_, self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ + vec2<f32>(0.0, other.g0_.w), self_.g1_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_);
}

fn multiVectorAtOrigin_add_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) + vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_add_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) + other.g1_);
}

fn multiVectorAtOrigin_add_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn origin_add_antiScalar(self_: Origin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_add_dualNum(self_: Origin, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_add_flector(self_: Origin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_, other.g1_);
}

fn origin_add_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn origin_add_horizon(self_: Origin, other: Horizon) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn origin_add_line(self_: Origin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), other.g0_, other.g1_, vec4<f32>(0.0));
}

fn origin_add_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), other.g0_, vec4<f32>(0.0));
}

fn origin_add_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0), other.g0_, vec3<f32>(0.0));
}

fn origin_add_motor(self_: Origin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0));
}

fn origin_add_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g1_, other.g2_, other.g3_, other.g4_);
}

fn origin_add_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn origin_add_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0) + other.g0_, other.g1_, other.g2_);
}

fn origin_add_origin(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0_ + other.g0_);
}

fn origin_add_plane(self_: Origin, other: Plane) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_), other.g0_);
}

fn origin_add_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_add_point(self_: Origin, other: Point) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + other.g0_);
}

fn origin_add_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_add_rotor(self_: Origin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_.w), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0));
}

fn origin_add_scalar(self_: Origin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_add_transflector(self_: Origin, other: Transflector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), other.g1_);
}

fn origin_add_translator(self_: Origin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn plane_add_antiScalar(self_: Plane, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_);
}

fn plane_add_dualNum(self_: Plane, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_);
}

fn plane_add_flector(self_: Plane, other: Flector) -> Flector {
    return Flector(other.g0_, self_.g0_ + other.g1_);
}

fn plane_add_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn plane_add_horizon(self_: Plane, other: Horizon) -> Plane {
    return Plane(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn plane_add_line(self_: Plane, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), other.g0_, other.g1_, self_.g0_);
}

fn plane_add_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), other.g0_, self_.g0_);
}

fn plane_add_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), other.g0_, vec3<f32>(0.0), self_.g0_);
}

fn plane_add_motor(self_: Plane, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, self_.g0_);
}

fn plane_add_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, other.g1_, other.g2_, other.g3_, self_.g0_ + other.g4_);
}

fn plane_add_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn plane_add_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), self_.g0_ + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn plane_add_origin(self_: Plane, other: Origin) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_);
}

fn plane_add_plane(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0_ + other.g0_);
}

fn plane_add_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return Plane(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_add_point(self_: Plane, other: Point) -> Flector {
    return Flector(other.g0_, self_.g0_);
}

fn plane_add_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Transflector {
    return Transflector(other.g0_, self_.g0_);
}

fn plane_add_rotor(self_: Plane, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), self_.g0_);
}

fn plane_add_scalar(self_: Plane, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_);
}

fn plane_add_transflector(self_: Plane, other: Transflector) -> Transflector {
    return Transflector(other.g0_, self_.g0_ + other.g1_);
}

fn plane_add_translator(self_: Plane, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_);
}

fn planeAtOrigin_add_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), self_.g0_);
}

fn planeAtOrigin_add_dualNum(self_: PlaneAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_flector(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return Flector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g1_);
}

fn planeAtOrigin_add_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn planeAtOrigin_add_horizon(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn planeAtOrigin_add_line(self_: PlaneAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), other.g0_, other.g1_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0), other.g0_, self_.g0_);
}

fn planeAtOrigin_add_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, other.g1_, other.g2_, other.g3_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g4_);
}

fn planeAtOrigin_add_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn planeAtOrigin_add_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(other.g0_, other.g1_, self_.g0_ + other.g2_);
}

fn planeAtOrigin_add_origin(self_: PlaneAtOrigin, other: Origin) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_plane(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_);
}

fn planeAtOrigin_add_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ + other.g0_);
}

fn planeAtOrigin_add_point(self_: PlaneAtOrigin, other: Point) -> Flector {
    return Flector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Transflector {
    return Transflector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, other.g0_.w), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_);
}

fn planeAtOrigin_add_scalar(self_: PlaneAtOrigin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_add_transflector(self_: PlaneAtOrigin, other: Transflector) -> Transflector {
    return Transflector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g1_);
}

fn planeAtOrigin_add_translator(self_: PlaneAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn point_add_antiScalar(self_: Point, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_add_dualNum(self_: Point, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_add_flector(self_: Point, other: Flector) -> Flector {
    return Flector(self_.g0_ + other.g0_, other.g1_);
}

fn point_add_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Flector {
    return Flector(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn point_add_horizon(self_: Point, other: Horizon) -> Flector {
    return Flector(self_.g0_, vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn point_add_line(self_: Point, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, other.g0_, other.g1_, vec4<f32>(0.0));
}

fn point_add_lineAtInfinity(self_: Point, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0), other.g0_, vec4<f32>(0.0));
}

fn point_add_lineAtOrigin(self_: Point, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_add_motor(self_: Point, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0));
}

fn point_add_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, self_.g0_ + other.g1_, other.g2_, other.g3_, other.g4_);
}

fn point_add_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), self_.g0_ + vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn point_add_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn point_add_origin(self_: Point, other: Origin) -> Point {
    return Point(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn point_add_plane(self_: Point, other: Plane) -> Flector {
    return Flector(self_.g0_, other.g0_);
}

fn point_add_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn point_add_point(self_: Point, other: Point) -> Point {
    return Point(self_.g0_ + other.g0_);
}

fn point_add_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Point {
    return Point(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn point_add_rotor(self_: Point, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_add_scalar(self_: Point, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_add_transflector(self_: Point, other: Transflector) -> Flector {
    return Flector(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), other.g1_);
}

fn point_add_translator(self_: Point, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn pointAtInfinity_add_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_add_dualNum(self_: PointAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_add_flector(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, other.g1_);
}

fn pointAtInfinity_add_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_);
}

fn pointAtInfinity_add_horizon(self_: PointAtInfinity, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn pointAtInfinity_add_line(self_: PointAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), other.g0_, other.g1_, vec4<f32>(0.0));
}

fn pointAtInfinity_add_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), self_.g0_, other.g0_);
}

fn pointAtInfinity_add_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_add_motor(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0));
}

fn pointAtInfinity_add_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g1_, other.g2_, other.g3_, other.g4_);
}

fn pointAtInfinity_add_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(other.g0_, self_.g0_ + other.g1_, other.g2_);
}

fn pointAtInfinity_add_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn pointAtInfinity_add_origin(self_: PointAtInfinity, other: Origin) -> Point {
    return Point(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn pointAtInfinity_add_plane(self_: PointAtInfinity, other: Plane) -> Transflector {
    return Transflector(self_.g0_, other.g0_);
}

fn pointAtInfinity_add_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> Transflector {
    return Transflector(self_.g0_, vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn pointAtInfinity_add_point(self_: PointAtInfinity, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_);
}

fn pointAtInfinity_add_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ + other.g0_);
}

fn pointAtInfinity_add_rotor(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_add_scalar(self_: PointAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0));
}

fn pointAtInfinity_add_transflector(self_: PointAtInfinity, other: Transflector) -> Transflector {
    return Transflector(self_.g0_ + other.g0_, other.g1_);
}

fn pointAtInfinity_add_translator(self_: PointAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn rotor_add_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn rotor_add_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_add_flector(self_: Rotor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), other.g1_);
}

fn rotor_add_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn rotor_add_horizon(self_: Rotor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn rotor_add_line(self_: Rotor, other: Line) -> Motor {
    return Motor(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), other.g1_);
}

fn rotor_add_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0_, other.g0_);
}

fn rotor_add_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_add_motor(self_: Rotor, other: Motor) -> Motor {
    return Motor(self_.g0_ + other.g0_, other.g1_);
}

fn rotor_add_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + other.g0_, other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g2_, other.g3_, other.g4_);
}

fn rotor_add_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn rotor_add_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_.w) + other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g1_, other.g2_);
}

fn rotor_add_origin(self_: Rotor, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0));
}

fn rotor_add_plane(self_: Rotor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), other.g0_);
}

fn rotor_add_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_.w), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), other.g0_);
}

fn rotor_add_point(self_: Rotor, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_add_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_add_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0_ + other.g0_);
}

fn rotor_add_scalar(self_: Rotor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_add_transflector(self_: Rotor, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), other.g1_);
}

fn rotor_add_translator(self_: Rotor, other: Translator) -> Motor {
    return Motor(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_add_antiScalar(self_: Scalar, other: AntiScalar) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_));
}

fn scalar_add_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_, 0.0) + other.g0_);
}

fn scalar_add_flector(self_: Scalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), other.g1_);
}

fn scalar_add_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_.w), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0));
}

fn scalar_add_horizon(self_: Scalar, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn scalar_add_line(self_: Scalar, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), other.g0_, other.g1_, vec4<f32>(0.0));
}

fn scalar_add_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0), vec3<f32>(0.0), other.g0_);
}

fn scalar_add_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_add_motor(self_: Scalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, vec4<f32>(0.0));
}

fn scalar_add_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) + other.g0_, other.g1_, other.g2_, other.g3_, other.g4_);
}

fn scalar_add_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0) + other.g0_, other.g1_, other.g2_);
}

fn scalar_add_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn scalar_add_origin(self_: Scalar, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_add_plane(self_: Scalar, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), other.g0_);
}

fn scalar_add_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn scalar_add_point(self_: Scalar, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_add_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0), other.g0_, vec3<f32>(0.0));
}

fn scalar_add_rotor(self_: Scalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_add_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ + other.g0_);
}

fn scalar_add_transflector(self_: Scalar, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), other.g1_);
}

fn scalar_add_translator(self_: Scalar, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) + vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_add_antiScalar(self_: Transflector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn transflector_add_dualNum(self_: Transflector, other: DualNum) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn transflector_add_flector(self_: Transflector, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, self_.g1_ + other.g1_);
}

fn transflector_add_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Transflector {
    return Transflector(self_.g0_ + vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn transflector_add_horizon(self_: Transflector, other: Horizon) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn transflector_add_line(self_: Transflector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), other.g0_, other.g1_, self_.g1_);
}

fn transflector_add_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), other.g0_, self_.g1_);
}

fn transflector_add_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), other.g0_, vec3<f32>(0.0), self_.g1_);
}

fn transflector_add_motor(self_: Transflector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), other.g1_, self_.g1_);
}

fn transflector_add_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g1_, other.g2_, other.g3_, self_.g1_ + other.g4_);
}

fn transflector_add_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), other.g2_, self_.g1_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn transflector_add_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(0.0), self_.g1_ + vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn transflector_add_origin(self_: Transflector, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn transflector_add_plane(self_: Transflector, other: Plane) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ + other.g0_);
}

fn transflector_add_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_add_point(self_: Transflector, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) + other.g0_, self_.g1_);
}

fn transflector_add_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Transflector {
    return Transflector(self_.g0_ + other.g0_, self_.g1_);
}

fn transflector_add_rotor(self_: Transflector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), self_.g1_);
}

fn transflector_add_scalar(self_: Transflector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(other.g0_, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn transflector_add_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return Transflector(self_.g0_ + other.g0_, self_.g1_ + other.g1_);
}

fn transflector_add_translator(self_: Transflector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_);
}

fn translator_add_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0_ + vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn translator_add_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_add_flector(self_: Translator, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), other.g0_, vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), other.g1_);
}

fn translator_add_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn translator_add_horizon(self_: Translator, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn translator_add_line(self_: Translator, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g1_);
}

fn translator_add_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> Translator {
    return Translator(self_.g0_ + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn translator_add_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn translator_add_motor(self_: Translator, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g1_);
}

fn translator_add_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + other.g0_, other.g1_, other.g2_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g3_, other.g4_);
}

fn translator_add_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_.x, 0.0), vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) + other.g2_, vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn translator_add_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn translator_add_origin(self_: Translator, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_add_plane(self_: Translator, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), other.g0_);
}

fn translator_add_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn translator_add_point(self_: Translator, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), other.g0_, vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_add_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_add_rotor(self_: Translator, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) + other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn translator_add_scalar(self_: Translator, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) + vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_add_transflector(self_: Translator, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), other.g1_);
}

fn translator_add_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_ + other.g0_);
}

fn antiScalar_div_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ / other.g0_);
}

fn dualNum_div_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(self_.g0_ / other.g0_);
}

fn flector_div_flector(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0_ / other.g0_, self_.g1_ / other.g1_);
}

fn flectorAtInfinity_div_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ / other.g0_);
}

fn horizon_div_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ / other.g0_);
}

fn line_div_line(self_: Line, other: Line) -> Line {
    return Line(self_.g0_ / other.g0_, self_.g1_ / other.g1_);
}

fn lineAtInfinity_div_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ / other.g0_);
}

fn lineAtOrigin_div_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ / other.g0_);
}

fn motor_div_motor(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0_ / other.g0_, self_.g1_ / other.g1_);
}

fn multiVector_div_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ / other.g0_, self_.g1_ / other.g1_, self_.g2_ / other.g2_, self_.g3_ / other.g3_, self_.g4_ / other.g4_);
}

fn multiVectorAtInfinity_div_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ / other.g0_, self_.g1_ / other.g1_, self_.g2_ / other.g2_);
}

fn multiVectorAtOrigin_div_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ / other.g0_, self_.g1_ / other.g1_, self_.g2_ / other.g2_);
}

fn origin_div_origin(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0_ / other.g0_);
}

fn plane_div_plane(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0_ / other.g0_);
}

fn planeAtOrigin_div_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ / other.g0_);
}

fn point_div_point(self_: Point, other: Point) -> Point {
    return Point(self_.g0_ / other.g0_);
}

fn pointAtInfinity_div_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ / other.g0_);
}

fn rotor_div_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0_ / other.g0_);
}

fn scalar_div_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ / other.g0_);
}

fn transflector_div_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return Transflector(self_.g0_ / other.g0_, self_.g1_ / other.g1_);
}

fn translator_div_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_ / other.g0_);
}

fn dualNum_into_antiScalar(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.y);
}

fn dualNum_into_scalar(self_: DualNum) -> Scalar {
    return Scalar(self_.g0_.x);
}

fn flector_into_flectorAtInfinity(self_: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g1_.w));
}

fn flector_into_horizon(self_: Flector) -> Horizon {
    return Horizon(self_.g1_.w);
}

fn flector_into_origin(self_: Flector) -> Origin {
    return Origin(self_.g0_.w);
}

fn flector_into_plane(self_: Flector) -> Plane {
    return Plane(self_.g1_);
}

fn flector_into_planeAtOrigin(self_: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z));
}

fn flector_into_point(self_: Flector) -> Point {
    return Point(self_.g0_);
}

fn flector_into_pointAtInfinity(self_: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn flector_into_transflector(self_: Flector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_);
}

fn flectorAtInfinity_into_horizon(self_: FlectorAtInfinity) -> Horizon {
    return Horizon(self_.g0_.w);
}

fn flectorAtInfinity_into_pointAtInfinity(self_: FlectorAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn line_into_lineAtInfinity(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(self_.g1_);
}

fn line_into_lineAtOrigin(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_);
}

fn motor_into_antiScalar(self_: Motor) -> AntiScalar {
    return AntiScalar(self_.g0_.w);
}

fn motor_into_line(self_: Motor) -> Line {
    return Line(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_);
}

fn motor_into_lineAtInfinity(self_: Motor) -> LineAtInfinity {
    return LineAtInfinity(self_.g1_);
}

fn motor_into_lineAtOrigin(self_: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn motor_into_rotor(self_: Motor) -> Rotor {
    return Rotor(self_.g0_);
}

fn motor_into_translator(self_: Motor) -> Translator {
    return Translator(vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g0_.w));
}

fn multiVector_into_antiScalar(self_: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_.y);
}

fn multiVector_into_dualNum(self_: MultiVector) -> DualNum {
    return DualNum(self_.g0_);
}

fn multiVector_into_flector(self_: MultiVector) -> Flector {
    return Flector(self_.g1_, self_.g4_);
}

fn multiVector_into_flectorAtInfinity(self_: MultiVector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g4_.w));
}

fn multiVector_into_horizon(self_: MultiVector) -> Horizon {
    return Horizon(self_.g4_.w);
}

fn multiVector_into_line(self_: MultiVector) -> Line {
    return Line(self_.g2_, self_.g3_);
}

fn multiVector_into_lineAtInfinity(self_: MultiVector) -> LineAtInfinity {
    return LineAtInfinity(self_.g3_);
}

fn multiVector_into_lineAtOrigin(self_: MultiVector) -> LineAtOrigin {
    return LineAtOrigin(self_.g2_);
}

fn multiVector_into_motor(self_: MultiVector) -> Motor {
    return Motor(vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g0_.y), self_.g3_);
}

fn multiVector_into_multiVectorAtInfinity(self_: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x, self_.g4_.w), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z), self_.g3_);
}

fn multiVector_into_multiVectorAtOrigin(self_: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.w, self_.g0_.y), self_.g2_, vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z));
}

fn multiVector_into_origin(self_: MultiVector) -> Origin {
    return Origin(self_.g1_.w);
}

fn multiVector_into_plane(self_: MultiVector) -> Plane {
    return Plane(self_.g4_);
}

fn multiVector_into_planeAtOrigin(self_: MultiVector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z));
}

fn multiVector_into_point(self_: MultiVector) -> Point {
    return Point(self_.g1_);
}

fn multiVector_into_pointAtInfinity(self_: MultiVector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z));
}

fn multiVector_into_rotor(self_: MultiVector) -> Rotor {
    return Rotor(vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g0_.y));
}

fn multiVector_into_scalar(self_: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x);
}

fn multiVector_into_transflector(self_: MultiVector) -> Transflector {
    return Transflector(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z), self_.g4_);
}

fn multiVector_into_translator(self_: MultiVector) -> Translator {
    return Translator(vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g0_.y));
}

fn multiVectorAtInfinity_into_flectorAtInfinity(self_: MultiVectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g0_.y));
}

fn multiVectorAtInfinity_into_horizon(self_: MultiVectorAtInfinity) -> Horizon {
    return Horizon(self_.g0_.y);
}

fn multiVectorAtInfinity_into_lineAtInfinity(self_: MultiVectorAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g2_);
}

fn multiVectorAtInfinity_into_pointAtInfinity(self_: MultiVectorAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g1_);
}

fn multiVectorAtInfinity_into_scalar(self_: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x);
}

fn multiVectorAtOrigin_into_antiScalar(self_: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.y);
}

fn multiVectorAtOrigin_into_lineAtOrigin(self_: MultiVectorAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_);
}

fn multiVectorAtOrigin_into_origin(self_: MultiVectorAtOrigin) -> Origin {
    return Origin(self_.g0_.x);
}

fn multiVectorAtOrigin_into_planeAtOrigin(self_: MultiVectorAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g2_);
}

fn multiVectorAtOrigin_into_rotor(self_: MultiVectorAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g0_.y));
}

fn plane_into_horizon(self_: Plane) -> Horizon {
    return Horizon(self_.g0_.w);
}

fn plane_into_planeAtOrigin(self_: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn point_into_origin(self_: Point) -> Origin {
    return Origin(self_.g0_.w);
}

fn point_into_pointAtInfinity(self_: Point) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn rotor_into_antiScalar(self_: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0_.w);
}

fn rotor_into_lineAtOrigin(self_: Rotor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn transflector_into_flectorAtInfinity(self_: Transflector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g1_.w));
}

fn transflector_into_horizon(self_: Transflector) -> Horizon {
    return Horizon(self_.g1_.w);
}

fn transflector_into_plane(self_: Transflector) -> Plane {
    return Plane(self_.g1_);
}

fn transflector_into_planeAtOrigin(self_: Transflector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z));
}

fn transflector_into_pointAtInfinity(self_: Transflector) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_);
}

fn translator_into_antiScalar(self_: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.w);
}

fn translator_into_lineAtInfinity(self_: Translator) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn antiScalar_mul_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn dualNum_mul_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(self_.g0_ * other.g0_);
}

fn flector_mul_flector(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0_ * other.g0_, self_.g1_ * other.g1_);
}

fn flectorAtInfinity_mul_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * other.g0_);
}

fn horizon_mul_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn line_mul_line(self_: Line, other: Line) -> Line {
    return Line(self_.g0_ * other.g0_, self_.g1_ * other.g1_);
}

fn lineAtInfinity_mul_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * other.g0_);
}

fn lineAtOrigin_mul_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * other.g0_);
}

fn motor_mul_motor(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0_ * other.g0_, self_.g1_ * other.g1_);
}

fn multiVector_mul_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ * other.g0_, self_.g1_ * other.g1_, self_.g2_ * other.g2_, self_.g3_ * other.g3_, self_.g4_ * other.g4_);
}

fn multiVectorAtInfinity_mul_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * other.g0_, self_.g1_ * other.g1_, self_.g2_ * other.g2_);
}

fn multiVectorAtOrigin_mul_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * other.g0_, self_.g1_ * other.g1_, self_.g2_ * other.g2_);
}

fn origin_mul_origin(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn plane_mul_plane(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0_ * other.g0_);
}

fn planeAtOrigin_mul_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * other.g0_);
}

fn point_mul_point(self_: Point, other: Point) -> Point {
    return Point(self_.g0_ * other.g0_);
}

fn pointAtInfinity_mul_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * other.g0_);
}

fn rotor_mul_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0_ * other.g0_);
}

fn scalar_mul_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn transflector_mul_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return Transflector(self_.g0_ * other.g0_, self_.g1_ * other.g1_);
}

fn translator_mul_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_ * other.g0_);
}

fn antiScalar_sub_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ - other.g0_);
}

fn antiScalar_sub_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(0.0, self_.g0_) - other.g0_);
}

fn antiScalar_sub_flector(self_: AntiScalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn antiScalar_sub_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn antiScalar_sub_horizon(self_: AntiScalar, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn antiScalar_sub_line(self_: AntiScalar, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0) - other.g1_);
}

fn antiScalar_sub_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn antiScalar_sub_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn antiScalar_sub_motor(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_, vec3<f32>(0.0) - other.g1_);
}

fn antiScalar_sub_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn antiScalar_sub_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn antiScalar_sub_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_) - other.g0_, vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn antiScalar_sub_origin(self_: AntiScalar, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_) - vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn antiScalar_sub_plane(self_: AntiScalar, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g0_);
}

fn antiScalar_sub_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_);
}

fn antiScalar_sub_point(self_: AntiScalar, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn antiScalar_sub_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn antiScalar_sub_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_);
}

fn antiScalar_sub_scalar(self_: AntiScalar, other: Scalar) -> DualNum {
    return DualNum(vec2<f32>(0.0, self_.g0_) - vec2<f32>(other.g0_, 0.0));
}

fn antiScalar_sub_transflector(self_: AntiScalar, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn antiScalar_sub_translator(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_);
}

fn dualNum_sub_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return DualNum(self_.g0_ - vec2<f32>(0.0, other.g0_));
}

fn dualNum_sub_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(self_.g0_ - other.g0_);
}

fn dualNum_sub_flector(self_: DualNum, other: Flector) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn dualNum_sub_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn dualNum_sub_horizon(self_: DualNum, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn dualNum_sub_line(self_: DualNum, other: Line) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn dualNum_sub_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec4<f32>(0.0));
}

fn dualNum_sub_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_sub_motor(self_: DualNum, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn dualNum_sub_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn dualNum_sub_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn dualNum_sub_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn dualNum_sub_origin(self_: DualNum, other: Origin) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_sub_plane(self_: DualNum, other: Plane) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g0_);
}

fn dualNum_sub_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn dualNum_sub_point(self_: DualNum, other: Point) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_sub_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_sub_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_sub_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return DualNum(self_.g0_ - vec2<f32>(other.g0_, 0.0));
}

fn dualNum_sub_transflector(self_: DualNum, other: Transflector) -> MultiVector {
    return MultiVector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn dualNum_sub_translator(self_: DualNum, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_sub_antiScalar(self_: Flector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn flector_sub_dualNum(self_: Flector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn flector_sub_flector(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0_ - other.g0_, self_.g1_ - other.g1_);
}

fn flector_sub_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Flector {
    return Flector(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn flector_sub_horizon(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g0_, self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn flector_sub_line(self_: Flector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, self_.g1_);
}

fn flector_sub_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, self_.g1_);
}

fn flector_sub_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), self_.g1_);
}

fn flector_sub_motor(self_: Flector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, self_.g1_);
}

fn flector_sub_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, self_.g0_ - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, self_.g1_ - other.g4_);
}

fn flector_sub_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), self_.g0_ - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn flector_sub_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), self_.g1_ - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn flector_sub_origin(self_: Flector, other: Origin) -> Flector {
    return Flector(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn flector_sub_plane(self_: Flector, other: Plane) -> Flector {
    return Flector(self_.g0_, self_.g1_ - other.g0_);
}

fn flector_sub_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0_, self_.g1_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_sub_point(self_: Flector, other: Point) -> Flector {
    return Flector(self_.g0_ - other.g0_, self_.g1_);
}

fn flector_sub_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_);
}

fn flector_sub_rotor(self_: Flector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), self_.g1_);
}

fn flector_sub_scalar(self_: Flector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn flector_sub_transflector(self_: Flector, other: Transflector) -> Flector {
    return Flector(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ - other.g1_);
}

fn flector_sub_translator(self_: Flector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_);
}

fn flectorAtInfinity_sub_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_dualNum(self_: FlectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_flector(self_: FlectorAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - other.g1_);
}

fn flectorAtInfinity_sub_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ - other.g0_);
}

fn flectorAtInfinity_sub_horizon(self_: FlectorAtInfinity, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn flectorAtInfinity_sub_line(self_: FlectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.w), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0) - other.g0_);
}

fn flectorAtInfinity_sub_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_motor(self_: FlectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - other.g4_);
}

fn flectorAtInfinity_sub_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn flectorAtInfinity_sub_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn flectorAtInfinity_sub_origin(self_: FlectorAtInfinity, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_plane(self_: FlectorAtInfinity, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - other.g0_);
}

fn flectorAtInfinity_sub_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_sub_point(self_: FlectorAtInfinity, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_sub_rotor(self_: FlectorAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn flectorAtInfinity_sub_scalar(self_: FlectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0));
}

fn flectorAtInfinity_sub_transflector(self_: FlectorAtInfinity, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - other.g1_);
}

fn flectorAtInfinity_sub_translator(self_: FlectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w));
}

fn horizon_sub_antiScalar(self_: Horizon, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_dualNum(self_: Horizon, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_flector(self_: Horizon, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g1_);
}

fn horizon_sub_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_);
}

fn horizon_sub_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ - other.g0_);
}

fn horizon_sub_line(self_: Horizon, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_);
}

fn horizon_sub_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_motor(self_: Horizon, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g4_);
}

fn horizon_sub_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_) - other.g0_, vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn horizon_sub_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn horizon_sub_origin(self_: Horizon, other: Origin) -> Flector {
    return Flector(vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_plane(self_: Horizon, other: Plane) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_);
}

fn horizon_sub_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_sub_point(self_: Horizon, other: Point) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_sub_rotor(self_: Horizon, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn horizon_sub_scalar(self_: Horizon, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_) - vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn horizon_sub_transflector(self_: Horizon, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g1_);
}

fn horizon_sub_translator(self_: Horizon, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_));
}

fn line_sub_antiScalar(self_: Line, other: AntiScalar) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn line_sub_dualNum(self_: Line, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_sub_flector(self_: Line, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - other.g0_, self_.g0_, self_.g1_, vec4<f32>(0.0) - other.g1_);
}

fn line_sub_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, self_.g1_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn line_sub_horizon(self_: Line, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn line_sub_line(self_: Line, other: Line) -> Line {
    return Line(self_.g0_ - other.g0_, self_.g1_ - other.g1_);
}

fn line_sub_lineAtInfinity(self_: Line, other: LineAtInfinity) -> Line {
    return Line(self_.g0_, self_.g1_ - other.g0_);
}

fn line_sub_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Line {
    return Line(self_.g0_ - other.g0_, self_.g1_);
}

fn line_sub_motor(self_: Line, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, self_.g1_ - other.g1_);
}

fn line_sub_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, self_.g0_ - other.g2_, self_.g1_ - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn line_sub_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g0_, self_.g1_ - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn line_sub_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), self_.g0_ - other.g1_, self_.g1_, vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn line_sub_origin(self_: Line, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_sub_plane(self_: Line, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0) - other.g0_);
}

fn line_sub_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn line_sub_point(self_: Line, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - other.g0_, self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_sub_pointAtInfinity(self_: Line, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_sub_rotor(self_: Line, other: Rotor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, self_.g1_);
}

fn line_sub_scalar(self_: Line, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), self_.g0_, self_.g1_, vec4<f32>(0.0));
}

fn line_sub_transflector(self_: Line, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, self_.g1_, vec4<f32>(0.0) - other.g1_);
}

fn line_sub_translator(self_: Line, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), self_.g1_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn lineAtInfinity_sub_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn lineAtInfinity_sub_dualNum(self_: LineAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0));
}

fn lineAtInfinity_sub_flector(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0) - other.g1_);
}

fn lineAtInfinity_sub_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_);
}

fn lineAtInfinity_sub_horizon(self_: LineAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), self_.g0_);
}

fn lineAtInfinity_sub_line(self_: LineAtInfinity, other: Line) -> Line {
    return Line(vec3<f32>(0.0) - other.g0_, self_.g0_ - other.g1_);
}

fn lineAtInfinity_sub_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ - other.g0_);
}

fn lineAtInfinity_sub_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(0.0) - other.g0_, self_.g0_);
}

fn lineAtInfinity_sub_motor(self_: LineAtInfinity, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0) - other.g0_, self_.g0_ - other.g1_);
}

fn lineAtInfinity_sub_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, self_.g0_ - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn lineAtInfinity_sub_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, self_.g0_ - other.g2_);
}

fn lineAtInfinity_sub_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn lineAtInfinity_sub_origin(self_: LineAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0));
}

fn lineAtInfinity_sub_plane(self_: LineAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0) - other.g0_);
}

fn lineAtInfinity_sub_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn lineAtInfinity_sub_point(self_: LineAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0));
}

fn lineAtInfinity_sub_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), vec3<f32>(0.0) - other.g0_, self_.g0_);
}

fn lineAtInfinity_sub_rotor(self_: LineAtInfinity, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0) - other.g0_, self_.g0_);
}

fn lineAtInfinity_sub_scalar(self_: LineAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), self_.g0_);
}

fn lineAtInfinity_sub_transflector(self_: LineAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), self_.g0_, vec4<f32>(0.0) - other.g1_);
}

fn lineAtInfinity_sub_translator(self_: LineAtInfinity, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_);
}

fn lineAtOrigin_sub_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn lineAtOrigin_sub_dualNum(self_: LineAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_sub_flector(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - other.g0_, self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn lineAtOrigin_sub_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn lineAtOrigin_sub_horizon(self_: LineAtOrigin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn lineAtOrigin_sub_line(self_: LineAtOrigin, other: Line) -> Line {
    return Line(self_.g0_ - other.g0_, vec3<f32>(0.0) - other.g1_);
}

fn lineAtOrigin_sub_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return Line(self_.g0_, vec3<f32>(0.0) - other.g0_);
}

fn lineAtOrigin_sub_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ - other.g0_);
}

fn lineAtOrigin_sub_motor(self_: LineAtOrigin, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, vec3<f32>(0.0) - other.g1_);
}

fn lineAtOrigin_sub_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, self_.g0_ - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn lineAtOrigin_sub_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g0_, vec3<f32>(0.0) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn lineAtOrigin_sub_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - other.g0_, self_.g0_ - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn lineAtOrigin_sub_origin(self_: LineAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0));
}

fn lineAtOrigin_sub_plane(self_: LineAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0) - other.g0_);
}

fn lineAtOrigin_sub_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0) - other.g0_);
}

fn lineAtOrigin_sub_point(self_: LineAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - other.g0_, self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_sub_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_sub_rotor(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_);
}

fn lineAtOrigin_sub_scalar(self_: LineAtOrigin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_sub_transflector(self_: LineAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_, vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn lineAtOrigin_sub_translator(self_: LineAtOrigin, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn motor_sub_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn motor_sub_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_sub_flector(self_: Motor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0) - other.g1_);
}

fn motor_sub_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn motor_sub_horizon(self_: Motor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn motor_sub_line(self_: Motor, other: Line) -> Motor {
    return Motor(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ - other.g1_);
}

fn motor_sub_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0_, self_.g1_ - other.g0_);
}

fn motor_sub_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> Motor {
    return Motor(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_);
}

fn motor_sub_motor(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0_ - other.g0_, self_.g1_ - other.g1_);
}

fn motor_sub_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g2_, self_.g1_ - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn motor_sub_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_ - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn motor_sub_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g1_, self_.g1_, vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn motor_sub_origin(self_: Motor, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_sub_plane(self_: Motor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0) - other.g0_);
}

fn motor_sub_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn motor_sub_point(self_: Motor, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_sub_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_sub_rotor(self_: Motor, other: Rotor) -> Motor {
    return Motor(self_.g0_ - other.g0_, self_.g1_);
}

fn motor_sub_scalar(self_: Motor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0));
}

fn motor_sub_transflector(self_: Motor, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), self_.g1_, vec4<f32>(0.0) - other.g1_);
}

fn motor_sub_translator(self_: Motor, other: Translator) -> Motor {
    return Motor(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), self_.g1_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn multiVector_sub_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_), self_.g1_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_sub_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(self_.g0_ - other.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_sub_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ - other.g0_, self_.g2_, self_.g3_, self_.g4_ - other.g1_);
}

fn multiVector_sub_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g2_, self_.g3_, self_.g4_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVector_sub_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn multiVector_sub_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_ - other.g0_, self_.g3_ - other.g1_, self_.g4_);
}

fn multiVector_sub_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_ - other.g0_, self_.g4_);
}

fn multiVector_sub_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_ - other.g0_, self_.g3_, self_.g4_);
}

fn multiVector_sub_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.w), self_.g1_, self_.g2_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g3_ - other.g1_, self_.g4_);
}

fn multiVector_sub_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_ - other.g0_, self_.g1_ - other.g1_, self_.g2_ - other.g2_, self_.g3_ - other.g3_, self_.g4_ - other.g4_);
}

fn multiVector_sub_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(other.g0_.x, 0.0), self_.g1_ - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g2_, self_.g3_ - other.g2_, self_.g4_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn multiVector_sub_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.y), self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), self_.g2_ - other.g1_, self_.g3_, self_.g4_ - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn multiVector_sub_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_sub_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_ - other.g0_);
}

fn multiVector_sub_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_, self_.g3_, self_.g4_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_sub_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ - other.g0_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_sub_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_sub_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.w), self_.g1_, self_.g2_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g3_, self_.g4_);
}

fn multiVector_sub_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(other.g0_, 0.0), self_.g1_, self_.g2_, self_.g3_, self_.g4_);
}

fn multiVector_sub_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g2_, self_.g3_, self_.g4_ - other.g1_);
}

fn multiVector_sub_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ - vec2<f32>(0.0, other.g0_.w), self_.g1_, self_.g2_, self_.g3_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g4_);
}

fn multiVectorAtInfinity_sub_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - other.g0_, vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) - other.g0_, vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) - other.g1_);
}

fn multiVectorAtInfinity_sub_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ - vec2<f32>(0.0, other.g0_.w), self_.g1_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_);
}

fn multiVectorAtInfinity_sub_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ - vec2<f32>(0.0, other.g0_), self_.g1_, self_.g2_);
}

fn multiVectorAtInfinity_sub_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0) - other.g0_, self_.g2_ - other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_, self_.g1_, self_.g2_ - other.g0_);
}

fn multiVectorAtInfinity_sub_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0) - other.g0_, self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_ - other.g1_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - other.g0_, vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, self_.g2_ - other.g3_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) - other.g4_);
}

fn multiVectorAtInfinity_sub_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ - other.g0_, self_.g1_ - other.g1_, self_.g2_ - other.g2_);
}

fn multiVectorAtInfinity_sub_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn multiVectorAtInfinity_sub_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) - other.g0_);
}

fn multiVectorAtInfinity_sub_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVectorAtInfinity_sub_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) - other.g0_, vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_, self_.g1_ - other.g0_, self_.g2_);
}

fn multiVectorAtInfinity_sub_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtInfinity_sub_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ - vec2<f32>(other.g0_, 0.0), self_.g1_, self_.g2_);
}

fn multiVectorAtInfinity_sub_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), self_.g2_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y) - other.g1_);
}

fn multiVectorAtInfinity_sub_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x, 0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, 0.0), vec3<f32>(0.0), self_.g2_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.y));
}

fn multiVectorAtOrigin_sub_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ - vec2<f32>(0.0, other.g0_), self_.g1_, self_.g2_);
}

fn multiVectorAtOrigin_sub_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - other.g0_, self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - other.g1_);
}

fn multiVectorAtOrigin_sub_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVectorAtOrigin_sub_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn multiVectorAtOrigin_sub_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_ - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0) - other.g0_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_, self_.g1_ - other.g0_, self_.g2_);
}

fn multiVectorAtOrigin_sub_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - other.g1_, self_.g1_ - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - other.g4_);
}

fn multiVectorAtOrigin_sub_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), self_.g1_, vec3<f32>(0.0) - other.g2_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn multiVectorAtOrigin_sub_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ - other.g0_, self_.g1_ - other.g1_, self_.g2_ - other.g2_);
}

fn multiVectorAtOrigin_sub_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ - vec2<f32>(other.g0_, 0.0), self_.g1_, self_.g2_);
}

fn multiVectorAtOrigin_sub_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - other.g0_);
}

fn multiVectorAtOrigin_sub_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_, self_.g1_, self_.g2_ - other.g0_);
}

fn multiVectorAtOrigin_sub_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - other.g0_, self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ - vec2<f32>(0.0, other.g0_.w), self_.g1_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g2_);
}

fn multiVectorAtOrigin_sub_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn multiVectorAtOrigin_sub_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_, vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0) - other.g1_);
}

fn multiVectorAtOrigin_sub_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.y) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_.x), self_.g1_, vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, 0.0));
}

fn origin_sub_antiScalar(self_: Origin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn origin_sub_dualNum(self_: Origin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_sub_flector(self_: Origin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_, vec4<f32>(0.0) - other.g1_);
}

fn origin_sub_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn origin_sub_horizon(self_: Origin, other: Horizon) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn origin_sub_line(self_: Origin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn origin_sub_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec4<f32>(0.0));
}

fn origin_sub_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0));
}

fn origin_sub_motor(self_: Origin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn origin_sub_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn origin_sub_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn origin_sub_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn origin_sub_origin(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0_ - other.g0_);
}

fn origin_sub_plane(self_: Origin, other: Plane) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec4<f32>(0.0) - other.g0_);
}

fn origin_sub_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_sub_point(self_: Origin, other: Point) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - other.g0_);
}

fn origin_sub_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_sub_rotor(self_: Origin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0));
}

fn origin_sub_scalar(self_: Origin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_sub_transflector(self_: Origin, other: Transflector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0_) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(0.0) - other.g1_);
}

fn origin_sub_translator(self_: Origin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0, 0.0, 0.0, self_.g0_), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn plane_sub_antiScalar(self_: Plane, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_);
}

fn plane_sub_dualNum(self_: Plane, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_);
}

fn plane_sub_flector(self_: Plane, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0_, self_.g0_ - other.g1_);
}

fn plane_sub_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn plane_sub_horizon(self_: Plane, other: Horizon) -> Plane {
    return Plane(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn plane_sub_line(self_: Plane, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, self_.g0_);
}

fn plane_sub_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, self_.g0_);
}

fn plane_sub_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), self_.g0_);
}

fn plane_sub_motor(self_: Plane, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, self_.g0_);
}

fn plane_sub_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, self_.g0_ - other.g4_);
}

fn plane_sub_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn plane_sub_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), self_.g0_ - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn plane_sub_origin(self_: Plane, other: Origin) -> Flector {
    return Flector(vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_);
}

fn plane_sub_plane(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0_ - other.g0_);
}

fn plane_sub_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return Plane(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_sub_point(self_: Plane, other: Point) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0_, self_.g0_);
}

fn plane_sub_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(0.0) - other.g0_, self_.g0_);
}

fn plane_sub_rotor(self_: Plane, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), self_.g0_);
}

fn plane_sub_scalar(self_: Plane, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_);
}

fn plane_sub_transflector(self_: Plane, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(0.0) - other.g0_, self_.g0_ - other.g1_);
}

fn plane_sub_translator(self_: Plane, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_);
}

fn planeAtOrigin_sub_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), self_.g0_);
}

fn planeAtOrigin_sub_dualNum(self_: PlaneAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_flector(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g1_);
}

fn planeAtOrigin_sub_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn planeAtOrigin_sub_horizon(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn planeAtOrigin_sub_line(self_: PlaneAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0), vec3<f32>(0.0) - other.g0_, self_.g0_);
}

fn planeAtOrigin_sub_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g4_);
}

fn planeAtOrigin_sub_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn planeAtOrigin_sub_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, self_.g0_ - other.g2_);
}

fn planeAtOrigin_sub_origin(self_: PlaneAtOrigin, other: Origin) -> Flector {
    return Flector(vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_plane(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_);
}

fn planeAtOrigin_sub_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ - other.g0_);
}

fn planeAtOrigin_sub_point(self_: PlaneAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g0_);
}

fn planeAtOrigin_sub_scalar(self_: PlaneAtOrigin, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn planeAtOrigin_sub_transflector(self_: PlaneAtOrigin, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g1_);
}

fn planeAtOrigin_sub_translator(self_: PlaneAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn point_sub_antiScalar(self_: Point, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_sub_dualNum(self_: Point, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_sub_flector(self_: Point, other: Flector) -> Flector {
    return Flector(self_.g0_ - other.g0_, vec4<f32>(0.0) - other.g1_);
}

fn point_sub_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Flector {
    return Flector(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn point_sub_horizon(self_: Point, other: Horizon) -> Flector {
    return Flector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn point_sub_line(self_: Point, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn point_sub_lineAtInfinity(self_: Point, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec4<f32>(0.0));
}

fn point_sub_lineAtOrigin(self_: Point, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_sub_motor(self_: Point, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn point_sub_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, self_.g0_ - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn point_sub_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), self_.g0_ - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn point_sub_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn point_sub_origin(self_: Point, other: Origin) -> Point {
    return Point(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn point_sub_plane(self_: Point, other: Plane) -> Flector {
    return Flector(self_.g0_, vec4<f32>(0.0) - other.g0_);
}

fn point_sub_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn point_sub_point(self_: Point, other: Point) -> Point {
    return Point(self_.g0_ - other.g0_);
}

fn point_sub_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Point {
    return Point(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn point_sub_rotor(self_: Point, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_sub_scalar(self_: Point, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_sub_transflector(self_: Point, other: Transflector) -> Flector {
    return Flector(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(0.0) - other.g1_);
}

fn point_sub_translator(self_: Point, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), self_.g0_, vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn pointAtInfinity_sub_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_sub_dualNum(self_: PointAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_sub_flector(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, vec4<f32>(0.0) - other.g1_);
}

fn pointAtInfinity_sub_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_);
}

fn pointAtInfinity_sub_horizon(self_: PointAtInfinity, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn pointAtInfinity_sub_line(self_: PointAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn pointAtInfinity_sub_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), self_.g0_, vec3<f32>(0.0) - other.g0_);
}

fn pointAtInfinity_sub_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_sub_motor(self_: PointAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn pointAtInfinity_sub_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn pointAtInfinity_sub_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - other.g0_, self_.g0_ - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn pointAtInfinity_sub_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn pointAtInfinity_sub_origin(self_: PointAtInfinity, other: Origin) -> Point {
    return Point(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn pointAtInfinity_sub_plane(self_: PointAtInfinity, other: Plane) -> Transflector {
    return Transflector(self_.g0_, vec4<f32>(0.0) - other.g0_);
}

fn pointAtInfinity_sub_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> Transflector {
    return Transflector(self_.g0_, vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn pointAtInfinity_sub_point(self_: PointAtInfinity, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_);
}

fn pointAtInfinity_sub_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ - other.g0_);
}

fn pointAtInfinity_sub_rotor(self_: PointAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_sub_scalar(self_: PointAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), self_.g0_, vec3<f32>(0.0));
}

fn pointAtInfinity_sub_transflector(self_: PointAtInfinity, other: Transflector) -> Transflector {
    return Transflector(self_.g0_ - other.g0_, vec4<f32>(0.0) - other.g1_);
}

fn pointAtInfinity_sub_translator(self_: PointAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn rotor_sub_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn rotor_sub_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_sub_flector(self_: Rotor, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn rotor_sub_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn rotor_sub_horizon(self_: Rotor, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn rotor_sub_line(self_: Rotor, other: Line) -> Motor {
    return Motor(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0) - other.g1_);
}

fn rotor_sub_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0_, vec3<f32>(0.0) - other.g0_);
}

fn rotor_sub_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_sub_motor(self_: Rotor, other: Motor) -> Motor {
    return Motor(self_.g0_ - other.g0_, vec3<f32>(0.0) - other.g1_);
}

fn rotor_sub_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn rotor_sub_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn rotor_sub_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn rotor_sub_origin(self_: Rotor, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0));
}

fn rotor_sub_plane(self_: Rotor, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0) - other.g0_);
}

fn rotor_sub_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0, self_.g0_.w), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0) - other.g0_);
}

fn rotor_sub_point(self_: Rotor, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_sub_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_sub_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0_ - other.g0_);
}

fn rotor_sub_scalar(self_: Rotor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_sub_transflector(self_: Rotor, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn rotor_sub_translator(self_: Rotor, other: Translator) -> Motor {
    return Motor(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_sub_antiScalar(self_: Scalar, other: AntiScalar) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_));
}

fn scalar_sub_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_, 0.0) - other.g0_);
}

fn scalar_sub_flector(self_: Scalar, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn scalar_sub_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0));
}

fn scalar_sub_horizon(self_: Scalar, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0));
}

fn scalar_sub_line(self_: Scalar, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn scalar_sub_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_);
}

fn scalar_sub_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_sub_motor(self_: Scalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, vec4<f32>(0.0));
}

fn scalar_sub_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn scalar_sub_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_);
}

fn scalar_sub_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn scalar_sub_origin(self_: Scalar, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_sub_plane(self_: Scalar, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g0_);
}

fn scalar_sub_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn scalar_sub_point(self_: Scalar, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_sub_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0));
}

fn scalar_sub_rotor(self_: Scalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn scalar_sub_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ - other.g0_);
}

fn scalar_sub_transflector(self_: Scalar, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0) - other.g1_);
}

fn scalar_sub_translator(self_: Scalar, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_, 0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_sub_antiScalar(self_: Transflector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn transflector_sub_dualNum(self_: Transflector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn transflector_sub_flector(self_: Transflector, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, self_.g1_ - other.g1_);
}

fn transflector_sub_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Transflector {
    return Transflector(self_.g0_ - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn transflector_sub_horizon(self_: Transflector, other: Horizon) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn transflector_sub_line(self_: Transflector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0) - other.g1_, self_.g1_);
}

fn transflector_sub_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g0_, self_.g1_);
}

fn transflector_sub_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - other.g0_, vec3<f32>(0.0), self_.g1_);
}

fn transflector_sub_motor(self_: Transflector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - other.g1_, self_.g1_);
}

fn transflector_sub_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0_, vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(0.0) - other.g3_, self_.g1_ - other.g4_);
}

fn transflector_sub_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - other.g2_, self_.g1_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn transflector_sub_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(0.0), self_.g1_ - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn transflector_sub_origin(self_: Transflector, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g1_);
}

fn transflector_sub_plane(self_: Transflector, other: Plane) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ - other.g0_);
}

fn transflector_sub_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_sub_point(self_: Transflector, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0) - other.g0_, self_.g1_);
}

fn transflector_sub_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Transflector {
    return Transflector(self_.g0_ - other.g0_, self_.g1_);
}

fn transflector_sub_rotor(self_: Transflector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), self_.g1_);
}

fn transflector_sub_scalar(self_: Transflector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(other.g0_, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g1_);
}

fn transflector_sub_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return Transflector(self_.g0_ - other.g0_, self_.g1_ - other.g1_);
}

fn transflector_sub_translator(self_: Transflector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(0.0, other.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_);
}

fn translator_sub_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0_ - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn translator_sub_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_sub_flector(self_: Translator, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - other.g1_);
}

fn translator_sub_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn translator_sub_horizon(self_: Translator, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn translator_sub_line(self_: Translator, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g1_);
}

fn translator_sub_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> Translator {
    return Translator(self_.g0_ - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn translator_sub_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn translator_sub_motor(self_: Translator, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g1_);
}

fn translator_sub_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - other.g0_, vec4<f32>(0.0) - other.g1_, vec3<f32>(0.0) - other.g2_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g3_, vec4<f32>(0.0) - other.g4_);
}

fn translator_sub_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_.x, 0.0), vec4<f32>(0.0) - vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) - other.g2_, vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn translator_sub_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(0.0, other.g0_.y), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(0.0) - other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn translator_sub_origin(self_: Translator, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_sub_plane(self_: Translator, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - other.g0_);
}

fn translator_sub_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn translator_sub_point(self_: Translator, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - other.g0_, vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_sub_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_sub_rotor(self_: Translator, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0_.w) - other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn translator_sub_scalar(self_: Translator, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w) - vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn translator_sub_transflector(self_: Translator, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0_.w), vec4<f32>(0.0) - vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0) - other.g1_);
}

fn translator_sub_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_ - other.g0_);
}

fn antiScalar_antiWedgeDot_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedgeDot_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_flector(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedgeDot_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedgeDot_line(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedgeDot_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_motor(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedgeDot_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn antiScalar_antiWedgeDot_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_antiWedgeDot_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_antiWedgeDot_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedgeDot_plane(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_point(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedgeDot_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedgeDot_transflector(self_: AntiScalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedgeDot_translator(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn dualNum_antiWedgeDot_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_antiWedgeDot_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedgeDot_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_antiWedgeDot_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedgeDot_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.y * other.g0_);
}

fn dualNum_antiWedgeDot_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_antiWedgeDot_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedgeDot_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_antiWedgeDot_motor(self_: DualNum, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn dualNum_antiWedgeDot_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.x, -other.g4_.y, -other.g4_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_, vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g0_.y) * other.g4_);
}

fn dualNum_antiWedgeDot_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_);
}

fn dualNum_antiWedgeDot_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(-other.g2_.x, -other.g2_.y, -other.g2_.z, other.g0_.x), vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g0_.x));
}

fn dualNum_antiWedgeDot_origin(self_: DualNum, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn dualNum_antiWedgeDot_plane(self_: DualNum, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedgeDot_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn dualNum_antiWedgeDot_point(self_: DualNum, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w));
}

fn dualNum_antiWedgeDot_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedgeDot_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn dualNum_antiWedgeDot_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn dualNum_antiWedgeDot_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_antiWedgeDot_translator(self_: DualNum, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_antiWedgeDot_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_antiWedgeDot_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.y) + self_.g1_.xyzx * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_antiWedgeDot_flector(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_antiWedgeDot_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn flector_antiWedgeDot_horizon(self_: Flector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn flector_antiWedgeDot_line(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn flector_antiWedgeDot_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn flector_antiWedgeDot_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn flector_antiWedgeDot_motor(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn flector_antiWedgeDot_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn flector_antiWedgeDot_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.w) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn flector_antiWedgeDot_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) - vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g2_.z, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g1_.w) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn flector_antiWedgeDot_origin(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn flector_antiWedgeDot_plane(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_antiWedgeDot_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_antiWedgeDot_point(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn flector_antiWedgeDot_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_antiWedgeDot_rotor(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g1_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn flector_antiWedgeDot_scalar(self_: Flector, other: Scalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + self_.g1_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn flector_antiWedgeDot_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) - vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_antiWedgeDot_translator(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn flectorAtInfinity_antiWedgeDot_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_antiWedgeDot_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn flectorAtInfinity_antiWedgeDot_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_antiWedgeDot_line(self_: FlectorAtInfinity, other: Line) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_antiWedgeDot_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_antiWedgeDot_motor(self_: FlectorAtInfinity, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedgeDot_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g4_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g4_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g4_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn flectorAtInfinity_antiWedgeDot_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn flectorAtInfinity_antiWedgeDot_origin(self_: FlectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn flectorAtInfinity_antiWedgeDot_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flectorAtInfinity_antiWedgeDot_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedgeDot_point(self_: FlectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w));
}

fn flectorAtInfinity_antiWedgeDot_rotor(self_: FlectorAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedgeDot_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_antiWedgeDot_translator(self_: FlectorAtInfinity, other: Translator) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn horizon_antiWedgeDot_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn horizon_antiWedgeDot_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.y);
}

fn horizon_antiWedgeDot_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_antiWedgeDot_line(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedgeDot_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedgeDot_motor(self_: Horizon, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedgeDot_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn horizon_antiWedgeDot_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn horizon_antiWedgeDot_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn horizon_antiWedgeDot_plane(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn horizon_antiWedgeDot_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedgeDot_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn horizon_antiWedgeDot_rotor(self_: Horizon, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedgeDot_transflector(self_: Horizon, other: Transflector) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_antiWedgeDot_translator(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.w);
}

fn line_antiWedgeDot_antiScalar(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_antiWedgeDot_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g0_ * vec3<f32>(other.g0_.x) + self_.g1_ * vec3<f32>(other.g0_.y));
}

fn line_antiWedgeDot_flector(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn line_antiWedgeDot_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_antiWedgeDot_horizon(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn line_antiWedgeDot_line(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn line_antiWedgeDot_lineAtInfinity(self_: Line, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn line_antiWedgeDot_lineAtOrigin(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn line_antiWedgeDot_motor(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn line_antiWedgeDot_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z));
}

fn line_antiWedgeDot_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn line_antiWedgeDot_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.z));
}

fn line_antiWedgeDot_origin(self_: Line, other: Origin) -> Transflector {
    return Transflector(vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn line_antiWedgeDot_plane(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn line_antiWedgeDot_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn line_antiWedgeDot_point(self_: Line, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_antiWedgeDot_pointAtInfinity(self_: Line, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn line_antiWedgeDot_rotor(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn line_antiWedgeDot_scalar(self_: Line, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn line_antiWedgeDot_transflector(self_: Line, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn line_antiWedgeDot_translator(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn lineAtInfinity_antiWedgeDot_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_antiWedgeDot_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_antiWedgeDot_flector(self_: LineAtInfinity, other: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, other.g1_.z));
}

fn lineAtInfinity_antiWedgeDot_line(self_: LineAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtInfinity_antiWedgeDot_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtInfinity_antiWedgeDot_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn lineAtInfinity_antiWedgeDot_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y));
}

fn lineAtInfinity_antiWedgeDot_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn lineAtInfinity_antiWedgeDot_origin(self_: LineAtInfinity, other: Origin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_antiWedgeDot_plane(self_: LineAtInfinity, other: Plane) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn lineAtInfinity_antiWedgeDot_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn lineAtInfinity_antiWedgeDot_point(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtInfinity_antiWedgeDot_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn lineAtInfinity_antiWedgeDot_transflector(self_: LineAtInfinity, other: Transflector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, other.g1_.z));
}

fn lineAtInfinity_antiWedgeDot_translator(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_antiWedgeDot_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_antiWedgeDot_dualNum(self_: LineAtOrigin, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtOrigin_antiWedgeDot_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn lineAtOrigin_antiWedgeDot_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtOrigin_antiWedgeDot_horizon(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_antiWedgeDot_line(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_antiWedgeDot_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtOrigin_antiWedgeDot_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_antiWedgeDot_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_antiWedgeDot_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn lineAtOrigin_antiWedgeDot_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtOrigin_antiWedgeDot_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtOrigin_antiWedgeDot_origin(self_: LineAtOrigin, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_antiWedgeDot_plane(self_: LineAtOrigin, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_antiWedgeDot_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_antiWedgeDot_point(self_: LineAtOrigin, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtOrigin_antiWedgeDot_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_antiWedgeDot_rotor(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtOrigin_antiWedgeDot_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_antiWedgeDot_transflector(self_: LineAtOrigin, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_antiWedgeDot_translator(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_antiWedgeDot_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_antiWedgeDot_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x) + self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn motor_antiWedgeDot_flector(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn motor_antiWedgeDot_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedgeDot_horizon(self_: Motor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn motor_antiWedgeDot_line(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_antiWedgeDot_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedgeDot_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_antiWedgeDot_motor(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn motor_antiWedgeDot_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z));
}

fn motor_antiWedgeDot_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn motor_antiWedgeDot_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.z));
}

fn motor_antiWedgeDot_origin(self_: Motor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn motor_antiWedgeDot_plane(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn motor_antiWedgeDot_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn motor_antiWedgeDot_point(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_antiWedgeDot_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn motor_antiWedgeDot_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn motor_antiWedgeDot_scalar(self_: Motor, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn motor_antiWedgeDot_transflector(self_: Motor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn motor_antiWedgeDot_translator(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn multiVector_antiWedgeDot_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_antiWedgeDot_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, self_.g1_ * vec4<f32>(other.g0_.y) + self_.g4_.xyzx * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), self_.g2_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.x) + self_.g3_ * vec3<f32>(other.g0_.y), vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_antiWedgeDot_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn multiVector_antiWedgeDot_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVector_antiWedgeDot_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_));
}

fn multiVector_antiWedgeDot_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVector_antiWedgeDot_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_antiWedgeDot_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVector_antiWedgeDot_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVector_antiWedgeDot_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g4_.z, 0.0) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g4_.w, other.g1_.w) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.x, -other.g4_.y, -other.g4_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g0_.y) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn multiVector_antiWedgeDot_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.w) * other.g2_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.y) * other.g2_ - vec3<f32>(self_.g1_.w) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn multiVector_antiWedgeDot_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) - vec2<f32>(self_.g1_.z, self_.g1_.w) * vec2<f32>(other.g2_.z, other.g0_.x) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(-other.g2_.x, -other.g2_.y, -other.g2_.z, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g4_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.y) * other.g1_ - vec3<f32>(self_.g1_.w) * other.g2_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g4_.w) * other.g2_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g4_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn multiVector_antiWedgeDot_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g3_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn multiVector_antiWedgeDot_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn multiVector_antiWedgeDot_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn multiVector_antiWedgeDot_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g3_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_antiWedgeDot_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVector_antiWedgeDot_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g1_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g4_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn multiVector_antiWedgeDot_scalar(self_: MultiVector, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_), vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVector_antiWedgeDot_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) - vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn multiVector_antiWedgeDot_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * other.g0_ + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVectorAtInfinity_antiWedgeDot_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_antiWedgeDot_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_antiWedgeDot_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w));
}

fn multiVectorAtInfinity_antiWedgeDot_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_antiWedgeDot_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_antiWedgeDot_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtInfinity_antiWedgeDot_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, -other.g1_.w) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.w, other.g0_.y) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g4_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g4_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g4_.z, other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g2_.x, other.g4_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g2_.y, other.g4_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g2_.z, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y));
}

fn multiVectorAtInfinity_antiWedgeDot_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn multiVectorAtInfinity_antiWedgeDot_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_antiWedgeDot_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_antiWedgeDot_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_antiWedgeDot_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_.w), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_antiWedgeDot_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtInfinity_antiWedgeDot_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn multiVectorAtInfinity_antiWedgeDot_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_antiWedgeDot_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_antiWedgeDot_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), self_.g1_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtOrigin_antiWedgeDot_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtOrigin_antiWedgeDot_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVectorAtOrigin_antiWedgeDot_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_), self_.g1_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_antiWedgeDot_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtOrigin_antiWedgeDot_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_antiWedgeDot_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_antiWedgeDot_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn multiVectorAtOrigin_antiWedgeDot_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g4_.w, other.g1_.w) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g0_.y) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z));
}

fn multiVectorAtOrigin_antiWedgeDot_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn multiVectorAtOrigin_antiWedgeDot_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn multiVectorAtOrigin_antiWedgeDot_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_antiWedgeDot_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVectorAtOrigin_antiWedgeDot_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_antiWedgeDot_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtOrigin_antiWedgeDot_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_antiWedgeDot_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtOrigin_antiWedgeDot_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_antiWedgeDot_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn multiVectorAtOrigin_antiWedgeDot_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn origin_antiWedgeDot_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_antiWedgeDot_dualNum(self_: Origin, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn origin_antiWedgeDot_flector(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn origin_antiWedgeDot_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_antiWedgeDot_horizon(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_antiWedgeDot_line(self_: Origin, other: Line) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g1_, vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_antiWedgeDot_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_antiWedgeDot_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_antiWedgeDot_motor(self_: Origin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_antiWedgeDot_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn origin_antiWedgeDot_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_antiWedgeDot_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_antiWedgeDot_origin(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_antiWedgeDot_plane(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_antiWedgeDot_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_antiWedgeDot_point(self_: Origin, other: Point) -> Translator {
    return Translator(vec4<f32>(0.0) - vec4<f32>(self_.g0_) * other.g0_);
}

fn origin_antiWedgeDot_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_antiWedgeDot_rotor(self_: Origin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_antiWedgeDot_scalar(self_: Origin, other: Scalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn origin_antiWedgeDot_transflector(self_: Origin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(0.0));
}

fn origin_antiWedgeDot_translator(self_: Origin, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn plane_antiWedgeDot_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_antiWedgeDot_dualNum(self_: Plane, other: DualNum) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_antiWedgeDot_flector(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_antiWedgeDot_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn plane_antiWedgeDot_horizon(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn plane_antiWedgeDot_line(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn plane_antiWedgeDot_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn plane_antiWedgeDot_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn plane_antiWedgeDot_motor(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn plane_antiWedgeDot_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn plane_antiWedgeDot_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn plane_antiWedgeDot_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.w) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn plane_antiWedgeDot_origin(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_antiWedgeDot_plane(self_: Plane, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_antiWedgeDot_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_antiWedgeDot_point(self_: Plane, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn plane_antiWedgeDot_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn plane_antiWedgeDot_rotor(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn plane_antiWedgeDot_scalar(self_: Plane, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn plane_antiWedgeDot_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_antiWedgeDot_translator(self_: Plane, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn planeAtOrigin_antiWedgeDot_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_antiWedgeDot_dualNum(self_: PlaneAtOrigin, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn planeAtOrigin_antiWedgeDot_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_antiWedgeDot_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn planeAtOrigin_antiWedgeDot_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_antiWedgeDot_line(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn planeAtOrigin_antiWedgeDot_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_antiWedgeDot_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn planeAtOrigin_antiWedgeDot_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn planeAtOrigin_antiWedgeDot_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z));
}

fn planeAtOrigin_antiWedgeDot_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn planeAtOrigin_antiWedgeDot_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn planeAtOrigin_antiWedgeDot_origin(self_: PlaneAtOrigin, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_antiWedgeDot_plane(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_antiWedgeDot_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn planeAtOrigin_antiWedgeDot_point(self_: PlaneAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn planeAtOrigin_antiWedgeDot_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn planeAtOrigin_antiWedgeDot_rotor(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0));
}

fn planeAtOrigin_antiWedgeDot_scalar(self_: PlaneAtOrigin, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_antiWedgeDot_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_antiWedgeDot_translator(self_: PlaneAtOrigin, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn point_antiWedgeDot_antiScalar(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_antiWedgeDot_dualNum(self_: Point, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn point_antiWedgeDot_flector(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn point_antiWedgeDot_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn point_antiWedgeDot_horizon(self_: Point, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_);
}

fn point_antiWedgeDot_line(self_: Point, other: Line) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_antiWedgeDot_lineAtInfinity(self_: Point, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn point_antiWedgeDot_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_antiWedgeDot_motor(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_antiWedgeDot_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn point_antiWedgeDot_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g1_);
}

fn point_antiWedgeDot_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) - vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g2_.z, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z));
}

fn point_antiWedgeDot_origin(self_: Point, other: Origin) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_antiWedgeDot_plane(self_: Point, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_antiWedgeDot_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_antiWedgeDot_point(self_: Point, other: Point) -> Translator {
    return Translator(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) - vec4<f32>(self_.g0_.w) * other.g0_);
}

fn point_antiWedgeDot_pointAtInfinity(self_: Point, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn point_antiWedgeDot_rotor(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_antiWedgeDot_scalar(self_: Point, other: Scalar) -> Horizon {
    return Horizon(self_.g0_.w * other.g0_);
}

fn point_antiWedgeDot_transflector(self_: Point, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) - vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0));
}

fn point_antiWedgeDot_translator(self_: Point, other: Translator) -> Point {
    return Point(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn pointAtInfinity_antiWedgeDot_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_antiWedgeDot_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn pointAtInfinity_antiWedgeDot_flector(self_: PointAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w));
}

fn pointAtInfinity_antiWedgeDot_line(self_: PointAtInfinity, other: Line) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn pointAtInfinity_antiWedgeDot_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn pointAtInfinity_antiWedgeDot_motor(self_: PointAtInfinity, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn pointAtInfinity_antiWedgeDot_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g4_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g4_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g4_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w));
}

fn pointAtInfinity_antiWedgeDot_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn pointAtInfinity_antiWedgeDot_origin(self_: PointAtInfinity, other: Origin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_antiWedgeDot_plane(self_: PointAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_antiWedgeDot_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_antiWedgeDot_point(self_: PointAtInfinity, other: Point) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_antiWedgeDot_rotor(self_: PointAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn pointAtInfinity_antiWedgeDot_transflector(self_: PointAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn pointAtInfinity_antiWedgeDot_translator(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn rotor_antiWedgeDot_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_antiWedgeDot_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec4<f32>(0.0));
}

fn rotor_antiWedgeDot_flector(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_antiWedgeDot_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedgeDot_horizon(self_: Rotor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_antiWedgeDot_line(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_antiWedgeDot_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedgeDot_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_antiWedgeDot_motor(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_antiWedgeDot_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g4_);
}

fn rotor_antiWedgeDot_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_antiWedgeDot_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_antiWedgeDot_origin(self_: Rotor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn rotor_antiWedgeDot_plane(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedgeDot_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_antiWedgeDot_point(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn rotor_antiWedgeDot_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_antiWedgeDot_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedgeDot_scalar(self_: Rotor, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn rotor_antiWedgeDot_transflector(self_: Rotor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_antiWedgeDot_translator(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn scalar_antiWedgeDot_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_antiWedgeDot_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_antiWedgeDot_flector(self_: Scalar, other: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0) - vec4<f32>(self_.g0_) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w));
}

fn scalar_antiWedgeDot_line(self_: Scalar, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_antiWedgeDot_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_antiWedgeDot_motor(self_: Scalar, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_antiWedgeDot_multiVector(self_: Scalar, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.y, -other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_antiWedgeDot_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_antiWedgeDot_origin(self_: Scalar, other: Origin) -> Horizon {
    return Horizon(0.0 - self_.g0_ * other.g0_);
}

fn scalar_antiWedgeDot_plane(self_: Scalar, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_antiWedgeDot_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_antiWedgeDot_point(self_: Scalar, other: Point) -> Horizon {
    return Horizon(0.0 - self_.g0_ * other.g0_.w);
}

fn scalar_antiWedgeDot_rotor(self_: Scalar, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_antiWedgeDot_transflector(self_: Scalar, other: Transflector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn scalar_antiWedgeDot_translator(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn transflector_antiWedgeDot_antiScalar(self_: Transflector, other: AntiScalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_antiWedgeDot_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_antiWedgeDot_flector(self_: Transflector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_antiWedgeDot_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn transflector_antiWedgeDot_horizon(self_: Transflector, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn transflector_antiWedgeDot_line(self_: Transflector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn transflector_antiWedgeDot_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn transflector_antiWedgeDot_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn transflector_antiWedgeDot_motor(self_: Transflector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn transflector_antiWedgeDot_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn transflector_antiWedgeDot_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn transflector_antiWedgeDot_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g1_.w) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn transflector_antiWedgeDot_origin(self_: Transflector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), self_.g0_ * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn transflector_antiWedgeDot_plane(self_: Transflector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_antiWedgeDot_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_antiWedgeDot_point(self_: Transflector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w), self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn transflector_antiWedgeDot_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn transflector_antiWedgeDot_rotor(self_: Transflector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g1_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn transflector_antiWedgeDot_scalar(self_: Transflector, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn transflector_antiWedgeDot_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_antiWedgeDot_translator(self_: Transflector, other: Translator) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn translator_antiWedgeDot_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_antiWedgeDot_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn translator_antiWedgeDot_flector(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_antiWedgeDot_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedgeDot_horizon(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.w * other.g0_);
}

fn translator_antiWedgeDot_line(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_antiWedgeDot_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedgeDot_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn translator_antiWedgeDot_motor(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_antiWedgeDot_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g4_);
}

fn translator_antiWedgeDot_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn translator_antiWedgeDot_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g2_.z));
}

fn translator_antiWedgeDot_origin(self_: Translator, other: Origin) -> Point {
    return Point(self_.g0_ * vec4<f32>(-other.g0_));
}

fn translator_antiWedgeDot_plane(self_: Translator, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedgeDot_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g0_.z));
}

fn translator_antiWedgeDot_point(self_: Translator, other: Point) -> Point {
    return Point(self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedgeDot_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedgeDot_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn translator_antiWedgeDot_scalar(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn translator_antiWedgeDot_transflector(self_: Translator, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_antiWedgeDot_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn antiScalar_geometricAntiProduct_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_geometricAntiProduct_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_flector(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricAntiProduct_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn antiScalar_geometricAntiProduct_line(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricAntiProduct_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_motor(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricAntiProduct_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn antiScalar_geometricAntiProduct_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_geometricAntiProduct_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_geometricAntiProduct_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn antiScalar_geometricAntiProduct_plane(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_point(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricAntiProduct_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn antiScalar_geometricAntiProduct_transflector(self_: AntiScalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricAntiProduct_translator(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn dualNum_geometricAntiProduct_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_geometricAntiProduct_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_geometricAntiProduct_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_geometricAntiProduct_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_geometricAntiProduct_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.y * other.g0_);
}

fn dualNum_geometricAntiProduct_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_geometricAntiProduct_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_geometricAntiProduct_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_geometricAntiProduct_motor(self_: DualNum, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn dualNum_geometricAntiProduct_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.x, -other.g4_.y, -other.g4_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_, vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g0_.y) * other.g4_);
}

fn dualNum_geometricAntiProduct_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_);
}

fn dualNum_geometricAntiProduct_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(-other.g2_.x, -other.g2_.y, -other.g2_.z, other.g0_.x), vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g0_.x));
}

fn dualNum_geometricAntiProduct_origin(self_: DualNum, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn dualNum_geometricAntiProduct_plane(self_: DualNum, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_geometricAntiProduct_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn dualNum_geometricAntiProduct_point(self_: DualNum, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w));
}

fn dualNum_geometricAntiProduct_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_geometricAntiProduct_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn dualNum_geometricAntiProduct_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn dualNum_geometricAntiProduct_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_geometricAntiProduct_translator(self_: DualNum, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_geometricAntiProduct_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.y) + self_.g1_.xyzx * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_geometricAntiProduct_flector(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn flector_geometricAntiProduct_horizon(self_: Flector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn flector_geometricAntiProduct_line(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn flector_geometricAntiProduct_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn flector_geometricAntiProduct_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn flector_geometricAntiProduct_motor(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn flector_geometricAntiProduct_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn flector_geometricAntiProduct_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.w) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn flector_geometricAntiProduct_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) - vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g2_.z, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g1_.w) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn flector_geometricAntiProduct_origin(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_plane(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_point(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_geometricAntiProduct_rotor(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g1_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn flector_geometricAntiProduct_scalar(self_: Flector, other: Scalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + self_.g1_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn flector_geometricAntiProduct_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) - vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_geometricAntiProduct_translator(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn flectorAtInfinity_geometricAntiProduct_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_geometricAntiProduct_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn flectorAtInfinity_geometricAntiProduct_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_geometricAntiProduct_line(self_: FlectorAtInfinity, other: Line) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricAntiProduct_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricAntiProduct_motor(self_: FlectorAtInfinity, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_geometricAntiProduct_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g4_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g4_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g4_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn flectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn flectorAtInfinity_geometricAntiProduct_origin(self_: FlectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn flectorAtInfinity_geometricAntiProduct_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flectorAtInfinity_geometricAntiProduct_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_geometricAntiProduct_point(self_: FlectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w));
}

fn flectorAtInfinity_geometricAntiProduct_rotor(self_: FlectorAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_geometricAntiProduct_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_geometricAntiProduct_translator(self_: FlectorAtInfinity, other: Translator) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn horizon_geometricAntiProduct_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn horizon_geometricAntiProduct_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.y);
}

fn horizon_geometricAntiProduct_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_geometricAntiProduct_line(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricAntiProduct_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricAntiProduct_motor(self_: Horizon, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricAntiProduct_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn horizon_geometricAntiProduct_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn horizon_geometricAntiProduct_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn horizon_geometricAntiProduct_plane(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn horizon_geometricAntiProduct_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricAntiProduct_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn horizon_geometricAntiProduct_rotor(self_: Horizon, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricAntiProduct_transflector(self_: Horizon, other: Transflector) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_geometricAntiProduct_translator(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.w);
}

fn line_geometricAntiProduct_antiScalar(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_geometricAntiProduct_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g0_ * vec3<f32>(other.g0_.x) + self_.g1_ * vec3<f32>(other.g0_.y));
}

fn line_geometricAntiProduct_flector(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn line_geometricAntiProduct_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_geometricAntiProduct_horizon(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn line_geometricAntiProduct_line(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn line_geometricAntiProduct_lineAtInfinity(self_: Line, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn line_geometricAntiProduct_lineAtOrigin(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn line_geometricAntiProduct_motor(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn line_geometricAntiProduct_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z));
}

fn line_geometricAntiProduct_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn line_geometricAntiProduct_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.z));
}

fn line_geometricAntiProduct_origin(self_: Line, other: Origin) -> Transflector {
    return Transflector(vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn line_geometricAntiProduct_plane(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn line_geometricAntiProduct_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn line_geometricAntiProduct_point(self_: Line, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_geometricAntiProduct_pointAtInfinity(self_: Line, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn line_geometricAntiProduct_rotor(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn line_geometricAntiProduct_scalar(self_: Line, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn line_geometricAntiProduct_transflector(self_: Line, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn line_geometricAntiProduct_translator(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn lineAtInfinity_geometricAntiProduct_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_geometricAntiProduct_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_geometricAntiProduct_flector(self_: LineAtInfinity, other: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, other.g1_.z));
}

fn lineAtInfinity_geometricAntiProduct_line(self_: LineAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtInfinity_geometricAntiProduct_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtInfinity_geometricAntiProduct_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn lineAtInfinity_geometricAntiProduct_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y));
}

fn lineAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn lineAtInfinity_geometricAntiProduct_origin(self_: LineAtInfinity, other: Origin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_geometricAntiProduct_plane(self_: LineAtInfinity, other: Plane) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn lineAtInfinity_geometricAntiProduct_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn lineAtInfinity_geometricAntiProduct_point(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtInfinity_geometricAntiProduct_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn lineAtInfinity_geometricAntiProduct_transflector(self_: LineAtInfinity, other: Transflector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, other.g1_.z));
}

fn lineAtInfinity_geometricAntiProduct_translator(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_geometricAntiProduct_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_geometricAntiProduct_dualNum(self_: LineAtOrigin, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtOrigin_geometricAntiProduct_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn lineAtOrigin_geometricAntiProduct_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtOrigin_geometricAntiProduct_horizon(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_geometricAntiProduct_line(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_geometricAntiProduct_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtOrigin_geometricAntiProduct_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_geometricAntiProduct_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_geometricAntiProduct_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn lineAtOrigin_geometricAntiProduct_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtOrigin_geometricAntiProduct_origin(self_: LineAtOrigin, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_geometricAntiProduct_plane(self_: LineAtOrigin, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_geometricAntiProduct_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_geometricAntiProduct_point(self_: LineAtOrigin, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtOrigin_geometricAntiProduct_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_geometricAntiProduct_rotor(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtOrigin_geometricAntiProduct_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_geometricAntiProduct_transflector(self_: LineAtOrigin, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_geometricAntiProduct_translator(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_geometricAntiProduct_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_geometricAntiProduct_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x) + self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn motor_geometricAntiProduct_flector(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn motor_geometricAntiProduct_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_geometricAntiProduct_horizon(self_: Motor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn motor_geometricAntiProduct_line(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_geometricAntiProduct_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_);
}

fn motor_geometricAntiProduct_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_geometricAntiProduct_motor(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn motor_geometricAntiProduct_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z));
}

fn motor_geometricAntiProduct_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn motor_geometricAntiProduct_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.z));
}

fn motor_geometricAntiProduct_origin(self_: Motor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn motor_geometricAntiProduct_plane(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn motor_geometricAntiProduct_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn motor_geometricAntiProduct_point(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_geometricAntiProduct_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn motor_geometricAntiProduct_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn motor_geometricAntiProduct_scalar(self_: Motor, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn motor_geometricAntiProduct_transflector(self_: Motor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn motor_geometricAntiProduct_translator(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn multiVector_geometricAntiProduct_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_geometricAntiProduct_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, self_.g1_ * vec4<f32>(other.g0_.y) + self_.g4_.xyzx * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), self_.g2_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.x) + self_.g3_ * vec3<f32>(other.g0_.y), vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_geometricAntiProduct_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn multiVector_geometricAntiProduct_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVector_geometricAntiProduct_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_));
}

fn multiVector_geometricAntiProduct_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVector_geometricAntiProduct_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_geometricAntiProduct_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVector_geometricAntiProduct_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVector_geometricAntiProduct_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g4_.z, 0.0) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g4_.w, other.g1_.w) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.x, -other.g4_.y, -other.g4_.z, 0.0) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g0_.y) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn multiVector_geometricAntiProduct_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.w) * other.g2_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.y) * other.g2_ - vec3<f32>(self_.g1_.w) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn multiVector_geometricAntiProduct_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) - vec2<f32>(self_.g1_.z, self_.g1_.w) * vec2<f32>(other.g2_.z, other.g0_.x) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(-other.g2_.x, -other.g2_.y, -other.g2_.z, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g4_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.y) * other.g1_ - vec3<f32>(self_.g1_.w) * other.g2_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g4_.w) * other.g2_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g4_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn multiVector_geometricAntiProduct_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g3_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn multiVector_geometricAntiProduct_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn multiVector_geometricAntiProduct_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z));
}

fn multiVector_geometricAntiProduct_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g3_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_geometricAntiProduct_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVector_geometricAntiProduct_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g1_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g4_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn multiVector_geometricAntiProduct_scalar(self_: MultiVector, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_), vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVector_geometricAntiProduct_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) - vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z));
}

fn multiVector_geometricAntiProduct_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * other.g0_ + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn multiVectorAtInfinity_geometricAntiProduct_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_geometricAntiProduct_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_geometricAntiProduct_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w));
}

fn multiVectorAtInfinity_geometricAntiProduct_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricAntiProduct_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricAntiProduct_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtInfinity_geometricAntiProduct_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, -other.g1_.w) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.w, other.g0_.y) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g4_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g4_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g4_.z, other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g2_.x, other.g4_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g2_.y, other.g4_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g2_.z, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y));
}

fn multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn multiVectorAtInfinity_geometricAntiProduct_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_geometricAntiProduct_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricAntiProduct_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricAntiProduct_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_.w), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_geometricAntiProduct_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtInfinity_geometricAntiProduct_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn multiVectorAtInfinity_geometricAntiProduct_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_geometricAntiProduct_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_geometricAntiProduct_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), self_.g1_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtOrigin_geometricAntiProduct_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtOrigin_geometricAntiProduct_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVectorAtOrigin_geometricAntiProduct_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_), self_.g1_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_geometricAntiProduct_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtOrigin_geometricAntiProduct_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricAntiProduct_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricAntiProduct_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn multiVectorAtOrigin_geometricAntiProduct_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g4_.w, other.g1_.w) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g0_.y) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z));
}

fn multiVectorAtOrigin_geometricAntiProduct_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g0_.y) * other.g0_ - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn multiVectorAtOrigin_geometricAntiProduct_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_geometricAntiProduct_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVectorAtOrigin_geometricAntiProduct_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricAntiProduct_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtOrigin_geometricAntiProduct_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricAntiProduct_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtOrigin_geometricAntiProduct_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_geometricAntiProduct_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn multiVectorAtOrigin_geometricAntiProduct_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn origin_geometricAntiProduct_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_geometricAntiProduct_dualNum(self_: Origin, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn origin_geometricAntiProduct_flector(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn origin_geometricAntiProduct_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_geometricAntiProduct_horizon(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_geometricAntiProduct_line(self_: Origin, other: Line) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g1_, vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_geometricAntiProduct_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricAntiProduct_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricAntiProduct_motor(self_: Origin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_geometricAntiProduct_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn origin_geometricAntiProduct_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_geometricAntiProduct_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_geometricAntiProduct_origin(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_geometricAntiProduct_plane(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_geometricAntiProduct_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricAntiProduct_point(self_: Origin, other: Point) -> Translator {
    return Translator(vec4<f32>(0.0) - vec4<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricAntiProduct_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricAntiProduct_rotor(self_: Origin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn origin_geometricAntiProduct_scalar(self_: Origin, other: Scalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn origin_geometricAntiProduct_transflector(self_: Origin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(0.0));
}

fn origin_geometricAntiProduct_translator(self_: Origin, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn plane_geometricAntiProduct_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_geometricAntiProduct_dualNum(self_: Plane, other: DualNum) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_geometricAntiProduct_flector(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_geometricAntiProduct_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn plane_geometricAntiProduct_horizon(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn plane_geometricAntiProduct_line(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn plane_geometricAntiProduct_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn plane_geometricAntiProduct_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn plane_geometricAntiProduct_motor(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn plane_geometricAntiProduct_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn plane_geometricAntiProduct_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn plane_geometricAntiProduct_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.w) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn plane_geometricAntiProduct_origin(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_geometricAntiProduct_plane(self_: Plane, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_geometricAntiProduct_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_geometricAntiProduct_point(self_: Plane, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn plane_geometricAntiProduct_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn plane_geometricAntiProduct_rotor(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn plane_geometricAntiProduct_scalar(self_: Plane, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn plane_geometricAntiProduct_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_geometricAntiProduct_translator(self_: Plane, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn planeAtOrigin_geometricAntiProduct_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_geometricAntiProduct_dualNum(self_: PlaneAtOrigin, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn planeAtOrigin_geometricAntiProduct_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_geometricAntiProduct_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn planeAtOrigin_geometricAntiProduct_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_geometricAntiProduct_line(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn planeAtOrigin_geometricAntiProduct_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_geometricAntiProduct_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn planeAtOrigin_geometricAntiProduct_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn planeAtOrigin_geometricAntiProduct_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z));
}

fn planeAtOrigin_geometricAntiProduct_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn planeAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn planeAtOrigin_geometricAntiProduct_origin(self_: PlaneAtOrigin, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_geometricAntiProduct_plane(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_geometricAntiProduct_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn planeAtOrigin_geometricAntiProduct_point(self_: PlaneAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn planeAtOrigin_geometricAntiProduct_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn planeAtOrigin_geometricAntiProduct_rotor(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0));
}

fn planeAtOrigin_geometricAntiProduct_scalar(self_: PlaneAtOrigin, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_geometricAntiProduct_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_geometricAntiProduct_translator(self_: PlaneAtOrigin, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn point_geometricAntiProduct_antiScalar(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_geometricAntiProduct_dualNum(self_: Point, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn point_geometricAntiProduct_flector(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn point_geometricAntiProduct_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn point_geometricAntiProduct_horizon(self_: Point, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_);
}

fn point_geometricAntiProduct_line(self_: Point, other: Line) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_geometricAntiProduct_lineAtInfinity(self_: Point, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn point_geometricAntiProduct_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_geometricAntiProduct_motor(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_geometricAntiProduct_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn point_geometricAntiProduct_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g1_);
}

fn point_geometricAntiProduct_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) - vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g2_.z, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z));
}

fn point_geometricAntiProduct_origin(self_: Point, other: Origin) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_geometricAntiProduct_plane(self_: Point, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_geometricAntiProduct_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_geometricAntiProduct_point(self_: Point, other: Point) -> Translator {
    return Translator(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) - vec4<f32>(self_.g0_.w) * other.g0_);
}

fn point_geometricAntiProduct_pointAtInfinity(self_: Point, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn point_geometricAntiProduct_rotor(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_geometricAntiProduct_scalar(self_: Point, other: Scalar) -> Horizon {
    return Horizon(self_.g0_.w * other.g0_);
}

fn point_geometricAntiProduct_transflector(self_: Point, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) - vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0));
}

fn point_geometricAntiProduct_translator(self_: Point, other: Translator) -> Point {
    return Point(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn pointAtInfinity_geometricAntiProduct_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_geometricAntiProduct_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn pointAtInfinity_geometricAntiProduct_flector(self_: PointAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w));
}

fn pointAtInfinity_geometricAntiProduct_line(self_: PointAtInfinity, other: Line) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn pointAtInfinity_geometricAntiProduct_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn pointAtInfinity_geometricAntiProduct_motor(self_: PointAtInfinity, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn pointAtInfinity_geometricAntiProduct_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g4_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g4_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g4_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w));
}

fn pointAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn pointAtInfinity_geometricAntiProduct_origin(self_: PointAtInfinity, other: Origin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_geometricAntiProduct_plane(self_: PointAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_geometricAntiProduct_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_geometricAntiProduct_point(self_: PointAtInfinity, other: Point) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_geometricAntiProduct_rotor(self_: PointAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn pointAtInfinity_geometricAntiProduct_transflector(self_: PointAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn pointAtInfinity_geometricAntiProduct_translator(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn rotor_geometricAntiProduct_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_geometricAntiProduct_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec4<f32>(0.0));
}

fn rotor_geometricAntiProduct_flector(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_geometricAntiProduct_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_geometricAntiProduct_horizon(self_: Rotor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_geometricAntiProduct_line(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_geometricAntiProduct_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_geometricAntiProduct_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_geometricAntiProduct_motor(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_geometricAntiProduct_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g4_);
}

fn rotor_geometricAntiProduct_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_geometricAntiProduct_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_geometricAntiProduct_origin(self_: Rotor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn rotor_geometricAntiProduct_plane(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_geometricAntiProduct_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_geometricAntiProduct_point(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn rotor_geometricAntiProduct_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_geometricAntiProduct_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_geometricAntiProduct_scalar(self_: Rotor, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn rotor_geometricAntiProduct_transflector(self_: Rotor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_geometricAntiProduct_translator(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn scalar_geometricAntiProduct_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_geometricAntiProduct_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_geometricAntiProduct_flector(self_: Scalar, other: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(0.0) - vec4<f32>(self_.g0_) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w));
}

fn scalar_geometricAntiProduct_line(self_: Scalar, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricAntiProduct_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricAntiProduct_motor(self_: Scalar, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_geometricAntiProduct_multiVector(self_: Scalar, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.y, -other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_geometricAntiProduct_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_geometricAntiProduct_origin(self_: Scalar, other: Origin) -> Horizon {
    return Horizon(0.0 - self_.g0_ * other.g0_);
}

fn scalar_geometricAntiProduct_plane(self_: Scalar, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_geometricAntiProduct_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricAntiProduct_point(self_: Scalar, other: Point) -> Horizon {
    return Horizon(0.0 - self_.g0_ * other.g0_.w);
}

fn scalar_geometricAntiProduct_rotor(self_: Scalar, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn scalar_geometricAntiProduct_transflector(self_: Scalar, other: Transflector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn scalar_geometricAntiProduct_translator(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn transflector_geometricAntiProduct_antiScalar(self_: Transflector, other: AntiScalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_geometricAntiProduct_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_geometricAntiProduct_flector(self_: Transflector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_geometricAntiProduct_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn transflector_geometricAntiProduct_horizon(self_: Transflector, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn transflector_geometricAntiProduct_line(self_: Transflector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn transflector_geometricAntiProduct_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn transflector_geometricAntiProduct_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn transflector_geometricAntiProduct_motor(self_: Transflector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn transflector_geometricAntiProduct_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g4_.z, -other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g4_.z, other.g1_.w, other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g4_.y, -other.g4_.x, other.g1_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn transflector_geometricAntiProduct_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn transflector_geometricAntiProduct_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.x, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g1_.w) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, other.g0_.y));
}

fn transflector_geometricAntiProduct_origin(self_: Transflector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), self_.g0_ * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn transflector_geometricAntiProduct_plane(self_: Transflector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_geometricAntiProduct_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_geometricAntiProduct_point(self_: Transflector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w), self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn transflector_geometricAntiProduct_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn transflector_geometricAntiProduct_rotor(self_: Transflector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g1_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn transflector_geometricAntiProduct_scalar(self_: Transflector, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn transflector_geometricAntiProduct_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_geometricAntiProduct_translator(self_: Transflector, other: Translator) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w));
}

fn translator_geometricAntiProduct_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_geometricAntiProduct_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn translator_geometricAntiProduct_flector(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_geometricAntiProduct_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_geometricAntiProduct_horizon(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.w * other.g0_);
}

fn translator_geometricAntiProduct_line(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_geometricAntiProduct_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_geometricAntiProduct_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn translator_geometricAntiProduct_motor(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_geometricAntiProduct_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g4_);
}

fn translator_geometricAntiProduct_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn translator_geometricAntiProduct_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x, other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g2_.z));
}

fn translator_geometricAntiProduct_origin(self_: Translator, other: Origin) -> Point {
    return Point(self_.g0_ * vec4<f32>(-other.g0_));
}

fn translator_geometricAntiProduct_plane(self_: Translator, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_geometricAntiProduct_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g0_.z));
}

fn translator_geometricAntiProduct_point(self_: Translator, other: Point) -> Point {
    return Point(self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_geometricAntiProduct_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_geometricAntiProduct_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec4<f32>(0.0));
}

fn translator_geometricAntiProduct_scalar(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn translator_geometricAntiProduct_transflector(self_: Translator, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_geometricAntiProduct_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn antiScalar_geometricProduct_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_geometricProduct_flector(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn antiScalar_geometricProduct_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn antiScalar_geometricProduct_horizon(self_: AntiScalar, other: Horizon) -> Origin {
    return Origin(0.0 - self_.g0_ * other.g0_);
}

fn antiScalar_geometricProduct_line(self_: AntiScalar, other: Line) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricProduct_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricProduct_motor(self_: AntiScalar, other: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricProduct_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * vec2<f32>(-other.g4_.w, other.g0_.x), vec3<f32>(self_.g0_) * other.g3_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn antiScalar_geometricProduct_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_geometricProduct_plane(self_: AntiScalar, other: Plane) -> Origin {
    return Origin(0.0 - self_.g0_ * other.g0_.w);
}

fn antiScalar_geometricProduct_point(self_: AntiScalar, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn antiScalar_geometricProduct_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_geometricProduct_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_geometricProduct_transflector(self_: AntiScalar, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn antiScalar_geometricProduct_translator(self_: AntiScalar, other: Translator) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn dualNum_geometricProduct_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn dualNum_geometricProduct_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x));
}

fn dualNum_geometricProduct_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_geometricProduct_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * other.g0_ * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * other.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn dualNum_geometricProduct_horizon(self_: DualNum, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn dualNum_geometricProduct_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_geometricProduct_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_geometricProduct_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_geometricProduct_motor(self_: DualNum, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_geometricProduct_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_, vec3<f32>(self_.g0_.x) * other.g3_, vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0));
}

fn dualNum_geometricProduct_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g0_.y), vec3<f32>(self_.g0_.y) * other.g2_, vec3<f32>(self_.g0_.x) * other.g2_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, other.g0_.y));
}

fn dualNum_geometricProduct_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec3<f32>(self_.g0_.x) * other.g2_);
}

fn dualNum_geometricProduct_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.g0_.x * other.g0_);
}

fn dualNum_geometricProduct_plane(self_: DualNum, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_geometricProduct_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_geometricProduct_point(self_: DualNum, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_geometricProduct_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_geometricProduct_rotor(self_: DualNum, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_geometricProduct_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_geometricProduct_transflector(self_: DualNum, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_geometricProduct_translator(self_: DualNum, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flector_geometricProduct_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn flector_geometricProduct_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g0_.xyzx * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_geometricProduct_flector(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_geometricProduct_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g0_.z, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_geometricProduct_horizon(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn flector_geometricProduct_line(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_geometricProduct_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn flector_geometricProduct_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_geometricProduct_motor(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_geometricProduct_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn flector_geometricProduct_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g1_.z, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g1_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn flector_geometricProduct_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) + vec2<f32>(self_.g1_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) - vec3<f32>(self_.g1_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g1_.w) * other.g1_);
}

fn flector_geometricProduct_origin(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn flector_geometricProduct_plane(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) + vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn flector_geometricProduct_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn flector_geometricProduct_point(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_geometricProduct_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_geometricProduct_rotor(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_geometricProduct_scalar(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_geometricProduct_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_geometricProduct_translator(self_: Flector, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn flectorAtInfinity_geometricProduct_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn flectorAtInfinity_geometricProduct_dualNum(self_: FlectorAtInfinity, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, other.g0_.y), self_.g0_ * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, other.g0_.x));
}

fn flectorAtInfinity_geometricProduct_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flectorAtInfinity_geometricProduct_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flectorAtInfinity_geometricProduct_horizon(self_: FlectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn flectorAtInfinity_geometricProduct_line(self_: FlectorAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricProduct_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricProduct_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricProduct_motor(self_: FlectorAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricProduct_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn flectorAtInfinity_geometricProduct_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g0_.w) * other.g1_);
}

fn flectorAtInfinity_geometricProduct_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) - vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_);
}

fn flectorAtInfinity_geometricProduct_origin(self_: FlectorAtInfinity, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(0.0) - self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_geometricProduct_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(-other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn flectorAtInfinity_geometricProduct_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricProduct_point(self_: FlectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g0_.z, -other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flectorAtInfinity_geometricProduct_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_geometricProduct_rotor(self_: FlectorAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_geometricProduct_scalar(self_: FlectorAtInfinity, other: Scalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_geometricProduct_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0));
}

fn flectorAtInfinity_geometricProduct_translator(self_: FlectorAtInfinity, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn horizon_geometricProduct_antiScalar(self_: Horizon, other: AntiScalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn horizon_geometricProduct_dualNum(self_: Horizon, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn horizon_geometricProduct_flector(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn horizon_geometricProduct_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn horizon_geometricProduct_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_geometricProduct_line(self_: Horizon, other: Line) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g1_, vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_geometricProduct_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricProduct_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricProduct_motor(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_geometricProduct_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn horizon_geometricProduct_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g1_);
}

fn horizon_geometricProduct_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g1_);
}

fn horizon_geometricProduct_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_geometricProduct_plane(self_: Horizon, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_geometricProduct_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricProduct_point(self_: Horizon, other: Point) -> Translator {
    return Translator(vec4<f32>(0.0) - vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricProduct_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_geometricProduct_rotor(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_geometricProduct_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn horizon_geometricProduct_transflector(self_: Horizon, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(0.0));
}

fn horizon_geometricProduct_translator(self_: Horizon, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn line_geometricProduct_antiScalar(self_: Line, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn line_geometricProduct_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.x) + self_.g1_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn line_geometricProduct_flector(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn line_geometricProduct_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_geometricProduct_horizon(self_: Line, other: Horizon) -> Transflector {
    return Transflector(self_.g1_ * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn line_geometricProduct_line(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn line_geometricProduct_lineAtInfinity(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn line_geometricProduct_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn line_geometricProduct_motor(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn line_geometricProduct_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn line_geometricProduct_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn line_geometricProduct_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn line_geometricProduct_origin(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn line_geometricProduct_plane(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn line_geometricProduct_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn line_geometricProduct_point(self_: Line, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_geometricProduct_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_geometricProduct_rotor(self_: Line, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_geometricProduct_scalar(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_geometricProduct_transflector(self_: Line, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn line_geometricProduct_translator(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtInfinity_geometricProduct_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_geometricProduct_dualNum(self_: LineAtInfinity, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_geometricProduct_flector(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_geometricProduct_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtInfinity_geometricProduct_horizon(self_: LineAtInfinity, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_geometricProduct_line(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtInfinity_geometricProduct_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtInfinity_geometricProduct_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtInfinity_geometricProduct_motor(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtInfinity_geometricProduct_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn lineAtInfinity_geometricProduct_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtInfinity_geometricProduct_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtInfinity_geometricProduct_origin(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_geometricProduct_plane(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtInfinity_geometricProduct_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtInfinity_geometricProduct_point(self_: LineAtInfinity, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_geometricProduct_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtInfinity_geometricProduct_rotor(self_: LineAtInfinity, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtInfinity_geometricProduct_scalar(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_geometricProduct_transflector(self_: LineAtInfinity, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn lineAtInfinity_geometricProduct_translator(self_: LineAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_geometricProduct_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtOrigin_geometricProduct_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0));
}

fn lineAtOrigin_geometricProduct_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0));
}

fn lineAtOrigin_geometricProduct_horizon(self_: LineAtOrigin, other: Horizon) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_geometricProduct_line(self_: LineAtOrigin, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z));
}

fn lineAtOrigin_geometricProduct_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_geometricProduct_motor(self_: LineAtOrigin, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z));
}

fn lineAtOrigin_geometricProduct_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g3_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w));
}

fn lineAtOrigin_geometricProduct_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn lineAtOrigin_geometricProduct_plane(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_geometricProduct_point(self_: LineAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_geometricProduct_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_geometricProduct_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_geometricProduct_transflector(self_: LineAtOrigin, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0));
}

fn lineAtOrigin_geometricProduct_translator(self_: LineAtOrigin, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn motor_geometricProduct_antiScalar(self_: Motor, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_geometricProduct_dualNum(self_: Motor, other: DualNum) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_.x) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn motor_geometricProduct_flector(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn motor_geometricProduct_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_geometricProduct_horizon(self_: Motor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0), self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn motor_geometricProduct_line(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn motor_geometricProduct_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_geometricProduct_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn motor_geometricProduct_motor(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn motor_geometricProduct_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn motor_geometricProduct_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn motor_geometricProduct_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn motor_geometricProduct_origin(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_geometricProduct_plane(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn motor_geometricProduct_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn motor_geometricProduct_point(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_geometricProduct_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_geometricProduct_rotor(self_: Motor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_geometricProduct_scalar(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_geometricProduct_transflector(self_: Motor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn motor_geometricProduct_translator(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn multiVector_geometricProduct_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_, 0.0), self_.g3_ * vec3<f32>(other.g0_), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn multiVector_geometricProduct_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.x) + self_.g3_ * vec3<f32>(other.g0_.y), self_.g3_ * vec3<f32>(other.g0_.x), self_.g1_.xyzx * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_geometricProduct_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g4_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn multiVector_geometricProduct_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z, self_.g1_.w) * vec2<f32>(other.g0_.z, other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * other.g0_ * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0), vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * other.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_geometricProduct_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g4_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_) + vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g3_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0), vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn multiVector_geometricProduct_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g4_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_geometricProduct_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVector_geometricProduct_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g4_.w) * other.g0_);
}

fn multiVector_geometricProduct_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_geometricProduct_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g3_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g4_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn multiVector_geometricProduct_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z, self_.g1_.w) * vec2<f32>(other.g1_.z, other.g0_.y) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g4_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.w) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) - vec3<f32>(self_.g4_.w) * other.g1_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g4_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn multiVector_geometricProduct_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g4_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) - vec3<f32>(self_.g4_.w) * other.g2_, vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g4_.w) * other.g1_);
}

fn multiVector_geometricProduct_origin(self_: MultiVector, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_));
}

fn multiVector_geometricProduct_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g4_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) + vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVector_geometricProduct_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g4_.w) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_geometricProduct_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_geometricProduct_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_geometricProduct_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn multiVector_geometricProduct_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_geometricProduct_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g1_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn multiVector_geometricProduct_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * other.g0_, vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_geometricProduct_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), self_.g2_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_geometricProduct_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVectorAtInfinity_geometricProduct_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(-other.g0_), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_geometricProduct_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtInfinity_geometricProduct_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn multiVectorAtInfinity_geometricProduct_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g4_.w, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g3_ - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn multiVectorAtInfinity_geometricProduct_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn multiVectorAtInfinity_geometricProduct_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * other.g0_.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ - vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn multiVectorAtInfinity_geometricProduct_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_geometricProduct_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_geometricProduct_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_geometricProduct_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtInfinity_geometricProduct_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_geometricProduct_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn multiVectorAtInfinity_geometricProduct_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtOrigin_geometricProduct_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_geometricProduct_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w));
}

fn multiVectorAtOrigin_geometricProduct_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVectorAtOrigin_geometricProduct_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g0_), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_geometricProduct_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn multiVectorAtOrigin_geometricProduct_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricProduct_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn multiVectorAtOrigin_geometricProduct_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g4_.w) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.w, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g3_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g3_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g3_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g3_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g3_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g3_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w), vec3<f32>(self_.g0_.x) * other.g3_ - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x));
}

fn multiVectorAtOrigin_geometricProduct_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn multiVectorAtOrigin_geometricProduct_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_geometricProduct_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricProduct_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_geometricProduct_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_geometricProduct_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w));
}

fn multiVectorAtOrigin_geometricProduct_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn origin_geometricProduct_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.g0_ * other.g0_.x);
}

fn origin_geometricProduct_flector(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_geometricProduct_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricProduct_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn origin_geometricProduct_line(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_geometricProduct_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricProduct_motor(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_geometricProduct_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.x, other.g4_.w), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_) * other.g3_);
}

fn origin_geometricProduct_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn origin_geometricProduct_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn origin_geometricProduct_point(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_geometricProduct_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_geometricProduct_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_geometricProduct_transflector(self_: Origin, other: Transflector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_geometricProduct_translator(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_geometricProduct_antiScalar(self_: Plane, other: AntiScalar) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn plane_geometricProduct_dualNum(self_: Plane, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_geometricProduct_flector(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn plane_geometricProduct_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn plane_geometricProduct_horizon(self_: Plane, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_geometricProduct_line(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_geometricProduct_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn plane_geometricProduct_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_geometricProduct_motor(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_geometricProduct_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn plane_geometricProduct_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn plane_geometricProduct_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * other.g1_);
}

fn plane_geometricProduct_origin(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_);
}

fn plane_geometricProduct_plane(self_: Plane, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_geometricProduct_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_geometricProduct_point(self_: Plane, other: Point) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_geometricProduct_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_geometricProduct_rotor(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_geometricProduct_scalar(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_geometricProduct_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0));
}

fn plane_geometricProduct_translator(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn planeAtOrigin_geometricProduct_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_geometricProduct_flector(self_: PlaneAtOrigin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g0_.z));
}

fn planeAtOrigin_geometricProduct_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn planeAtOrigin_geometricProduct_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_geometricProduct_line(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0));
}

fn planeAtOrigin_geometricProduct_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn planeAtOrigin_geometricProduct_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0));
}

fn planeAtOrigin_geometricProduct_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x));
}

fn planeAtOrigin_geometricProduct_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn planeAtOrigin_geometricProduct_plane(self_: PlaneAtOrigin, other: Plane) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_geometricProduct_point(self_: PlaneAtOrigin, other: Point) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_geometricProduct_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_geometricProduct_scalar(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_geometricProduct_transflector(self_: PlaneAtOrigin, other: Transflector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g0_.z));
}

fn planeAtOrigin_geometricProduct_translator(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn point_geometricProduct_antiScalar(self_: Point, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn point_geometricProduct_dualNum(self_: Point, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x), self_.g0_.xyzx * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn point_geometricProduct_flector(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn point_geometricProduct_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w), vec4<f32>(0.0));
}

fn point_geometricProduct_horizon(self_: Point, other: Horizon) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(-other.g0_));
}

fn point_geometricProduct_line(self_: Point, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_geometricProduct_lineAtInfinity(self_: Point, other: LineAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_geometricProduct_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn point_geometricProduct_motor(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_geometricProduct_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0));
}

fn point_geometricProduct_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g1_.z, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z));
}

fn point_geometricProduct_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn point_geometricProduct_origin(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn point_geometricProduct_plane(self_: Point, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w));
}

fn point_geometricProduct_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn point_geometricProduct_point(self_: Point, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_geometricProduct_pointAtInfinity(self_: Point, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_geometricProduct_rotor(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0));
}

fn point_geometricProduct_scalar(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_geometricProduct_transflector(self_: Point, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn point_geometricProduct_translator(self_: Point, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn pointAtInfinity_geometricProduct_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_geometricProduct_dualNum(self_: PointAtInfinity, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn pointAtInfinity_geometricProduct_flector(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn pointAtInfinity_geometricProduct_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn pointAtInfinity_geometricProduct_horizon(self_: PointAtInfinity, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_geometricProduct_line(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn pointAtInfinity_geometricProduct_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn pointAtInfinity_geometricProduct_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn pointAtInfinity_geometricProduct_motor(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn pointAtInfinity_geometricProduct_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z));
}

fn pointAtInfinity_geometricProduct_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn pointAtInfinity_geometricProduct_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn pointAtInfinity_geometricProduct_origin(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_geometricProduct_plane(self_: PointAtInfinity, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_geometricProduct_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn pointAtInfinity_geometricProduct_point(self_: PointAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_geometricProduct_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_geometricProduct_rotor(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0));
}

fn pointAtInfinity_geometricProduct_scalar(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_geometricProduct_transflector(self_: PointAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn pointAtInfinity_geometricProduct_translator(self_: PointAtInfinity, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn rotor_geometricProduct_dualNum(self_: Rotor, other: DualNum) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn rotor_geometricProduct_flector(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_geometricProduct_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_geometricProduct_horizon(self_: Rotor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_), self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn rotor_geometricProduct_line(self_: Rotor, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn rotor_geometricProduct_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_geometricProduct_motor(self_: Rotor, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn rotor_geometricProduct_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g4_.w, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn rotor_geometricProduct_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_geometricProduct_plane(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0));
}

fn rotor_geometricProduct_point(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_geometricProduct_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_geometricProduct_scalar(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_geometricProduct_transflector(self_: Rotor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_geometricProduct_translator(self_: Rotor, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn scalar_geometricProduct_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn scalar_geometricProduct_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_flector(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_geometricProduct_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn scalar_geometricProduct_line(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_geometricProduct_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_motor(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_geometricProduct_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn scalar_geometricProduct_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_geometricProduct_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_geometricProduct_origin(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn scalar_geometricProduct_plane(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_point(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_rotor(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_geometricProduct_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_geometricProduct_transflector(self_: Scalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_geometricProduct_translator(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn transflector_geometricProduct_antiScalar(self_: Transflector, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn transflector_geometricProduct_dualNum(self_: Transflector, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_geometricProduct_flector(self_: Transflector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_geometricProduct_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_geometricProduct_horizon(self_: Transflector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn transflector_geometricProduct_line(self_: Transflector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_geometricProduct_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn transflector_geometricProduct_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_geometricProduct_motor(self_: Transflector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_geometricProduct_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn transflector_geometricProduct_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g1_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn transflector_geometricProduct_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) + vec2<f32>(self_.g1_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) - vec3<f32>(self_.g1_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g1_.w) * other.g1_);
}

fn transflector_geometricProduct_origin(self_: Transflector, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn transflector_geometricProduct_plane(self_: Transflector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) + vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn transflector_geometricProduct_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn transflector_geometricProduct_point(self_: Transflector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_geometricProduct_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_geometricProduct_rotor(self_: Transflector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_geometricProduct_scalar(self_: Transflector, other: Scalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_geometricProduct_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_geometricProduct_translator(self_: Transflector, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn translator_geometricProduct_antiScalar(self_: Translator, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn translator_geometricProduct_dualNum(self_: Translator, other: DualNum) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x));
}

fn translator_geometricProduct_flector(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn translator_geometricProduct_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) - self_.g0_.wwwz * other.g0_.xyzz);
}

fn translator_geometricProduct_horizon(self_: Translator, other: Horizon) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_geometricProduct_line(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn translator_geometricProduct_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn translator_geometricProduct_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn translator_geometricProduct_motor(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn translator_geometricProduct_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g3_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0));
}

fn translator_geometricProduct_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g2_.z, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, -other.g0_.y), vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) - self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g1_.z));
}

fn translator_geometricProduct_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn translator_geometricProduct_origin(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn translator_geometricProduct_plane(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn translator_geometricProduct_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn translator_geometricProduct_point(self_: Translator, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn translator_geometricProduct_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) - self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g0_.z));
}

fn translator_geometricProduct_rotor(self_: Translator, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn translator_geometricProduct_scalar(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_geometricProduct_transflector(self_: Translator, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn translator_geometricProduct_translator(self_: Translator, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn antiScalar_wedgeDot_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_wedgeDot_flector(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn antiScalar_wedgeDot_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn antiScalar_wedgeDot_horizon(self_: AntiScalar, other: Horizon) -> Origin {
    return Origin(0.0 - self_.g0_ * other.g0_);
}

fn antiScalar_wedgeDot_line(self_: AntiScalar, other: Line) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_wedgeDot_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_wedgeDot_motor(self_: AntiScalar, other: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_wedgeDot_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * vec2<f32>(-other.g4_.w, other.g0_.x), vec3<f32>(self_.g0_) * other.g3_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn antiScalar_wedgeDot_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_wedgeDot_plane(self_: AntiScalar, other: Plane) -> Origin {
    return Origin(0.0 - self_.g0_ * other.g0_.w);
}

fn antiScalar_wedgeDot_point(self_: AntiScalar, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn antiScalar_wedgeDot_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_wedgeDot_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_wedgeDot_transflector(self_: AntiScalar, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn antiScalar_wedgeDot_translator(self_: AntiScalar, other: Translator) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn dualNum_wedgeDot_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn dualNum_wedgeDot_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x));
}

fn dualNum_wedgeDot_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_wedgeDot_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * other.g0_ * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * other.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn dualNum_wedgeDot_horizon(self_: DualNum, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn dualNum_wedgeDot_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_wedgeDot_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedgeDot_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedgeDot_motor(self_: DualNum, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_wedgeDot_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_, vec3<f32>(self_.g0_.x) * other.g3_, vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0));
}

fn dualNum_wedgeDot_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g0_.y), vec3<f32>(self_.g0_.y) * other.g2_, vec3<f32>(self_.g0_.x) * other.g2_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, other.g0_.y));
}

fn dualNum_wedgeDot_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec3<f32>(self_.g0_.x) * other.g2_);
}

fn dualNum_wedgeDot_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.g0_.x * other.g0_);
}

fn dualNum_wedgeDot_plane(self_: DualNum, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedgeDot_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedgeDot_point(self_: DualNum, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_wedgeDot_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_wedgeDot_rotor(self_: DualNum, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedgeDot_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_wedgeDot_transflector(self_: DualNum, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn dualNum_wedgeDot_translator(self_: DualNum, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flector_wedgeDot_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn flector_wedgeDot_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g0_.xyzx * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_wedgeDot_flector(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_wedgeDot_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g0_.z, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_wedgeDot_horizon(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn flector_wedgeDot_line(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_wedgeDot_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn flector_wedgeDot_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_wedgeDot_motor(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_wedgeDot_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn flector_wedgeDot_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g1_.z, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g1_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn flector_wedgeDot_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) + vec2<f32>(self_.g1_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) - vec3<f32>(self_.g1_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g1_.w) * other.g1_);
}

fn flector_wedgeDot_origin(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn flector_wedgeDot_plane(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) + vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn flector_wedgeDot_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn flector_wedgeDot_point(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_wedgeDot_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_wedgeDot_rotor(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_wedgeDot_scalar(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_wedgeDot_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_wedgeDot_translator(self_: Flector, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn flectorAtInfinity_wedgeDot_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), self_.g0_.xyzx * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn flectorAtInfinity_wedgeDot_dualNum(self_: FlectorAtInfinity, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, other.g0_.y), self_.g0_ * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, other.g0_.x));
}

fn flectorAtInfinity_wedgeDot_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flectorAtInfinity_wedgeDot_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flectorAtInfinity_wedgeDot_horizon(self_: FlectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn flectorAtInfinity_wedgeDot_line(self_: FlectorAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_wedgeDot_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_wedgeDot_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_wedgeDot_motor(self_: FlectorAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_wedgeDot_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn flectorAtInfinity_wedgeDot_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g0_.w) * other.g1_);
}

fn flectorAtInfinity_wedgeDot_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) - vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_);
}

fn flectorAtInfinity_wedgeDot_origin(self_: FlectorAtInfinity, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(0.0) - self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_wedgeDot_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(-other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn flectorAtInfinity_wedgeDot_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn flectorAtInfinity_wedgeDot_point(self_: FlectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g0_.z, -other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flectorAtInfinity_wedgeDot_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_wedgeDot_rotor(self_: FlectorAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flectorAtInfinity_wedgeDot_scalar(self_: FlectorAtInfinity, other: Scalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_wedgeDot_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0));
}

fn flectorAtInfinity_wedgeDot_translator(self_: FlectorAtInfinity, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn horizon_wedgeDot_antiScalar(self_: Horizon, other: AntiScalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn horizon_wedgeDot_dualNum(self_: Horizon, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn horizon_wedgeDot_flector(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn horizon_wedgeDot_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn horizon_wedgeDot_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_wedgeDot_line(self_: Horizon, other: Line) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g1_, vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_wedgeDot_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_wedgeDot_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_wedgeDot_motor(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_wedgeDot_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn horizon_wedgeDot_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g1_);
}

fn horizon_wedgeDot_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g1_);
}

fn horizon_wedgeDot_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_wedgeDot_plane(self_: Horizon, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_wedgeDot_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_wedgeDot_point(self_: Horizon, other: Point) -> Translator {
    return Translator(vec4<f32>(0.0) - vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_wedgeDot_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_wedgeDot_rotor(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn horizon_wedgeDot_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn horizon_wedgeDot_transflector(self_: Horizon, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g1_.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(0.0));
}

fn horizon_wedgeDot_translator(self_: Horizon, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn line_wedgeDot_antiScalar(self_: Line, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn line_wedgeDot_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.x) + self_.g1_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn line_wedgeDot_flector(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn line_wedgeDot_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_wedgeDot_horizon(self_: Line, other: Horizon) -> Transflector {
    return Transflector(self_.g1_ * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn line_wedgeDot_line(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn line_wedgeDot_lineAtInfinity(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn line_wedgeDot_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn line_wedgeDot_motor(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn line_wedgeDot_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn line_wedgeDot_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn line_wedgeDot_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn line_wedgeDot_origin(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn line_wedgeDot_plane(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn line_wedgeDot_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn line_wedgeDot_point(self_: Line, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_wedgeDot_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_wedgeDot_rotor(self_: Line, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_wedgeDot_scalar(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_wedgeDot_transflector(self_: Line, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn line_wedgeDot_translator(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtInfinity_wedgeDot_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_wedgeDot_dualNum(self_: LineAtInfinity, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_wedgeDot_flector(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_wedgeDot_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtInfinity_wedgeDot_horizon(self_: LineAtInfinity, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_wedgeDot_line(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtInfinity_wedgeDot_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn lineAtInfinity_wedgeDot_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtInfinity_wedgeDot_motor(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtInfinity_wedgeDot_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn lineAtInfinity_wedgeDot_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtInfinity_wedgeDot_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn lineAtInfinity_wedgeDot_origin(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_wedgeDot_plane(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtInfinity_wedgeDot_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn lineAtInfinity_wedgeDot_point(self_: LineAtInfinity, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_wedgeDot_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtInfinity_wedgeDot_rotor(self_: LineAtInfinity, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn lineAtInfinity_wedgeDot_scalar(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_wedgeDot_transflector(self_: LineAtInfinity, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn lineAtInfinity_wedgeDot_translator(self_: LineAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_wedgeDot_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtOrigin_wedgeDot_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0));
}

fn lineAtOrigin_wedgeDot_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0));
}

fn lineAtOrigin_wedgeDot_horizon(self_: LineAtOrigin, other: Horizon) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_wedgeDot_line(self_: LineAtOrigin, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z));
}

fn lineAtOrigin_wedgeDot_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn lineAtOrigin_wedgeDot_motor(self_: LineAtOrigin, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z));
}

fn lineAtOrigin_wedgeDot_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g3_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w));
}

fn lineAtOrigin_wedgeDot_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn lineAtOrigin_wedgeDot_plane(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_wedgeDot_point(self_: LineAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_wedgeDot_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn lineAtOrigin_wedgeDot_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_wedgeDot_transflector(self_: LineAtOrigin, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0));
}

fn lineAtOrigin_wedgeDot_translator(self_: LineAtOrigin, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn motor_wedgeDot_antiScalar(self_: Motor, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_wedgeDot_dualNum(self_: Motor, other: DualNum) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_.x) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn motor_wedgeDot_flector(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn motor_wedgeDot_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_wedgeDot_horizon(self_: Motor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0), self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn motor_wedgeDot_line(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn motor_wedgeDot_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn motor_wedgeDot_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn motor_wedgeDot_motor(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn motor_wedgeDot_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn motor_wedgeDot_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn motor_wedgeDot_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g1_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g1_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g1_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn motor_wedgeDot_origin(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_wedgeDot_plane(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn motor_wedgeDot_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn motor_wedgeDot_point(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_wedgeDot_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_wedgeDot_rotor(self_: Motor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_wedgeDot_scalar(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_wedgeDot_transflector(self_: Motor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn motor_wedgeDot_translator(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn multiVector_wedgeDot_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_, 0.0), self_.g3_ * vec3<f32>(other.g0_), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn multiVector_wedgeDot_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x) + vec4<f32>(self_.g4_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.x) + self_.g3_ * vec3<f32>(other.g0_.y), self_.g3_ * vec3<f32>(other.g0_.x), self_.g1_.xyzx * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_wedgeDot_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g4_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn multiVector_wedgeDot_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z, self_.g1_.w) * vec2<f32>(other.g0_.z, other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * other.g0_ * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0), vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * other.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_wedgeDot_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g4_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_) + vec4<f32>(self_.g3_.x, self_.g3_.y, self_.g3_.z, self_.g3_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0), vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_) + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn multiVector_wedgeDot_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g4_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_wedgeDot_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVector_wedgeDot_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g4_.w) * other.g0_);
}

fn multiVector_wedgeDot_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_wedgeDot_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g3_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g4_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn multiVector_wedgeDot_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z, self_.g1_.w) * vec2<f32>(other.g1_.z, other.g0_.y) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g4_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.w) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) - vec3<f32>(self_.g4_.w) * other.g1_, vec4<f32>(self_.g0_.y, self_.g0_.y, self_.g0_.y, self_.g0_.x) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g4_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g4_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn multiVector_wedgeDot_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) - vec2<f32>(self_.g3_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g3_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g3_.z) * vec2<f32>(other.g2_.z, other.g1_.z) + vec2<f32>(self_.g4_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) - vec3<f32>(self_.g4_.w) * other.g2_, vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g4_.w) * other.g1_);
}

fn multiVector_wedgeDot_origin(self_: MultiVector, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_));
}

fn multiVector_wedgeDot_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g4_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) + vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVector_wedgeDot_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g4_.w) * other.g0_, vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_wedgeDot_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_wedgeDot_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_wedgeDot_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g3_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn multiVector_wedgeDot_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_wedgeDot_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g4_.w, self_.g4_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.x, self_.g0_.x, self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g1_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g1_.w) * other.g0_ + vec3<f32>(self_.g4_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn multiVector_wedgeDot_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * other.g0_, vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g3_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g3_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g3_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_wedgeDot_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), self_.g2_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.w, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_wedgeDot_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVectorAtInfinity_wedgeDot_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx * vec2<f32>(-other.g0_), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_wedgeDot_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtInfinity_wedgeDot_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn multiVectorAtInfinity_wedgeDot_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g4_.w, other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, other.g4_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g3_.z, other.g2_.z), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g3_ - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z));
}

fn multiVectorAtInfinity_wedgeDot_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn multiVectorAtInfinity_wedgeDot_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * other.g0_.yx * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ - vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn multiVectorAtInfinity_wedgeDot_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_wedgeDot_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_wedgeDot_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedgeDot_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w));
}

fn multiVectorAtInfinity_wedgeDot_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_wedgeDot_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn multiVectorAtInfinity_wedgeDot_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtOrigin_wedgeDot_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_wedgeDot_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w));
}

fn multiVectorAtOrigin_wedgeDot_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn multiVectorAtOrigin_wedgeDot_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g0_), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_wedgeDot_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn multiVectorAtOrigin_wedgeDot_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedgeDot_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn multiVectorAtOrigin_wedgeDot_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g4_.w) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.w, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g3_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g3_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g3_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g3_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g3_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g3_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g0_.y) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w), vec3<f32>(self_.g0_.x) * other.g3_ - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x));
}

fn multiVectorAtOrigin_wedgeDot_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * other.g0_.yx * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) - vec2<f32>(self_.g2_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g2_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g2_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + vec3<f32>(self_.g0_.y) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g0_.y) * other.g1_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn multiVectorAtOrigin_wedgeDot_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_wedgeDot_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedgeDot_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedgeDot_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_wedgeDot_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_ + vec3<f32>(self_.g2_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.y) * other.g0_ + vec3<f32>(self_.g1_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w));
}

fn multiVectorAtOrigin_wedgeDot_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn origin_wedgeDot_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.g0_ * other.g0_.x);
}

fn origin_wedgeDot_flector(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_wedgeDot_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn origin_wedgeDot_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn origin_wedgeDot_line(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_wedgeDot_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_wedgeDot_motor(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_wedgeDot_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.x, other.g4_.w), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_) * other.g3_);
}

fn origin_wedgeDot_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn origin_wedgeDot_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn origin_wedgeDot_point(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_wedgeDot_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_wedgeDot_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_wedgeDot_transflector(self_: Origin, other: Transflector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_wedgeDot_translator(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_wedgeDot_antiScalar(self_: Plane, other: AntiScalar) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn plane_wedgeDot_dualNum(self_: Plane, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_wedgeDot_flector(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn plane_wedgeDot_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn plane_wedgeDot_horizon(self_: Plane, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_wedgeDot_line(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_wedgeDot_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn plane_wedgeDot_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_wedgeDot_motor(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_wedgeDot_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g0_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn plane_wedgeDot_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn plane_wedgeDot_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * other.g1_);
}

fn plane_wedgeDot_origin(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_);
}

fn plane_wedgeDot_plane(self_: Plane, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_wedgeDot_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_wedgeDot_point(self_: Plane, other: Point) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_wedgeDot_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_wedgeDot_rotor(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_wedgeDot_scalar(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_wedgeDot_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g0_.w, self_.g0_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0));
}

fn plane_wedgeDot_translator(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn planeAtOrigin_wedgeDot_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_wedgeDot_flector(self_: PlaneAtOrigin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g0_.z));
}

fn planeAtOrigin_wedgeDot_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn planeAtOrigin_wedgeDot_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_wedgeDot_line(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0));
}

fn planeAtOrigin_wedgeDot_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn planeAtOrigin_wedgeDot_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0));
}

fn planeAtOrigin_wedgeDot_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x));
}

fn planeAtOrigin_wedgeDot_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn planeAtOrigin_wedgeDot_plane(self_: PlaneAtOrigin, other: Plane) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_wedgeDot_point(self_: PlaneAtOrigin, other: Point) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_wedgeDot_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_wedgeDot_scalar(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_wedgeDot_transflector(self_: PlaneAtOrigin, other: Transflector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g0_.z));
}

fn planeAtOrigin_wedgeDot_translator(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn point_wedgeDot_antiScalar(self_: Point, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn point_wedgeDot_dualNum(self_: Point, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x), self_.g0_.xyzx * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn point_wedgeDot_flector(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn point_wedgeDot_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w), vec4<f32>(0.0));
}

fn point_wedgeDot_horizon(self_: Point, other: Horizon) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(-other.g0_));
}

fn point_wedgeDot_line(self_: Point, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_wedgeDot_lineAtInfinity(self_: Point, other: LineAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_wedgeDot_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn point_wedgeDot_motor(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_wedgeDot_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0));
}

fn point_wedgeDot_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(other.g1_.z, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z));
}

fn point_wedgeDot_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn point_wedgeDot_origin(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn point_wedgeDot_plane(self_: Point, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w));
}

fn point_wedgeDot_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn point_wedgeDot_point(self_: Point, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_wedgeDot_pointAtInfinity(self_: Point, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn point_wedgeDot_rotor(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0));
}

fn point_wedgeDot_scalar(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_wedgeDot_transflector(self_: Point, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g1_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn point_wedgeDot_translator(self_: Point, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn pointAtInfinity_wedgeDot_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_wedgeDot_dualNum(self_: PointAtInfinity, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn pointAtInfinity_wedgeDot_flector(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn pointAtInfinity_wedgeDot_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w));
}

fn pointAtInfinity_wedgeDot_horizon(self_: PointAtInfinity, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_wedgeDot_line(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn pointAtInfinity_wedgeDot_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn pointAtInfinity_wedgeDot_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn pointAtInfinity_wedgeDot_motor(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z));
}

fn pointAtInfinity_wedgeDot_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z));
}

fn pointAtInfinity_wedgeDot_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y));
}

fn pointAtInfinity_wedgeDot_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y));
}

fn pointAtInfinity_wedgeDot_origin(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_wedgeDot_plane(self_: PointAtInfinity, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_wedgeDot_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z));
}

fn pointAtInfinity_wedgeDot_point(self_: PointAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn pointAtInfinity_wedgeDot_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_wedgeDot_rotor(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0));
}

fn pointAtInfinity_wedgeDot_scalar(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_wedgeDot_transflector(self_: PointAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w), vec4<f32>(0.0));
}

fn pointAtInfinity_wedgeDot_translator(self_: PointAtInfinity, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn rotor_wedgeDot_dualNum(self_: Rotor, other: DualNum) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn rotor_wedgeDot_flector(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_wedgeDot_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_wedgeDot_horizon(self_: Rotor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_), self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0));
}

fn rotor_wedgeDot_line(self_: Rotor, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn rotor_wedgeDot_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_wedgeDot_motor(self_: Rotor, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn rotor_wedgeDot_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g4_.w, other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g3_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn rotor_wedgeDot_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, -other.g2_.z) + vec2<f32>(self_.g0_.w) * other.g0_.yx * vec2<f32>(-1.0, 1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_wedgeDot_plane(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0));
}

fn rotor_wedgeDot_point(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_wedgeDot_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_wedgeDot_scalar(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_wedgeDot_transflector(self_: Rotor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn rotor_wedgeDot_translator(self_: Rotor, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn scalar_wedgeDot_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn scalar_wedgeDot_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_flector(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedgeDot_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn scalar_wedgeDot_line(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedgeDot_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_motor(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedgeDot_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn scalar_wedgeDot_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_wedgeDot_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_wedgeDot_origin(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn scalar_wedgeDot_plane(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_point(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_rotor(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedgeDot_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_wedgeDot_transflector(self_: Scalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedgeDot_translator(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn transflector_wedgeDot_antiScalar(self_: Transflector, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_, other.g0_, other.g0_, 0.0));
}

fn transflector_wedgeDot_dualNum(self_: Transflector, other: DualNum) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_wedgeDot_flector(self_: Transflector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_wedgeDot_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g0_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_wedgeDot_horizon(self_: Transflector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_), vec4<f32>(0.0));
}

fn transflector_wedgeDot_line(self_: Transflector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_wedgeDot_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn transflector_wedgeDot_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_wedgeDot_motor(self_: Transflector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_wedgeDot_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g4_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) - vec2<f32>(self_.g1_.w) * vec2<f32>(other.g4_.w, other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, -other.g1_.w, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, -other.g1_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g4_.w, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g4_.w, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g4_.w, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g4_.w, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g4_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.y, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.y, -other.g3_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g3_.z, -other.g3_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, other.g0_.x, other.g3_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, other.g0_.x));
}

fn transflector_wedgeDot_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g0_.y, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.y, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, -other.g0_.y, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, -other.g0_.y) - vec3<f32>(self_.g1_.w) * other.g1_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.x, other.g2_.z, -other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, other.g0_.x, other.g2_.x, 0.0) + self_.g1_.zzzw * vec4<f32>(other.g2_.y, -other.g2_.x, other.g0_.x, other.g0_.x));
}

fn transflector_wedgeDot_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, other.g2_.z) + vec2<f32>(self_.g1_.w) * other.g0_.yx * vec2<f32>(1.0, -1.0), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g0_.x, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, -other.g0_.x, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, -other.g0_.x) - vec3<f32>(self_.g1_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y) + vec3<f32>(self_.g1_.w) * other.g1_);
}

fn transflector_wedgeDot_origin(self_: Transflector, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn transflector_wedgeDot_plane(self_: Transflector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) + vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn transflector_wedgeDot_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn transflector_wedgeDot_point(self_: Transflector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_wedgeDot_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_wedgeDot_rotor(self_: Transflector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_wedgeDot_scalar(self_: Transflector, other: Scalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_wedgeDot_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, other.g1_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) - vec2<f32>(self_.g1_.w, self_.g1_.z) * vec2<f32>(other.g1_.w, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g1_.x) * vec3<f32>(other.g1_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, other.g1_.w, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g1_.w) - vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(-other.g1_.w, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, -other.g1_.w, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, -other.g1_.w) - vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_wedgeDot_translator(self_: Transflector, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn translator_wedgeDot_antiScalar(self_: Translator, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn translator_wedgeDot_dualNum(self_: Translator, other: DualNum) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x));
}

fn translator_wedgeDot_flector(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.w, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn translator_wedgeDot_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g0_.w, other.g0_.x, 0.0) + self_.g0_.zzzw * other.g0_.yxww * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) - self_.g0_.wwwz * other.g0_.xyzz);
}

fn translator_wedgeDot_horizon(self_: Translator, other: Horizon) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_wedgeDot_line(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn translator_wedgeDot_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn translator_wedgeDot_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g0_.z));
}

fn translator_wedgeDot_motor(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, other.g0_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, other.g0_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.w, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, other.g0_.w, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, other.g0_.w) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0), vec4<f32>(0.0));
}

fn translator_wedgeDot_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g3_.x, other.g2_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g3_.y, other.g2_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g3_.z, other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, other.g1_.z, -other.g1_.y, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g4_.w, other.g1_.x, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g4_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.y, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g3_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g3_.z, -other.g3_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g3_.z, other.g0_.x, other.g3_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g3_.y, -other.g3_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g4_.z, -other.g4_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g4_.z, other.g1_.w, other.g4_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g4_.y, -other.g4_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g1_.x, -other.g1_.y, -other.g1_.z, 0.0));
}

fn translator_wedgeDot_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g2_.z, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.y, other.g1_.z, -other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, other.g0_.y, other.g1_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(other.g1_.y, -other.g1_.x, other.g0_.y, -other.g0_.y), vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) - self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, other.g1_.z));
}

fn translator_wedgeDot_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(0.0) - vec2<f32>(self_.g0_.x) * vec2<f32>(other.g2_.x, other.g1_.x) - vec2<f32>(self_.g0_.y) * vec2<f32>(other.g2_.y, other.g1_.y) - vec2<f32>(self_.g0_.z) * vec2<f32>(other.g2_.z, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.y, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, other.g0_.y, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, other.g0_.y), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, other.g0_.x, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, other.g0_.x));
}

fn translator_wedgeDot_origin(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn translator_wedgeDot_plane(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn translator_wedgeDot_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0));
}

fn translator_wedgeDot_point(self_: Translator, other: Point) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn translator_wedgeDot_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) - self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g0_.z));
}

fn translator_wedgeDot_rotor(self_: Translator, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0_.y) * other.g0_.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0_.z) * other.g0_.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn translator_wedgeDot_scalar(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_wedgeDot_transflector(self_: Translator, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, other.g1_.w, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(-other.g0_.x, -other.g0_.y, -other.g0_.z, 0.0));
}

fn translator_wedgeDot_translator(self_: Translator, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(0.0));
}

fn antiScalar_antiWedge_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedge_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_flector(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedge_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedge_line(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedge_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_motor(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedge_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn antiScalar_antiWedge_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_antiWedge_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_antiWedge_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedge_plane(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_point(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_antiWedge_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn antiScalar_antiWedge_transflector(self_: AntiScalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_antiWedge_translator(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn dualNum_antiWedge_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_antiWedge_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_antiWedge_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.y * other.g0_);
}

fn dualNum_antiWedge_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_antiWedge_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_motor(self_: DualNum, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn dualNum_antiWedge_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_, vec3<f32>(self_.g0_.y) * other.g3_, vec4<f32>(self_.g0_.y) * other.g4_);
}

fn dualNum_antiWedge_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_);
}

fn dualNum_antiWedge_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn dualNum_antiWedge_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.g0_.y * other.g0_);
}

fn dualNum_antiWedge_plane(self_: DualNum, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_point(self_: DualNum, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_antiWedge_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_antiWedge_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn dualNum_antiWedge_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_antiWedge_translator(self_: DualNum, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_antiWedge_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_antiWedge_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.y), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_antiWedge_flector(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_antiWedge_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w));
}

fn flector_antiWedge_horizon(self_: Flector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn flector_antiWedge_line(self_: Flector, other: Line) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_antiWedge_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flector_antiWedge_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn flector_antiWedge_motor(self_: Flector, other: Motor) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn flector_antiWedge_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g4_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), self_.g0_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_antiWedge_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.y));
}

fn flector_antiWedge_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.x, 0.0), self_.g0_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g2_, self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_antiWedge_origin(self_: Flector, other: Origin) -> Scalar {
    return Scalar(self_.g1_.w * other.g0_);
}

fn flector_antiWedge_plane(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_antiWedge_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_antiWedge_point(self_: Flector, other: Point) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z + self_.g1_.w * other.g0_.w);
}

fn flector_antiWedge_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn flector_antiWedge_rotor(self_: Flector, other: Rotor) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn flector_antiWedge_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_antiWedge_translator(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn flectorAtInfinity_antiWedge_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_antiWedge_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn flectorAtInfinity_antiWedge_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_antiWedge_line(self_: FlectorAtInfinity, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedge_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedge_motor(self_: FlectorAtInfinity, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedge_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn flectorAtInfinity_antiWedge_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn flectorAtInfinity_antiWedge_origin(self_: FlectorAtInfinity, other: Origin) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn flectorAtInfinity_antiWedge_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flectorAtInfinity_antiWedge_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedge_point(self_: FlectorAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_.w);
}

fn flectorAtInfinity_antiWedge_rotor(self_: FlectorAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_antiWedge_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_antiWedge_translator(self_: FlectorAtInfinity, other: Translator) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn horizon_antiWedge_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn horizon_antiWedge_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.y);
}

fn horizon_antiWedge_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_antiWedge_line(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedge_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedge_motor(self_: Horizon, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedge_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn horizon_antiWedge_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn horizon_antiWedge_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn horizon_antiWedge_plane(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn horizon_antiWedge_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedge_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn horizon_antiWedge_rotor(self_: Horizon, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_antiWedge_transflector(self_: Horizon, other: Transflector) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_antiWedge_translator(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.w);
}

fn line_antiWedge_antiScalar(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_antiWedge_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y));
}

fn line_antiWedge_flector(self_: Line, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0));
}

fn line_antiWedge_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn line_antiWedge_horizon(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn line_antiWedge_line(self_: Line, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_antiWedge_lineAtInfinity(self_: Line, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_antiWedge_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_antiWedge_motor(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn line_antiWedge_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn line_antiWedge_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn line_antiWedge_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn line_antiWedge_plane(self_: Line, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn line_antiWedge_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn line_antiWedge_rotor(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn line_antiWedge_transflector(self_: Line, other: Transflector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0));
}

fn line_antiWedge_translator(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn lineAtInfinity_antiWedge_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_antiWedge_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_antiWedge_flector(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtInfinity_antiWedge_line(self_: LineAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_antiWedge_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_antiWedge_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtInfinity_antiWedge_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_antiWedge_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_antiWedge_plane(self_: LineAtInfinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtInfinity_antiWedge_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtInfinity_antiWedge_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtInfinity_antiWedge_transflector(self_: LineAtInfinity, other: Transflector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtInfinity_antiWedge_translator(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_antiWedge_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_antiWedge_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtOrigin_antiWedge_flector(self_: LineAtOrigin, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn lineAtOrigin_antiWedge_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_antiWedge_horizon(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_antiWedge_line(self_: LineAtOrigin, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_antiWedge_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_antiWedge_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_antiWedge_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_antiWedge_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn lineAtOrigin_antiWedge_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn lineAtOrigin_antiWedge_plane(self_: LineAtOrigin, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtOrigin_antiWedge_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_antiWedge_rotor(self_: LineAtOrigin, other: Rotor) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_antiWedge_transflector(self_: LineAtOrigin, other: Transflector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn lineAtOrigin_antiWedge_translator(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn motor_antiWedge_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_antiWedge_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn motor_antiWedge_flector(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * other.g1_);
}

fn motor_antiWedge_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedge_horizon(self_: Motor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn motor_antiWedge_line(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn motor_antiWedge_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedge_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn motor_antiWedge_motor(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.w) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn motor_antiWedge_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * other.g3_ + self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * other.g4_);
}

fn motor_antiWedge_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn motor_antiWedge_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn motor_antiWedge_origin(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn motor_antiWedge_plane(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedge_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn motor_antiWedge_point(self_: Motor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedge_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn motor_antiWedge_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn motor_antiWedge_scalar(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn motor_antiWedge_transflector(self_: Motor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * other.g1_);
}

fn motor_antiWedge_translator(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn multiVector_antiWedge_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_antiWedge_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, self_.g1_ * vec4<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.y), self_.g3_ * vec3<f32>(other.g0_.y), self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_antiWedge_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVector_antiWedge_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w));
}

fn multiVector_antiWedge_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_));
}

fn multiVector_antiWedge_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn multiVector_antiWedge_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVector_antiWedge_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVector_antiWedge_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g3_ * vec3<f32>(other.g0_.w), self_.g4_ * vec4<f32>(other.g0_.w));
}

fn multiVector_antiWedge_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g4_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g2_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g3_ + self_.g3_ * vec3<f32>(other.g0_.y) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.y) * other.g4_ + self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_antiWedge_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g2_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.y));
}

fn multiVector_antiWedge_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + self_.g1_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g4_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g2_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), self_.g3_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.w) * other.g2_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0) + self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_antiWedge_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVector_antiWedge_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * other.g0_);
}

fn multiVector_antiWedge_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_antiWedge_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVector_antiWedge_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVector_antiWedge_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g2_ * vec3<f32>(other.g0_.w), self_.g3_ * vec3<f32>(other.g0_.w), self_.g4_ * vec4<f32>(other.g0_.w));
}

fn multiVector_antiWedge_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn multiVector_antiWedge_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVector_antiWedge_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g3_ * vec3<f32>(other.g0_.w), self_.g4_ * vec4<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_antiWedge_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_antiWedge_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_antiWedge_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn multiVectorAtInfinity_antiWedge_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtInfinity_antiWedge_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtInfinity_antiWedge_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_antiWedge_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.w, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g2_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_antiWedge_origin(self_: MultiVectorAtInfinity, other: Origin) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn multiVectorAtInfinity_antiWedge_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn multiVectorAtInfinity_antiWedge_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtInfinity_antiWedge_point(self_: MultiVectorAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_.w);
}

fn multiVectorAtInfinity_antiWedge_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_antiWedge_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn multiVectorAtInfinity_antiWedge_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_antiWedge_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_antiWedge_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtOrigin_antiWedge_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVectorAtOrigin_antiWedge_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_antiWedge_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_), self_.g1_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_antiWedge_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn multiVectorAtOrigin_antiWedge_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtOrigin_antiWedge_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtOrigin_antiWedge_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn multiVectorAtOrigin_antiWedge_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.w, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g3_ - self_.g2_ * vec3<f32>(other.g4_.w), vec4<f32>(self_.g0_.y) * other.g4_ + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ - self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtOrigin_antiWedge_origin(self_: MultiVectorAtOrigin, other: Origin) -> Origin {
    return Origin(self_.g0_.y * other.g0_);
}

fn multiVectorAtOrigin_antiWedge_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtOrigin_antiWedge_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtOrigin_antiWedge_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVectorAtOrigin_antiWedge_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtOrigin_antiWedge_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_antiWedge_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn multiVectorAtOrigin_antiWedge_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVectorAtOrigin_antiWedge_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn origin_antiWedge_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_antiWedge_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.g0_ * other.g0_.y);
}

fn origin_antiWedge_flector(self_: Origin, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g1_.w);
}

fn origin_antiWedge_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.w);
}

fn origin_antiWedge_horizon(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_antiWedge_motor(self_: Origin, other: Motor) -> Origin {
    return Origin(self_.g0_ * other.g0_.w);
}

fn origin_antiWedge_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g4_.w, 0.0), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_antiWedge_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.y);
}

fn origin_antiWedge_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> Origin {
    return Origin(self_.g0_ * other.g0_.y);
}

fn origin_antiWedge_plane(self_: Origin, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.w);
}

fn origin_antiWedge_rotor(self_: Origin, other: Rotor) -> Origin {
    return Origin(self_.g0_ * other.g0_.w);
}

fn origin_antiWedge_transflector(self_: Origin, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g1_.w);
}

fn origin_antiWedge_translator(self_: Origin, other: Translator) -> Origin {
    return Origin(self_.g0_ * other.g0_.w);
}

fn plane_antiWedge_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_antiWedge_dualNum(self_: Plane, other: DualNum) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_antiWedge_flector(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_antiWedge_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w));
}

fn plane_antiWedge_horizon(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn plane_antiWedge_line(self_: Plane, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_antiWedge_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn plane_antiWedge_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn plane_antiWedge_motor(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_ * vec4<f32>(other.g0_.w));
}

fn plane_antiWedge_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_antiWedge_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y));
}

fn plane_antiWedge_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g0_.w) * other.g2_, self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_antiWedge_origin(self_: Plane, other: Origin) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn plane_antiWedge_plane(self_: Plane, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_antiWedge_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_antiWedge_point(self_: Plane, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn plane_antiWedge_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn plane_antiWedge_rotor(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g0_ * vec4<f32>(other.g0_.w));
}

fn plane_antiWedge_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_antiWedge_translator(self_: Plane, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), self_.g0_ * vec4<f32>(other.g0_.w));
}

fn planeAtOrigin_antiWedge_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_antiWedge_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn planeAtOrigin_antiWedge_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_antiWedge_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_antiWedge_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_antiWedge_line(self_: PlaneAtOrigin, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_antiWedge_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn planeAtOrigin_antiWedge_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_antiWedge_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn planeAtOrigin_antiWedge_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g4_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn planeAtOrigin_antiWedge_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.y));
}

fn planeAtOrigin_antiWedge_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), self_.g0_ * vec3<f32>(other.g0_.y));
}

fn planeAtOrigin_antiWedge_plane(self_: PlaneAtOrigin, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_antiWedge_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn planeAtOrigin_antiWedge_point(self_: PlaneAtOrigin, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_antiWedge_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_antiWedge_rotor(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn planeAtOrigin_antiWedge_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_antiWedge_translator(self_: PlaneAtOrigin, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn point_antiWedge_antiScalar(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_antiWedge_dualNum(self_: Point, other: DualNum) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn point_antiWedge_flector(self_: Point, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g0_.w * other.g1_.w);
}

fn point_antiWedge_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn point_antiWedge_horizon(self_: Point, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_);
}

fn point_antiWedge_motor(self_: Point, other: Motor) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn point_antiWedge_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g4_.w, 0.0), self_.g0_ * vec4<f32>(other.g0_.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_antiWedge_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.y);
}

fn point_antiWedge_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec4<f32>(other.g0_.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_antiWedge_plane(self_: Point, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn point_antiWedge_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn point_antiWedge_rotor(self_: Point, other: Rotor) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn point_antiWedge_transflector(self_: Point, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g0_.w * other.g1_.w);
}

fn point_antiWedge_translator(self_: Point, other: Translator) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn pointAtInfinity_antiWedge_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_antiWedge_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn pointAtInfinity_antiWedge_flector(self_: PointAtInfinity, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn pointAtInfinity_antiWedge_motor(self_: PointAtInfinity, other: Motor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_antiWedge_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn pointAtInfinity_antiWedge_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn pointAtInfinity_antiWedge_plane(self_: PointAtInfinity, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_antiWedge_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_antiWedge_rotor(self_: PointAtInfinity, other: Rotor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_antiWedge_transflector(self_: PointAtInfinity, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn pointAtInfinity_antiWedge_translator(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn rotor_antiWedge_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_antiWedge_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_antiWedge_flector(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_antiWedge_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_horizon(self_: Rotor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_antiWedge_line(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_antiWedge_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_motor(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_antiWedge_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.w) * other.g4_);
}

fn rotor_antiWedge_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_antiWedge_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_antiWedge_origin(self_: Rotor, other: Origin) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn rotor_antiWedge_plane(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_antiWedge_point(self_: Rotor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_antiWedge_scalar(self_: Rotor, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn rotor_antiWedge_transflector(self_: Rotor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_antiWedge_translator(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn scalar_antiWedge_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_antiWedge_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_antiWedge_motor(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn scalar_antiWedge_multiVector(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_antiWedge_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_antiWedge_rotor(self_: Scalar, other: Rotor) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn scalar_antiWedge_translator(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn transflector_antiWedge_antiScalar(self_: Transflector, other: AntiScalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_antiWedge_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_antiWedge_flector(self_: Transflector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_antiWedge_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w));
}

fn transflector_antiWedge_horizon(self_: Transflector, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn transflector_antiWedge_line(self_: Transflector, other: Line) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_antiWedge_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn transflector_antiWedge_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn transflector_antiWedge_motor(self_: Transflector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn transflector_antiWedge_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_antiWedge_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.y));
}

fn transflector_antiWedge_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g2_, self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_antiWedge_origin(self_: Transflector, other: Origin) -> Scalar {
    return Scalar(self_.g1_.w * other.g0_);
}

fn transflector_antiWedge_plane(self_: Transflector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_antiWedge_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_antiWedge_point(self_: Transflector, other: Point) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z + self_.g1_.w * other.g0_.w);
}

fn transflector_antiWedge_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn transflector_antiWedge_rotor(self_: Transflector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn transflector_antiWedge_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_antiWedge_translator(self_: Transflector, other: Translator) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn translator_antiWedge_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_antiWedge_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn translator_antiWedge_flector(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_antiWedge_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedge_horizon(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.w * other.g0_);
}

fn translator_antiWedge_line(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_antiWedge_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedge_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn translator_antiWedge_motor(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_antiWedge_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.w) * other.g4_);
}

fn translator_antiWedge_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn translator_antiWedge_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn translator_antiWedge_origin(self_: Translator, other: Origin) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn translator_antiWedge_plane(self_: Translator, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedge_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn translator_antiWedge_point(self_: Translator, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedge_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_antiWedge_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn translator_antiWedge_scalar(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn translator_antiWedge_transflector(self_: Translator, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_antiWedge_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn antiScalar_join_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_join_multiVector(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_join_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_join_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn dualNum_join_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn dualNum_join_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x));
}

fn dualNum_join_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_join_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.x * other.g0_);
}

fn dualNum_join_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_join_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_motor(self_: DualNum, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_join_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(self_.g0_.x) * other.g1_, vec3<f32>(self_.g0_.x) * other.g2_, vec3<f32>(self_.g0_.x) * other.g3_, vec4<f32>(self_.g0_.x) * other.g4_);
}

fn dualNum_join_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn dualNum_join_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec3<f32>(self_.g0_.x) * other.g2_);
}

fn dualNum_join_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.g0_.x * other.g0_);
}

fn dualNum_join_plane(self_: DualNum, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_point(self_: DualNum, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_rotor(self_: DualNum, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_join_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_join_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_join_translator(self_: DualNum, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn flector_join_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_join_flector(self_: Flector, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_join_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_join_horizon(self_: Flector, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn flector_join_line(self_: Flector, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn flector_join_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn flector_join_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flector_join_motor(self_: Flector, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn flector_join_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g1_.w), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_join_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_join_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn flector_join_origin(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn flector_join_plane(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn flector_join_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flector_join_point(self_: Flector, other: Point) -> Motor {
    return Motor(self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_join_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_join_rotor(self_: Flector, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flector_join_scalar(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_join_transflector(self_: Flector, other: Transflector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_join_translator(self_: Flector, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flectorAtInfinity_join_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn flectorAtInfinity_join_flector(self_: FlectorAtInfinity, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_join_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_join_line(self_: FlectorAtInfinity, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn flectorAtInfinity_join_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_join_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flectorAtInfinity_join_motor(self_: FlectorAtInfinity, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn flectorAtInfinity_join_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g1_.w), self_.g0_.xyzx * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn flectorAtInfinity_join_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn flectorAtInfinity_join_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn flectorAtInfinity_join_origin(self_: FlectorAtInfinity, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(0.0) - self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_join_plane(self_: FlectorAtInfinity, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_join_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_join_point(self_: FlectorAtInfinity, other: Point) -> Motor {
    return Motor(vec4<f32>(0.0) - self_.g0_ * vec4<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_join_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_join_rotor(self_: FlectorAtInfinity, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flectorAtInfinity_join_scalar(self_: FlectorAtInfinity, other: Scalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_join_transflector(self_: FlectorAtInfinity, other: Transflector) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g1_.z));
}

fn flectorAtInfinity_join_translator(self_: FlectorAtInfinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn horizon_join_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.x);
}

fn horizon_join_flector(self_: Horizon, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.w);
}

fn horizon_join_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn horizon_join_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.x);
}

fn horizon_join_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.x);
}

fn horizon_join_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_join_point(self_: Horizon, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.w);
}

fn horizon_join_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn line_join_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn line_join_flector(self_: Line, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_join_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_join_line(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_join_lineAtInfinity(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_join_lineAtOrigin(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_join_motor(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_join_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn line_join_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn line_join_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn line_join_origin(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn line_join_point(self_: Line, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_join_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_join_rotor(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_join_scalar(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_join_transflector(self_: Line, other: Transflector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_join_translator(self_: Line, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_join_flector(self_: LineAtInfinity, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_join_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_line(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_motor(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn lineAtInfinity_join_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_join_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_join_origin(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_join_point(self_: LineAtInfinity, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_join_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_rotor(self_: LineAtInfinity, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_join_scalar(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_join_transflector(self_: LineAtInfinity, other: Transflector) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_join_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtOrigin_join_flector(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_join_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_join_line(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_join_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_join_motor(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_join_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z), self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtOrigin_join_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtOrigin_join_point(self_: LineAtOrigin, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_join_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_join_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_join_transflector(self_: LineAtOrigin, other: Transflector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_join_translator(self_: LineAtOrigin, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_join_dualNum(self_: Motor, other: DualNum) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn motor_join_flector(self_: Motor, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_join_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_join_line(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_join_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_join_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_join_motor(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_join_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn motor_join_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn motor_join_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn motor_join_origin(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_join_point(self_: Motor, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_join_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_join_rotor(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_join_scalar(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_join_transflector(self_: Motor, other: Transflector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_join_translator(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn multiVector_join_antiScalar(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn multiVector_join_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x), self_.g2_ * vec3<f32>(other.g0_.x), self_.g3_ * vec3<f32>(other.g0_.x), self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_join_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_join_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_join_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn multiVector_join_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn multiVector_join_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn multiVector_join_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_join_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn multiVector_join_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + self_.g1_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + self_.g2_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_join_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g1_.w) * other.g1_ + self_.g2_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_join_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.x));
}

fn multiVector_join_origin(self_: MultiVector, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_));
}

fn multiVector_join_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x) * other.g0_);
}

fn multiVector_join_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVector_join_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_join_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_join_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_join_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_join_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_join_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn multiVectorAtInfinity_join_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn multiVectorAtInfinity_join_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0), self_.g2_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn multiVectorAtInfinity_join_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_join_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_join_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.x * other.g0_);
}

fn multiVectorAtInfinity_join_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtInfinity_join_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtInfinity_join_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_join_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtInfinity_join_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g2_ - self_.g1_ * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn multiVectorAtInfinity_join_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtInfinity_join_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ - self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtInfinity_join_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_join_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtInfinity_join_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtInfinity_join_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_join_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_join_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_join_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_join_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVectorAtInfinity_join_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVectorAtOrigin_join_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_join_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_join_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_join_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn multiVectorAtOrigin_join_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g1_);
}

fn multiVectorAtOrigin_join_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtOrigin_join_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g1_);
}

fn multiVectorAtOrigin_join_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g4_.w) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_join_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_join_plane(self_: MultiVectorAtOrigin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.w);
}

fn multiVectorAtOrigin_join_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_join_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_join_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_join_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_join_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_join_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.g0_ * other.g0_.x);
}

fn origin_join_flector(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_join_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn origin_join_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn origin_join_line(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_join_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_join_motor(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_join_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.x, other.g4_.w), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_) * other.g3_);
}

fn origin_join_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn origin_join_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn origin_join_point(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_join_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_join_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_join_transflector(self_: Origin, other: Transflector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_join_translator(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_join_dualNum(self_: Plane, other: DualNum) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_join_flector(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn plane_join_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn plane_join_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_join_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_join_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.x);
}

fn plane_join_origin(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_);
}

fn plane_join_point(self_: Plane, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn plane_join_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn plane_join_scalar(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_join_transflector(self_: Plane, other: Transflector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_join_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_join_flector(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_join_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_join_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_join_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_join_point(self_: PlaneAtOrigin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_join_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_join_scalar(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_join_transflector(self_: PlaneAtOrigin, other: Transflector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn point_join_dualNum(self_: Point, other: DualNum) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn point_join_flector(self_: Point, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_join_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_join_horizon(self_: Point, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn point_join_line(self_: Point, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_join_lineAtInfinity(self_: Point, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_join_lineAtOrigin(self_: Point, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn point_join_motor(self_: Point, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_join_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0));
}

fn point_join_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z));
}

fn point_join_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn point_join_origin(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn point_join_plane(self_: Point, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn point_join_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn point_join_point(self_: Point, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_join_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_join_rotor(self_: Point, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn point_join_scalar(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_join_transflector(self_: Point, other: Transflector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_join_translator(self_: Point, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn pointAtInfinity_join_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn pointAtInfinity_join_flector(self_: PointAtInfinity, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_join_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_join_line(self_: PointAtInfinity, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn pointAtInfinity_join_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_join_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_join_motor(self_: PointAtInfinity, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn pointAtInfinity_join_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z));
}

fn pointAtInfinity_join_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn pointAtInfinity_join_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn pointAtInfinity_join_origin(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_join_plane(self_: PointAtInfinity, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_join_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_join_point(self_: PointAtInfinity, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_join_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_join_rotor(self_: PointAtInfinity, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_join_scalar(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_join_transflector(self_: PointAtInfinity, other: Transflector) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g1_.z));
}

fn pointAtInfinity_join_translator(self_: PointAtInfinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn rotor_join_dualNum(self_: Rotor, other: DualNum) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn rotor_join_flector(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_join_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_join_line(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn rotor_join_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn rotor_join_motor(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn rotor_join_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn rotor_join_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn rotor_join_point(self_: Rotor, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_join_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_join_scalar(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_join_transflector(self_: Rotor, other: Transflector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_join_translator(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn scalar_join_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn scalar_join_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_flector(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_join_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn scalar_join_line(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_join_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_motor(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_join_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn scalar_join_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_join_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_join_origin(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn scalar_join_plane(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_point(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_rotor(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_join_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_join_transflector(self_: Scalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_join_translator(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn transflector_join_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_join_flector(self_: Transflector, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn transflector_join_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn transflector_join_line(self_: Transflector, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn transflector_join_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn transflector_join_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn transflector_join_motor(self_: Transflector, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn transflector_join_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_join_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_join_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn transflector_join_origin(self_: Transflector, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn transflector_join_plane(self_: Transflector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn transflector_join_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn transflector_join_point(self_: Transflector, other: Point) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn transflector_join_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn transflector_join_rotor(self_: Transflector, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn transflector_join_scalar(self_: Transflector, other: Scalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_join_transflector(self_: Transflector, other: Transflector) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn transflector_join_translator(self_: Transflector, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_dualNum(self_: Translator, other: DualNum) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn translator_join_flector(self_: Translator, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn translator_join_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_line(self_: Translator, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_motor(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn translator_join_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn translator_join_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x));
}

fn translator_join_origin(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn translator_join_point(self_: Translator, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn translator_join_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_rotor(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_join_scalar(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_join_transflector(self_: Translator, other: Transflector) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn antiScalar_meet_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_meet_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_flector(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_meet_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn antiScalar_meet_line(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_meet_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_motor(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_meet_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn antiScalar_meet_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_meet_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn antiScalar_meet_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn antiScalar_meet_plane(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_point(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn antiScalar_meet_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn antiScalar_meet_transflector(self_: AntiScalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn antiScalar_meet_translator(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn dualNum_meet_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_meet_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_meet_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.y * other.g0_);
}

fn dualNum_meet_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_meet_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_motor(self_: DualNum, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn dualNum_meet_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_, vec3<f32>(self_.g0_.y) * other.g3_, vec4<f32>(self_.g0_.y) * other.g4_);
}

fn dualNum_meet_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(self_.g0_.y) * other.g2_);
}

fn dualNum_meet_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x), vec3<f32>(self_.g0_.y) * other.g1_, vec3<f32>(0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn dualNum_meet_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.g0_.y * other.g0_);
}

fn dualNum_meet_plane(self_: DualNum, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_point(self_: DualNum, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.y) * other.g0_);
}

fn dualNum_meet_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_meet_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn dualNum_meet_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.y) * other.g1_);
}

fn dualNum_meet_translator(self_: DualNum, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_meet_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_meet_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.y), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_meet_flector(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_meet_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w));
}

fn flector_meet_horizon(self_: Flector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn flector_meet_line(self_: Flector, other: Line) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn flector_meet_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flector_meet_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn flector_meet_motor(self_: Flector, other: Motor) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn flector_meet_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g4_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), self_.g0_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_meet_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.y));
}

fn flector_meet_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.x, 0.0), self_.g0_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g2_, self_.g1_ * vec4<f32>(other.g0_.y));
}

fn flector_meet_origin(self_: Flector, other: Origin) -> Scalar {
    return Scalar(self_.g1_.w * other.g0_);
}

fn flector_meet_plane(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn flector_meet_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn flector_meet_point(self_: Flector, other: Point) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z + self_.g1_.w * other.g0_.w);
}

fn flector_meet_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn flector_meet_rotor(self_: Flector, other: Rotor) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn flector_meet_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn flector_meet_translator(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn flectorAtInfinity_meet_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_meet_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn flectorAtInfinity_meet_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_meet_line(self_: FlectorAtInfinity, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_meet_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_meet_motor(self_: FlectorAtInfinity, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_meet_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn flectorAtInfinity_meet_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn flectorAtInfinity_meet_origin(self_: FlectorAtInfinity, other: Origin) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn flectorAtInfinity_meet_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn flectorAtInfinity_meet_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_meet_point(self_: FlectorAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_.w);
}

fn flectorAtInfinity_meet_rotor(self_: FlectorAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn flectorAtInfinity_meet_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn flectorAtInfinity_meet_translator(self_: FlectorAtInfinity, other: Translator) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn horizon_meet_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn horizon_meet_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.y);
}

fn horizon_meet_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_meet_line(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_meet_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_meet_motor(self_: Horizon, other: Motor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_meet_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * vec2<f32>(other.g1_.w, other.g0_.y), vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z));
}

fn horizon_meet_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn horizon_meet_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn horizon_meet_plane(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn horizon_meet_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn horizon_meet_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn horizon_meet_rotor(self_: Horizon, other: Rotor) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn horizon_meet_transflector(self_: Horizon, other: Transflector) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn horizon_meet_translator(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.w);
}

fn line_meet_antiScalar(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_meet_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y));
}

fn line_meet_flector(self_: Line, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0));
}

fn line_meet_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn line_meet_horizon(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn line_meet_line(self_: Line, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_meet_lineAtInfinity(self_: Line, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_meet_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_meet_motor(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn line_meet_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn line_meet_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn line_meet_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn line_meet_plane(self_: Line, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn line_meet_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0));
}

fn line_meet_rotor(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn line_meet_transflector(self_: Line, other: Transflector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0));
}

fn line_meet_translator(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn lineAtInfinity_meet_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_meet_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_meet_flector(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtInfinity_meet_line(self_: LineAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_meet_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_meet_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtInfinity_meet_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_meet_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtInfinity_meet_plane(self_: LineAtInfinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtInfinity_meet_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtInfinity_meet_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtInfinity_meet_transflector(self_: LineAtInfinity, other: Transflector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtInfinity_meet_translator(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_meet_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_meet_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn lineAtOrigin_meet_flector(self_: LineAtOrigin, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn lineAtOrigin_meet_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_meet_horizon(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_meet_line(self_: LineAtOrigin, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_meet_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_meet_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_meet_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn lineAtOrigin_meet_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn lineAtOrigin_meet_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn lineAtOrigin_meet_plane(self_: LineAtOrigin, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtOrigin_meet_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_meet_rotor(self_: LineAtOrigin, other: Rotor) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn lineAtOrigin_meet_transflector(self_: LineAtOrigin, other: Transflector) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn lineAtOrigin_meet_translator(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn motor_meet_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_meet_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn motor_meet_flector(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * other.g1_);
}

fn motor_meet_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_meet_horizon(self_: Motor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn motor_meet_line(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn motor_meet_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn motor_meet_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn motor_meet_motor(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.w) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn motor_meet_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * other.g3_ + self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * other.g4_);
}

fn motor_meet_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn motor_meet_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, 0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, self_.g1_ * vec3<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn motor_meet_origin(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn motor_meet_plane(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_meet_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn motor_meet_point(self_: Motor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn motor_meet_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn motor_meet_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn motor_meet_scalar(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn motor_meet_transflector(self_: Motor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g1_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g1_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec4<f32>(self_.g0_.w) * other.g1_);
}

fn motor_meet_translator(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn multiVector_meet_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_meet_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_, self_.g1_ * vec4<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.y), self_.g3_ * vec3<f32>(other.g0_.y), self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_meet_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVector_meet_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w));
}

fn multiVector_meet_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_, 0.0), self_.g2_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_));
}

fn multiVector_meet_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn multiVector_meet_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVector_meet_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVector_meet_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g3_ * vec3<f32>(other.g0_.w), self_.g4_ * vec4<f32>(other.g0_.w));
}

fn multiVector_meet_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g4_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g4_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g2_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g3_ + self_.g3_ * vec3<f32>(other.g0_.y) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), vec4<f32>(self_.g0_.y) * other.g4_ + self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_meet_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g2_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.y));
}

fn multiVector_meet_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + self_.g1_ * vec4<f32>(other.g0_.y) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, 0.0) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g4_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g2_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), self_.g3_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g4_.w) * other.g2_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0) + self_.g4_ * vec4<f32>(other.g0_.y));
}

fn multiVector_meet_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVector_meet_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g0_.y) * other.g0_);
}

fn multiVector_meet_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g4_.w) * other.g0_, vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn multiVector_meet_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVector_meet_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVector_meet_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g3_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g3_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g3_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g4_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g4_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g2_ * vec3<f32>(other.g0_.w), self_.g3_ * vec3<f32>(other.g0_.w), self_.g4_ * vec4<f32>(other.g0_.w));
}

fn multiVector_meet_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn multiVector_meet_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g4_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g4_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g4_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g3_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g3_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0), vec3<f32>(self_.g4_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g4_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g4_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g4_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVector_meet_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w) + vec4<f32>(self_.g4_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g4_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g4_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g2_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g3_ * vec3<f32>(other.g0_.w), self_.g4_ * vec4<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_meet_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_meet_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_meet_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.w, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn multiVectorAtInfinity_meet_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtInfinity_meet_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtInfinity_meet_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_meet_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.w, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g2_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z) + self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_meet_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtInfinity_meet_origin(self_: MultiVectorAtInfinity, other: Origin) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn multiVectorAtInfinity_meet_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn multiVectorAtInfinity_meet_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtInfinity_meet_point(self_: MultiVectorAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_.w);
}

fn multiVectorAtInfinity_meet_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtInfinity_meet_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z));
}

fn multiVectorAtInfinity_meet_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_.w), self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_meet_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_meet_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), self_.g1_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtOrigin_meet_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVectorAtOrigin_meet_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_meet_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(-other.g0_), self_.g1_ * vec3<f32>(other.g0_), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_meet_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(0.0));
}

fn multiVectorAtOrigin_meet_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtOrigin_meet_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtOrigin_meet_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * other.g1_, vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn multiVectorAtOrigin_meet_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.w, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g0_.y) * other.g1_ + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g3_ - self_.g2_ * vec3<f32>(other.g4_.w), vec4<f32>(self_.g0_.y) * other.g4_ + vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn multiVectorAtOrigin_meet_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ - self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtOrigin_meet_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.y) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g2_ + self_.g2_ * vec3<f32>(other.g0_.y));
}

fn multiVectorAtOrigin_meet_origin(self_: MultiVectorAtOrigin, other: Origin) -> Origin {
    return Origin(self_.g0_.y * other.g0_);
}

fn multiVectorAtOrigin_meet_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.w, 0.0), vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g0_.w), vec4<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtOrigin_meet_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.y) * other.g0_);
}

fn multiVectorAtOrigin_meet_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multiVectorAtOrigin_meet_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * other.g0_, vec3<f32>(0.0));
}

fn multiVectorAtOrigin_meet_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z) + self_.g1_ * vec3<f32>(other.g0_.w), self_.g2_ * vec3<f32>(other.g0_.w));
}

fn multiVectorAtOrigin_meet_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.y * other.g0_);
}

fn multiVectorAtOrigin_meet_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.w, 0.0) + vec2<f32>(self_.g2_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g2_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g2_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z), vec3<f32>(self_.g2_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g2_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g2_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g2_ * vec3<f32>(other.g1_.w), vec4<f32>(self_.g0_.y) * other.g1_);
}

fn multiVectorAtOrigin_meet_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, 0.0), self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g2_.x, self_.g2_.y, self_.g2_.z, self_.g2_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn origin_meet_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_meet_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.g0_ * other.g0_.y);
}

fn origin_meet_flector(self_: Origin, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g1_.w);
}

fn origin_meet_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.w);
}

fn origin_meet_horizon(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_meet_motor(self_: Origin, other: Motor) -> Origin {
    return Origin(self_.g0_ * other.g0_.w);
}

fn origin_meet_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(-other.g4_.w, 0.0), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_meet_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.y);
}

fn origin_meet_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> Origin {
    return Origin(self_.g0_ * other.g0_.y);
}

fn origin_meet_plane(self_: Origin, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.w);
}

fn origin_meet_rotor(self_: Origin, other: Rotor) -> Origin {
    return Origin(self_.g0_ * other.g0_.w);
}

fn origin_meet_transflector(self_: Origin, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g1_.w);
}

fn origin_meet_translator(self_: Origin, other: Translator) -> Origin {
    return Origin(self_.g0_ * other.g0_.w);
}

fn plane_meet_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_meet_dualNum(self_: Plane, other: DualNum) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_meet_flector(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_meet_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w));
}

fn plane_meet_horizon(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn plane_meet_line(self_: Plane, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn plane_meet_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn plane_meet_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn plane_meet_motor(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g0_ * vec4<f32>(other.g0_.w));
}

fn plane_meet_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_meet_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y));
}

fn plane_meet_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g0_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g0_.w) * other.g2_, self_.g0_ * vec4<f32>(other.g0_.y));
}

fn plane_meet_origin(self_: Plane, other: Origin) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn plane_meet_plane(self_: Plane, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_meet_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn plane_meet_point(self_: Plane, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn plane_meet_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn plane_meet_rotor(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g0_ * vec4<f32>(other.g0_.w));
}

fn plane_meet_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn plane_meet_translator(self_: Plane, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), self_.g0_ * vec4<f32>(other.g0_.w));
}

fn planeAtOrigin_meet_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_meet_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn planeAtOrigin_meet_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_meet_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_meet_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_meet_line(self_: PlaneAtOrigin, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z));
}

fn planeAtOrigin_meet_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn planeAtOrigin_meet_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_meet_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn planeAtOrigin_meet_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g4_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0));
}

fn planeAtOrigin_meet_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.y));
}

fn planeAtOrigin_meet_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), self_.g0_ * vec3<f32>(other.g0_.y));
}

fn planeAtOrigin_meet_plane(self_: PlaneAtOrigin, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w));
}

fn planeAtOrigin_meet_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn planeAtOrigin_meet_point(self_: PlaneAtOrigin, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_meet_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_meet_rotor(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn planeAtOrigin_meet_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec4<f32>(0.0));
}

fn planeAtOrigin_meet_translator(self_: PlaneAtOrigin, other: Translator) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0));
}

fn point_meet_antiScalar(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_meet_dualNum(self_: Point, other: DualNum) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.y));
}

fn point_meet_flector(self_: Point, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g0_.w * other.g1_.w);
}

fn point_meet_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn point_meet_horizon(self_: Point, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_);
}

fn point_meet_motor(self_: Point, other: Motor) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn point_meet_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g0_.w) * vec2<f32>(-other.g4_.w, 0.0), self_.g0_ * vec4<f32>(other.g0_.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_meet_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.y);
}

fn point_meet_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec4<f32>(other.g0_.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_meet_plane(self_: Point, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn point_meet_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn point_meet_rotor(self_: Point, other: Rotor) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn point_meet_transflector(self_: Point, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g0_.w * other.g1_.w);
}

fn point_meet_translator(self_: Point, other: Translator) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.w));
}

fn pointAtInfinity_meet_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_meet_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.y));
}

fn pointAtInfinity_meet_flector(self_: PointAtInfinity, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn pointAtInfinity_meet_motor(self_: PointAtInfinity, other: Motor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_meet_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn pointAtInfinity_meet_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0), self_.g0_ * vec3<f32>(other.g0_.y), vec3<f32>(0.0));
}

fn pointAtInfinity_meet_plane(self_: PointAtInfinity, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_meet_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_meet_rotor(self_: PointAtInfinity, other: Rotor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn pointAtInfinity_meet_transflector(self_: PointAtInfinity, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn pointAtInfinity_meet_translator(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.w));
}

fn rotor_meet_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_meet_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_meet_flector(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_meet_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_horizon(self_: Rotor, other: Horizon) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_meet_line(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_meet_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_motor(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn rotor_meet_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g3_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g3_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g3_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(other.g4_.w, 0.0, 0.0, -other.g4_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g4_.w, 0.0, -other.g4_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g4_.w, -other.g4_.z) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.w) * other.g4_);
}

fn rotor_meet_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_meet_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn rotor_meet_origin(self_: Rotor, other: Origin) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn rotor_meet_plane(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z), vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn rotor_meet_point(self_: Rotor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn rotor_meet_scalar(self_: Rotor, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn rotor_meet_transflector(self_: Rotor, other: Transflector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec4<f32>(self_.g0_.w) * other.g1_);
}

fn rotor_meet_translator(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn scalar_meet_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_meet_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_meet_motor(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn scalar_meet_multiVector(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_meet_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.y);
}

fn scalar_meet_rotor(self_: Scalar, other: Rotor) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn scalar_meet_translator(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.w);
}

fn transflector_meet_antiScalar(self_: Transflector, other: AntiScalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_meet_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.y), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_meet_flector(self_: Transflector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_meet_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w));
}

fn transflector_meet_horizon(self_: Transflector, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_));
}

fn transflector_meet_line(self_: Transflector, other: Line) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn transflector_meet_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn transflector_meet_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn transflector_meet_motor(self_: Transflector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g1_.z, -other.g1_.y, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g1_.z, 0.0, other.g1_.x, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g1_.y, -other.g1_.x, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn transflector_meet_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g4_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g4_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g4_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g1_.w, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g3_.z, -other.g3_.y, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g3_.z, 0.0, other.g3_.x, -other.g2_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g3_.y, -other.g3_.x, 0.0, -other.g2_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g4_.z, other.g4_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g4_.z, 0.0, -other.g4_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g4_.y, other.g4_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g4_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g4_.x, other.g4_.y, other.g4_.z), self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_meet_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(other.g1_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g1_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g1_.z, 0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g2_.z, -other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g2_.z, 0.0, other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g2_.y, -other.g2_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.y));
}

fn transflector_meet_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g1_.w) * vec2<f32>(other.g0_.x, 0.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.y, other.g0_.y, other.g0_.y, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + self_.g1_.wwwz * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, -other.g1_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g2_.z, other.g2_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g2_.z, 0.0, -other.g2_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g2_.y, other.g2_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g2_, self_.g1_ * vec4<f32>(other.g0_.y));
}

fn transflector_meet_origin(self_: Transflector, other: Origin) -> Scalar {
    return Scalar(self_.g1_.w * other.g0_);
}

fn transflector_meet_plane(self_: Transflector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(0.0));
}

fn transflector_meet_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec4<f32>(0.0));
}

fn transflector_meet_point(self_: Transflector, other: Point) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z + self_.g1_.w * other.g0_.w);
}

fn transflector_meet_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn transflector_meet_rotor(self_: Transflector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn transflector_meet_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g1_.z, 0.0) + vec2<f32>(self_.g1_.x) * vec2<f32>(other.g0_.x, 0.0) + vec2<f32>(self_.g1_.y) * vec2<f32>(other.g0_.y, 0.0) + vec2<f32>(self_.g1_.z) * vec2<f32>(other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec4<f32>(0.0));
}

fn transflector_meet_translator(self_: Transflector, other: Translator) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0), self_.g1_ * vec4<f32>(other.g0_.w));
}

fn translator_meet_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_meet_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec4<f32>(0.0));
}

fn translator_meet_flector(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_meet_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_meet_horizon(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.w * other.g0_);
}

fn translator_meet_line(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_meet_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_meet_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g0_.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn translator_meet_motor(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * other.g1_, vec4<f32>(0.0));
}

fn translator_meet_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g2_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g2_.y, 0.0) + vec2<f32>(self_.g0_.z) * vec2<f32>(-other.g2_.z, 0.0) + vec2<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g4_.z, other.g4_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g4_.z, 0.0, -other.g4_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g4_.y, other.g4_.x, 0.0, 0.0) + vec4<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y) + vec3<f32>(self_.g0_.w) * other.g3_, vec4<f32>(self_.g0_.w) * other.g4_);
}

fn translator_meet_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.w) * other.g2_);
}

fn translator_meet_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g1_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g1_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g1_.z, other.g0_.y), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g2_.z, other.g2_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g2_.z, 0.0, -other.g2_.x, 0.0) + self_.g0_.zzzw * vec4<f32>(-other.g2_.y, other.g2_.x, 0.0, other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.y), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, 0.0));
}

fn translator_meet_origin(self_: Translator, other: Origin) -> Origin {
    return Origin(self_.g0_.w * other.g0_);
}

fn translator_meet_plane(self_: Translator, other: Plane) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_meet_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0));
}

fn translator_meet_point(self_: Translator, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.w) * other.g0_);
}

fn translator_meet_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.w) * other.g0_);
}

fn translator_meet_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(-other.g0_.x, 0.0) + vec2<f32>(self_.g0_.y) * vec2<f32>(-other.g0_.y, 0.0) + vec2<f32>(self_.g0_.z, self_.g0_.w) * vec2<f32>(-other.g0_.z, other.g0_.w), vec4<f32>(0.0), vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w), vec4<f32>(0.0));
}

fn translator_meet_scalar(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.w * other.g0_);
}

fn translator_meet_transflector(self_: Translator, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + vec3<f32>(self_.g0_.w) * other.g0_, vec4<f32>(self_.g0_.w) * other.g1_);
}

fn translator_meet_translator(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0_.xyzx * vec4<f32>(other.g0_.w, other.g0_.w, other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * other.g0_);
}

fn antiScalar_wedge_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_wedge_multiVector(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_wedge_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.x);
}

fn antiScalar_wedge_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn dualNum_wedge_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn dualNum_wedge_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x));
}

fn dualNum_wedge_flector(self_: DualNum, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_wedge_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.x * other.g0_);
}

fn dualNum_wedge_line(self_: DualNum, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_wedge_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_motor(self_: DualNum, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_wedge_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(self_.g0_.x) * other.g1_, vec3<f32>(self_.g0_.x) * other.g2_, vec3<f32>(self_.g0_.x) * other.g3_, vec4<f32>(self_.g0_.x) * other.g4_);
}

fn dualNum_wedge_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g2_, vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y));
}

fn dualNum_wedge_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec3<f32>(self_.g0_.x) * other.g2_);
}

fn dualNum_wedge_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.g0_.x * other.g0_);
}

fn dualNum_wedge_plane(self_: DualNum, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_point(self_: DualNum, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_rotor(self_: DualNum, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn dualNum_wedge_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return DualNum(self_.g0_ * vec2<f32>(other.g0_));
}

fn dualNum_wedge_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g0_.x) * other.g1_);
}

fn dualNum_wedge_translator(self_: DualNum, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * other.g0_);
}

fn flector_wedge_dualNum(self_: Flector, other: DualNum) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_wedge_flector(self_: Flector, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_wedge_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.w) * other.g0_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_wedge_horizon(self_: Flector, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn flector_wedge_line(self_: Flector, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn flector_wedge_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn flector_wedge_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flector_wedge_motor(self_: Flector, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn flector_wedge_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g1_.w), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_wedge_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn flector_wedge_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn flector_wedge_origin(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0_.xyzx * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn flector_wedge_plane(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn flector_wedge_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flector_wedge_point(self_: Flector, other: Point) -> Motor {
    return Motor(self_.g0_.xyzx * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_wedge_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_wedge_rotor(self_: Flector, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flector_wedge_scalar(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn flector_wedge_transflector(self_: Flector, other: Transflector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flector_wedge_translator(self_: Flector, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flectorAtInfinity_wedge_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn flectorAtInfinity_wedge_flector(self_: FlectorAtInfinity, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_wedge_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_wedge_line(self_: FlectorAtInfinity, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn flectorAtInfinity_wedge_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_wedge_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flectorAtInfinity_wedge_motor(self_: FlectorAtInfinity, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn flectorAtInfinity_wedge_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g1_.w), self_.g0_.xyzx * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn flectorAtInfinity_wedge_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn flectorAtInfinity_wedge_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn flectorAtInfinity_wedge_origin(self_: FlectorAtInfinity, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(0.0) - self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_wedge_plane(self_: FlectorAtInfinity, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_wedge_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_wedge_point(self_: FlectorAtInfinity, other: Point) -> Motor {
    return Motor(vec4<f32>(0.0) - self_.g0_ * vec4<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_wedge_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn flectorAtInfinity_wedge_rotor(self_: FlectorAtInfinity, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn flectorAtInfinity_wedge_scalar(self_: FlectorAtInfinity, other: Scalar) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(other.g0_));
}

fn flectorAtInfinity_wedge_transflector(self_: FlectorAtInfinity, other: Transflector) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g1_.z));
}

fn flectorAtInfinity_wedge_translator(self_: FlectorAtInfinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn horizon_wedge_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.x);
}

fn horizon_wedge_flector(self_: Horizon, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.w);
}

fn horizon_wedge_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn horizon_wedge_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> Horizon {
    return Horizon(self_.g0_ * other.g0_.x);
}

fn horizon_wedge_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.x);
}

fn horizon_wedge_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_wedge_point(self_: Horizon, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.w);
}

fn horizon_wedge_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn line_wedge_dualNum(self_: Line, other: DualNum) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn line_wedge_flector(self_: Line, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_wedge_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_wedge_line(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_wedge_lineAtInfinity(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_wedge_lineAtOrigin(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_wedge_motor(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_wedge_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn line_wedge_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn line_wedge_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn line_wedge_origin(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn line_wedge_point(self_: Line, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn line_wedge_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_wedge_rotor(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_wedge_scalar(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn line_wedge_transflector(self_: Line, other: Transflector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn line_wedge_translator(self_: Line, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_wedge_flector(self_: LineAtInfinity, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_wedge_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_line(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_motor(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn lineAtInfinity_wedge_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_wedge_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtInfinity_wedge_origin(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_wedge_point(self_: LineAtInfinity, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn lineAtInfinity_wedge_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_rotor(self_: LineAtInfinity, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_wedge_scalar(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtInfinity_wedge_transflector(self_: LineAtInfinity, other: Transflector) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_wedge_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn lineAtOrigin_wedge_flector(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_wedge_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_wedge_line(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_wedge_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_wedge_motor(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_wedge_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z), self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtOrigin_wedge_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn lineAtOrigin_wedge_point(self_: LineAtOrigin, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_wedge_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_wedge_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn lineAtOrigin_wedge_transflector(self_: LineAtOrigin, other: Transflector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn lineAtOrigin_wedge_translator(self_: LineAtOrigin, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_wedge_dualNum(self_: Motor, other: DualNum) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn motor_wedge_flector(self_: Motor, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_wedge_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_wedge_line(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_wedge_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_wedge_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_wedge_motor(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_wedge_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn motor_wedge_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn motor_wedge_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g1_ * vec3<f32>(other.g0_.x));
}

fn motor_wedge_origin(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_wedge_point(self_: Motor, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn motor_wedge_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_wedge_rotor(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_wedge_scalar(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_));
}

fn motor_wedge_transflector(self_: Motor, other: Transflector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn motor_wedge_translator(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn multiVector_wedge_antiScalar(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn multiVector_wedge_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x), self_.g2_ * vec3<f32>(other.g0_.x), self_.g3_ * vec3<f32>(other.g0_.x), self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_wedge_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_wedge_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.w) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_wedge_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_));
}

fn multiVector_wedge_line(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn multiVector_wedge_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn multiVector_wedge_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_wedge_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn multiVector_wedge_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g4_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(self_.g0_.x) * other.g1_ + self_.g1_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + self_.g2_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z) + self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_wedge_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_.x) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0) + self_.g1_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g1_.w) * other.g1_ + self_.g2_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.y) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g1_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g1_.z, other.g1_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g1_.z, 0.0, -other.g1_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g1_.y, other.g1_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z) + self_.g4_ * vec4<f32>(other.g0_.x));
}

fn multiVector_wedge_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(self_.g0_.x) * other.g1_ - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + self_.g3_ * vec3<f32>(other.g0_.x));
}

fn multiVector_wedge_origin(self_: MultiVector, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_, 0.0) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_), vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_));
}

fn multiVector_wedge_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x) * other.g0_);
}

fn multiVector_wedge_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVector_wedge_point(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z) + vec2<f32>(self_.g4_.w) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g1_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVector_wedge_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_wedge_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g3_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g3_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g3_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVector_wedge_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_), self_.g3_ * vec3<f32>(other.g0_), self_.g4_ * vec4<f32>(other.g0_));
}

fn multiVector_wedge_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g4_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g4_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g4_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(self_.g1_.w) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g2_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g2_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g3_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g3_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g3_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVector_wedge_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g1_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn multiVectorAtInfinity_wedge_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn multiVectorAtInfinity_wedge_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_, vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0), self_.g2_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x));
}

fn multiVectorAtInfinity_wedge_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_wedge_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedge_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> Horizon {
    return Horizon(self_.g0_.x * other.g0_);
}

fn multiVectorAtInfinity_wedge_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtInfinity_wedge_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtInfinity_wedge_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedge_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec4<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * other.g1_, vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn multiVectorAtInfinity_wedge_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.w) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g2_.z), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z, self_.g1_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(self_.g0_.x) * other.g2_ - self_.g1_ * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * other.g4_ + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0_.x) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g2_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtInfinity_wedge_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ - self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtInfinity_wedge_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_wedge_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtInfinity_wedge_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtInfinity_wedge_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g0_.w), vec4<f32>(self_.g0_.x) * other.g0_, vec3<f32>(0.0) - self_.g1_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g2_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn multiVectorAtInfinity_wedge_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedge_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn multiVectorAtInfinity_wedge_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtInfinity_wedge_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, other.g1_.z), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0), vec4<f32>(self_.g0_.x) * other.g1_ + vec4<f32>(self_.g2_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g2_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g2_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVectorAtInfinity_wedge_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn multiVectorAtOrigin_wedge_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_.x), self_.g1_ * vec3<f32>(other.g0_.x), self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_wedge_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedge_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g0_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedge_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_);
}

fn multiVectorAtOrigin_wedge_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g1_);
}

fn multiVectorAtOrigin_wedge_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g0_);
}

fn multiVectorAtOrigin_wedge_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * other.g1_);
}

fn multiVectorAtOrigin_wedge_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(other.g0_.x, other.g4_.w) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z) + self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g3_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * other.g0_ + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g0_.x) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(self_.g0_.x) * other.g1_ + self_.g1_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * other.g2_ + vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0) + self_.g2_ * vec3<f32>(other.g0_.x));
}

fn multiVectorAtOrigin_wedge_plane(self_: MultiVectorAtOrigin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.w);
}

fn multiVectorAtOrigin_wedge_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedge_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedge_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(other.g0_), self_.g1_ * vec3<f32>(other.g0_), self_.g2_ * vec3<f32>(other.g0_));
}

fn multiVectorAtOrigin_wedge_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g1_.w) + vec2<f32>(self_.g2_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g2_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g2_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(self_.g0_.x) * other.g0_, vec3<f32>(self_.g1_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g1_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g1_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn multiVectorAtOrigin_wedge_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g0_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g0_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g0_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_wedge_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.g0_ * other.g0_.x);
}

fn origin_wedge_flector(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_wedge_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn origin_wedge_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn origin_wedge_line(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_wedge_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_wedge_motor(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g1_);
}

fn origin_wedge_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * vec2<f32>(other.g0_.x, other.g4_.w), vec3<f32>(self_.g0_) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_) * other.g3_);
}

fn origin_wedge_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn origin_wedge_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn origin_wedge_point(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn origin_wedge_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn origin_wedge_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn origin_wedge_transflector(self_: Origin, other: Transflector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w));
}

fn origin_wedge_translator(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z));
}

fn plane_wedge_dualNum(self_: Plane, other: DualNum) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_wedge_flector(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn plane_wedge_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn plane_wedge_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_wedge_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0_ * vec4<f32>(other.g0_.x));
}

fn plane_wedge_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.x);
}

fn plane_wedge_origin(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_);
}

fn plane_wedge_point(self_: Plane, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn plane_wedge_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn plane_wedge_scalar(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(other.g0_));
}

fn plane_wedge_transflector(self_: Plane, other: Transflector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_wedge_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_wedge_flector(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_wedge_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_wedge_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_wedge_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), self_.g0_ * vec3<f32>(other.g0_.x));
}

fn planeAtOrigin_wedge_point(self_: PlaneAtOrigin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_wedge_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_wedge_scalar(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(other.g0_));
}

fn planeAtOrigin_wedge_transflector(self_: PlaneAtOrigin, other: Transflector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn point_wedge_dualNum(self_: Point, other: DualNum) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn point_wedge_flector(self_: Point, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_wedge_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_wedge_horizon(self_: Point, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn point_wedge_line(self_: Point, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_wedge_lineAtInfinity(self_: Point, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, -other.g0_.z));
}

fn point_wedge_lineAtOrigin(self_: Point, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn point_wedge_motor(self_: Point, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g1_.x, other.g1_.y, other.g1_.z, 0.0));
}

fn point_wedge_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g4_.w), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g1_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g1_.x, other.g1_.y, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g3_.x, other.g3_.y, other.g3_.z, 0.0));
}

fn point_wedge_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.y), self_.g0_ * vec4<f32>(other.g0_.x), vec3<f32>(self_.g0_.w) * other.g1_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + self_.g0_.wwwz * vec4<f32>(other.g2_.x, other.g2_.y, other.g2_.z, -other.g2_.z));
}

fn point_wedge_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z), vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn point_wedge_origin(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn point_wedge_plane(self_: Point, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn point_wedge_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn point_wedge_point(self_: Point, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.w) + vec3<f32>(self_.g0_.w) * vec3<f32>(other.g0_.x, other.g0_.y, other.g0_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_wedge_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0_.w) * other.g0_, vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_wedge_rotor(self_: Point, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn point_wedge_scalar(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0_ * vec4<f32>(other.g0_));
}

fn point_wedge_transflector(self_: Point, other: Transflector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1_.z) + vec4<f32>(self_.g0_.w) * vec4<f32>(other.g0_.x, other.g0_.y, other.g0_.z, other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn point_wedge_translator(self_: Point, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + self_.g0_.wwwz * other.g0_.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn pointAtInfinity_wedge_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_.x));
}

fn pointAtInfinity_wedge_flector(self_: PointAtInfinity, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_wedge_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_wedge_line(self_: PointAtInfinity, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn pointAtInfinity_wedge_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_wedge_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_wedge_motor(self_: PointAtInfinity, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn pointAtInfinity_wedge_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z));
}

fn pointAtInfinity_wedge_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z), self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn pointAtInfinity_wedge_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn pointAtInfinity_wedge_origin(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_wedge_plane(self_: PointAtInfinity, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_wedge_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_wedge_point(self_: PointAtInfinity, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_wedge_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn pointAtInfinity_wedge_rotor(self_: PointAtInfinity, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn pointAtInfinity_wedge_scalar(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(other.g0_));
}

fn pointAtInfinity_wedge_transflector(self_: PointAtInfinity, other: Transflector) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g1_.z));
}

fn pointAtInfinity_wedge_translator(self_: PointAtInfinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn rotor_wedge_dualNum(self_: Rotor, other: DualNum) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn rotor_wedge_flector(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_wedge_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_wedge_line(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn rotor_wedge_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn rotor_wedge_motor(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn rotor_wedge_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g3_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g3_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g3_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn rotor_wedge_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0));
}

fn rotor_wedge_point(self_: Rotor, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_wedge_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_wedge_scalar(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(other.g0_));
}

fn rotor_wedge_transflector(self_: Rotor, other: Transflector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn rotor_wedge_translator(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn scalar_wedge_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn scalar_wedge_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return DualNum(vec2<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_flector(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedge_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0_ * other.g0_);
}

fn scalar_wedge_line(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedge_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_motor(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedge_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_, vec3<f32>(self_.g0_) * other.g3_, vec4<f32>(self_.g0_) * other.g4_);
}

fn scalar_wedge_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_wedge_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_) * other.g0_, vec3<f32>(self_.g0_) * other.g1_, vec3<f32>(self_.g0_) * other.g2_);
}

fn scalar_wedge_origin(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0_ * other.g0_);
}

fn scalar_wedge_plane(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_point(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_rotor(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_) * other.g0_);
}

fn scalar_wedge_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn scalar_wedge_transflector(self_: Scalar, other: Transflector) -> Transflector {
    return Transflector(vec3<f32>(self_.g0_) * other.g0_, vec4<f32>(self_.g0_) * other.g1_);
}

fn scalar_wedge_translator(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0_) * other.g0_);
}

fn transflector_wedge_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_.x), self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_wedge_flector(self_: Transflector, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x) * vec4<f32>(-other.g0_.w, 0.0, 0.0, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, -other.g0_.w, 0.0, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, -other.g0_.w, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn transflector_wedge_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn transflector_wedge_line(self_: Transflector, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn transflector_wedge_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn transflector_wedge_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn transflector_wedge_motor(self_: Transflector, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g0_.z, -other.g0_.y, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g0_.z, 0.0, other.g0_.x, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g0_.y, -other.g0_.x, 0.0, -other.g1_.z));
}

fn transflector_wedge_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g4_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g4_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g4_.z) + vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g1_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g1_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, other.g2_.z, -other.g2_.y, -other.g3_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(-other.g2_.z, 0.0, other.g2_.x, -other.g3_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(other.g2_.y, -other.g2_.x, 0.0, -other.g3_.z) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_wedge_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g1_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g1_.z) * vec2<f32>(0.0, -other.g1_.z), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(other.g0_.x, other.g0_.x, other.g0_.x, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g1_.z, other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g1_.z, 0.0, -other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g1_.y, other.g1_.x, 0.0), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g2_.z) + self_.g1_ * vec4<f32>(other.g0_.x));
}

fn transflector_wedge_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, other.g2_.z) + vec2<f32>(self_.g1_.w) * vec2<f32>(0.0, -other.g0_.x), vec3<f32>(0.0) - self_.g0_ * vec3<f32>(other.g0_.x), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g1_.z, -other.g1_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g1_.z, 0.0, other.g1_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g1_.y, -other.g1_.x, 0.0));
}

fn transflector_wedge_origin(self_: Transflector, other: Origin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_, -other.g0_, -other.g0_, 0.0) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_));
}

fn transflector_wedge_plane(self_: Transflector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn transflector_wedge_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn transflector_wedge_point(self_: Transflector, other: Point) -> Motor {
    return Motor(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g0_.x) * vec4<f32>(-other.g0_.w, -other.g0_.w, -other.g0_.w, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z) + vec4<f32>(self_.g1_.w) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.w), vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, -other.g0_.z, other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(other.g0_.z, 0.0, -other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(-other.g0_.y, other.g0_.x, 0.0));
}

fn transflector_wedge_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, 0.0) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, 0.0) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, 0.0) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn transflector_wedge_rotor(self_: Transflector, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x) * vec3<f32>(0.0, other.g0_.z, -other.g0_.y) + vec3<f32>(self_.g0_.y) * vec3<f32>(-other.g0_.z, 0.0, other.g0_.x) + vec3<f32>(self_.g0_.z) * vec3<f32>(other.g0_.y, -other.g0_.x, 0.0));
}

fn transflector_wedge_scalar(self_: Transflector, other: Scalar) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(other.g0_), self_.g1_ * vec4<f32>(other.g0_));
}

fn transflector_wedge_transflector(self_: Transflector, other: Transflector) -> Translator {
    return Translator(vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, -other.g0_.z, other.g0_.y, other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(other.g0_.z, 0.0, -other.g0_.x, other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(-other.g0_.y, other.g0_.x, 0.0, other.g1_.z) + vec4<f32>(self_.g1_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g1_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.y) + vec4<f32>(self_.g1_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g0_.z));
}

fn transflector_wedge_translator(self_: Transflector, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_dualNum(self_: Translator, other: DualNum) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_.x));
}

fn translator_wedge_flector(self_: Translator, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn translator_wedge_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_line(self_: Translator, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_motor(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g2_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g2_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g2_.z) + vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(other.g1_.w, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g1_.w, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g1_.w, -other.g1_.z));
}

fn translator_wedge_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w) * vec2<f32>(0.0, other.g0_.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x), vec4<f32>(self_.g0_.x) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, 0.0, -other.g1_.z));
}

fn translator_wedge_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g0_.x) * vec2<f32>(0.0, -other.g1_.x) + vec2<f32>(self_.g0_.y) * vec2<f32>(0.0, -other.g1_.y) + vec2<f32>(self_.g0_.z) * vec2<f32>(0.0, -other.g1_.z), vec3<f32>(0.0), vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_.x));
}

fn translator_wedge_origin(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z) * vec3<f32>(other.g0_));
}

fn translator_wedge_point(self_: Translator, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0_.x) * vec4<f32>(other.g0_.w, 0.0, 0.0, -other.g0_.x) + vec4<f32>(self_.g0_.y) * vec4<f32>(0.0, other.g0_.w, 0.0, -other.g0_.y) + vec4<f32>(self_.g0_.z) * vec4<f32>(0.0, 0.0, other.g0_.w, -other.g0_.z));
}

fn translator_wedge_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_rotor(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_wedge_scalar(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(other.g0_));
}

fn translator_wedge_transflector(self_: Translator, other: Transflector) -> Horizon {
    return Horizon(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn antiScalar_antiDot_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_);
}

fn antiScalar_antiDot_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.y);
}

fn antiScalar_antiDot_motor(self_: AntiScalar, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn antiScalar_antiDot_multiVector(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.y);
}

fn antiScalar_antiDot_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.y);
}

fn antiScalar_antiDot_rotor(self_: AntiScalar, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn antiScalar_antiDot_translator(self_: AntiScalar, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_ * other.g0_.w);
}

fn dualNum_antiDot_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_);
}

fn dualNum_antiDot_dualNum(self_: DualNum, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y);
}

fn dualNum_antiDot_motor(self_: DualNum, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w);
}

fn dualNum_antiDot_multiVector(self_: DualNum, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y);
}

fn dualNum_antiDot_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y);
}

fn dualNum_antiDot_rotor(self_: DualNum, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w);
}

fn dualNum_antiDot_translator(self_: DualNum, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w);
}

fn flector_antiDot_flector(self_: Flector, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.w + self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z);
}

fn flector_antiDot_multiVector(self_: Flector, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g1_.w + self_.g1_.x * other.g4_.x + self_.g1_.y * other.g4_.y + self_.g1_.z * other.g4_.z);
}

fn flector_antiDot_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.x + self_.g1_.x * other.g2_.x + self_.g1_.y * other.g2_.y + self_.g1_.z * other.g2_.z);
}

fn flector_antiDot_origin(self_: Flector, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_);
}

fn flector_antiDot_plane(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn flector_antiDot_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn flector_antiDot_point(self_: Flector, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn flector_antiDot_transflector(self_: Flector, other: Transflector) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z);
}

fn line_antiDot_line(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_antiDot_lineAtOrigin(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_antiDot_motor(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn line_antiDot_multiVector(self_: Line, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g2_.x - self_.g0_.y * other.g2_.y - self_.g0_.z * other.g2_.z);
}

fn line_antiDot_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn line_antiDot_rotor(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_antiDot_line(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_antiDot_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_antiDot_motor(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtOrigin_antiDot_multiVector(self_: LineAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g2_.x - self_.g0_.y * other.g2_.y - self_.g0_.z * other.g2_.z);
}

fn lineAtOrigin_antiDot_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtOrigin_antiDot_rotor(self_: LineAtOrigin, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_antiDot_antiScalar(self_: Motor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn motor_antiDot_dualNum(self_: Motor, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.y);
}

fn motor_antiDot_line(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_antiDot_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_antiDot_motor(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn motor_antiDot_multiVector(self_: Motor, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g2_.x - self_.g0_.y * other.g2_.y - self_.g0_.z * other.g2_.z + self_.g0_.w * other.g0_.y);
}

fn motor_antiDot_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z + self_.g0_.w * other.g0_.y);
}

fn motor_antiDot_rotor(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn motor_antiDot_translator(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.w);
}

fn multiVector_antiDot_antiScalar(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_);
}

fn multiVector_antiDot_dualNum(self_: MultiVector, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y);
}

fn multiVector_antiDot_flector(self_: MultiVector, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.w * other.g0_.w + self_.g4_.x * other.g1_.x + self_.g4_.y * other.g1_.y + self_.g4_.z * other.g1_.z);
}

fn multiVector_antiDot_line(self_: MultiVector, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g2_.x * other.g0_.x - self_.g2_.y * other.g0_.y - self_.g2_.z * other.g0_.z);
}

fn multiVector_antiDot_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g2_.x * other.g0_.x - self_.g2_.y * other.g0_.y - self_.g2_.z * other.g0_.z);
}

fn multiVector_antiDot_motor(self_: MultiVector, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w - self_.g2_.x * other.g0_.x - self_.g2_.y * other.g0_.y - self_.g2_.z * other.g0_.z);
}

fn multiVector_antiDot_multiVector(self_: MultiVector, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y - self_.g1_.w * other.g1_.w - self_.g2_.x * other.g2_.x - self_.g2_.y * other.g2_.y - self_.g2_.z * other.g2_.z + self_.g4_.x * other.g4_.x + self_.g4_.y * other.g4_.y + self_.g4_.z * other.g4_.z);
}

fn multiVector_antiDot_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y - self_.g1_.w * other.g0_.x - self_.g2_.x * other.g1_.x - self_.g2_.y * other.g1_.y - self_.g2_.z * other.g1_.z + self_.g4_.x * other.g2_.x + self_.g4_.y * other.g2_.y + self_.g4_.z * other.g2_.z);
}

fn multiVector_antiDot_origin(self_: MultiVector, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.w * other.g0_);
}

fn multiVector_antiDot_plane(self_: MultiVector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g4_.x * other.g0_.x + self_.g4_.y * other.g0_.y + self_.g4_.z * other.g0_.z);
}

fn multiVector_antiDot_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g4_.x * other.g0_.x + self_.g4_.y * other.g0_.y + self_.g4_.z * other.g0_.z);
}

fn multiVector_antiDot_point(self_: MultiVector, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.w * other.g0_.w);
}

fn multiVector_antiDot_rotor(self_: MultiVector, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w - self_.g2_.x * other.g0_.x - self_.g2_.y * other.g0_.y - self_.g2_.z * other.g0_.z);
}

fn multiVector_antiDot_transflector(self_: MultiVector, other: Transflector) -> AntiScalar {
    return AntiScalar(self_.g4_.x * other.g1_.x + self_.g4_.y * other.g1_.y + self_.g4_.z * other.g1_.z);
}

fn multiVector_antiDot_translator(self_: MultiVector, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w);
}

fn multiVectorAtOrigin_antiDot_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_);
}

fn multiVectorAtOrigin_antiDot_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.y);
}

fn multiVectorAtOrigin_antiDot_flector(self_: MultiVectorAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.w + self_.g2_.x * other.g1_.x + self_.g2_.y * other.g1_.y + self_.g2_.z * other.g1_.z);
}

fn multiVectorAtOrigin_antiDot_line(self_: MultiVectorAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn multiVectorAtOrigin_antiDot_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn multiVectorAtOrigin_antiDot_motor(self_: MultiVectorAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn multiVectorAtOrigin_antiDot_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.w + self_.g0_.y * other.g0_.y - self_.g1_.x * other.g2_.x - self_.g1_.y * other.g2_.y - self_.g1_.z * other.g2_.z + self_.g2_.x * other.g4_.x + self_.g2_.y * other.g4_.y + self_.g2_.z * other.g4_.z);
}

fn multiVectorAtOrigin_antiDot_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y - self_.g1_.x * other.g1_.x - self_.g1_.y * other.g1_.y - self_.g1_.z * other.g1_.z + self_.g2_.x * other.g2_.x + self_.g2_.y * other.g2_.y + self_.g2_.z * other.g2_.z);
}

fn multiVectorAtOrigin_antiDot_origin(self_: MultiVectorAtOrigin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_);
}

fn multiVectorAtOrigin_antiDot_plane(self_: MultiVectorAtOrigin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g2_.x * other.g0_.x + self_.g2_.y * other.g0_.y + self_.g2_.z * other.g0_.z);
}

fn multiVectorAtOrigin_antiDot_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g2_.x * other.g0_.x + self_.g2_.y * other.g0_.y + self_.g2_.z * other.g0_.z);
}

fn multiVectorAtOrigin_antiDot_point(self_: MultiVectorAtOrigin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.w);
}

fn multiVectorAtOrigin_antiDot_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn multiVectorAtOrigin_antiDot_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> AntiScalar {
    return AntiScalar(self_.g2_.x * other.g1_.x + self_.g2_.y * other.g1_.y + self_.g2_.z * other.g1_.z);
}

fn multiVectorAtOrigin_antiDot_translator(self_: MultiVectorAtOrigin, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.y * other.g0_.w);
}

fn origin_antiDot_flector(self_: Origin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.w);
}

fn origin_antiDot_multiVector(self_: Origin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g1_.w);
}

fn origin_antiDot_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.x);
}

fn origin_antiDot_origin(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_);
}

fn origin_antiDot_point(self_: Origin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_ * other.g0_.w);
}

fn plane_antiDot_flector(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn plane_antiDot_multiVector(self_: Plane, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g4_.x + self_.g0_.y * other.g4_.y + self_.g0_.z * other.g4_.z);
}

fn plane_antiDot_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g2_.x + self_.g0_.y * other.g2_.y + self_.g0_.z * other.g2_.z);
}

fn plane_antiDot_plane(self_: Plane, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn plane_antiDot_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn plane_antiDot_transflector(self_: Plane, other: Transflector) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn planeAtOrigin_antiDot_flector(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn planeAtOrigin_antiDot_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g4_.x + self_.g0_.y * other.g4_.y + self_.g0_.z * other.g4_.z);
}

fn planeAtOrigin_antiDot_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g2_.x + self_.g0_.y * other.g2_.y + self_.g0_.z * other.g2_.z);
}

fn planeAtOrigin_antiDot_plane(self_: PlaneAtOrigin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_antiDot_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn planeAtOrigin_antiDot_transflector(self_: PlaneAtOrigin, other: Transflector) -> AntiScalar {
    return AntiScalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn point_antiDot_flector(self_: Point, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn point_antiDot_multiVector(self_: Point, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g1_.w);
}

fn point_antiDot_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.x);
}

fn point_antiDot_origin(self_: Point, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_);
}

fn point_antiDot_point(self_: Point, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn rotor_antiDot_antiScalar(self_: Rotor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn rotor_antiDot_dualNum(self_: Rotor, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.y);
}

fn rotor_antiDot_line(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn rotor_antiDot_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn rotor_antiDot_motor(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn rotor_antiDot_multiVector(self_: Rotor, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g2_.x - self_.g0_.y * other.g2_.y - self_.g0_.z * other.g2_.z + self_.g0_.w * other.g0_.y);
}

fn rotor_antiDot_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z + self_.g0_.w * other.g0_.y);
}

fn rotor_antiDot_rotor(self_: Rotor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z + self_.g0_.w * other.g0_.w);
}

fn rotor_antiDot_translator(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.w);
}

fn transflector_antiDot_flector(self_: Transflector, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z);
}

fn transflector_antiDot_multiVector(self_: Transflector, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g4_.x + self_.g1_.y * other.g4_.y + self_.g1_.z * other.g4_.z);
}

fn transflector_antiDot_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g2_.x + self_.g1_.y * other.g2_.y + self_.g1_.z * other.g2_.z);
}

fn transflector_antiDot_plane(self_: Transflector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn transflector_antiDot_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn transflector_antiDot_transflector(self_: Transflector, other: Transflector) -> AntiScalar {
    return AntiScalar(self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z);
}

fn translator_antiDot_antiScalar(self_: Translator, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_);
}

fn translator_antiDot_dualNum(self_: Translator, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.y);
}

fn translator_antiDot_motor(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.w);
}

fn translator_antiDot_multiVector(self_: Translator, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.y);
}

fn translator_antiDot_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.y);
}

fn translator_antiDot_rotor(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.w);
}

fn translator_antiDot_translator(self_: Translator, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.w * other.g0_.w);
}

fn dualNum_dot_dualNum(self_: DualNum, other: DualNum) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x);
}

fn dualNum_dot_multiVector(self_: DualNum, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x);
}

fn dualNum_dot_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x);
}

fn dualNum_dot_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_);
}

fn flector_dot_flector(self_: Flector, other: Flector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g1_.w * other.g1_.w);
}

fn flector_dot_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g1_.w * other.g0_.w);
}

fn flector_dot_horizon(self_: Flector, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g1_.w * other.g0_);
}

fn flector_dot_multiVector(self_: Flector, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z - self_.g1_.w * other.g4_.w);
}

fn flector_dot_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z - self_.g1_.w * other.g0_.y);
}

fn flector_dot_plane(self_: Flector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g1_.w * other.g0_.w);
}

fn flector_dot_point(self_: Flector, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flector_dot_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flector_dot_transflector(self_: Flector, other: Transflector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g1_.w * other.g1_.w);
}

fn flectorAtInfinity_dot_flector(self_: FlectorAtInfinity, other: Flector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g0_.w * other.g1_.w);
}

fn flectorAtInfinity_dot_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g0_.w * other.g0_.w);
}

fn flectorAtInfinity_dot_horizon(self_: FlectorAtInfinity, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_);
}

fn flectorAtInfinity_dot_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z - self_.g0_.w * other.g4_.w);
}

fn flectorAtInfinity_dot_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z - self_.g0_.w * other.g0_.y);
}

fn flectorAtInfinity_dot_plane(self_: FlectorAtInfinity, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn flectorAtInfinity_dot_point(self_: FlectorAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_dot_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn flectorAtInfinity_dot_transflector(self_: FlectorAtInfinity, other: Transflector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g0_.w * other.g1_.w);
}

fn horizon_dot_flector(self_: Horizon, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g1_.w);
}

fn horizon_dot_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.w);
}

fn horizon_dot_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_);
}

fn horizon_dot_multiVector(self_: Horizon, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g4_.w);
}

fn horizon_dot_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.y);
}

fn horizon_dot_plane(self_: Horizon, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g0_.w);
}

fn horizon_dot_transflector(self_: Horizon, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_ * other.g1_.w);
}

fn line_dot_line(self_: Line, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g1_.x - self_.g1_.y * other.g1_.y - self_.g1_.z * other.g1_.z);
}

fn line_dot_lineAtInfinity(self_: Line, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn line_dot_motor(self_: Line, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g1_.x - self_.g1_.y * other.g1_.y - self_.g1_.z * other.g1_.z);
}

fn line_dot_multiVector(self_: Line, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g3_.x - self_.g1_.y * other.g3_.y - self_.g1_.z * other.g3_.z);
}

fn line_dot_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g2_.x - self_.g1_.y * other.g2_.y - self_.g1_.z * other.g2_.z);
}

fn line_dot_translator(self_: Line, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn lineAtInfinity_dot_line(self_: LineAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtInfinity_dot_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn lineAtInfinity_dot_motor(self_: LineAtInfinity, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn lineAtInfinity_dot_multiVector(self_: LineAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g3_.x - self_.g0_.y * other.g3_.y - self_.g0_.z * other.g3_.z);
}

fn lineAtInfinity_dot_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g2_.x - self_.g0_.y * other.g2_.y - self_.g0_.z * other.g2_.z);
}

fn lineAtInfinity_dot_translator(self_: LineAtInfinity, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn motor_dot_line(self_: Motor, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g1_.x - self_.g1_.y * other.g1_.y - self_.g1_.z * other.g1_.z);
}

fn motor_dot_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn motor_dot_motor(self_: Motor, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g1_.x - self_.g1_.y * other.g1_.y - self_.g1_.z * other.g1_.z);
}

fn motor_dot_multiVector(self_: Motor, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g3_.x - self_.g1_.y * other.g3_.y - self_.g1_.z * other.g3_.z);
}

fn motor_dot_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g2_.x - self_.g1_.y * other.g2_.y - self_.g1_.z * other.g2_.z);
}

fn motor_dot_translator(self_: Motor, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g1_.x * other.g0_.x - self_.g1_.y * other.g0_.y - self_.g1_.z * other.g0_.z);
}

fn multiVector_dot_dualNum(self_: MultiVector, other: DualNum) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x);
}

fn multiVector_dot_flector(self_: MultiVector, other: Flector) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z - self_.g4_.w * other.g1_.w);
}

fn multiVector_dot_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z - self_.g4_.w * other.g0_.w);
}

fn multiVector_dot_horizon(self_: MultiVector, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g4_.w * other.g0_);
}

fn multiVector_dot_line(self_: MultiVector, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g3_.x * other.g1_.x - self_.g3_.y * other.g1_.y - self_.g3_.z * other.g1_.z);
}

fn multiVector_dot_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g3_.x * other.g0_.x - self_.g3_.y * other.g0_.y - self_.g3_.z * other.g0_.z);
}

fn multiVector_dot_motor(self_: MultiVector, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g3_.x * other.g1_.x - self_.g3_.y * other.g1_.y - self_.g3_.z * other.g1_.z);
}

fn multiVector_dot_multiVector(self_: MultiVector, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z - self_.g3_.x * other.g3_.x - self_.g3_.y * other.g3_.y - self_.g3_.z * other.g3_.z - self_.g4_.w * other.g4_.w);
}

fn multiVector_dot_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z - self_.g3_.x * other.g2_.x - self_.g3_.y * other.g2_.y - self_.g3_.z * other.g2_.z - self_.g4_.w * other.g0_.y);
}

fn multiVector_dot_plane(self_: MultiVector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g4_.w * other.g0_.w);
}

fn multiVector_dot_point(self_: MultiVector, other: Point) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVector_dot_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVector_dot_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_);
}

fn multiVector_dot_transflector(self_: MultiVector, other: Transflector) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z - self_.g4_.w * other.g1_.w);
}

fn multiVector_dot_translator(self_: MultiVector, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g3_.x * other.g0_.x - self_.g3_.y * other.g0_.y - self_.g3_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x);
}

fn multiVectorAtInfinity_dot_flector(self_: MultiVectorAtInfinity, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_.y * other.g1_.w + self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.y * other.g0_.w + self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.y * other.g0_);
}

fn multiVectorAtInfinity_dot_line(self_: MultiVectorAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g2_.x * other.g1_.x - self_.g2_.y * other.g1_.y - self_.g2_.z * other.g1_.z);
}

fn multiVectorAtInfinity_dot_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g2_.x * other.g0_.x - self_.g2_.y * other.g0_.y - self_.g2_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_motor(self_: MultiVectorAtInfinity, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g2_.x * other.g1_.x - self_.g2_.y * other.g1_.y - self_.g2_.z * other.g1_.z);
}

fn multiVectorAtInfinity_dot_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x - self_.g0_.y * other.g4_.w + self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z - self_.g2_.x * other.g3_.x - self_.g2_.y * other.g3_.y - self_.g2_.z * other.g3_.z);
}

fn multiVectorAtInfinity_dot_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y + self_.g1_.x * other.g1_.x + self_.g1_.y * other.g1_.y + self_.g1_.z * other.g1_.z - self_.g2_.x * other.g2_.x - self_.g2_.y * other.g2_.y - self_.g2_.z * other.g2_.z);
}

fn multiVectorAtInfinity_dot_plane(self_: MultiVectorAtInfinity, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.y * other.g0_.w);
}

fn multiVectorAtInfinity_dot_point(self_: MultiVectorAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_);
}

fn multiVectorAtInfinity_dot_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_.y * other.g1_.w + self_.g1_.x * other.g0_.x + self_.g1_.y * other.g0_.y + self_.g1_.z * other.g0_.z);
}

fn multiVectorAtInfinity_dot_translator(self_: MultiVectorAtInfinity, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g2_.x * other.g0_.x - self_.g2_.y * other.g0_.y - self_.g2_.z * other.g0_.z);
}

fn plane_dot_flector(self_: Plane, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g1_.w);
}

fn plane_dot_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn plane_dot_horizon(self_: Plane, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_);
}

fn plane_dot_multiVector(self_: Plane, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g4_.w);
}

fn plane_dot_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.y);
}

fn plane_dot_plane(self_: Plane, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g0_.w);
}

fn plane_dot_transflector(self_: Plane, other: Transflector) -> Scalar {
    return Scalar(0.0 - self_.g0_.w * other.g1_.w);
}

fn point_dot_flector(self_: Point, other: Flector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn point_dot_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn point_dot_multiVector(self_: Point, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn point_dot_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn point_dot_point(self_: Point, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn point_dot_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn point_dot_transflector(self_: Point, other: Transflector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_dot_flector(self_: PointAtInfinity, other: Flector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_dot_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_dot_multiVector(self_: PointAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn pointAtInfinity_dot_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z);
}

fn pointAtInfinity_dot_point(self_: PointAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_dot_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn pointAtInfinity_dot_transflector(self_: PointAtInfinity, other: Transflector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn scalar_dot_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.x);
}

fn scalar_dot_multiVector(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.x);
}

fn scalar_dot_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_ * other.g0_.x);
}

fn scalar_dot_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0_ * other.g0_);
}

fn transflector_dot_flector(self_: Transflector, other: Flector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g1_.w * other.g1_.w);
}

fn transflector_dot_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g1_.w * other.g0_.w);
}

fn transflector_dot_horizon(self_: Transflector, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g1_.w * other.g0_);
}

fn transflector_dot_multiVector(self_: Transflector, other: MultiVector) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z - self_.g1_.w * other.g4_.w);
}

fn transflector_dot_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g1_.x + self_.g0_.y * other.g1_.y + self_.g0_.z * other.g1_.z - self_.g1_.w * other.g0_.y);
}

fn transflector_dot_plane(self_: Transflector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g1_.w * other.g0_.w);
}

fn transflector_dot_point(self_: Transflector, other: Point) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn transflector_dot_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z);
}

fn transflector_dot_transflector(self_: Transflector, other: Transflector) -> Scalar {
    return Scalar(self_.g0_.x * other.g0_.x + self_.g0_.y * other.g0_.y + self_.g0_.z * other.g0_.z - self_.g1_.w * other.g1_.w);
}

fn translator_dot_line(self_: Translator, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn translator_dot_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn translator_dot_motor(self_: Translator, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g1_.x - self_.g0_.y * other.g1_.y - self_.g0_.z * other.g1_.z);
}

fn translator_dot_multiVector(self_: Translator, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g3_.x - self_.g0_.y * other.g3_.y - self_.g0_.z * other.g3_.z);
}

fn translator_dot_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g2_.x - self_.g0_.y * other.g2_.y - self_.g0_.z * other.g2_.z);
}

fn translator_dot_translator(self_: Translator, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0_.x * other.g0_.x - self_.g0_.y * other.g0_.y - self_.g0_.z * other.g0_.z);
}

fn dualNum_bulk(self_: DualNum) -> Scalar {
    return Scalar(self_.g0_.x);
}

fn flector_bulk(self_: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g1_.w));
}

fn flectorAtInfinity_bulk(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return self_;
}

fn horizon_bulk(self_: Horizon) -> Horizon {
    return self_;
}

fn line_bulk(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(self_.g1_);
}

fn lineAtInfinity_bulk(self_: LineAtInfinity) -> LineAtInfinity {
    return self_;
}

fn motor_bulk(self_: Motor) -> LineAtInfinity {
    return LineAtInfinity(self_.g1_);
}

fn multiVector_bulk(self_: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.x, self_.g4_.w), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z), self_.g3_);
}

fn multiVectorAtInfinity_bulk(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return self_;
}

fn plane_bulk(self_: Plane) -> Horizon {
    return Horizon(self_.g0_.w);
}

fn point_bulk(self_: Point) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn pointAtInfinity_bulk(self_: PointAtInfinity) -> PointAtInfinity {
    return self_;
}

fn scalar_bulk(self_: Scalar) -> Scalar {
    return self_;
}

fn transflector_bulk(self_: Transflector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, self_.g1_.w));
}

fn translator_bulk(self_: Translator) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn antiScalar_weight(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn dualNum_weight(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.y);
}

fn flector_weight(self_: Flector) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(0.0, 0.0, 0.0, 1.0), self_.g1_ * vec4<f32>(1.0, 1.0, 1.0, 0.0));
}

fn line_weight(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_);
}

fn lineAtOrigin_weight(self_: LineAtOrigin) -> LineAtOrigin {
    return self_;
}

fn motor_weight(self_: Motor) -> Rotor {
    return Rotor(self_.g0_);
}

fn multiVector_weight(self_: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(self_.g1_.w, self_.g0_.y), self_.g2_, vec3<f32>(self_.g4_.x, self_.g4_.y, self_.g4_.z));
}

fn multiVectorAtOrigin_weight(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return self_;
}

fn origin_weight(self_: Origin) -> Origin {
    return self_;
}

fn plane_weight(self_: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn planeAtOrigin_weight(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return self_;
}

fn point_weight(self_: Point) -> Origin {
    return Origin(self_.g0_.w);
}

fn rotor_weight(self_: Rotor) -> Rotor {
    return self_;
}

fn transflector_weight(self_: Transflector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z));
}

fn translator_weight(self_: Translator) -> AntiScalar {
    return AntiScalar(self_.g0_.w);
}

fn flector_antiDual(self_: Flector) -> FlectorAtInfinity {
    return FlectorAtInfinity(vec4<f32>(-self_.g1_.x, -self_.g1_.y, -self_.g1_.z, self_.g0_.w));
}

fn line_antiDual(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_antiDual(self_: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_antiDual(self_: Motor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn multiVector_antiDual(self_: MultiVector) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g1_.w), vec3<f32>(-self_.g4_.x, self_.g4_.y, self_.g4_.z), self_.g2_ * vec3<f32>(-1.0));
}

fn multiVectorAtOrigin_antiDual(self_: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0, self_.g0_.x), self_.g2_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn origin_antiDual(self_: Origin) -> Horizon {
    return Horizon(self_.g0_);
}

fn plane_antiDual(self_: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn planeAtOrigin_antiDual(self_: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn point_antiDual(self_: Point) -> Horizon {
    return Horizon(self_.g0_.w);
}

fn rotor_antiDual(self_: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn transflector_antiDual(self_: Transflector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(-self_.g1_.x, self_.g1_.y, self_.g1_.z));
}

fn antiScalar_antiReversal(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn dualNum_antiReversal(self_: DualNum) -> DualNum {
    return self_;
}

fn flector_antiReversal(self_: Flector) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(-1.0), self_.g1_);
}

fn flectorAtInfinity_antiReversal(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn horizon_antiReversal(self_: Horizon) -> Horizon {
    return self_;
}

fn line_antiReversal(self_: Line) -> Line {
    return Line(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_antiReversal(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_antiReversal(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_antiReversal(self_: Motor) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn multiVector_antiReversal(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ * vec4<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0), self_.g3_ * vec3<f32>(-1.0), self_.g4_);
}

fn multiVectorAtInfinity_antiReversal(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_, self_.g1_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0));
}

fn multiVectorAtOrigin_antiReversal(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(-1.0, 1.0), self_.g1_ * vec3<f32>(-1.0), self_.g2_);
}

fn origin_antiReversal(self_: Origin) -> Origin {
    return Origin(-self_.g0_);
}

fn plane_antiReversal(self_: Plane) -> Plane {
    return self_;
}

fn planeAtOrigin_antiReversal(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return self_;
}

fn point_antiReversal(self_: Point) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn pointAtInfinity_antiReversal(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn rotor_antiReversal(self_: Rotor) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn scalar_antiReversal(self_: Scalar) -> Scalar {
    return self_;
}

fn transflector_antiReversal(self_: Transflector) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(-1.0), self_.g1_);
}

fn translator_antiReversal(self_: Translator) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn antiScalar_automorphism(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn dualNum_automorphism(self_: DualNum) -> DualNum {
    return self_;
}

fn flector_automorphism(self_: Flector) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0));
}

fn flectorAtInfinity_automorphism(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(-1.0));
}

fn horizon_automorphism(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0_);
}

fn line_automorphism(self_: Line) -> Line {
    return self_;
}

fn lineAtInfinity_automorphism(self_: LineAtInfinity) -> LineAtInfinity {
    return self_;
}

fn lineAtOrigin_automorphism(self_: LineAtOrigin) -> LineAtOrigin {
    return self_;
}

fn motor_automorphism(self_: Motor) -> Motor {
    return self_;
}

fn multiVector_automorphism(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ * vec4<f32>(-1.0), self_.g2_, self_.g3_, self_.g4_ * vec4<f32>(-1.0));
}

fn multiVectorAtInfinity_automorphism(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(1.0, -1.0), self_.g1_ * vec3<f32>(-1.0), self_.g2_);
}

fn multiVectorAtOrigin_automorphism(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(-1.0, 1.0), self_.g1_, self_.g2_ * vec3<f32>(-1.0));
}

fn origin_automorphism(self_: Origin) -> Origin {
    return Origin(-self_.g0_);
}

fn plane_automorphism(self_: Plane) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(-1.0));
}

fn planeAtOrigin_automorphism(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn point_automorphism(self_: Point) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn pointAtInfinity_automorphism(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn rotor_automorphism(self_: Rotor) -> Rotor {
    return self_;
}

fn scalar_automorphism(self_: Scalar) -> Scalar {
    return self_;
}

fn transflector_automorphism(self_: Transflector) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0));
}

fn translator_automorphism(self_: Translator) -> Translator {
    return self_;
}

fn antiScalar_conjugation(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn dualNum_conjugation(self_: DualNum) -> DualNum {
    return self_;
}

fn flector_conjugation(self_: Flector) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(-1.0), self_.g1_);
}

fn flectorAtInfinity_conjugation(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn horizon_conjugation(self_: Horizon) -> Horizon {
    return self_;
}

fn line_conjugation(self_: Line) -> Line {
    return Line(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_conjugation(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_conjugation(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_conjugation(self_: Motor) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn multiVector_conjugation(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ * vec4<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0), self_.g3_ * vec3<f32>(-1.0), self_.g4_);
}

fn multiVectorAtInfinity_conjugation(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_, self_.g1_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0));
}

fn multiVectorAtOrigin_conjugation(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(-1.0, 1.0), self_.g1_ * vec3<f32>(-1.0), self_.g2_);
}

fn origin_conjugation(self_: Origin) -> Origin {
    return Origin(-self_.g0_);
}

fn plane_conjugation(self_: Plane) -> Plane {
    return self_;
}

fn planeAtOrigin_conjugation(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return self_;
}

fn point_conjugation(self_: Point) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn pointAtInfinity_conjugation(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn rotor_conjugation(self_: Rotor) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn scalar_conjugation(self_: Scalar) -> Scalar {
    return self_;
}

fn transflector_conjugation(self_: Transflector) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(-1.0), self_.g1_);
}

fn translator_conjugation(self_: Translator) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn antiScalar_doubleComplement(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn dualNum_doubleComplement(self_: DualNum) -> DualNum {
    return self_;
}

fn flector_doubleComplement(self_: Flector) -> Flector {
    return Flector(self_.g0_ * vec4<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0));
}

fn flectorAtInfinity_doubleComplement(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(-1.0));
}

fn horizon_doubleComplement(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0_);
}

fn line_doubleComplement(self_: Line) -> Line {
    return self_;
}

fn lineAtInfinity_doubleComplement(self_: LineAtInfinity) -> LineAtInfinity {
    return self_;
}

fn lineAtOrigin_doubleComplement(self_: LineAtOrigin) -> LineAtOrigin {
    return self_;
}

fn motor_doubleComplement(self_: Motor) -> Motor {
    return self_;
}

fn multiVector_doubleComplement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_ * vec4<f32>(-1.0), self_.g2_, self_.g3_, self_.g4_ * vec4<f32>(-1.0));
}

fn multiVectorAtInfinity_doubleComplement(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(1.0, -1.0), self_.g1_ * vec3<f32>(-1.0), self_.g2_);
}

fn multiVectorAtOrigin_doubleComplement(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_ * vec2<f32>(-1.0, 1.0), self_.g1_, self_.g2_ * vec3<f32>(-1.0));
}

fn origin_doubleComplement(self_: Origin) -> Origin {
    return Origin(-self_.g0_);
}

fn plane_doubleComplement(self_: Plane) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(-1.0));
}

fn planeAtOrigin_doubleComplement(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn point_doubleComplement(self_: Point) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn pointAtInfinity_doubleComplement(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn rotor_doubleComplement(self_: Rotor) -> Rotor {
    return self_;
}

fn scalar_doubleComplement(self_: Scalar) -> Scalar {
    return self_;
}

fn transflector_doubleComplement(self_: Transflector) -> Transflector {
    return Transflector(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec4<f32>(-1.0));
}

fn translator_doubleComplement(self_: Translator) -> Translator {
    return self_;
}

fn dualNum_dual(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.g0_.x);
}

fn flector_dual(self_: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, -self_.g1_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn flectorAtInfinity_dual(self_: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, -self_.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn horizon_dual(self_: Horizon) -> Origin {
    return Origin(-self_.g0_);
}

fn line_dual(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_dual(self_: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_dual(self_: Motor) -> LineAtOrigin {
    return LineAtOrigin(self_.g1_ * vec3<f32>(-1.0));
}

fn multiVector_dual(self_: MultiVector) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(vec2<f32>(-self_.g4_.w, self_.g0_.x), self_.g3_ * vec3<f32>(-1.0), vec3<f32>(self_.g1_.x, self_.g1_.y, self_.g1_.z));
}

fn multiVectorAtInfinity_dual(self_: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-1.0, 1.0), self_.g2_ * vec3<f32>(-1.0), self_.g1_);
}

fn plane_dual(self_: Plane) -> Origin {
    return Origin(-self_.g0_.w);
}

fn point_dual(self_: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn pointAtInfinity_dual(self_: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_);
}

fn scalar_dual(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_);
}

fn transflector_dual(self_: Transflector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, -self_.g1_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn translator_dual(self_: Translator) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn antiScalar_leftComplement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0_);
}

fn dualNum_leftComplement(self_: DualNum) -> DualNum {
    return DualNum(self_.g0_.yx);
}

fn flector_leftComplement(self_: Flector) -> Flector {
    return Flector(self_.g1_ * vec4<f32>(-1.0), self_.g0_);
}

fn flectorAtInfinity_leftComplement(self_: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, -self_.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn horizon_leftComplement(self_: Horizon) -> Origin {
    return Origin(-self_.g0_);
}

fn line_leftComplement(self_: Line) -> Line {
    return Line(self_.g1_ * vec3<f32>(-1.0), self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_leftComplement(self_: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_leftComplement(self_: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_leftComplement(self_: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w, 0.0), vec4<f32>(0.0), self_.g1_ * vec3<f32>(-1.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn multiVector_leftComplement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_.yx, self_.g4_ * vec4<f32>(-1.0), self_.g3_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0), self_.g1_);
}

fn multiVectorAtInfinity_leftComplement(self_: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-1.0, 1.0), self_.g2_ * vec3<f32>(-1.0), self_.g1_);
}

fn multiVectorAtOrigin_leftComplement(self_: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx, self_.g2_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn origin_leftComplement(self_: Origin) -> Horizon {
    return Horizon(self_.g0_);
}

fn plane_leftComplement(self_: Plane) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn planeAtOrigin_leftComplement(self_: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn point_leftComplement(self_: Point) -> Plane {
    return Plane(self_.g0_);
}

fn pointAtInfinity_leftComplement(self_: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_);
}

fn rotor_leftComplement(self_: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn scalar_leftComplement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_);
}

fn transflector_leftComplement(self_: Transflector) -> Flector {
    return Flector(self_.g1_ * vec4<f32>(-1.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn translator_leftComplement(self_: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn antiScalar_reversal(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn dualNum_reversal(self_: DualNum) -> DualNum {
    return self_;
}

fn flector_reversal(self_: Flector) -> Flector {
    return Flector(self_.g0_, self_.g1_ * vec4<f32>(-1.0));
}

fn flectorAtInfinity_reversal(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return FlectorAtInfinity(self_.g0_ * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn horizon_reversal(self_: Horizon) -> Horizon {
    return Horizon(-self_.g0_);
}

fn line_reversal(self_: Line) -> Line {
    return Line(self_.g0_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_reversal(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_reversal(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_reversal(self_: Motor) -> Motor {
    return Motor(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn multiVector_reversal(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_, self_.g1_, self_.g2_ * vec3<f32>(-1.0), self_.g3_ * vec3<f32>(-1.0), self_.g4_ * vec4<f32>(-1.0));
}

fn multiVectorAtInfinity_reversal(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_ * vec2<f32>(1.0, -1.0), self_.g1_, self_.g2_ * vec3<f32>(-1.0));
}

fn multiVectorAtOrigin_reversal(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_, self_.g1_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0));
}

fn origin_reversal(self_: Origin) -> Origin {
    return self_;
}

fn plane_reversal(self_: Plane) -> Plane {
    return Plane(self_.g0_ * vec4<f32>(-1.0));
}

fn planeAtOrigin_reversal(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn point_reversal(self_: Point) -> Point {
    return self_;
}

fn pointAtInfinity_reversal(self_: PointAtInfinity) -> PointAtInfinity {
    return self_;
}

fn rotor_reversal(self_: Rotor) -> Rotor {
    return Rotor(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn scalar_reversal(self_: Scalar) -> Scalar {
    return self_;
}

fn transflector_reversal(self_: Transflector) -> Transflector {
    return Transflector(self_.g0_, self_.g1_ * vec4<f32>(-1.0));
}

fn translator_reversal(self_: Translator) -> Translator {
    return Translator(self_.g0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn antiScalar_rightComplement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0_);
}

fn dualNum_rightComplement(self_: DualNum) -> DualNum {
    return DualNum(self_.g0_.yx);
}

fn flector_rightComplement(self_: Flector) -> Flector {
    return Flector(self_.g1_ * vec4<f32>(-1.0), self_.g0_);
}

fn flectorAtInfinity_rightComplement(self_: FlectorAtInfinity) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, -self_.g0_.w), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn horizon_rightComplement(self_: Horizon) -> Origin {
    return Origin(-self_.g0_);
}

fn line_rightComplement(self_: Line) -> Line {
    return Line(self_.g1_ * vec3<f32>(-1.0), self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtInfinity_rightComplement(self_: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(self_.g0_ * vec3<f32>(-1.0));
}

fn lineAtOrigin_rightComplement(self_: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn motor_rightComplement(self_: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w, 0.0), vec4<f32>(0.0), self_.g1_ * vec3<f32>(-1.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z), vec4<f32>(0.0));
}

fn multiVector_rightComplement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0_.yx, self_.g4_ * vec4<f32>(-1.0), self_.g3_ * vec3<f32>(-1.0), self_.g2_ * vec3<f32>(-1.0), self_.g1_);
}

fn multiVectorAtInfinity_rightComplement(self_: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return MultiVectorAtOrigin(self_.g0_.yx * vec2<f32>(-1.0, 1.0), self_.g2_ * vec3<f32>(-1.0), self_.g1_);
}

fn multiVectorAtOrigin_rightComplement(self_: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(self_.g0_.yx, self_.g2_ * vec3<f32>(-1.0), self_.g1_ * vec3<f32>(-1.0));
}

fn origin_rightComplement(self_: Origin) -> Horizon {
    return Horizon(self_.g0_);
}

fn plane_rightComplement(self_: Plane) -> Point {
    return Point(self_.g0_ * vec4<f32>(-1.0));
}

fn planeAtOrigin_rightComplement(self_: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0_ * vec3<f32>(-1.0));
}

fn point_rightComplement(self_: Point) -> Plane {
    return Plane(self_.g0_);
}

fn pointAtInfinity_rightComplement(self_: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0_);
}

fn rotor_rightComplement(self_: Rotor) -> MultiVectorAtInfinity {
    return MultiVectorAtInfinity(vec2<f32>(self_.g0_.w, 0.0), vec3<f32>(0.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z));
}

fn scalar_rightComplement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0_);
}

fn transflector_rightComplement(self_: Transflector) -> Flector {
    return Flector(self_.g1_ * vec4<f32>(-1.0), vec4<f32>(self_.g0_.x, self_.g0_.y, self_.g0_.z, 0.0));
}

fn translator_rightComplement(self_: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0_.w, 0.0), vec4<f32>(0.0), vec3<f32>(-self_.g0_.x, self_.g0_.y, self_.g0_.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn dualNum_leftBulkDual(self_: DualNum) -> AntiScalar {
    return scalar_leftComplement(dualNum_bulk(self_));
}

fn flector_leftBulkDual(self_: Flector) -> Flector {
    return flectorAtInfinity_leftComplement(flector_bulk(self_));
}

fn flectorAtInfinity_leftBulkDual(self_: FlectorAtInfinity) -> Flector {
    return flectorAtInfinity_leftComplement(flectorAtInfinity_bulk(self_));
}

fn horizon_leftBulkDual(self_: Horizon) -> Origin {
    return horizon_leftComplement(horizon_bulk(self_));
}

fn line_leftBulkDual(self_: Line) -> LineAtOrigin {
    return lineAtInfinity_leftComplement(line_bulk(self_));
}

fn lineAtInfinity_leftBulkDual(self_: LineAtInfinity) -> LineAtOrigin {
    return lineAtInfinity_leftComplement(lineAtInfinity_bulk(self_));
}

fn motor_leftBulkDual(self_: Motor) -> LineAtOrigin {
    return lineAtInfinity_leftComplement(motor_bulk(self_));
}

fn multiVector_leftBulkDual(self_: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_leftComplement(multiVector_bulk(self_));
}

fn multiVectorAtInfinity_leftBulkDual(self_: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_leftComplement(multiVectorAtInfinity_bulk(self_));
}

fn plane_leftBulkDual(self_: Plane) -> Origin {
    return horizon_leftComplement(plane_bulk(self_));
}

fn point_leftBulkDual(self_: Point) -> PlaneAtOrigin {
    return pointAtInfinity_leftComplement(point_bulk(self_));
}

fn pointAtInfinity_leftBulkDual(self_: PointAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_leftComplement(pointAtInfinity_bulk(self_));
}

fn scalar_leftBulkDual(self_: Scalar) -> AntiScalar {
    return scalar_leftComplement(scalar_bulk(self_));
}

fn transflector_leftBulkDual(self_: Transflector) -> Flector {
    return flectorAtInfinity_leftComplement(transflector_bulk(self_));
}

fn translator_leftBulkDual(self_: Translator) -> LineAtOrigin {
    return lineAtInfinity_leftComplement(translator_bulk(self_));
}

fn antiScalar_leftWeightDual(self_: AntiScalar) -> Scalar {
    return antiScalar_leftComplement(antiScalar_weight(self_));
}

fn dualNum_leftWeightDual(self_: DualNum) -> Scalar {
    return antiScalar_leftComplement(dualNum_weight(self_));
}

fn flector_leftWeightDual(self_: Flector) -> Flector {
    return flector_leftComplement(flector_weight(self_));
}

fn line_leftWeightDual(self_: Line) -> LineAtInfinity {
    return lineAtOrigin_leftComplement(line_weight(self_));
}

fn lineAtOrigin_leftWeightDual(self_: LineAtOrigin) -> LineAtInfinity {
    return lineAtOrigin_leftComplement(lineAtOrigin_weight(self_));
}

fn motor_leftWeightDual(self_: Motor) -> MultiVectorAtInfinity {
    return rotor_leftComplement(motor_weight(self_));
}

fn multiVector_leftWeightDual(self_: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_leftComplement(multiVector_weight(self_));
}

fn multiVectorAtOrigin_leftWeightDual(self_: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_leftComplement(multiVectorAtOrigin_weight(self_));
}

fn origin_leftWeightDual(self_: Origin) -> Horizon {
    return origin_leftComplement(origin_weight(self_));
}

fn plane_leftWeightDual(self_: Plane) -> PointAtInfinity {
    return planeAtOrigin_leftComplement(plane_weight(self_));
}

fn planeAtOrigin_leftWeightDual(self_: PlaneAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_leftComplement(planeAtOrigin_weight(self_));
}

fn point_leftWeightDual(self_: Point) -> Horizon {
    return origin_leftComplement(point_weight(self_));
}

fn rotor_leftWeightDual(self_: Rotor) -> MultiVectorAtInfinity {
    return rotor_leftComplement(rotor_weight(self_));
}

fn transflector_leftWeightDual(self_: Transflector) -> PointAtInfinity {
    return planeAtOrigin_leftComplement(transflector_weight(self_));
}

fn translator_leftWeightDual(self_: Translator) -> Scalar {
    return antiScalar_leftComplement(translator_weight(self_));
}

fn dualNum_rightBulkDual(self_: DualNum) -> AntiScalar {
    return scalar_rightComplement(dualNum_bulk(self_));
}

fn flector_rightBulkDual(self_: Flector) -> Flector {
    return flectorAtInfinity_rightComplement(flector_bulk(self_));
}

fn flectorAtInfinity_rightBulkDual(self_: FlectorAtInfinity) -> Flector {
    return flectorAtInfinity_rightComplement(flectorAtInfinity_bulk(self_));
}

fn horizon_rightBulkDual(self_: Horizon) -> Origin {
    return horizon_rightComplement(horizon_bulk(self_));
}

fn line_rightBulkDual(self_: Line) -> LineAtOrigin {
    return lineAtInfinity_rightComplement(line_bulk(self_));
}

fn lineAtInfinity_rightBulkDual(self_: LineAtInfinity) -> LineAtOrigin {
    return lineAtInfinity_rightComplement(lineAtInfinity_bulk(self_));
}

fn motor_rightBulkDual(self_: Motor) -> LineAtOrigin {
    return lineAtInfinity_rightComplement(motor_bulk(self_));
}

fn multiVector_rightBulkDual(self_: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_rightComplement(multiVector_bulk(self_));
}

fn multiVectorAtInfinity_rightBulkDual(self_: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_rightComplement(multiVectorAtInfinity_bulk(self_));
}

fn plane_rightBulkDual(self_: Plane) -> Origin {
    return horizon_rightComplement(plane_bulk(self_));
}

fn point_rightBulkDual(self_: Point) -> PlaneAtOrigin {
    return pointAtInfinity_rightComplement(point_bulk(self_));
}

fn pointAtInfinity_rightBulkDual(self_: PointAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_rightComplement(pointAtInfinity_bulk(self_));
}

fn scalar_rightBulkDual(self_: Scalar) -> AntiScalar {
    return scalar_rightComplement(scalar_bulk(self_));
}

fn transflector_rightBulkDual(self_: Transflector) -> Flector {
    return flectorAtInfinity_rightComplement(transflector_bulk(self_));
}

fn translator_rightBulkDual(self_: Translator) -> LineAtOrigin {
    return lineAtInfinity_rightComplement(translator_bulk(self_));
}

fn antiScalar_rightWeightDual(self_: AntiScalar) -> Scalar {
    return antiScalar_rightComplement(antiScalar_weight(self_));
}

fn dualNum_rightWeightDual(self_: DualNum) -> Scalar {
    return antiScalar_rightComplement(dualNum_weight(self_));
}

fn flector_rightWeightDual(self_: Flector) -> Flector {
    return flector_rightComplement(flector_weight(self_));
}

fn line_rightWeightDual(self_: Line) -> LineAtInfinity {
    return lineAtOrigin_rightComplement(line_weight(self_));
}

fn lineAtOrigin_rightWeightDual(self_: LineAtOrigin) -> LineAtInfinity {
    return lineAtOrigin_rightComplement(lineAtOrigin_weight(self_));
}

fn motor_rightWeightDual(self_: Motor) -> MultiVectorAtInfinity {
    return rotor_rightComplement(motor_weight(self_));
}

fn multiVector_rightWeightDual(self_: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_rightComplement(multiVector_weight(self_));
}

fn multiVectorAtOrigin_rightWeightDual(self_: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_rightComplement(multiVectorAtOrigin_weight(self_));
}

fn origin_rightWeightDual(self_: Origin) -> Horizon {
    return origin_rightComplement(origin_weight(self_));
}

fn plane_rightWeightDual(self_: Plane) -> PointAtInfinity {
    return planeAtOrigin_rightComplement(plane_weight(self_));
}

fn planeAtOrigin_rightWeightDual(self_: PlaneAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_rightComplement(planeAtOrigin_weight(self_));
}

fn point_rightWeightDual(self_: Point) -> Horizon {
    return origin_rightComplement(point_weight(self_));
}

fn rotor_rightWeightDual(self_: Rotor) -> MultiVectorAtInfinity {
    return rotor_rightComplement(rotor_weight(self_));
}

fn transflector_rightWeightDual(self_: Transflector) -> PointAtInfinity {
    return planeAtOrigin_rightComplement(transflector_weight(self_));
}

fn translator_rightWeightDual(self_: Translator) -> Scalar {
    return antiScalar_rightComplement(translator_weight(self_));
}

fn antiScalar_antiGrade() -> i32 {
    return 0;
}

fn horizon_antiGrade() -> i32 {
    return 1;
}

fn line_antiGrade() -> i32 {
    return 2;
}

fn lineAtInfinity_antiGrade() -> i32 {
    return 2;
}

fn lineAtOrigin_antiGrade() -> i32 {
    return 2;
}

fn origin_antiGrade() -> i32 {
    return 3;
}

fn plane_antiGrade() -> i32 {
    return 1;
}

fn planeAtOrigin_antiGrade() -> i32 {
    return 1;
}

fn point_antiGrade() -> i32 {
    return 3;
}

fn pointAtInfinity_antiGrade() -> i32 {
    return 3;
}

fn scalar_antiGrade() -> i32 {
    return 4;
}

fn antiScalar_grade() -> i32 {
    return 4;
}

fn horizon_grade() -> i32 {
    return 3;
}

fn line_grade() -> i32 {
    return 2;
}

fn lineAtInfinity_grade() -> i32 {
    return 2;
}

fn lineAtOrigin_grade() -> i32 {
    return 2;
}

fn origin_grade() -> i32 {
    return 1;
}

fn plane_grade() -> i32 {
    return 3;
}

fn planeAtOrigin_grade() -> i32 {
    return 3;
}

fn point_grade() -> i32 {
    return 1;
}

fn pointAtInfinity_grade() -> i32 {
    return 1;
}

fn scalar_grade() -> i32 {
    return 0;
}

fn antiScalar_antiSqrt(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(sqrt(self_.g0_));
}

fn dualNum_antiSqrt(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let sqrt_t: f32 = sqrt(t);
    return DualNum(vec2<f32>(s / (2.0 * sqrt_t), sqrt_t));
}

fn antiScalar_attitude(self_: AntiScalar) -> Horizon {
    return antiScalar_antiWedge_horizon(self_, horizon_unit());
}

fn dualNum_attitude(self_: DualNum) -> Horizon {
    return dualNum_antiWedge_horizon(self_, horizon_unit());
}

fn flector_attitude(self_: Flector) -> MultiVectorAtInfinity {
    return flector_antiWedge_horizon(self_, horizon_unit());
}

fn line_attitude(self_: Line) -> PointAtInfinity {
    return line_antiWedge_horizon(self_, horizon_unit());
}

fn lineAtOrigin_attitude(self_: LineAtOrigin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(self_, horizon_unit());
}

fn motor_attitude(self_: Motor) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(self_, horizon_unit());
}

fn multiVector_attitude(self_: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_horizon(self_, horizon_unit());
}

fn multiVectorAtOrigin_attitude(self_: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(self_, horizon_unit());
}

fn origin_attitude(self_: Origin) -> Scalar {
    return origin_antiWedge_horizon(self_, horizon_unit());
}

fn plane_attitude(self_: Plane) -> LineAtInfinity {
    return plane_antiWedge_horizon(self_, horizon_unit());
}

fn planeAtOrigin_attitude(self_: PlaneAtOrigin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(self_, horizon_unit());
}

fn point_attitude(self_: Point) -> Scalar {
    return point_antiWedge_horizon(self_, horizon_unit());
}

fn rotor_attitude(self_: Rotor) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(self_, horizon_unit());
}

fn transflector_attitude(self_: Transflector) -> LineAtInfinity {
    return transflector_antiWedge_horizon(self_, horizon_unit());
}

fn translator_attitude(self_: Translator) -> Horizon {
    return translator_antiWedge_horizon(self_, horizon_unit());
}

fn dualNum_sqrt(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let sqrt_s: f32 = sqrt(s);
    return DualNum(vec2<f32>(sqrt_s, t / (2.0 * sqrt_s)));
}

fn scalar_sqrt(self_: Scalar) -> Scalar {
    return Scalar(sqrt(self_.g0_));
}

fn antiScalar_antiInverse(self_: AntiScalar) -> AntiScalar {
    return antiScalar_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), antiScalar_antiDot_antiScalar(self_, self_)));
}

fn dualNum_antiInverse(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(-1.0 * s / (t * t), 1.0 / t));
}

fn flector_antiInverse(self_: Flector) -> Flector {
    return flector_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), flector_antiDot_flector(self_, self_)));
}

fn line_antiInverse(self_: Line) -> Line {
    return line_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), line_antiDot_line(self_, self_)));
}

fn lineAtOrigin_antiInverse(self_: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), lineAtOrigin_antiDot_lineAtOrigin(self_, self_)));
}

fn motor_antiInverse(self_: Motor) -> Motor {
    return motor_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), motor_antiDot_motor(self_, self_)));
}

fn multiVector_antiInverse(self_: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), multiVector_antiDot_multiVector(self_, self_)));
}

fn multiVectorAtOrigin_antiInverse(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), multiVectorAtOrigin_antiDot_multiVectorAtOrigin(self_, self_)));
}

fn origin_antiInverse(self_: Origin) -> Origin {
    return origin_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), origin_antiDot_origin(self_, self_)));
}

fn plane_antiInverse(self_: Plane) -> Plane {
    return plane_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), plane_antiDot_plane(self_, self_)));
}

fn planeAtOrigin_antiInverse(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), planeAtOrigin_antiDot_planeAtOrigin(self_, self_)));
}

fn point_antiInverse(self_: Point) -> Point {
    return point_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), point_antiDot_point(self_, self_)));
}

fn rotor_antiInverse(self_: Rotor) -> Rotor {
    return rotor_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), rotor_antiDot_rotor(self_, self_)));
}

fn transflector_antiInverse(self_: Transflector) -> Transflector {
    return transflector_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), transflector_antiDot_transflector(self_, self_)));
}

fn translator_antiInverse(self_: Translator) -> Translator {
    return translator_geometricAntiProduct_antiScalar(self_, antiScalar_div_antiScalar(antiScalar_unit(), translator_antiDot_translator(self_, self_)));
}

fn dualNum_inverse(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(1.0 / s, -1.0 * t / (s * s)));
}

fn flector_inverse(self_: Flector) -> Flector {
    return flector_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), flector_dot_flector(self_, self_)));
}

fn flectorAtInfinity_inverse(self_: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), flectorAtInfinity_dot_flectorAtInfinity(self_, self_)));
}

fn horizon_inverse(self_: Horizon) -> Horizon {
    return horizon_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), horizon_dot_horizon(self_, self_)));
}

fn line_inverse(self_: Line) -> Line {
    return line_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), line_dot_line(self_, self_)));
}

fn lineAtInfinity_inverse(self_: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), lineAtInfinity_dot_lineAtInfinity(self_, self_)));
}

fn motor_inverse(self_: Motor) -> Motor {
    return motor_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), motor_dot_motor(self_, self_)));
}

fn multiVector_inverse(self_: MultiVector) -> MultiVector {
    return multiVector_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), multiVector_dot_multiVector(self_, self_)));
}

fn multiVectorAtInfinity_inverse(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), multiVectorAtInfinity_dot_multiVectorAtInfinity(self_, self_)));
}

fn plane_inverse(self_: Plane) -> Plane {
    return plane_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), plane_dot_plane(self_, self_)));
}

fn point_inverse(self_: Point) -> Point {
    return point_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), point_dot_point(self_, self_)));
}

fn pointAtInfinity_inverse(self_: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), pointAtInfinity_dot_pointAtInfinity(self_, self_)));
}

fn scalar_inverse(self_: Scalar) -> Scalar {
    return scalar_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), scalar_dot_scalar(self_, self_)));
}

fn transflector_inverse(self_: Transflector) -> Transflector {
    return transflector_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), transflector_dot_transflector(self_, self_)));
}

fn translator_inverse(self_: Translator) -> Translator {
    return translator_geometricProduct_scalar(self_, scalar_div_scalar(scalar_unit(), translator_dot_translator(self_, self_)));
}

fn dualNum_antiCos(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(-1.0 * s * sin(t), cos(t)));
}

fn antiScalar_antiCosh(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(cosh(self_.g0_));
}

fn dualNum_antiCosh(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(s * sinh(t), cosh(t)));
}

fn antiScalar_antiExp(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(exp(self_.g0_));
}

fn dualNum_antiExp(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let exp_t: f32 = exp(t);
    return DualNum(vec2<f32>(s * exp_t, exp_t));
}

fn antiScalar_antiInverseSqrt(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(1.0 / sqrt(self_.g0_));
}

fn dualNum_antiInverseSqrt(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let sqrt_t: f32 = sqrt(t);
    return DualNum(vec2<f32>(-1.0 * s / (2.0 * t * sqrt_t), 1.0 / sqrt_t));
}

fn antiScalar_antiPow(self_: AntiScalar, other: f32) -> AntiScalar {
    return AntiScalar(pow(self_.g0_, other));
}

fn dualNum_antiPow(self_: DualNum, other: f32) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(other * pow(t, other - 1.0) * s, pow(t, other)));
}

fn dualNum_antiSin(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(s * cos(t), sin(t)));
}

fn antiScalar_antiSinh(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(sinh(self_.g0_));
}

fn dualNum_antiSinh(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(s * cosh(t), sinh(t)));
}

fn dualNum_antiTan(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let tan_t: f32 = tan(t);
    return DualNum(vec2<f32>(s * (1.0 + tan_t * tan_t), tan_t));
}

fn antiScalar_antiTanh(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(tanh(self_.g0_));
}

fn dualNum_antiTanh(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let tanh_t: f32 = tanh(t);
    return DualNum(vec2<f32>(s * (1.0 - tanh_t * tanh_t), tanh_t));
}

fn dualNum_cos(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(cos(s), -1.0 * t * sin(s)));
}

fn dualNum_cosh(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(cosh(s), t * sinh(s)));
}

fn scalar_cosh(self_: Scalar) -> Scalar {
    return Scalar(cosh(self_.g0_));
}

fn dualNum_exp(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let exp_s: f32 = exp(s);
    return DualNum(vec2<f32>(exp_s, t * exp_s));
}

fn scalar_exp(self_: Scalar) -> Scalar {
    return Scalar(exp(self_.g0_));
}

fn dualNum_inverseSqrt(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let sqrt_s: f32 = sqrt(s);
    return DualNum(vec2<f32>(1.0 / sqrt_s, -1.0 * t / (2.0 * s * sqrt_s)));
}

fn scalar_inverseSqrt(self_: Scalar) -> Scalar {
    return Scalar(1.0 / sqrt(self_.g0_));
}

fn dualNum_pow(self_: DualNum, other: f32) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(pow(s, other), other * pow(s, other - 1.0) * t));
}

fn scalar_pow(self_: Scalar, other: f32) -> Scalar {
    return Scalar(pow(self_.g0_, other));
}

fn dualNum_sin(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(sin(s), t * cos(s)));
}

fn dualNum_sinh(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    return DualNum(vec2<f32>(sinh(s), t * cosh(s)));
}

fn scalar_sinh(self_: Scalar) -> Scalar {
    return Scalar(sinh(self_.g0_));
}

fn dualNum_tan(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let tan_s: f32 = tan(s);
    return DualNum(vec2<f32>(tan_s, t * (1.0 + tan_s * tan_s)));
}

fn dualNum_tanh(self_: DualNum) -> DualNum {
    let s: f32 = self_.g0_.x;
    let t: f32 = self_.g0_.y;
    let tanh_s: f32 = tanh(s);
    return DualNum(vec2<f32>(tanh_s, t * (1.0 - tanh_s * tanh_s)));
}

fn scalar_tanh(self_: Scalar) -> Scalar {
    return Scalar(tanh(self_.g0_));
}

fn dualNum_bulkNormSquared(self_: DualNum) -> Scalar {
    let flat_bulk_thing: Scalar = dualNum_bulk(self_);
    return scalar_dot_scalar(flat_bulk_thing, flat_bulk_thing);
}

fn flector_bulkNormSquared(self_: Flector) -> Scalar {
    let flat_bulk_thing: FlectorAtInfinity = flector_bulk(self_);
    return flectorAtInfinity_dot_flectorAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn flectorAtInfinity_bulkNormSquared(self_: FlectorAtInfinity) -> Scalar {
    let flat_bulk_thing: FlectorAtInfinity = flectorAtInfinity_bulk(self_);
    return flectorAtInfinity_dot_flectorAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn horizon_bulkNormSquared(self_: Horizon) -> Scalar {
    let flat_bulk_thing: Horizon = horizon_bulk(self_);
    return horizon_dot_horizon(flat_bulk_thing, flat_bulk_thing);
}

fn line_bulkNormSquared(self_: Line) -> Scalar {
    let flat_bulk_thing: LineAtInfinity = line_bulk(self_);
    return lineAtInfinity_dot_lineAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn lineAtInfinity_bulkNormSquared(self_: LineAtInfinity) -> Scalar {
    let flat_bulk_thing: LineAtInfinity = lineAtInfinity_bulk(self_);
    return lineAtInfinity_dot_lineAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn motor_bulkNormSquared(self_: Motor) -> Scalar {
    let flat_bulk_thing: LineAtInfinity = motor_bulk(self_);
    return lineAtInfinity_dot_lineAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn multiVector_bulkNormSquared(self_: MultiVector) -> Scalar {
    let flat_bulk_thing: MultiVectorAtInfinity = multiVector_bulk(self_);
    return multiVectorAtInfinity_dot_multiVectorAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn multiVectorAtInfinity_bulkNormSquared(self_: MultiVectorAtInfinity) -> Scalar {
    let flat_bulk_thing: MultiVectorAtInfinity = multiVectorAtInfinity_bulk(self_);
    return multiVectorAtInfinity_dot_multiVectorAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn plane_bulkNormSquared(self_: Plane) -> Scalar {
    let flat_bulk_thing: Horizon = plane_bulk(self_);
    return horizon_dot_horizon(flat_bulk_thing, flat_bulk_thing);
}

fn point_bulkNormSquared(self_: Point) -> Scalar {
    let flat_bulk_thing: PointAtInfinity = point_bulk(self_);
    return pointAtInfinity_dot_pointAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn pointAtInfinity_bulkNormSquared(self_: PointAtInfinity) -> Scalar {
    let flat_bulk_thing: PointAtInfinity = pointAtInfinity_bulk(self_);
    return pointAtInfinity_dot_pointAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn scalar_bulkNormSquared(self_: Scalar) -> Scalar {
    let flat_bulk_thing: Scalar = scalar_bulk(self_);
    return scalar_dot_scalar(flat_bulk_thing, flat_bulk_thing);
}

fn transflector_bulkNormSquared(self_: Transflector) -> Scalar {
    let flat_bulk_thing: FlectorAtInfinity = transflector_bulk(self_);
    return flectorAtInfinity_dot_flectorAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn translator_bulkNormSquared(self_: Translator) -> Scalar {
    let flat_bulk_thing: LineAtInfinity = translator_bulk(self_);
    return lineAtInfinity_dot_lineAtInfinity(flat_bulk_thing, flat_bulk_thing);
}

fn dualNum_bulkNorm(self_: DualNum) -> Scalar {
    return scalar_sqrt(dualNum_bulkNormSquared(self_));
}

fn flector_bulkNorm(self_: Flector) -> Scalar {
    return scalar_sqrt(flector_bulkNormSquared(self_));
}

fn flectorAtInfinity_bulkNorm(self_: FlectorAtInfinity) -> Scalar {
    return scalar_sqrt(flectorAtInfinity_bulkNormSquared(self_));
}

fn horizon_bulkNorm(self_: Horizon) -> Scalar {
    return scalar_sqrt(horizon_bulkNormSquared(self_));
}

fn line_bulkNorm(self_: Line) -> Scalar {
    return scalar_sqrt(line_bulkNormSquared(self_));
}

fn lineAtInfinity_bulkNorm(self_: LineAtInfinity) -> Scalar {
    return scalar_sqrt(lineAtInfinity_bulkNormSquared(self_));
}

fn motor_bulkNorm(self_: Motor) -> Scalar {
    return scalar_sqrt(motor_bulkNormSquared(self_));
}

fn multiVector_bulkNorm(self_: MultiVector) -> Scalar {
    return scalar_sqrt(multiVector_bulkNormSquared(self_));
}

fn multiVectorAtInfinity_bulkNorm(self_: MultiVectorAtInfinity) -> Scalar {
    return scalar_sqrt(multiVectorAtInfinity_bulkNormSquared(self_));
}

fn plane_bulkNorm(self_: Plane) -> Scalar {
    return scalar_sqrt(plane_bulkNormSquared(self_));
}

fn point_bulkNorm(self_: Point) -> Scalar {
    return scalar_sqrt(point_bulkNormSquared(self_));
}

fn pointAtInfinity_bulkNorm(self_: PointAtInfinity) -> Scalar {
    return scalar_sqrt(pointAtInfinity_bulkNormSquared(self_));
}

fn scalar_bulkNorm(self_: Scalar) -> Scalar {
    return scalar_sqrt(scalar_bulkNormSquared(self_));
}

fn transflector_bulkNorm(self_: Transflector) -> Scalar {
    return scalar_sqrt(transflector_bulkNormSquared(self_));
}

fn translator_bulkNorm(self_: Translator) -> Scalar {
    return scalar_sqrt(translator_bulkNormSquared(self_));
}

fn antiScalar_weightNormSquared(self_: AntiScalar) -> AntiScalar {
    let flat_weight: AntiScalar = antiScalar_weight(self_);
    return antiScalar_antiDot_antiScalar(flat_weight, flat_weight);
}

fn dualNum_weightNormSquared(self_: DualNum) -> AntiScalar {
    let flat_weight: AntiScalar = dualNum_weight(self_);
    return antiScalar_antiDot_antiScalar(flat_weight, flat_weight);
}

fn flector_weightNormSquared(self_: Flector) -> AntiScalar {
    let flat_weight: Flector = flector_weight(self_);
    return flector_antiDot_flector(flat_weight, flat_weight);
}

fn line_weightNormSquared(self_: Line) -> AntiScalar {
    let flat_weight: LineAtOrigin = line_weight(self_);
    return lineAtOrigin_antiDot_lineAtOrigin(flat_weight, flat_weight);
}

fn lineAtOrigin_weightNormSquared(self_: LineAtOrigin) -> AntiScalar {
    let flat_weight: LineAtOrigin = lineAtOrigin_weight(self_);
    return lineAtOrigin_antiDot_lineAtOrigin(flat_weight, flat_weight);
}

fn motor_weightNormSquared(self_: Motor) -> AntiScalar {
    let flat_weight: Rotor = motor_weight(self_);
    return rotor_antiDot_rotor(flat_weight, flat_weight);
}

fn multiVector_weightNormSquared(self_: MultiVector) -> AntiScalar {
    let flat_weight: MultiVectorAtOrigin = multiVector_weight(self_);
    return multiVectorAtOrigin_antiDot_multiVectorAtOrigin(flat_weight, flat_weight);
}

fn multiVectorAtOrigin_weightNormSquared(self_: MultiVectorAtOrigin) -> AntiScalar {
    let flat_weight: MultiVectorAtOrigin = multiVectorAtOrigin_weight(self_);
    return multiVectorAtOrigin_antiDot_multiVectorAtOrigin(flat_weight, flat_weight);
}

fn origin_weightNormSquared(self_: Origin) -> AntiScalar {
    let flat_weight: Origin = origin_weight(self_);
    return origin_antiDot_origin(flat_weight, flat_weight);
}

fn plane_weightNormSquared(self_: Plane) -> AntiScalar {
    let flat_weight: PlaneAtOrigin = plane_weight(self_);
    return planeAtOrigin_antiDot_planeAtOrigin(flat_weight, flat_weight);
}

fn planeAtOrigin_weightNormSquared(self_: PlaneAtOrigin) -> AntiScalar {
    let flat_weight: PlaneAtOrigin = planeAtOrigin_weight(self_);
    return planeAtOrigin_antiDot_planeAtOrigin(flat_weight, flat_weight);
}

fn point_weightNormSquared(self_: Point) -> AntiScalar {
    let flat_weight: Origin = point_weight(self_);
    return origin_antiDot_origin(flat_weight, flat_weight);
}

fn rotor_weightNormSquared(self_: Rotor) -> AntiScalar {
    let flat_weight: Rotor = rotor_weight(self_);
    return rotor_antiDot_rotor(flat_weight, flat_weight);
}

fn transflector_weightNormSquared(self_: Transflector) -> AntiScalar {
    let flat_weight: PlaneAtOrigin = transflector_weight(self_);
    return planeAtOrigin_antiDot_planeAtOrigin(flat_weight, flat_weight);
}

fn translator_weightNormSquared(self_: Translator) -> AntiScalar {
    let flat_weight: AntiScalar = translator_weight(self_);
    return antiScalar_antiDot_antiScalar(flat_weight, flat_weight);
}

fn antiScalar_weightNorm(self_: AntiScalar) -> AntiScalar {
    return antiScalar_antiSqrt(antiScalar_weightNormSquared(self_));
}

fn dualNum_weightNorm(self_: DualNum) -> AntiScalar {
    return antiScalar_antiSqrt(dualNum_weightNormSquared(self_));
}

fn flector_weightNorm(self_: Flector) -> AntiScalar {
    return antiScalar_antiSqrt(flector_weightNormSquared(self_));
}

fn line_weightNorm(self_: Line) -> AntiScalar {
    return antiScalar_antiSqrt(line_weightNormSquared(self_));
}

fn lineAtOrigin_weightNorm(self_: LineAtOrigin) -> AntiScalar {
    return antiScalar_antiSqrt(lineAtOrigin_weightNormSquared(self_));
}

fn motor_weightNorm(self_: Motor) -> AntiScalar {
    return antiScalar_antiSqrt(motor_weightNormSquared(self_));
}

fn multiVector_weightNorm(self_: MultiVector) -> AntiScalar {
    return antiScalar_antiSqrt(multiVector_weightNormSquared(self_));
}

fn multiVectorAtOrigin_weightNorm(self_: MultiVectorAtOrigin) -> AntiScalar {
    return antiScalar_antiSqrt(multiVectorAtOrigin_weightNormSquared(self_));
}

fn origin_weightNorm(self_: Origin) -> AntiScalar {
    return antiScalar_antiSqrt(origin_weightNormSquared(self_));
}

fn plane_weightNorm(self_: Plane) -> AntiScalar {
    return antiScalar_antiSqrt(plane_weightNormSquared(self_));
}

fn planeAtOrigin_weightNorm(self_: PlaneAtOrigin) -> AntiScalar {
    return antiScalar_antiSqrt(planeAtOrigin_weightNormSquared(self_));
}

fn point_weightNorm(self_: Point) -> AntiScalar {
    return antiScalar_antiSqrt(point_weightNormSquared(self_));
}

fn rotor_weightNorm(self_: Rotor) -> AntiScalar {
    return antiScalar_antiSqrt(rotor_weightNormSquared(self_));
}

fn transflector_weightNorm(self_: Transflector) -> AntiScalar {
    return antiScalar_antiSqrt(transflector_weightNormSquared(self_));
}

fn translator_weightNorm(self_: Translator) -> AntiScalar {
    return antiScalar_antiSqrt(translator_weightNormSquared(self_));
}

fn dualNum_normSquared(self_: DualNum) -> DualNum {
    return scalar_add_antiScalar(dualNum_bulkNormSquared(self_), dualNum_weightNormSquared(self_));
}

fn flector_normSquared(self_: Flector) -> DualNum {
    return scalar_add_antiScalar(flector_bulkNormSquared(self_), flector_weightNormSquared(self_));
}

fn line_normSquared(self_: Line) -> DualNum {
    return scalar_add_antiScalar(line_bulkNormSquared(self_), line_weightNormSquared(self_));
}

fn motor_normSquared(self_: Motor) -> DualNum {
    return scalar_add_antiScalar(motor_bulkNormSquared(self_), motor_weightNormSquared(self_));
}

fn multiVector_normSquared(self_: MultiVector) -> DualNum {
    return scalar_add_antiScalar(multiVector_bulkNormSquared(self_), multiVector_weightNormSquared(self_));
}

fn plane_normSquared(self_: Plane) -> DualNum {
    return scalar_add_antiScalar(plane_bulkNormSquared(self_), plane_weightNormSquared(self_));
}

fn point_normSquared(self_: Point) -> DualNum {
    return scalar_add_antiScalar(point_bulkNormSquared(self_), point_weightNormSquared(self_));
}

fn transflector_normSquared(self_: Transflector) -> DualNum {
    return scalar_add_antiScalar(transflector_bulkNormSquared(self_), transflector_weightNormSquared(self_));
}

fn translator_normSquared(self_: Translator) -> DualNum {
    return scalar_add_antiScalar(translator_bulkNormSquared(self_), translator_weightNormSquared(self_));
}

fn dualNum_norm(self_: DualNum) -> DualNum {
    return scalar_add_antiScalar(dualNum_bulkNorm(self_), dualNum_weightNorm(self_));
}

fn flector_norm(self_: Flector) -> DualNum {
    return scalar_add_antiScalar(flector_bulkNorm(self_), flector_weightNorm(self_));
}

fn line_norm(self_: Line) -> DualNum {
    return scalar_add_antiScalar(line_bulkNorm(self_), line_weightNorm(self_));
}

fn motor_norm(self_: Motor) -> DualNum {
    return scalar_add_antiScalar(motor_bulkNorm(self_), motor_weightNorm(self_));
}

fn multiVector_norm(self_: MultiVector) -> DualNum {
    return scalar_add_antiScalar(multiVector_bulkNorm(self_), multiVector_weightNorm(self_));
}

fn plane_norm(self_: Plane) -> DualNum {
    return scalar_add_antiScalar(plane_bulkNorm(self_), plane_weightNorm(self_));
}

fn point_norm(self_: Point) -> DualNum {
    return scalar_add_antiScalar(point_bulkNorm(self_), point_weightNorm(self_));
}

fn transflector_norm(self_: Transflector) -> DualNum {
    return scalar_add_antiScalar(transflector_bulkNorm(self_), transflector_weightNorm(self_));
}

fn translator_norm(self_: Translator) -> DualNum {
    return scalar_add_antiScalar(translator_bulkNorm(self_), translator_weightNorm(self_));
}

fn dualNum_unitizedNormSquared(self_: DualNum) -> f32 {
    return dualNum_bulkNormSquared(self_).g0_ / dualNum_weightNormSquared(self_).g0_;
}

fn flector_unitizedNormSquared(self_: Flector) -> f32 {
    return flector_bulkNormSquared(self_).g0_ / flector_weightNormSquared(self_).g0_;
}

fn line_unitizedNormSquared(self_: Line) -> f32 {
    return line_bulkNormSquared(self_).g0_ / line_weightNormSquared(self_).g0_;
}

fn motor_unitizedNormSquared(self_: Motor) -> f32 {
    return motor_bulkNormSquared(self_).g0_ / motor_weightNormSquared(self_).g0_;
}

fn multiVector_unitizedNormSquared(self_: MultiVector) -> f32 {
    return multiVector_bulkNormSquared(self_).g0_ / multiVector_weightNormSquared(self_).g0_;
}

fn plane_unitizedNormSquared(self_: Plane) -> f32 {
    return plane_bulkNormSquared(self_).g0_ / plane_weightNormSquared(self_).g0_;
}

fn point_unitizedNormSquared(self_: Point) -> f32 {
    return point_bulkNormSquared(self_).g0_ / point_weightNormSquared(self_).g0_;
}

fn transflector_unitizedNormSquared(self_: Transflector) -> f32 {
    return transflector_bulkNormSquared(self_).g0_ / transflector_weightNormSquared(self_).g0_;
}

fn translator_unitizedNormSquared(self_: Translator) -> f32 {
    return translator_bulkNormSquared(self_).g0_ / translator_weightNormSquared(self_).g0_;
}

fn dualNum_unitizedNorm(self_: DualNum) -> f32 {
    return sqrt(dualNum_unitizedNormSquared(self_));
}

fn flector_unitizedNorm(self_: Flector) -> f32 {
    return sqrt(flector_unitizedNormSquared(self_));
}

fn line_unitizedNorm(self_: Line) -> f32 {
    return sqrt(line_unitizedNormSquared(self_));
}

fn motor_unitizedNorm(self_: Motor) -> f32 {
    return sqrt(motor_unitizedNormSquared(self_));
}

fn multiVector_unitizedNorm(self_: MultiVector) -> f32 {
    return sqrt(multiVector_unitizedNormSquared(self_));
}

fn plane_unitizedNorm(self_: Plane) -> f32 {
    return sqrt(plane_unitizedNormSquared(self_));
}

fn point_unitizedNorm(self_: Point) -> f32 {
    return sqrt(point_unitizedNormSquared(self_));
}

fn transflector_unitizedNorm(self_: Transflector) -> f32 {
    return sqrt(transflector_unitizedNormSquared(self_));
}

fn translator_unitizedNorm(self_: Translator) -> f32 {
    return sqrt(translator_unitizedNormSquared(self_));
}

fn antiScalar_unitize(self_: AntiScalar) -> AntiScalar {
    return antiScalar_geometricProduct_scalar(self_, Scalar(1.0 / antiScalar_weightNorm(self_).g0_));
}

fn dualNum_unitize(self_: DualNum) -> DualNum {
    return dualNum_geometricProduct_scalar(self_, Scalar(1.0 / dualNum_weightNorm(self_).g0_));
}

fn flector_unitize(self_: Flector) -> Flector {
    return flector_geometricProduct_scalar(self_, Scalar(1.0 / flector_weightNorm(self_).g0_));
}

fn line_unitize(self_: Line) -> Line {
    return line_geometricProduct_scalar(self_, Scalar(1.0 / line_weightNorm(self_).g0_));
}

fn lineAtOrigin_unitize(self_: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_geometricProduct_scalar(self_, Scalar(1.0 / lineAtOrigin_weightNorm(self_).g0_));
}

fn motor_unitize(self_: Motor) -> Motor {
    return motor_geometricProduct_scalar(self_, Scalar(1.0 / motor_weightNorm(self_).g0_));
}

fn multiVector_unitize(self_: MultiVector) -> MultiVector {
    return multiVector_geometricProduct_scalar(self_, Scalar(1.0 / multiVector_weightNorm(self_).g0_));
}

fn multiVectorAtOrigin_unitize(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_scalar(self_, Scalar(1.0 / multiVectorAtOrigin_weightNorm(self_).g0_));
}

fn origin_unitize(self_: Origin) -> Origin {
    return origin_geometricProduct_scalar(self_, Scalar(1.0 / origin_weightNorm(self_).g0_));
}

fn plane_unitize(self_: Plane) -> Plane {
    return plane_geometricProduct_scalar(self_, Scalar(1.0 / plane_weightNorm(self_).g0_));
}

fn planeAtOrigin_unitize(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_geometricProduct_scalar(self_, Scalar(1.0 / planeAtOrigin_weightNorm(self_).g0_));
}

fn point_unitize(self_: Point) -> Point {
    return point_geometricProduct_scalar(self_, Scalar(1.0 / point_weightNorm(self_).g0_));
}

fn rotor_unitize(self_: Rotor) -> Rotor {
    return rotor_geometricProduct_scalar(self_, Scalar(1.0 / rotor_weightNorm(self_).g0_));
}

fn transflector_unitize(self_: Transflector) -> Transflector {
    return transflector_geometricProduct_scalar(self_, Scalar(1.0 / transflector_weightNorm(self_).g0_));
}

fn translator_unitize(self_: Translator) -> Translator {
    return translator_geometricProduct_scalar(self_, Scalar(1.0 / translator_weightNorm(self_).g0_));
}

fn antiScalar_sandwich_flector(self_: AntiScalar, other: Flector) -> Flector {
    return flector_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_flector(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_flectorAtInfinity(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return horizon_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_horizon(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_line(self_: AntiScalar, other: Line) -> Line {
    return line_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_line(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_lineAtInfinity(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_lineAtOrigin(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_motor(self_: AntiScalar, other: Motor) -> Motor {
    return motor_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_motor(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_multiVector(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_multiVectorAtInfinity(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_multiVectorAtOrigin(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_origin(self_: AntiScalar, other: Origin) -> Origin {
    return origin_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_origin(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_plane(self_: AntiScalar, other: Plane) -> Plane {
    return plane_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_plane(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_planeAtOrigin(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_point(self_: AntiScalar, other: Point) -> Point {
    return point_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_point(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_pointAtInfinity(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return rotor_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_rotor(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_transflector(self_: AntiScalar, other: Transflector) -> Transflector {
    return transflector_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_transflector(self_, other), antiScalar_antiReversal(self_));
}

fn antiScalar_sandwich_translator(self_: AntiScalar, other: Translator) -> Translator {
    return translator_geometricAntiProduct_antiScalar(antiScalar_geometricAntiProduct_translator(self_, other), antiScalar_antiReversal(self_));
}

fn dualNum_sandwich_flector(self_: DualNum, other: Flector) -> Flector {
    return flector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_flector(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_flectorAtInfinity(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return horizon_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_horizon(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_line(self_: DualNum, other: Line) -> Line {
    return line_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_line(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_lineAtInfinity(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> LineAtOrigin {
    return line_into_lineAtOrigin(line_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_lineAtOrigin(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_motor(self_: DualNum, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_motor(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_multiVector(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_multiVectorAtInfinity(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_multiVectorAtOrigin(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_origin(self_: DualNum, other: Origin) -> Origin {
    return flector_into_origin(flector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_origin(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_plane(self_: DualNum, other: Plane) -> Plane {
    return transflector_into_plane(transflector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_plane(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return transflector_into_planeAtOrigin(transflector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_planeAtOrigin(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_point(self_: DualNum, other: Point) -> Point {
    return flector_into_point(flector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_point(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_pointAtInfinity(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_rotor(self_: DualNum, other: Rotor) -> Rotor {
    return multiVector_into_rotor(multiVector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_rotor(self_, other), dualNum_antiReversal(self_)));
}

fn dualNum_sandwich_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return transflector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_transflector(self_, other), dualNum_antiReversal(self_));
}

fn dualNum_sandwich_translator(self_: DualNum, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_dualNum(dualNum_geometricAntiProduct_translator(self_, other), dualNum_antiReversal(self_)));
}

fn flector_sandwich_flector(self_: Flector, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_flector(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_flector(flector_geometricAntiProduct_flectorAtInfinity(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_horizon(self_: Flector, other: Horizon) -> Horizon {
    return multiVectorAtInfinity_into_horizon(multiVectorAtInfinity_geometricAntiProduct_flector(flector_geometricAntiProduct_horizon(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_line(self_: Flector, other: Line) -> Line {
    return multiVector_into_line(flector_geometricAntiProduct_flector(flector_geometricAntiProduct_line(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(flectorAtInfinity_geometricAntiProduct_flector(flector_geometricAntiProduct_lineAtInfinity(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Line {
    return multiVector_into_line(flector_geometricAntiProduct_flector(flector_geometricAntiProduct_lineAtOrigin(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_motor(self_: Flector, other: Motor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_flector(flector_geometricAntiProduct_motor(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_multiVector(self_, other), flector_antiReversal(self_));
}

fn flector_sandwich_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_flector(flector_geometricAntiProduct_multiVectorAtInfinity(self_, other), flector_antiReversal(self_));
}

fn flector_sandwich_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_multiVectorAtOrigin(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_origin(self_: Flector, other: Origin) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_origin(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_plane(self_: Flector, other: Plane) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_plane(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_planeAtOrigin(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_point(self_: Flector, other: Point) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_point(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> PointAtInfinity {
    return multiVectorAtInfinity_into_pointAtInfinity(multiVectorAtInfinity_geometricAntiProduct_flector(flector_geometricAntiProduct_pointAtInfinity(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_rotor(self_: Flector, other: Rotor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_flector(flector_geometricAntiProduct_rotor(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_transflector(self_: Flector, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_flector(flector_geometricAntiProduct_transflector(self_, other), flector_antiReversal(self_)));
}

fn flector_sandwich_translator(self_: Flector, other: Translator) -> Translator {
    return multiVector_into_translator(flector_geometricAntiProduct_flector(flector_geometricAntiProduct_translator(self_, other), flector_antiReversal(self_)));
}

fn line_sandwich_flector(self_: Line, other: Flector) -> Flector {
    return flector_geometricAntiProduct_line(line_geometricAntiProduct_flector(self_, other), line_antiReversal(self_));
}

fn line_sandwich_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_line(line_geometricAntiProduct_flectorAtInfinity(self_, other), line_antiReversal(self_));
}

fn line_sandwich_horizon(self_: Line, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(pointAtInfinity_geometricAntiProduct_line(line_geometricAntiProduct_horizon(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_line(self_: Line, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_line(line_geometricAntiProduct_line(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_lineAtInfinity(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(multiVectorAtInfinity_geometricAntiProduct_line(line_geometricAntiProduct_lineAtInfinity(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_lineAtOrigin(self_: Line, other: LineAtOrigin) -> LineAtOrigin {
    return multiVector_into_lineAtOrigin(multiVector_geometricAntiProduct_line(line_geometricAntiProduct_lineAtOrigin(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_motor(self_: Line, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_line(line_geometricAntiProduct_motor(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_line(line_geometricAntiProduct_multiVector(self_, other), line_antiReversal(self_));
}

fn line_sandwich_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_line(line_geometricAntiProduct_multiVectorAtInfinity(self_, other), line_antiReversal(self_));
}

fn line_sandwich_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_line(line_geometricAntiProduct_multiVectorAtOrigin(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_origin(self_: Line, other: Origin) -> Origin {
    return flector_into_origin(transflector_geometricAntiProduct_line(line_geometricAntiProduct_origin(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_plane(self_: Line, other: Plane) -> Plane {
    return flector_into_plane(flector_geometricAntiProduct_line(line_geometricAntiProduct_plane(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return flector_into_planeAtOrigin(flector_geometricAntiProduct_line(line_geometricAntiProduct_planeAtOrigin(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_point(self_: Line, other: Point) -> Point {
    return flector_into_point(transflector_geometricAntiProduct_line(line_geometricAntiProduct_point(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_pointAtInfinity(self_: Line, other: PointAtInfinity) -> PointAtInfinity {
    return flectorAtInfinity_into_pointAtInfinity(flectorAtInfinity_geometricAntiProduct_line(line_geometricAntiProduct_pointAtInfinity(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_rotor(self_: Line, other: Rotor) -> Rotor {
    return multiVector_into_rotor(multiVector_geometricAntiProduct_line(line_geometricAntiProduct_rotor(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_transflector(self_: Line, other: Transflector) -> Transflector {
    return flector_into_transflector(flector_geometricAntiProduct_line(line_geometricAntiProduct_transflector(self_, other), line_antiReversal(self_)));
}

fn line_sandwich_translator(self_: Line, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_line(line_geometricAntiProduct_translator(self_, other), line_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return flector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_flector(self_, other), lineAtOrigin_antiReversal(self_));
}

fn lineAtOrigin_sandwich_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_flectorAtInfinity(self_, other), lineAtOrigin_antiReversal(self_));
}

fn lineAtOrigin_sandwich_horizon(self_: LineAtOrigin, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(pointAtInfinity_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_horizon(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_line(self_: LineAtOrigin, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_line(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(multiVectorAtInfinity_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_lineAtInfinity(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return rotor_into_lineAtOrigin(rotor_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_lineAtOrigin(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_motor(self_: LineAtOrigin, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_motor(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_multiVector(self_, other), lineAtOrigin_antiReversal(self_));
}

fn lineAtOrigin_sandwich_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_multiVectorAtInfinity(self_, other), lineAtOrigin_antiReversal(self_));
}

fn lineAtOrigin_sandwich_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_, other), lineAtOrigin_antiReversal(self_));
}

fn lineAtOrigin_sandwich_origin(self_: LineAtOrigin, other: Origin) -> Origin {
    return flector_into_origin(planeAtOrigin_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_origin(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_plane(self_: LineAtOrigin, other: Plane) -> Plane {
    return flector_into_plane(flector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_plane(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return flector_into_planeAtOrigin(flector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_planeAtOrigin(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_point(self_: LineAtOrigin, other: Point) -> Point {
    return flector_into_point(transflector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_point(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return flectorAtInfinity_into_pointAtInfinity(flectorAtInfinity_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_pointAtInfinity(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_rotor(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return rotor_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_rotor(self_, other), lineAtOrigin_antiReversal(self_));
}

fn lineAtOrigin_sandwich_transflector(self_: LineAtOrigin, other: Transflector) -> Transflector {
    return flector_into_transflector(flector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_transflector(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn lineAtOrigin_sandwich_translator(self_: LineAtOrigin, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_lineAtOrigin(lineAtOrigin_geometricAntiProduct_translator(self_, other), lineAtOrigin_antiReversal(self_)));
}

fn motor_sandwich_flector(self_: Motor, other: Flector) -> Flector {
    return flector_geometricAntiProduct_motor(motor_geometricAntiProduct_flector(self_, other), motor_antiReversal(self_));
}

fn motor_sandwich_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_motor(motor_geometricAntiProduct_flectorAtInfinity(self_, other), motor_antiReversal(self_));
}

fn motor_sandwich_horizon(self_: Motor, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(flectorAtInfinity_geometricAntiProduct_motor(motor_geometricAntiProduct_horizon(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_line(self_: Motor, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_line(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(multiVectorAtInfinity_geometricAntiProduct_motor(motor_geometricAntiProduct_lineAtInfinity(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_lineAtOrigin(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_motor(self_: Motor, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_motor(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_multiVector(self_, other), motor_antiReversal(self_));
}

fn motor_sandwich_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_motor(motor_geometricAntiProduct_multiVectorAtInfinity(self_, other), motor_antiReversal(self_));
}

fn motor_sandwich_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_multiVectorAtOrigin(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_origin(self_: Motor, other: Origin) -> Point {
    return flector_into_point(flector_geometricAntiProduct_motor(motor_geometricAntiProduct_origin(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_plane(self_: Motor, other: Plane) -> Plane {
    return flector_into_plane(flector_geometricAntiProduct_motor(motor_geometricAntiProduct_plane(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Plane {
    return flector_into_plane(flector_geometricAntiProduct_motor(motor_geometricAntiProduct_planeAtOrigin(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_point(self_: Motor, other: Point) -> Point {
    return flector_into_point(flector_geometricAntiProduct_motor(motor_geometricAntiProduct_point(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return flectorAtInfinity_into_pointAtInfinity(flectorAtInfinity_geometricAntiProduct_motor(motor_geometricAntiProduct_pointAtInfinity(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_rotor(self_: Motor, other: Rotor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_rotor(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_transflector(self_: Motor, other: Transflector) -> Transflector {
    return flector_into_transflector(flector_geometricAntiProduct_motor(motor_geometricAntiProduct_transflector(self_, other), motor_antiReversal(self_)));
}

fn motor_sandwich_translator(self_: Motor, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_motor(motor_geometricAntiProduct_translator(self_, other), motor_antiReversal(self_)));
}

fn multiVector_sandwich_flector(self_: MultiVector, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_flector(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_flectorAtInfinity(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_horizon(self_: MultiVector, other: Horizon) -> Horizon {
    return multiVectorAtInfinity_into_horizon(multiVectorAtInfinity_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_horizon(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_line(self_: MultiVector, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_line(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(multiVectorAtInfinity_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_lineAtInfinity(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> LineAtOrigin {
    return multiVector_into_lineAtOrigin(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_lineAtOrigin(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_motor(self_: MultiVector, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_motor(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_multiVector(self_, other), multiVector_antiReversal(self_));
}

fn multiVector_sandwich_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_multiVectorAtInfinity(self_, other), multiVector_antiReversal(self_));
}

fn multiVector_sandwich_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_multiVectorAtOrigin(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_origin(self_: MultiVector, other: Origin) -> Origin {
    return multiVector_into_origin(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_origin(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_plane(self_: MultiVector, other: Plane) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_plane(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return multiVector_into_planeAtOrigin(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_planeAtOrigin(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_point(self_: MultiVector, other: Point) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_point(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> PointAtInfinity {
    return multiVectorAtInfinity_into_pointAtInfinity(multiVectorAtInfinity_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_pointAtInfinity(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_rotor(self_: MultiVector, other: Rotor) -> Rotor {
    return multiVector_into_rotor(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_rotor(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_transflector(self_: MultiVector, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_transflector(self_, other), multiVector_antiReversal(self_)));
}

fn multiVector_sandwich_translator(self_: MultiVector, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_multiVector(multiVector_geometricAntiProduct_translator(self_, other), multiVector_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_flector(self_: MultiVectorAtOrigin, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_flector(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_flectorAtInfinity(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> Horizon {
    return multiVectorAtInfinity_into_horizon(multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_horizon(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_line(self_: MultiVectorAtOrigin, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_line(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_lineAtInfinity(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return multiVectorAtOrigin_into_lineAtOrigin(multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_lineAtOrigin(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_motor(self_: MultiVectorAtOrigin, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_motor(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_multiVector(self_, other), multiVectorAtOrigin_antiReversal(self_));
}

fn multiVectorAtOrigin_sandwich_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_multiVectorAtInfinity(self_, other), multiVectorAtOrigin_antiReversal(self_));
}

fn multiVectorAtOrigin_sandwich_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiReversal(self_));
}

fn multiVectorAtOrigin_sandwich_origin(self_: MultiVectorAtOrigin, other: Origin) -> Origin {
    return multiVectorAtOrigin_into_origin(multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_origin(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_plane(self_: MultiVectorAtOrigin, other: Plane) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_plane(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return multiVectorAtOrigin_into_planeAtOrigin(multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_planeAtOrigin(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_point(self_: MultiVectorAtOrigin, other: Point) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_point(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return multiVectorAtInfinity_into_pointAtInfinity(multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_pointAtInfinity(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> Rotor {
    return multiVectorAtOrigin_into_rotor(multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_rotor(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_transflector(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn multiVectorAtOrigin_sandwich_translator(self_: MultiVectorAtOrigin, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_multiVectorAtOrigin(multiVectorAtOrigin_geometricAntiProduct_translator(self_, other), multiVectorAtOrigin_antiReversal(self_)));
}

fn origin_sandwich_flector(self_: Origin, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_origin(origin_geometricAntiProduct_flector(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_origin(origin_geometricAntiProduct_flectorAtInfinity(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_horizon(self_: Origin, other: Horizon) -> Horizon {
    return scalar_geometricAntiProduct_origin(origin_geometricAntiProduct_horizon(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_line(self_: Origin, other: Line) -> Line {
    return multiVector_into_line(transflector_geometricAntiProduct_origin(origin_geometricAntiProduct_line(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> LineAtInfinity {
    return pointAtInfinity_geometricAntiProduct_origin(origin_geometricAntiProduct_lineAtInfinity(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> LineAtOrigin {
    return planeAtOrigin_geometricAntiProduct_origin(origin_geometricAntiProduct_lineAtOrigin(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_motor(self_: Origin, other: Motor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_origin(origin_geometricAntiProduct_motor(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_origin(origin_geometricAntiProduct_multiVector(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_origin(origin_geometricAntiProduct_multiVectorAtInfinity(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_origin(origin_geometricAntiProduct_multiVectorAtOrigin(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_origin(self_: Origin, other: Origin) -> Origin {
    return antiScalar_geometricAntiProduct_origin(origin_geometricAntiProduct_origin(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_plane(self_: Origin, other: Plane) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_origin(origin_geometricAntiProduct_plane(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_geometricAntiProduct_origin(origin_geometricAntiProduct_planeAtOrigin(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_point(self_: Origin, other: Point) -> Point {
    return translator_geometricAntiProduct_origin(origin_geometricAntiProduct_point(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_geometricAntiProduct_origin(origin_geometricAntiProduct_pointAtInfinity(self_, other), origin_antiReversal(self_));
}

fn origin_sandwich_rotor(self_: Origin, other: Rotor) -> Rotor {
    return multiVector_into_rotor(flector_geometricAntiProduct_origin(origin_geometricAntiProduct_rotor(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_transflector(self_: Origin, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_origin(origin_geometricAntiProduct_transflector(self_, other), origin_antiReversal(self_)));
}

fn origin_sandwich_translator(self_: Origin, other: Translator) -> Translator {
    return point_geometricAntiProduct_origin(origin_geometricAntiProduct_translator(self_, other), origin_antiReversal(self_));
}

fn plane_sandwich_flector(self_: Plane, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_plane(plane_geometricAntiProduct_flector(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_plane(plane_geometricAntiProduct_flectorAtInfinity(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_horizon(self_: Plane, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(lineAtInfinity_geometricAntiProduct_plane(plane_geometricAntiProduct_horizon(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_line(self_: Plane, other: Line) -> Line {
    return multiVector_into_line(flector_geometricAntiProduct_plane(plane_geometricAntiProduct_line(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(flectorAtInfinity_geometricAntiProduct_plane(plane_geometricAntiProduct_lineAtInfinity(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> LineAtOrigin {
    return multiVector_into_lineAtOrigin(flector_geometricAntiProduct_plane(plane_geometricAntiProduct_lineAtOrigin(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_motor(self_: Plane, other: Motor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_plane(plane_geometricAntiProduct_motor(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_plane(plane_geometricAntiProduct_multiVector(self_, other), plane_antiReversal(self_));
}

fn plane_sandwich_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_plane(plane_geometricAntiProduct_multiVectorAtInfinity(self_, other), plane_antiReversal(self_));
}

fn plane_sandwich_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_plane(plane_geometricAntiProduct_multiVectorAtOrigin(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_origin(self_: Plane, other: Origin) -> Origin {
    return multiVector_into_origin(multiVector_geometricAntiProduct_plane(plane_geometricAntiProduct_origin(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_plane(self_: Plane, other: Plane) -> Plane {
    return flector_into_plane(motor_geometricAntiProduct_plane(plane_geometricAntiProduct_plane(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return flector_into_planeAtOrigin(motor_geometricAntiProduct_plane(plane_geometricAntiProduct_planeAtOrigin(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_point(self_: Plane, other: Point) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_plane(plane_geometricAntiProduct_point(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> PointAtInfinity {
    return multiVectorAtInfinity_into_pointAtInfinity(multiVectorAtInfinity_geometricAntiProduct_plane(plane_geometricAntiProduct_pointAtInfinity(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_rotor(self_: Plane, other: Rotor) -> Rotor {
    return multiVector_into_rotor(flector_geometricAntiProduct_plane(plane_geometricAntiProduct_rotor(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_transflector(self_: Plane, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_plane(plane_geometricAntiProduct_transflector(self_, other), plane_antiReversal(self_)));
}

fn plane_sandwich_translator(self_: Plane, other: Translator) -> Translator {
    return multiVector_into_translator(transflector_geometricAntiProduct_plane(plane_geometricAntiProduct_translator(self_, other), plane_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_flector(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_flector(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_flectorAtInfinity(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_horizon(self_: PlaneAtOrigin, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(lineAtInfinity_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_horizon(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_line(self_: PlaneAtOrigin, other: Line) -> Line {
    return multiVector_into_line(flector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_line(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(flectorAtInfinity_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_lineAtInfinity(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return multiVector_into_lineAtOrigin(flector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_lineAtOrigin(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_motor(self_: PlaneAtOrigin, other: Motor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_motor(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_multiVector(self_, other), planeAtOrigin_antiReversal(self_));
}

fn planeAtOrigin_sandwich_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_multiVectorAtInfinity(self_, other), planeAtOrigin_antiReversal(self_));
}

fn planeAtOrigin_sandwich_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_, other), planeAtOrigin_antiReversal(self_));
}

fn planeAtOrigin_sandwich_origin(self_: PlaneAtOrigin, other: Origin) -> Origin {
    return flector_into_origin(lineAtOrigin_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_origin(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_plane(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return flector_into_plane(motor_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_plane(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return flector_into_planeAtOrigin(rotor_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_planeAtOrigin(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_point(self_: PlaneAtOrigin, other: Point) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_point(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> PointAtInfinity {
    return multiVectorAtInfinity_into_pointAtInfinity(multiVectorAtInfinity_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_pointAtInfinity(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_rotor(self_: PlaneAtOrigin, other: Rotor) -> Rotor {
    return multiVector_into_rotor(flector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_rotor(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_transflector(self_: PlaneAtOrigin, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_transflector(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn planeAtOrigin_sandwich_translator(self_: PlaneAtOrigin, other: Translator) -> Translator {
    return multiVector_into_translator(transflector_geometricAntiProduct_planeAtOrigin(planeAtOrigin_geometricAntiProduct_translator(self_, other), planeAtOrigin_antiReversal(self_)));
}

fn point_sandwich_flector(self_: Point, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_point(point_geometricAntiProduct_flector(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_point(point_geometricAntiProduct_flectorAtInfinity(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_horizon(self_: Point, other: Horizon) -> Horizon {
    return scalar_geometricAntiProduct_point(point_geometricAntiProduct_horizon(self_, other), point_antiReversal(self_));
}

fn point_sandwich_line(self_: Point, other: Line) -> Line {
    return multiVector_into_line(transflector_geometricAntiProduct_point(point_geometricAntiProduct_line(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_lineAtInfinity(self_: Point, other: LineAtInfinity) -> LineAtInfinity {
    return pointAtInfinity_geometricAntiProduct_point(point_geometricAntiProduct_lineAtInfinity(self_, other), point_antiReversal(self_));
}

fn point_sandwich_lineAtOrigin(self_: Point, other: LineAtOrigin) -> LineAtOrigin {
    return multiVector_into_lineAtOrigin(transflector_geometricAntiProduct_point(point_geometricAntiProduct_lineAtOrigin(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_motor(self_: Point, other: Motor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_point(point_geometricAntiProduct_motor(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_point(point_geometricAntiProduct_multiVector(self_, other), point_antiReversal(self_));
}

fn point_sandwich_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_point(point_geometricAntiProduct_multiVectorAtInfinity(self_, other), point_antiReversal(self_));
}

fn point_sandwich_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_point(point_geometricAntiProduct_multiVectorAtOrigin(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_origin(self_: Point, other: Origin) -> Origin {
    return point_into_origin(translator_geometricAntiProduct_point(point_geometricAntiProduct_origin(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_plane(self_: Point, other: Plane) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_point(point_geometricAntiProduct_plane(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return multiVector_into_planeAtOrigin(multiVector_geometricAntiProduct_point(point_geometricAntiProduct_planeAtOrigin(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_point(self_: Point, other: Point) -> Point {
    return translator_geometricAntiProduct_point(point_geometricAntiProduct_point(self_, other), point_antiReversal(self_));
}

fn point_sandwich_pointAtInfinity(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_geometricAntiProduct_point(point_geometricAntiProduct_pointAtInfinity(self_, other), point_antiReversal(self_));
}

fn point_sandwich_rotor(self_: Point, other: Rotor) -> Rotor {
    return multiVector_into_rotor(flector_geometricAntiProduct_point(point_geometricAntiProduct_rotor(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_transflector(self_: Point, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_point(point_geometricAntiProduct_transflector(self_, other), point_antiReversal(self_)));
}

fn point_sandwich_translator(self_: Point, other: Translator) -> Translator {
    return point_geometricAntiProduct_point(point_geometricAntiProduct_translator(self_, other), point_antiReversal(self_));
}

fn rotor_sandwich_flector(self_: Rotor, other: Flector) -> Flector {
    return flector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_flector(self_, other), rotor_antiReversal(self_));
}

fn rotor_sandwich_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_rotor(rotor_geometricAntiProduct_flectorAtInfinity(self_, other), rotor_antiReversal(self_));
}

fn rotor_sandwich_horizon(self_: Rotor, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(flectorAtInfinity_geometricAntiProduct_rotor(rotor_geometricAntiProduct_horizon(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_line(self_: Rotor, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_line(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(multiVectorAtInfinity_geometricAntiProduct_rotor(rotor_geometricAntiProduct_lineAtInfinity(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return rotor_into_lineAtOrigin(rotor_geometricAntiProduct_rotor(rotor_geometricAntiProduct_lineAtOrigin(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_motor(self_: Rotor, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_motor(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_multiVector(self_, other), rotor_antiReversal(self_));
}

fn rotor_sandwich_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_rotor(rotor_geometricAntiProduct_multiVectorAtInfinity(self_, other), rotor_antiReversal(self_));
}

fn rotor_sandwich_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_rotor(rotor_geometricAntiProduct_multiVectorAtOrigin(self_, other), rotor_antiReversal(self_));
}

fn rotor_sandwich_origin(self_: Rotor, other: Origin) -> Origin {
    return flector_into_origin(flector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_origin(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_plane(self_: Rotor, other: Plane) -> Plane {
    return flector_into_plane(flector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_plane(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return flector_into_planeAtOrigin(flector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_planeAtOrigin(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_point(self_: Rotor, other: Point) -> Point {
    return flector_into_point(flector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_point(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return flectorAtInfinity_into_pointAtInfinity(flectorAtInfinity_geometricAntiProduct_rotor(rotor_geometricAntiProduct_pointAtInfinity(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return rotor_geometricAntiProduct_rotor(rotor_geometricAntiProduct_rotor(self_, other), rotor_antiReversal(self_));
}

fn rotor_sandwich_transflector(self_: Rotor, other: Transflector) -> Transflector {
    return flector_into_transflector(flector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_transflector(self_, other), rotor_antiReversal(self_)));
}

fn rotor_sandwich_translator(self_: Rotor, other: Translator) -> Translator {
    return multiVector_into_translator(multiVector_geometricAntiProduct_rotor(rotor_geometricAntiProduct_translator(self_, other), rotor_antiReversal(self_)));
}

fn transflector_sandwich_flector(self_: Transflector, other: Flector) -> Flector {
    return multiVector_into_flector(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_flector(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return multiVectorAtInfinity_into_flectorAtInfinity(multiVectorAtInfinity_geometricAntiProduct_transflector(transflector_geometricAntiProduct_flectorAtInfinity(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_horizon(self_: Transflector, other: Horizon) -> Horizon {
    return flectorAtInfinity_into_horizon(lineAtInfinity_geometricAntiProduct_transflector(transflector_geometricAntiProduct_horizon(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_line(self_: Transflector, other: Line) -> Line {
    return multiVector_into_line(flector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_line(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> LineAtInfinity {
    return multiVectorAtInfinity_into_lineAtInfinity(flectorAtInfinity_geometricAntiProduct_transflector(transflector_geometricAntiProduct_lineAtInfinity(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> LineAtOrigin {
    return multiVector_into_lineAtOrigin(flector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_lineAtOrigin(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_motor(self_: Transflector, other: Motor) -> Motor {
    return multiVector_into_motor(flector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_motor(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_multiVector(self_, other), transflector_antiReversal(self_));
}

fn transflector_sandwich_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_transflector(transflector_geometricAntiProduct_multiVectorAtInfinity(self_, other), transflector_antiReversal(self_));
}

fn transflector_sandwich_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_multiVectorAtOrigin(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_origin(self_: Transflector, other: Origin) -> Origin {
    return multiVector_into_origin(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_origin(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_plane(self_: Transflector, other: Plane) -> Plane {
    return multiVector_into_plane(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_plane(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return multiVector_into_planeAtOrigin(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_planeAtOrigin(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_point(self_: Transflector, other: Point) -> Point {
    return multiVector_into_point(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_point(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> PointAtInfinity {
    return multiVectorAtInfinity_into_pointAtInfinity(multiVectorAtInfinity_geometricAntiProduct_transflector(transflector_geometricAntiProduct_pointAtInfinity(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_rotor(self_: Transflector, other: Rotor) -> Rotor {
    return multiVector_into_rotor(flector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_rotor(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return multiVector_into_transflector(multiVector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_transflector(self_, other), transflector_antiReversal(self_)));
}

fn transflector_sandwich_translator(self_: Transflector, other: Translator) -> Translator {
    return multiVector_into_translator(transflector_geometricAntiProduct_transflector(transflector_geometricAntiProduct_translator(self_, other), transflector_antiReversal(self_)));
}

fn translator_sandwich_flector(self_: Translator, other: Flector) -> Flector {
    return flector_geometricAntiProduct_translator(translator_geometricAntiProduct_flector(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_translator(translator_geometricAntiProduct_flectorAtInfinity(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_horizon(self_: Translator, other: Horizon) -> Horizon {
    return horizon_geometricAntiProduct_translator(translator_geometricAntiProduct_horizon(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_line(self_: Translator, other: Line) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_translator(translator_geometricAntiProduct_line(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_geometricAntiProduct_translator(translator_geometricAntiProduct_lineAtInfinity(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> Line {
    return multiVector_into_line(multiVector_geometricAntiProduct_translator(translator_geometricAntiProduct_lineAtOrigin(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_motor(self_: Translator, other: Motor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_translator(translator_geometricAntiProduct_motor(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_translator(translator_geometricAntiProduct_multiVector(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_translator(translator_geometricAntiProduct_multiVectorAtInfinity(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVector_into_multiVectorAtOrigin(multiVector_geometricAntiProduct_translator(translator_geometricAntiProduct_multiVectorAtOrigin(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_origin(self_: Translator, other: Origin) -> Point {
    return point_geometricAntiProduct_translator(translator_geometricAntiProduct_origin(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_plane(self_: Translator, other: Plane) -> Plane {
    return transflector_into_plane(transflector_geometricAntiProduct_translator(translator_geometricAntiProduct_plane(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Plane {
    return transflector_into_plane(transflector_geometricAntiProduct_translator(translator_geometricAntiProduct_planeAtOrigin(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_point(self_: Translator, other: Point) -> Point {
    return point_geometricAntiProduct_translator(translator_geometricAntiProduct_point(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_geometricAntiProduct_translator(translator_geometricAntiProduct_pointAtInfinity(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_rotor(self_: Translator, other: Rotor) -> Motor {
    return multiVector_into_motor(multiVector_geometricAntiProduct_translator(translator_geometricAntiProduct_rotor(self_, other), translator_antiReversal(self_)));
}

fn translator_sandwich_transflector(self_: Translator, other: Transflector) -> Transflector {
    return transflector_geometricAntiProduct_translator(translator_geometricAntiProduct_transflector(self_, other), translator_antiReversal(self_));
}

fn translator_sandwich_translator(self_: Translator, other: Translator) -> Translator {
    return translator_geometricAntiProduct_translator(translator_geometricAntiProduct_translator(self_, other), translator_antiReversal(self_));
}

fn point_pointInversion_flector(self_: Point, other: Flector) -> Flector {
    return point_sandwich_flector(point_unitize(self_), other);
}

fn point_pointInversion_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return point_sandwich_flectorAtInfinity(point_unitize(self_), other);
}

fn point_pointInversion_horizon(self_: Point, other: Horizon) -> Horizon {
    return point_sandwich_horizon(point_unitize(self_), other);
}

fn point_pointInversion_line(self_: Point, other: Line) -> Line {
    return point_sandwich_line(point_unitize(self_), other);
}

fn point_pointInversion_lineAtInfinity(self_: Point, other: LineAtInfinity) -> LineAtInfinity {
    return point_sandwich_lineAtInfinity(point_unitize(self_), other);
}

fn point_pointInversion_lineAtOrigin(self_: Point, other: LineAtOrigin) -> LineAtOrigin {
    return point_sandwich_lineAtOrigin(point_unitize(self_), other);
}

fn point_pointInversion_motor(self_: Point, other: Motor) -> Motor {
    return point_sandwich_motor(point_unitize(self_), other);
}

fn point_pointInversion_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return point_sandwich_multiVector(point_unitize(self_), other);
}

fn point_pointInversion_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return point_sandwich_multiVectorAtInfinity(point_unitize(self_), other);
}

fn point_pointInversion_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return point_sandwich_multiVectorAtOrigin(point_unitize(self_), other);
}

fn point_pointInversion_origin(self_: Point, other: Origin) -> Origin {
    return point_sandwich_origin(point_unitize(self_), other);
}

fn point_pointInversion_plane(self_: Point, other: Plane) -> Plane {
    return point_sandwich_plane(point_unitize(self_), other);
}

fn point_pointInversion_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return point_sandwich_planeAtOrigin(point_unitize(self_), other);
}

fn point_pointInversion_point(self_: Point, other: Point) -> Point {
    return point_sandwich_point(point_unitize(self_), other);
}

fn point_pointInversion_pointAtInfinity(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return point_sandwich_pointAtInfinity(point_unitize(self_), other);
}

fn point_pointInversion_rotor(self_: Point, other: Rotor) -> Rotor {
    return point_sandwich_rotor(point_unitize(self_), other);
}

fn point_pointInversion_transflector(self_: Point, other: Transflector) -> Transflector {
    return point_sandwich_transflector(point_unitize(self_), other);
}

fn point_pointInversion_translator(self_: Point, other: Translator) -> Translator {
    return point_sandwich_translator(point_unitize(self_), other);
}

fn plane_reflect_flector(self_: Plane, other: Flector) -> Flector {
    return plane_sandwich_flector(plane_unitize(self_), other);
}

fn plane_reflect_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return plane_sandwich_flectorAtInfinity(plane_unitize(self_), other);
}

fn plane_reflect_horizon(self_: Plane, other: Horizon) -> Horizon {
    return plane_sandwich_horizon(plane_unitize(self_), other);
}

fn plane_reflect_line(self_: Plane, other: Line) -> Line {
    return plane_sandwich_line(plane_unitize(self_), other);
}

fn plane_reflect_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> LineAtInfinity {
    return plane_sandwich_lineAtInfinity(plane_unitize(self_), other);
}

fn plane_reflect_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> LineAtOrigin {
    return plane_sandwich_lineAtOrigin(plane_unitize(self_), other);
}

fn plane_reflect_motor(self_: Plane, other: Motor) -> Motor {
    return plane_sandwich_motor(plane_unitize(self_), other);
}

fn plane_reflect_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_sandwich_multiVector(plane_unitize(self_), other);
}

fn plane_reflect_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return plane_sandwich_multiVectorAtInfinity(plane_unitize(self_), other);
}

fn plane_reflect_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return plane_sandwich_multiVectorAtOrigin(plane_unitize(self_), other);
}

fn plane_reflect_origin(self_: Plane, other: Origin) -> Origin {
    return plane_sandwich_origin(plane_unitize(self_), other);
}

fn plane_reflect_plane(self_: Plane, other: Plane) -> Plane {
    return plane_sandwich_plane(plane_unitize(self_), other);
}

fn plane_reflect_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_sandwich_planeAtOrigin(plane_unitize(self_), other);
}

fn plane_reflect_point(self_: Plane, other: Point) -> Point {
    return plane_sandwich_point(plane_unitize(self_), other);
}

fn plane_reflect_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> PointAtInfinity {
    return plane_sandwich_pointAtInfinity(plane_unitize(self_), other);
}

fn plane_reflect_rotor(self_: Plane, other: Rotor) -> Rotor {
    return plane_sandwich_rotor(plane_unitize(self_), other);
}

fn plane_reflect_transflector(self_: Plane, other: Transflector) -> Transflector {
    return plane_sandwich_transflector(plane_unitize(self_), other);
}

fn plane_reflect_translator(self_: Plane, other: Translator) -> Translator {
    return plane_sandwich_translator(plane_unitize(self_), other);
}

fn rotor_rotate_flector(self_: Rotor, other: Flector) -> Flector {
    return rotor_sandwich_flector(self_, other);
}

fn rotor_rotate_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return rotor_sandwich_flectorAtInfinity(self_, other);
}

fn rotor_rotate_horizon(self_: Rotor, other: Horizon) -> Horizon {
    return rotor_sandwich_horizon(self_, other);
}

fn rotor_rotate_line(self_: Rotor, other: Line) -> Line {
    return rotor_sandwich_line(self_, other);
}

fn rotor_rotate_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> LineAtInfinity {
    return rotor_sandwich_lineAtInfinity(self_, other);
}

fn rotor_rotate_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return rotor_sandwich_lineAtOrigin(self_, other);
}

fn rotor_rotate_motor(self_: Rotor, other: Motor) -> Motor {
    return rotor_sandwich_motor(self_, other);
}

fn rotor_rotate_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_sandwich_multiVector(self_, other);
}

fn rotor_rotate_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return rotor_sandwich_multiVectorAtInfinity(self_, other);
}

fn rotor_rotate_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return rotor_sandwich_multiVectorAtOrigin(self_, other);
}

fn rotor_rotate_origin(self_: Rotor, other: Origin) -> Origin {
    return rotor_sandwich_origin(self_, other);
}

fn rotor_rotate_plane(self_: Rotor, other: Plane) -> Plane {
    return rotor_sandwich_plane(self_, other);
}

fn rotor_rotate_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return rotor_sandwich_planeAtOrigin(self_, other);
}

fn rotor_rotate_point(self_: Rotor, other: Point) -> Point {
    return rotor_sandwich_point(self_, other);
}

fn rotor_rotate_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return rotor_sandwich_pointAtInfinity(self_, other);
}

fn rotor_rotate_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return rotor_sandwich_rotor(self_, other);
}

fn rotor_rotate_transflector(self_: Rotor, other: Transflector) -> Transflector {
    return rotor_sandwich_transflector(self_, other);
}

fn rotor_rotate_translator(self_: Rotor, other: Translator) -> Translator {
    return rotor_sandwich_translator(self_, other);
}

fn transflector_transflect_flector(self_: Transflector, other: Flector) -> Flector {
    return transflector_sandwich_flector(self_, other);
}

fn transflector_transflect_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return transflector_sandwich_flectorAtInfinity(self_, other);
}

fn transflector_transflect_horizon(self_: Transflector, other: Horizon) -> Horizon {
    return transflector_sandwich_horizon(self_, other);
}

fn transflector_transflect_line(self_: Transflector, other: Line) -> Line {
    return transflector_sandwich_line(self_, other);
}

fn transflector_transflect_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> LineAtInfinity {
    return transflector_sandwich_lineAtInfinity(self_, other);
}

fn transflector_transflect_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> LineAtOrigin {
    return transflector_sandwich_lineAtOrigin(self_, other);
}

fn transflector_transflect_motor(self_: Transflector, other: Motor) -> Motor {
    return transflector_sandwich_motor(self_, other);
}

fn transflector_transflect_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return transflector_sandwich_multiVector(self_, other);
}

fn transflector_transflect_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return transflector_sandwich_multiVectorAtInfinity(self_, other);
}

fn transflector_transflect_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return transflector_sandwich_multiVectorAtOrigin(self_, other);
}

fn transflector_transflect_origin(self_: Transflector, other: Origin) -> Origin {
    return transflector_sandwich_origin(self_, other);
}

fn transflector_transflect_plane(self_: Transflector, other: Plane) -> Plane {
    return transflector_sandwich_plane(self_, other);
}

fn transflector_transflect_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return transflector_sandwich_planeAtOrigin(self_, other);
}

fn transflector_transflect_point(self_: Transflector, other: Point) -> Point {
    return transflector_sandwich_point(self_, other);
}

fn transflector_transflect_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> PointAtInfinity {
    return transflector_sandwich_pointAtInfinity(self_, other);
}

fn transflector_transflect_rotor(self_: Transflector, other: Rotor) -> Rotor {
    return transflector_sandwich_rotor(self_, other);
}

fn transflector_transflect_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return transflector_sandwich_transflector(self_, other);
}

fn transflector_transflect_translator(self_: Transflector, other: Translator) -> Translator {
    return transflector_sandwich_translator(self_, other);
}

fn translator_translate_flector(self_: Translator, other: Flector) -> Flector {
    return translator_sandwich_flector(self_, other);
}

fn translator_translate_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return translator_sandwich_flectorAtInfinity(self_, other);
}

fn translator_translate_horizon(self_: Translator, other: Horizon) -> Horizon {
    return translator_sandwich_horizon(self_, other);
}

fn translator_translate_line(self_: Translator, other: Line) -> Line {
    return translator_sandwich_line(self_, other);
}

fn translator_translate_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return translator_sandwich_lineAtInfinity(self_, other);
}

fn translator_translate_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> Line {
    return translator_sandwich_lineAtOrigin(self_, other);
}

fn translator_translate_motor(self_: Translator, other: Motor) -> Motor {
    return translator_sandwich_motor(self_, other);
}

fn translator_translate_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_sandwich_multiVector(self_, other);
}

fn translator_translate_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return translator_sandwich_multiVectorAtInfinity(self_, other);
}

fn translator_translate_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return translator_sandwich_multiVectorAtOrigin(self_, other);
}

fn translator_translate_origin(self_: Translator, other: Origin) -> Point {
    return translator_sandwich_origin(self_, other);
}

fn translator_translate_plane(self_: Translator, other: Plane) -> Plane {
    return translator_sandwich_plane(self_, other);
}

fn translator_translate_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Plane {
    return translator_sandwich_planeAtOrigin(self_, other);
}

fn translator_translate_point(self_: Translator, other: Point) -> Point {
    return translator_sandwich_point(self_, other);
}

fn translator_translate_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return translator_sandwich_pointAtInfinity(self_, other);
}

fn translator_translate_rotor(self_: Translator, other: Rotor) -> Motor {
    return translator_sandwich_rotor(self_, other);
}

fn translator_translate_transflector(self_: Translator, other: Transflector) -> Transflector {
    return translator_sandwich_transflector(self_, other);
}

fn translator_translate_translator(self_: Translator, other: Translator) -> Translator {
    return translator_sandwich_translator(self_, other);
}

fn antiScalar_geometricAntiQuotient_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return antiScalar_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return antiScalar_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_flector(self_: AntiScalar, other: Flector) -> Flector {
    return antiScalar_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_line(self_: AntiScalar, other: Line) -> Line {
    return antiScalar_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_lineAtOrigin(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return antiScalar_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_motor(self_: AntiScalar, other: Motor) -> Motor {
    return antiScalar_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return antiScalar_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_multiVectorAtOrigin(self_: AntiScalar, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return antiScalar_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_origin(self_: AntiScalar, other: Origin) -> Origin {
    return antiScalar_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_plane(self_: AntiScalar, other: Plane) -> Plane {
    return antiScalar_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_planeAtOrigin(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return antiScalar_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_point(self_: AntiScalar, other: Point) -> Point {
    return antiScalar_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_rotor(self_: AntiScalar, other: Rotor) -> Rotor {
    return antiScalar_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_transflector(self_: AntiScalar, other: Transflector) -> Transflector {
    return antiScalar_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn antiScalar_geometricAntiQuotient_translator(self_: AntiScalar, other: Translator) -> Translator {
    return antiScalar_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    return dualNum_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_flector(self_: DualNum, other: Flector) -> Flector {
    return dualNum_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_line(self_: DualNum, other: Line) -> Line {
    return dualNum_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_lineAtOrigin(self_: DualNum, other: LineAtOrigin) -> Line {
    return dualNum_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_motor(self_: DualNum, other: Motor) -> MultiVector {
    return dualNum_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return dualNum_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_multiVectorAtOrigin(self_: DualNum, other: MultiVectorAtOrigin) -> MultiVector {
    return dualNum_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_origin(self_: DualNum, other: Origin) -> Flector {
    return dualNum_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_plane(self_: DualNum, other: Plane) -> Transflector {
    return dualNum_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_planeAtOrigin(self_: DualNum, other: PlaneAtOrigin) -> Transflector {
    return dualNum_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_point(self_: DualNum, other: Point) -> Flector {
    return dualNum_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_rotor(self_: DualNum, other: Rotor) -> MultiVector {
    return dualNum_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_transflector(self_: DualNum, other: Transflector) -> Transflector {
    return dualNum_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn dualNum_geometricAntiQuotient_translator(self_: DualNum, other: Translator) -> MultiVector {
    return dualNum_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn flector_geometricAntiQuotient_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    return flector_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn flector_geometricAntiQuotient_dualNum(self_: Flector, other: DualNum) -> Flector {
    return flector_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn flector_geometricAntiQuotient_flector(self_: Flector, other: Flector) -> MultiVector {
    return flector_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn flector_geometricAntiQuotient_line(self_: Flector, other: Line) -> Flector {
    return flector_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn flector_geometricAntiQuotient_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Flector {
    return flector_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn flector_geometricAntiQuotient_motor(self_: Flector, other: Motor) -> Flector {
    return flector_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn flector_geometricAntiQuotient_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn flector_geometricAntiQuotient_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return flector_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn flector_geometricAntiQuotient_origin(self_: Flector, other: Origin) -> MultiVector {
    return flector_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn flector_geometricAntiQuotient_plane(self_: Flector, other: Plane) -> MultiVector {
    return flector_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn flector_geometricAntiQuotient_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return flector_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn flector_geometricAntiQuotient_point(self_: Flector, other: Point) -> MultiVector {
    return flector_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn flector_geometricAntiQuotient_rotor(self_: Flector, other: Rotor) -> Flector {
    return flector_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn flector_geometricAntiQuotient_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return flector_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn flector_geometricAntiQuotient_translator(self_: Flector, other: Translator) -> Flector {
    return flector_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_antiScalar(self_: FlectorAtInfinity, other: AntiScalar) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_dualNum(self_: FlectorAtInfinity, other: DualNum) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_line(self_: FlectorAtInfinity, other: Line) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_motor(self_: FlectorAtInfinity, other: Motor) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_origin(self_: FlectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_point(self_: FlectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_rotor(self_: FlectorAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn flectorAtInfinity_geometricAntiQuotient_translator(self_: FlectorAtInfinity, other: Translator) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn horizon_geometricAntiQuotient_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return horizon_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn horizon_geometricAntiQuotient_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return horizon_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn horizon_geometricAntiQuotient_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return horizon_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn horizon_geometricAntiQuotient_line(self_: Horizon, other: Line) -> PointAtInfinity {
    return horizon_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn horizon_geometricAntiQuotient_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return horizon_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn horizon_geometricAntiQuotient_motor(self_: Horizon, other: Motor) -> FlectorAtInfinity {
    return horizon_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn horizon_geometricAntiQuotient_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return horizon_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn horizon_geometricAntiQuotient_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return horizon_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn horizon_geometricAntiQuotient_origin(self_: Horizon, other: Origin) -> Scalar {
    return horizon_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn horizon_geometricAntiQuotient_plane(self_: Horizon, other: Plane) -> LineAtInfinity {
    return horizon_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn horizon_geometricAntiQuotient_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return horizon_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn horizon_geometricAntiQuotient_point(self_: Horizon, other: Point) -> Scalar {
    return horizon_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn horizon_geometricAntiQuotient_rotor(self_: Horizon, other: Rotor) -> FlectorAtInfinity {
    return horizon_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn horizon_geometricAntiQuotient_transflector(self_: Horizon, other: Transflector) -> LineAtInfinity {
    return horizon_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn horizon_geometricAntiQuotient_translator(self_: Horizon, other: Translator) -> Horizon {
    return horizon_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn line_geometricAntiQuotient_antiScalar(self_: Line, other: AntiScalar) -> Line {
    return line_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn line_geometricAntiQuotient_dualNum(self_: Line, other: DualNum) -> Line {
    return line_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn line_geometricAntiQuotient_flector(self_: Line, other: Flector) -> Flector {
    return line_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn line_geometricAntiQuotient_line(self_: Line, other: Line) -> MultiVector {
    return line_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn line_geometricAntiQuotient_lineAtOrigin(self_: Line, other: LineAtOrigin) -> MultiVector {
    return line_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn line_geometricAntiQuotient_motor(self_: Line, other: Motor) -> MultiVector {
    return line_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn line_geometricAntiQuotient_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return line_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn line_geometricAntiQuotient_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return line_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn line_geometricAntiQuotient_origin(self_: Line, other: Origin) -> Transflector {
    return line_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn line_geometricAntiQuotient_plane(self_: Line, other: Plane) -> Flector {
    return line_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn line_geometricAntiQuotient_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Flector {
    return line_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn line_geometricAntiQuotient_point(self_: Line, other: Point) -> Transflector {
    return line_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn line_geometricAntiQuotient_rotor(self_: Line, other: Rotor) -> MultiVector {
    return line_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn line_geometricAntiQuotient_transflector(self_: Line, other: Transflector) -> Flector {
    return line_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn line_geometricAntiQuotient_translator(self_: Line, other: Translator) -> MultiVector {
    return line_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_antiScalar(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return lineAtInfinity_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_dualNum(self_: LineAtInfinity, other: DualNum) -> LineAtInfinity {
    return lineAtInfinity_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_flector(self_: LineAtInfinity, other: Flector) -> FlectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_line(self_: LineAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_origin(self_: LineAtInfinity, other: Origin) -> PointAtInfinity {
    return lineAtInfinity_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_plane(self_: LineAtInfinity, other: Plane) -> FlectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> FlectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_point(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return lineAtInfinity_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_transflector(self_: LineAtInfinity, other: Transflector) -> FlectorAtInfinity {
    return lineAtInfinity_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn lineAtInfinity_geometricAntiQuotient_translator(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return lineAtInfinity_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_antiScalar(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return lineAtOrigin_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_dualNum(self_: LineAtOrigin, other: DualNum) -> Line {
    return lineAtOrigin_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return lineAtOrigin_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_line(self_: LineAtOrigin, other: Line) -> MultiVector {
    return lineAtOrigin_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return lineAtOrigin_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return lineAtOrigin_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return lineAtOrigin_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_origin(self_: LineAtOrigin, other: Origin) -> PlaneAtOrigin {
    return lineAtOrigin_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_plane(self_: LineAtOrigin, other: Plane) -> Flector {
    return lineAtOrigin_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return lineAtOrigin_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_point(self_: LineAtOrigin, other: Point) -> Transflector {
    return lineAtOrigin_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_rotor(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return lineAtOrigin_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_transflector(self_: LineAtOrigin, other: Transflector) -> Flector {
    return lineAtOrigin_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn lineAtOrigin_geometricAntiQuotient_translator(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return lineAtOrigin_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn motor_geometricAntiQuotient_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    return motor_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn motor_geometricAntiQuotient_dualNum(self_: Motor, other: DualNum) -> MultiVector {
    return motor_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn motor_geometricAntiQuotient_flector(self_: Motor, other: Flector) -> Flector {
    return motor_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn motor_geometricAntiQuotient_line(self_: Motor, other: Line) -> MultiVector {
    return motor_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn motor_geometricAntiQuotient_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return motor_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn motor_geometricAntiQuotient_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn motor_geometricAntiQuotient_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn motor_geometricAntiQuotient_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return motor_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn motor_geometricAntiQuotient_origin(self_: Motor, other: Origin) -> Flector {
    return motor_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn motor_geometricAntiQuotient_plane(self_: Motor, other: Plane) -> Flector {
    return motor_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn motor_geometricAntiQuotient_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return motor_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn motor_geometricAntiQuotient_point(self_: Motor, other: Point) -> Flector {
    return motor_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn motor_geometricAntiQuotient_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return motor_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn motor_geometricAntiQuotient_transflector(self_: Motor, other: Transflector) -> Flector {
    return motor_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn motor_geometricAntiQuotient_translator(self_: Motor, other: Translator) -> MultiVector {
    return motor_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return multiVector_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return multiVector_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_line(self_: MultiVector, other: Line) -> MultiVector {
    return multiVector_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multiVector_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return multiVector_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return multiVector_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return multiVector_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multiVector_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_point(self_: MultiVector, other: Point) -> MultiVector {
    return multiVector_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return multiVector_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn multiVector_geometricAntiQuotient_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return multiVector_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_antiScalar(self_: MultiVectorAtInfinity, other: AntiScalar) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn multiVectorAtInfinity_geometricAntiQuotient_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_antiScalar(self_: MultiVectorAtOrigin, other: AntiScalar) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn multiVectorAtOrigin_geometricAntiQuotient_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVector {
    return multiVectorAtOrigin_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn origin_geometricAntiQuotient_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return origin_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn origin_geometricAntiQuotient_dualNum(self_: Origin, other: DualNum) -> Flector {
    return origin_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn origin_geometricAntiQuotient_flector(self_: Origin, other: Flector) -> MultiVector {
    return origin_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn origin_geometricAntiQuotient_line(self_: Origin, other: Line) -> Transflector {
    return origin_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn origin_geometricAntiQuotient_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return origin_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn origin_geometricAntiQuotient_motor(self_: Origin, other: Motor) -> Flector {
    return origin_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn origin_geometricAntiQuotient_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn origin_geometricAntiQuotient_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return origin_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn origin_geometricAntiQuotient_origin(self_: Origin, other: Origin) -> AntiScalar {
    return origin_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn origin_geometricAntiQuotient_plane(self_: Origin, other: Plane) -> MultiVector {
    return origin_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn origin_geometricAntiQuotient_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return origin_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn origin_geometricAntiQuotient_point(self_: Origin, other: Point) -> Translator {
    return origin_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn origin_geometricAntiQuotient_rotor(self_: Origin, other: Rotor) -> Flector {
    return origin_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn origin_geometricAntiQuotient_transflector(self_: Origin, other: Transflector) -> MultiVector {
    return origin_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn origin_geometricAntiQuotient_translator(self_: Origin, other: Translator) -> Point {
    return origin_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn plane_geometricAntiQuotient_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    return plane_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn plane_geometricAntiQuotient_dualNum(self_: Plane, other: DualNum) -> Transflector {
    return plane_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn plane_geometricAntiQuotient_flector(self_: Plane, other: Flector) -> MultiVector {
    return plane_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn plane_geometricAntiQuotient_line(self_: Plane, other: Line) -> Flector {
    return plane_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn plane_geometricAntiQuotient_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> Flector {
    return plane_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn plane_geometricAntiQuotient_motor(self_: Plane, other: Motor) -> Flector {
    return plane_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn plane_geometricAntiQuotient_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn plane_geometricAntiQuotient_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return plane_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn plane_geometricAntiQuotient_origin(self_: Plane, other: Origin) -> MultiVector {
    return plane_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn plane_geometricAntiQuotient_plane(self_: Plane, other: Plane) -> Motor {
    return plane_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn plane_geometricAntiQuotient_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return plane_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn plane_geometricAntiQuotient_point(self_: Plane, other: Point) -> MultiVector {
    return plane_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn plane_geometricAntiQuotient_rotor(self_: Plane, other: Rotor) -> Flector {
    return plane_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn plane_geometricAntiQuotient_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return plane_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn plane_geometricAntiQuotient_translator(self_: Plane, other: Translator) -> Transflector {
    return plane_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_antiScalar(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return planeAtOrigin_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_dualNum(self_: PlaneAtOrigin, other: DualNum) -> Transflector {
    return planeAtOrigin_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return planeAtOrigin_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_line(self_: PlaneAtOrigin, other: Line) -> Flector {
    return planeAtOrigin_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return planeAtOrigin_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return planeAtOrigin_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return planeAtOrigin_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return planeAtOrigin_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_origin(self_: PlaneAtOrigin, other: Origin) -> LineAtOrigin {
    return planeAtOrigin_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_plane(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return planeAtOrigin_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return planeAtOrigin_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_point(self_: PlaneAtOrigin, other: Point) -> MultiVector {
    return planeAtOrigin_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_rotor(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return planeAtOrigin_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return planeAtOrigin_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn planeAtOrigin_geometricAntiQuotient_translator(self_: PlaneAtOrigin, other: Translator) -> Transflector {
    return planeAtOrigin_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn point_geometricAntiQuotient_antiScalar(self_: Point, other: AntiScalar) -> Point {
    return point_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn point_geometricAntiQuotient_dualNum(self_: Point, other: DualNum) -> Flector {
    return point_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn point_geometricAntiQuotient_flector(self_: Point, other: Flector) -> MultiVector {
    return point_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn point_geometricAntiQuotient_line(self_: Point, other: Line) -> Transflector {
    return point_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn point_geometricAntiQuotient_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Transflector {
    return point_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn point_geometricAntiQuotient_motor(self_: Point, other: Motor) -> Flector {
    return point_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn point_geometricAntiQuotient_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return point_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn point_geometricAntiQuotient_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return point_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn point_geometricAntiQuotient_origin(self_: Point, other: Origin) -> Translator {
    return point_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn point_geometricAntiQuotient_plane(self_: Point, other: Plane) -> MultiVector {
    return point_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn point_geometricAntiQuotient_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> MultiVector {
    return point_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn point_geometricAntiQuotient_point(self_: Point, other: Point) -> Translator {
    return point_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn point_geometricAntiQuotient_rotor(self_: Point, other: Rotor) -> Flector {
    return point_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn point_geometricAntiQuotient_transflector(self_: Point, other: Transflector) -> MultiVector {
    return point_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn point_geometricAntiQuotient_translator(self_: Point, other: Translator) -> Point {
    return point_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_antiScalar(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return pointAtInfinity_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_dualNum(self_: PointAtInfinity, other: DualNum) -> PointAtInfinity {
    return pointAtInfinity_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_flector(self_: PointAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_line(self_: PointAtInfinity, other: Line) -> FlectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> FlectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_motor(self_: PointAtInfinity, other: Motor) -> FlectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_origin(self_: PointAtInfinity, other: Origin) -> LineAtInfinity {
    return pointAtInfinity_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_plane(self_: PointAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_point(self_: PointAtInfinity, other: Point) -> LineAtInfinity {
    return pointAtInfinity_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_rotor(self_: PointAtInfinity, other: Rotor) -> FlectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_transflector(self_: PointAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn pointAtInfinity_geometricAntiQuotient_translator(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return pointAtInfinity_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn rotor_geometricAntiQuotient_antiScalar(self_: Rotor, other: AntiScalar) -> Rotor {
    return rotor_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn rotor_geometricAntiQuotient_dualNum(self_: Rotor, other: DualNum) -> MultiVector {
    return rotor_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn rotor_geometricAntiQuotient_flector(self_: Rotor, other: Flector) -> Flector {
    return rotor_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn rotor_geometricAntiQuotient_line(self_: Rotor, other: Line) -> MultiVector {
    return rotor_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn rotor_geometricAntiQuotient_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return rotor_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn rotor_geometricAntiQuotient_motor(self_: Rotor, other: Motor) -> MultiVector {
    return rotor_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn rotor_geometricAntiQuotient_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn rotor_geometricAntiQuotient_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return rotor_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn rotor_geometricAntiQuotient_origin(self_: Rotor, other: Origin) -> Flector {
    return rotor_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn rotor_geometricAntiQuotient_plane(self_: Rotor, other: Plane) -> Flector {
    return rotor_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn rotor_geometricAntiQuotient_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return rotor_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn rotor_geometricAntiQuotient_point(self_: Rotor, other: Point) -> Flector {
    return rotor_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn rotor_geometricAntiQuotient_rotor(self_: Rotor, other: Rotor) -> Rotor {
    return rotor_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn rotor_geometricAntiQuotient_transflector(self_: Rotor, other: Transflector) -> Flector {
    return rotor_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn rotor_geometricAntiQuotient_translator(self_: Rotor, other: Translator) -> MultiVector {
    return rotor_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn scalar_geometricAntiQuotient_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return scalar_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn scalar_geometricAntiQuotient_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return scalar_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn scalar_geometricAntiQuotient_flector(self_: Scalar, other: Flector) -> FlectorAtInfinity {
    return scalar_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn scalar_geometricAntiQuotient_line(self_: Scalar, other: Line) -> LineAtInfinity {
    return scalar_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn scalar_geometricAntiQuotient_lineAtOrigin(self_: Scalar, other: LineAtOrigin) -> LineAtInfinity {
    return scalar_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn scalar_geometricAntiQuotient_motor(self_: Scalar, other: Motor) -> MultiVectorAtInfinity {
    return scalar_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn scalar_geometricAntiQuotient_multiVector(self_: Scalar, other: MultiVector) -> MultiVectorAtInfinity {
    return scalar_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn scalar_geometricAntiQuotient_multiVectorAtOrigin(self_: Scalar, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return scalar_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn scalar_geometricAntiQuotient_origin(self_: Scalar, other: Origin) -> Horizon {
    return scalar_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn scalar_geometricAntiQuotient_plane(self_: Scalar, other: Plane) -> PointAtInfinity {
    return scalar_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn scalar_geometricAntiQuotient_planeAtOrigin(self_: Scalar, other: PlaneAtOrigin) -> PointAtInfinity {
    return scalar_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn scalar_geometricAntiQuotient_point(self_: Scalar, other: Point) -> Horizon {
    return scalar_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn scalar_geometricAntiQuotient_rotor(self_: Scalar, other: Rotor) -> MultiVectorAtInfinity {
    return scalar_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn scalar_geometricAntiQuotient_transflector(self_: Scalar, other: Transflector) -> PointAtInfinity {
    return scalar_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn scalar_geometricAntiQuotient_translator(self_: Scalar, other: Translator) -> Scalar {
    return scalar_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn transflector_geometricAntiQuotient_antiScalar(self_: Transflector, other: AntiScalar) -> Transflector {
    return transflector_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn transflector_geometricAntiQuotient_dualNum(self_: Transflector, other: DualNum) -> Transflector {
    return transflector_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn transflector_geometricAntiQuotient_flector(self_: Transflector, other: Flector) -> MultiVector {
    return transflector_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn transflector_geometricAntiQuotient_line(self_: Transflector, other: Line) -> Flector {
    return transflector_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn transflector_geometricAntiQuotient_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Flector {
    return transflector_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn transflector_geometricAntiQuotient_motor(self_: Transflector, other: Motor) -> Flector {
    return transflector_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn transflector_geometricAntiQuotient_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return transflector_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn transflector_geometricAntiQuotient_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return transflector_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn transflector_geometricAntiQuotient_origin(self_: Transflector, other: Origin) -> MultiVector {
    return transflector_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn transflector_geometricAntiQuotient_plane(self_: Transflector, other: Plane) -> MultiVector {
    return transflector_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn transflector_geometricAntiQuotient_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> MultiVector {
    return transflector_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn transflector_geometricAntiQuotient_point(self_: Transflector, other: Point) -> MultiVector {
    return transflector_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn transflector_geometricAntiQuotient_rotor(self_: Transflector, other: Rotor) -> Flector {
    return transflector_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn transflector_geometricAntiQuotient_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return transflector_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn transflector_geometricAntiQuotient_translator(self_: Transflector, other: Translator) -> Transflector {
    return transflector_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn translator_geometricAntiQuotient_antiScalar(self_: Translator, other: AntiScalar) -> Translator {
    return translator_geometricAntiProduct_antiScalar(self_, antiScalar_antiInverse(other));
}

fn translator_geometricAntiQuotient_dualNum(self_: Translator, other: DualNum) -> MultiVector {
    return translator_geometricAntiProduct_dualNum(self_, dualNum_antiInverse(other));
}

fn translator_geometricAntiQuotient_flector(self_: Translator, other: Flector) -> Flector {
    return translator_geometricAntiProduct_flector(self_, flector_antiInverse(other));
}

fn translator_geometricAntiQuotient_line(self_: Translator, other: Line) -> MultiVector {
    return translator_geometricAntiProduct_line(self_, line_antiInverse(other));
}

fn translator_geometricAntiQuotient_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return translator_geometricAntiProduct_lineAtOrigin(self_, lineAtOrigin_antiInverse(other));
}

fn translator_geometricAntiQuotient_motor(self_: Translator, other: Motor) -> MultiVector {
    return translator_geometricAntiProduct_motor(self_, motor_antiInverse(other));
}

fn translator_geometricAntiQuotient_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_geometricAntiProduct_multiVector(self_, multiVector_antiInverse(other));
}

fn translator_geometricAntiQuotient_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return translator_geometricAntiProduct_multiVectorAtOrigin(self_, multiVectorAtOrigin_antiInverse(other));
}

fn translator_geometricAntiQuotient_origin(self_: Translator, other: Origin) -> Point {
    return translator_geometricAntiProduct_origin(self_, origin_antiInverse(other));
}

fn translator_geometricAntiQuotient_plane(self_: Translator, other: Plane) -> Transflector {
    return translator_geometricAntiProduct_plane(self_, plane_antiInverse(other));
}

fn translator_geometricAntiQuotient_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Transflector {
    return translator_geometricAntiProduct_planeAtOrigin(self_, planeAtOrigin_antiInverse(other));
}

fn translator_geometricAntiQuotient_point(self_: Translator, other: Point) -> Point {
    return translator_geometricAntiProduct_point(self_, point_antiInverse(other));
}

fn translator_geometricAntiQuotient_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return translator_geometricAntiProduct_rotor(self_, rotor_antiInverse(other));
}

fn translator_geometricAntiQuotient_transflector(self_: Translator, other: Transflector) -> Transflector {
    return translator_geometricAntiProduct_transflector(self_, transflector_antiInverse(other));
}

fn translator_geometricAntiQuotient_translator(self_: Translator, other: Translator) -> Translator {
    return translator_geometricAntiProduct_translator(self_, translator_antiInverse(other));
}

fn antiScalar_geometricQuotient_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return antiScalar_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn antiScalar_geometricQuotient_flector(self_: AntiScalar, other: Flector) -> Flector {
    return antiScalar_geometricProduct_flector(self_, flector_inverse(other));
}

fn antiScalar_geometricQuotient_flectorAtInfinity(self_: AntiScalar, other: FlectorAtInfinity) -> Flector {
    return antiScalar_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn antiScalar_geometricQuotient_horizon(self_: AntiScalar, other: Horizon) -> Origin {
    return antiScalar_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn antiScalar_geometricQuotient_line(self_: AntiScalar, other: Line) -> LineAtOrigin {
    return antiScalar_geometricProduct_line(self_, line_inverse(other));
}

fn antiScalar_geometricQuotient_lineAtInfinity(self_: AntiScalar, other: LineAtInfinity) -> LineAtOrigin {
    return antiScalar_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn antiScalar_geometricQuotient_motor(self_: AntiScalar, other: Motor) -> LineAtOrigin {
    return antiScalar_geometricProduct_motor(self_, motor_inverse(other));
}

fn antiScalar_geometricQuotient_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVectorAtOrigin {
    return antiScalar_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn antiScalar_geometricQuotient_multiVectorAtInfinity(self_: AntiScalar, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return antiScalar_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn antiScalar_geometricQuotient_plane(self_: AntiScalar, other: Plane) -> Origin {
    return antiScalar_geometricProduct_plane(self_, plane_inverse(other));
}

fn antiScalar_geometricQuotient_point(self_: AntiScalar, other: Point) -> PlaneAtOrigin {
    return antiScalar_geometricProduct_point(self_, point_inverse(other));
}

fn antiScalar_geometricQuotient_pointAtInfinity(self_: AntiScalar, other: PointAtInfinity) -> PlaneAtOrigin {
    return antiScalar_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn antiScalar_geometricQuotient_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return antiScalar_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn antiScalar_geometricQuotient_transflector(self_: AntiScalar, other: Transflector) -> Flector {
    return antiScalar_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn antiScalar_geometricQuotient_translator(self_: AntiScalar, other: Translator) -> LineAtOrigin {
    return antiScalar_geometricProduct_translator(self_, translator_inverse(other));
}

fn dualNum_geometricQuotient_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn dualNum_geometricQuotient_flector(self_: DualNum, other: Flector) -> Flector {
    return dualNum_geometricProduct_flector(self_, flector_inverse(other));
}

fn dualNum_geometricQuotient_flectorAtInfinity(self_: DualNum, other: FlectorAtInfinity) -> Flector {
    return dualNum_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn dualNum_geometricQuotient_horizon(self_: DualNum, other: Horizon) -> Flector {
    return dualNum_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn dualNum_geometricQuotient_line(self_: DualNum, other: Line) -> Line {
    return dualNum_geometricProduct_line(self_, line_inverse(other));
}

fn dualNum_geometricQuotient_lineAtInfinity(self_: DualNum, other: LineAtInfinity) -> Line {
    return dualNum_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn dualNum_geometricQuotient_motor(self_: DualNum, other: Motor) -> Motor {
    return dualNum_geometricProduct_motor(self_, motor_inverse(other));
}

fn dualNum_geometricQuotient_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    return dualNum_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn dualNum_geometricQuotient_multiVectorAtInfinity(self_: DualNum, other: MultiVectorAtInfinity) -> MultiVector {
    return dualNum_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn dualNum_geometricQuotient_plane(self_: DualNum, other: Plane) -> Flector {
    return dualNum_geometricProduct_plane(self_, plane_inverse(other));
}

fn dualNum_geometricQuotient_point(self_: DualNum, other: Point) -> Flector {
    return dualNum_geometricProduct_point(self_, point_inverse(other));
}

fn dualNum_geometricQuotient_pointAtInfinity(self_: DualNum, other: PointAtInfinity) -> Transflector {
    return dualNum_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn dualNum_geometricQuotient_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return dualNum_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn dualNum_geometricQuotient_transflector(self_: DualNum, other: Transflector) -> Flector {
    return dualNum_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn dualNum_geometricQuotient_translator(self_: DualNum, other: Translator) -> Motor {
    return dualNum_geometricProduct_translator(self_, translator_inverse(other));
}

fn flector_geometricQuotient_dualNum(self_: Flector, other: DualNum) -> Flector {
    return flector_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn flector_geometricQuotient_flector(self_: Flector, other: Flector) -> MultiVector {
    return flector_geometricProduct_flector(self_, flector_inverse(other));
}

fn flector_geometricQuotient_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVector {
    return flector_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn flector_geometricQuotient_horizon(self_: Flector, other: Horizon) -> MultiVector {
    return flector_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn flector_geometricQuotient_line(self_: Flector, other: Line) -> Flector {
    return flector_geometricProduct_line(self_, line_inverse(other));
}

fn flector_geometricQuotient_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Flector {
    return flector_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn flector_geometricQuotient_motor(self_: Flector, other: Motor) -> Flector {
    return flector_geometricProduct_motor(self_, motor_inverse(other));
}

fn flector_geometricQuotient_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn flector_geometricQuotient_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return flector_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn flector_geometricQuotient_plane(self_: Flector, other: Plane) -> MultiVector {
    return flector_geometricProduct_plane(self_, plane_inverse(other));
}

fn flector_geometricQuotient_point(self_: Flector, other: Point) -> MultiVector {
    return flector_geometricProduct_point(self_, point_inverse(other));
}

fn flector_geometricQuotient_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return flector_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn flector_geometricQuotient_scalar(self_: Flector, other: Scalar) -> Flector {
    return flector_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn flector_geometricQuotient_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return flector_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn flector_geometricQuotient_translator(self_: Flector, other: Translator) -> Flector {
    return flector_geometricProduct_translator(self_, translator_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_dualNum(self_: FlectorAtInfinity, other: DualNum) -> Flector {
    return flectorAtInfinity_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVector {
    return flectorAtInfinity_geometricProduct_flector(self_, flector_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_horizon(self_: FlectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_line(self_: FlectorAtInfinity, other: Line) -> Flector {
    return flectorAtInfinity_geometricProduct_line(self_, line_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_motor(self_: FlectorAtInfinity, other: Motor) -> Flector {
    return flectorAtInfinity_geometricProduct_motor(self_, motor_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return flectorAtInfinity_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVector {
    return flectorAtInfinity_geometricProduct_plane(self_, plane_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_point(self_: FlectorAtInfinity, other: Point) -> MultiVector {
    return flectorAtInfinity_geometricProduct_point(self_, point_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_scalar(self_: FlectorAtInfinity, other: Scalar) -> FlectorAtInfinity {
    return flectorAtInfinity_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVector {
    return flectorAtInfinity_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn flectorAtInfinity_geometricQuotient_translator(self_: FlectorAtInfinity, other: Translator) -> Flector {
    return flectorAtInfinity_geometricProduct_translator(self_, translator_inverse(other));
}

fn horizon_geometricQuotient_dualNum(self_: Horizon, other: DualNum) -> Flector {
    return horizon_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn horizon_geometricQuotient_flector(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_geometricProduct_flector(self_, flector_inverse(other));
}

fn horizon_geometricQuotient_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn horizon_geometricQuotient_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return horizon_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn horizon_geometricQuotient_line(self_: Horizon, other: Line) -> Transflector {
    return horizon_geometricProduct_line(self_, line_inverse(other));
}

fn horizon_geometricQuotient_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return horizon_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn horizon_geometricQuotient_motor(self_: Horizon, other: Motor) -> Flector {
    return horizon_geometricProduct_motor(self_, motor_inverse(other));
}

fn horizon_geometricQuotient_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn horizon_geometricQuotient_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn horizon_geometricQuotient_plane(self_: Horizon, other: Plane) -> MultiVector {
    return horizon_geometricProduct_plane(self_, plane_inverse(other));
}

fn horizon_geometricQuotient_point(self_: Horizon, other: Point) -> Translator {
    return horizon_geometricProduct_point(self_, point_inverse(other));
}

fn horizon_geometricQuotient_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return horizon_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn horizon_geometricQuotient_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return horizon_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn horizon_geometricQuotient_transflector(self_: Horizon, other: Transflector) -> MultiVector {
    return horizon_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn horizon_geometricQuotient_translator(self_: Horizon, other: Translator) -> Point {
    return horizon_geometricProduct_translator(self_, translator_inverse(other));
}

fn line_geometricQuotient_dualNum(self_: Line, other: DualNum) -> Line {
    return line_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn line_geometricQuotient_flector(self_: Line, other: Flector) -> Flector {
    return line_geometricProduct_flector(self_, flector_inverse(other));
}

fn line_geometricQuotient_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Flector {
    return line_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn line_geometricQuotient_horizon(self_: Line, other: Horizon) -> Transflector {
    return line_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn line_geometricQuotient_line(self_: Line, other: Line) -> MultiVector {
    return line_geometricProduct_line(self_, line_inverse(other));
}

fn line_geometricQuotient_lineAtInfinity(self_: Line, other: LineAtInfinity) -> MultiVector {
    return line_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn line_geometricQuotient_motor(self_: Line, other: Motor) -> MultiVector {
    return line_geometricProduct_motor(self_, motor_inverse(other));
}

fn line_geometricQuotient_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return line_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn line_geometricQuotient_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return line_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn line_geometricQuotient_plane(self_: Line, other: Plane) -> Flector {
    return line_geometricProduct_plane(self_, plane_inverse(other));
}

fn line_geometricQuotient_point(self_: Line, other: Point) -> Flector {
    return line_geometricProduct_point(self_, point_inverse(other));
}

fn line_geometricQuotient_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Flector {
    return line_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn line_geometricQuotient_scalar(self_: Line, other: Scalar) -> Line {
    return line_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn line_geometricQuotient_transflector(self_: Line, other: Transflector) -> Flector {
    return line_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn line_geometricQuotient_translator(self_: Line, other: Translator) -> MultiVector {
    return line_geometricProduct_translator(self_, translator_inverse(other));
}

fn lineAtInfinity_geometricQuotient_dualNum(self_: LineAtInfinity, other: DualNum) -> Line {
    return lineAtInfinity_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn lineAtInfinity_geometricQuotient_flector(self_: LineAtInfinity, other: Flector) -> Flector {
    return lineAtInfinity_geometricProduct_flector(self_, flector_inverse(other));
}

fn lineAtInfinity_geometricQuotient_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return lineAtInfinity_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn lineAtInfinity_geometricQuotient_horizon(self_: LineAtInfinity, other: Horizon) -> PointAtInfinity {
    return lineAtInfinity_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn lineAtInfinity_geometricQuotient_line(self_: LineAtInfinity, other: Line) -> MultiVector {
    return lineAtInfinity_geometricProduct_line(self_, line_inverse(other));
}

fn lineAtInfinity_geometricQuotient_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn lineAtInfinity_geometricQuotient_motor(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return lineAtInfinity_geometricProduct_motor(self_, motor_inverse(other));
}

fn lineAtInfinity_geometricQuotient_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return lineAtInfinity_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn lineAtInfinity_geometricQuotient_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return lineAtInfinity_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn lineAtInfinity_geometricQuotient_plane(self_: LineAtInfinity, other: Plane) -> Flector {
    return lineAtInfinity_geometricProduct_plane(self_, plane_inverse(other));
}

fn lineAtInfinity_geometricQuotient_point(self_: LineAtInfinity, other: Point) -> Transflector {
    return lineAtInfinity_geometricProduct_point(self_, point_inverse(other));
}

fn lineAtInfinity_geometricQuotient_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> FlectorAtInfinity {
    return lineAtInfinity_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn lineAtInfinity_geometricQuotient_scalar(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return lineAtInfinity_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn lineAtInfinity_geometricQuotient_transflector(self_: LineAtInfinity, other: Transflector) -> Flector {
    return lineAtInfinity_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn lineAtInfinity_geometricQuotient_translator(self_: LineAtInfinity, other: Translator) -> MultiVector {
    return lineAtInfinity_geometricProduct_translator(self_, translator_inverse(other));
}

fn lineAtOrigin_geometricQuotient_dualNum(self_: LineAtOrigin, other: DualNum) -> LineAtOrigin {
    return lineAtOrigin_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn lineAtOrigin_geometricQuotient_flector(self_: LineAtOrigin, other: Flector) -> Flector {
    return lineAtOrigin_geometricProduct_flector(self_, flector_inverse(other));
}

fn lineAtOrigin_geometricQuotient_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> Flector {
    return lineAtOrigin_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn lineAtOrigin_geometricQuotient_horizon(self_: LineAtOrigin, other: Horizon) -> PlaneAtOrigin {
    return lineAtOrigin_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn lineAtOrigin_geometricQuotient_line(self_: LineAtOrigin, other: Line) -> Rotor {
    return lineAtOrigin_geometricProduct_line(self_, line_inverse(other));
}

fn lineAtOrigin_geometricQuotient_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> Rotor {
    return lineAtOrigin_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn lineAtOrigin_geometricQuotient_motor(self_: LineAtOrigin, other: Motor) -> Rotor {
    return lineAtOrigin_geometricProduct_motor(self_, motor_inverse(other));
}

fn lineAtOrigin_geometricQuotient_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return lineAtOrigin_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn lineAtOrigin_geometricQuotient_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return lineAtOrigin_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn lineAtOrigin_geometricQuotient_plane(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return lineAtOrigin_geometricProduct_plane(self_, plane_inverse(other));
}

fn lineAtOrigin_geometricQuotient_point(self_: LineAtOrigin, other: Point) -> Flector {
    return lineAtOrigin_geometricProduct_point(self_, point_inverse(other));
}

fn lineAtOrigin_geometricQuotient_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return lineAtOrigin_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn lineAtOrigin_geometricQuotient_scalar(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return lineAtOrigin_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn lineAtOrigin_geometricQuotient_transflector(self_: LineAtOrigin, other: Transflector) -> Flector {
    return lineAtOrigin_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn lineAtOrigin_geometricQuotient_translator(self_: LineAtOrigin, other: Translator) -> Rotor {
    return lineAtOrigin_geometricProduct_translator(self_, translator_inverse(other));
}

fn motor_geometricQuotient_dualNum(self_: Motor, other: DualNum) -> Motor {
    return motor_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn motor_geometricQuotient_flector(self_: Motor, other: Flector) -> Flector {
    return motor_geometricProduct_flector(self_, flector_inverse(other));
}

fn motor_geometricQuotient_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Flector {
    return motor_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn motor_geometricQuotient_horizon(self_: Motor, other: Horizon) -> Flector {
    return motor_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn motor_geometricQuotient_line(self_: Motor, other: Line) -> MultiVector {
    return motor_geometricProduct_line(self_, line_inverse(other));
}

fn motor_geometricQuotient_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return motor_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn motor_geometricQuotient_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_geometricProduct_motor(self_, motor_inverse(other));
}

fn motor_geometricQuotient_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn motor_geometricQuotient_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return motor_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn motor_geometricQuotient_plane(self_: Motor, other: Plane) -> Flector {
    return motor_geometricProduct_plane(self_, plane_inverse(other));
}

fn motor_geometricQuotient_point(self_: Motor, other: Point) -> Flector {
    return motor_geometricProduct_point(self_, point_inverse(other));
}

fn motor_geometricQuotient_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Flector {
    return motor_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn motor_geometricQuotient_scalar(self_: Motor, other: Scalar) -> Motor {
    return motor_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn motor_geometricQuotient_transflector(self_: Motor, other: Transflector) -> Flector {
    return motor_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn motor_geometricQuotient_translator(self_: Motor, other: Translator) -> MultiVector {
    return motor_geometricProduct_translator(self_, translator_inverse(other));
}

fn multiVector_geometricQuotient_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    return multiVector_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn multiVector_geometricQuotient_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_geometricProduct_flector(self_, flector_inverse(other));
}

fn multiVector_geometricQuotient_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return multiVector_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn multiVector_geometricQuotient_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return multiVector_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn multiVector_geometricQuotient_line(self_: MultiVector, other: Line) -> MultiVector {
    return multiVector_geometricProduct_line(self_, line_inverse(other));
}

fn multiVector_geometricQuotient_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multiVector_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn multiVector_geometricQuotient_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return multiVector_geometricProduct_motor(self_, motor_inverse(other));
}

fn multiVector_geometricQuotient_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn multiVector_geometricQuotient_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn multiVector_geometricQuotient_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return multiVector_geometricProduct_plane(self_, plane_inverse(other));
}

fn multiVector_geometricQuotient_point(self_: MultiVector, other: Point) -> MultiVector {
    return multiVector_geometricProduct_point(self_, point_inverse(other));
}

fn multiVector_geometricQuotient_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multiVector_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn multiVector_geometricQuotient_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    return multiVector_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn multiVector_geometricQuotient_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn multiVector_geometricQuotient_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return multiVector_geometricProduct_translator(self_, translator_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_dualNum(self_: MultiVectorAtInfinity, other: DualNum) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_flector(self_, flector_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_line(self_, line_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_motor(self_, motor_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_plane(self_, plane_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_point(self_, point_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_scalar(self_: MultiVectorAtInfinity, other: Scalar) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn multiVectorAtInfinity_geometricQuotient_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return multiVectorAtInfinity_geometricProduct_translator(self_, translator_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_dualNum(self_: MultiVectorAtOrigin, other: DualNum) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_flector(self_, flector_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_line(self_, line_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_motor(self_, motor_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_plane(self_, plane_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_point(self_, point_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_scalar(self_: MultiVectorAtOrigin, other: Scalar) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn multiVectorAtOrigin_geometricQuotient_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_geometricProduct_translator(self_, translator_inverse(other));
}

fn origin_geometricQuotient_dualNum(self_: Origin, other: DualNum) -> Origin {
    return origin_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn origin_geometricQuotient_flector(self_: Origin, other: Flector) -> Rotor {
    return origin_geometricProduct_flector(self_, flector_inverse(other));
}

fn origin_geometricQuotient_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Rotor {
    return origin_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn origin_geometricQuotient_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return origin_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn origin_geometricQuotient_line(self_: Origin, other: Line) -> PlaneAtOrigin {
    return origin_geometricProduct_line(self_, line_inverse(other));
}

fn origin_geometricQuotient_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return origin_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn origin_geometricQuotient_motor(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return origin_geometricProduct_motor(self_, motor_inverse(other));
}

fn origin_geometricQuotient_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return origin_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn origin_geometricQuotient_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return origin_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn origin_geometricQuotient_plane(self_: Origin, other: Plane) -> AntiScalar {
    return origin_geometricProduct_plane(self_, plane_inverse(other));
}

fn origin_geometricQuotient_point(self_: Origin, other: Point) -> LineAtOrigin {
    return origin_geometricProduct_point(self_, point_inverse(other));
}

fn origin_geometricQuotient_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return origin_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn origin_geometricQuotient_scalar(self_: Origin, other: Scalar) -> Origin {
    return origin_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn origin_geometricQuotient_transflector(self_: Origin, other: Transflector) -> Rotor {
    return origin_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn origin_geometricQuotient_translator(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return origin_geometricProduct_translator(self_, translator_inverse(other));
}

fn plane_geometricQuotient_dualNum(self_: Plane, other: DualNum) -> Flector {
    return plane_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn plane_geometricQuotient_flector(self_: Plane, other: Flector) -> MultiVector {
    return plane_geometricProduct_flector(self_, flector_inverse(other));
}

fn plane_geometricQuotient_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVector {
    return plane_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn plane_geometricQuotient_horizon(self_: Plane, other: Horizon) -> MultiVector {
    return plane_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn plane_geometricQuotient_line(self_: Plane, other: Line) -> Flector {
    return plane_geometricProduct_line(self_, line_inverse(other));
}

fn plane_geometricQuotient_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> Flector {
    return plane_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn plane_geometricQuotient_motor(self_: Plane, other: Motor) -> Flector {
    return plane_geometricProduct_motor(self_, motor_inverse(other));
}

fn plane_geometricQuotient_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn plane_geometricQuotient_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return plane_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn plane_geometricQuotient_plane(self_: Plane, other: Plane) -> MultiVector {
    return plane_geometricProduct_plane(self_, plane_inverse(other));
}

fn plane_geometricQuotient_point(self_: Plane, other: Point) -> Motor {
    return plane_geometricProduct_point(self_, point_inverse(other));
}

fn plane_geometricQuotient_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Motor {
    return plane_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn plane_geometricQuotient_scalar(self_: Plane, other: Scalar) -> Plane {
    return plane_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn plane_geometricQuotient_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return plane_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn plane_geometricQuotient_translator(self_: Plane, other: Translator) -> Flector {
    return plane_geometricProduct_translator(self_, translator_inverse(other));
}

fn planeAtOrigin_geometricQuotient_dualNum(self_: PlaneAtOrigin, other: DualNum) -> PlaneAtOrigin {
    return planeAtOrigin_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn planeAtOrigin_geometricQuotient_flector(self_: PlaneAtOrigin, other: Flector) -> Rotor {
    return planeAtOrigin_geometricProduct_flector(self_, flector_inverse(other));
}

fn planeAtOrigin_geometricQuotient_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> Rotor {
    return planeAtOrigin_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn planeAtOrigin_geometricQuotient_horizon(self_: PlaneAtOrigin, other: Horizon) -> LineAtOrigin {
    return planeAtOrigin_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn planeAtOrigin_geometricQuotient_line(self_: PlaneAtOrigin, other: Line) -> Flector {
    return planeAtOrigin_geometricProduct_line(self_, line_inverse(other));
}

fn planeAtOrigin_geometricQuotient_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return planeAtOrigin_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn planeAtOrigin_geometricQuotient_motor(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return planeAtOrigin_geometricProduct_motor(self_, motor_inverse(other));
}

fn planeAtOrigin_geometricQuotient_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return planeAtOrigin_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn planeAtOrigin_geometricQuotient_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return planeAtOrigin_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn planeAtOrigin_geometricQuotient_plane(self_: PlaneAtOrigin, other: Plane) -> LineAtOrigin {
    return planeAtOrigin_geometricProduct_plane(self_, plane_inverse(other));
}

fn planeAtOrigin_geometricQuotient_point(self_: PlaneAtOrigin, other: Point) -> Rotor {
    return planeAtOrigin_geometricProduct_point(self_, point_inverse(other));
}

fn planeAtOrigin_geometricQuotient_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> Rotor {
    return planeAtOrigin_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn planeAtOrigin_geometricQuotient_scalar(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return planeAtOrigin_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn planeAtOrigin_geometricQuotient_transflector(self_: PlaneAtOrigin, other: Transflector) -> Rotor {
    return planeAtOrigin_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn planeAtOrigin_geometricQuotient_translator(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return planeAtOrigin_geometricProduct_translator(self_, translator_inverse(other));
}

fn point_geometricQuotient_dualNum(self_: Point, other: DualNum) -> Flector {
    return point_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn point_geometricQuotient_flector(self_: Point, other: Flector) -> MultiVector {
    return point_geometricProduct_flector(self_, flector_inverse(other));
}

fn point_geometricQuotient_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> MultiVector {
    return point_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn point_geometricQuotient_horizon(self_: Point, other: Horizon) -> Translator {
    return point_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn point_geometricQuotient_line(self_: Point, other: Line) -> Flector {
    return point_geometricProduct_line(self_, line_inverse(other));
}

fn point_geometricQuotient_lineAtInfinity(self_: Point, other: LineAtInfinity) -> Transflector {
    return point_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn point_geometricQuotient_motor(self_: Point, other: Motor) -> Flector {
    return point_geometricProduct_motor(self_, motor_inverse(other));
}

fn point_geometricQuotient_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return point_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn point_geometricQuotient_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return point_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn point_geometricQuotient_plane(self_: Point, other: Plane) -> Motor {
    return point_geometricProduct_plane(self_, plane_inverse(other));
}

fn point_geometricQuotient_point(self_: Point, other: Point) -> MultiVector {
    return point_geometricProduct_point(self_, point_inverse(other));
}

fn point_geometricQuotient_pointAtInfinity(self_: Point, other: PointAtInfinity) -> MultiVector {
    return point_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn point_geometricQuotient_scalar(self_: Point, other: Scalar) -> Point {
    return point_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn point_geometricQuotient_transflector(self_: Point, other: Transflector) -> MultiVector {
    return point_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn point_geometricQuotient_translator(self_: Point, other: Translator) -> Transflector {
    return point_geometricProduct_translator(self_, translator_inverse(other));
}

fn pointAtInfinity_geometricQuotient_dualNum(self_: PointAtInfinity, other: DualNum) -> Transflector {
    return pointAtInfinity_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn pointAtInfinity_geometricQuotient_flector(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return pointAtInfinity_geometricProduct_flector(self_, flector_inverse(other));
}

fn pointAtInfinity_geometricQuotient_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn pointAtInfinity_geometricQuotient_horizon(self_: PointAtInfinity, other: Horizon) -> LineAtInfinity {
    return pointAtInfinity_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn pointAtInfinity_geometricQuotient_line(self_: PointAtInfinity, other: Line) -> Flector {
    return pointAtInfinity_geometricProduct_line(self_, line_inverse(other));
}

fn pointAtInfinity_geometricQuotient_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> FlectorAtInfinity {
    return pointAtInfinity_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn pointAtInfinity_geometricQuotient_motor(self_: PointAtInfinity, other: Motor) -> Flector {
    return pointAtInfinity_geometricProduct_motor(self_, motor_inverse(other));
}

fn pointAtInfinity_geometricQuotient_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return pointAtInfinity_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn pointAtInfinity_geometricQuotient_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn pointAtInfinity_geometricQuotient_plane(self_: PointAtInfinity, other: Plane) -> Motor {
    return pointAtInfinity_geometricProduct_plane(self_, plane_inverse(other));
}

fn pointAtInfinity_geometricQuotient_point(self_: PointAtInfinity, other: Point) -> MultiVector {
    return pointAtInfinity_geometricProduct_point(self_, point_inverse(other));
}

fn pointAtInfinity_geometricQuotient_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn pointAtInfinity_geometricQuotient_scalar(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return pointAtInfinity_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn pointAtInfinity_geometricQuotient_transflector(self_: PointAtInfinity, other: Transflector) -> MultiVector {
    return pointAtInfinity_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn pointAtInfinity_geometricQuotient_translator(self_: PointAtInfinity, other: Translator) -> Transflector {
    return pointAtInfinity_geometricProduct_translator(self_, translator_inverse(other));
}

fn rotor_geometricQuotient_dualNum(self_: Rotor, other: DualNum) -> Rotor {
    return rotor_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn rotor_geometricQuotient_flector(self_: Rotor, other: Flector) -> Flector {
    return rotor_geometricProduct_flector(self_, flector_inverse(other));
}

fn rotor_geometricQuotient_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> Flector {
    return rotor_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn rotor_geometricQuotient_horizon(self_: Rotor, other: Horizon) -> Flector {
    return rotor_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn rotor_geometricQuotient_line(self_: Rotor, other: Line) -> Rotor {
    return rotor_geometricProduct_line(self_, line_inverse(other));
}

fn rotor_geometricQuotient_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> Rotor {
    return rotor_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn rotor_geometricQuotient_motor(self_: Rotor, other: Motor) -> Rotor {
    return rotor_geometricProduct_motor(self_, motor_inverse(other));
}

fn rotor_geometricQuotient_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return rotor_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn rotor_geometricQuotient_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return rotor_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn rotor_geometricQuotient_plane(self_: Rotor, other: Plane) -> Flector {
    return rotor_geometricProduct_plane(self_, plane_inverse(other));
}

fn rotor_geometricQuotient_point(self_: Rotor, other: Point) -> Flector {
    return rotor_geometricProduct_point(self_, point_inverse(other));
}

fn rotor_geometricQuotient_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> Flector {
    return rotor_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn rotor_geometricQuotient_scalar(self_: Rotor, other: Scalar) -> Rotor {
    return rotor_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn rotor_geometricQuotient_transflector(self_: Rotor, other: Transflector) -> Flector {
    return rotor_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn rotor_geometricQuotient_translator(self_: Rotor, other: Translator) -> Rotor {
    return rotor_geometricProduct_translator(self_, translator_inverse(other));
}

fn scalar_geometricQuotient_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return scalar_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn scalar_geometricQuotient_flector(self_: Scalar, other: Flector) -> Flector {
    return scalar_geometricProduct_flector(self_, flector_inverse(other));
}

fn scalar_geometricQuotient_flectorAtInfinity(self_: Scalar, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return scalar_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn scalar_geometricQuotient_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return scalar_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn scalar_geometricQuotient_line(self_: Scalar, other: Line) -> Line {
    return scalar_geometricProduct_line(self_, line_inverse(other));
}

fn scalar_geometricQuotient_lineAtInfinity(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return scalar_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn scalar_geometricQuotient_motor(self_: Scalar, other: Motor) -> Motor {
    return scalar_geometricProduct_motor(self_, motor_inverse(other));
}

fn scalar_geometricQuotient_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    return scalar_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn scalar_geometricQuotient_multiVectorAtInfinity(self_: Scalar, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return scalar_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn scalar_geometricQuotient_plane(self_: Scalar, other: Plane) -> Plane {
    return scalar_geometricProduct_plane(self_, plane_inverse(other));
}

fn scalar_geometricQuotient_point(self_: Scalar, other: Point) -> Point {
    return scalar_geometricProduct_point(self_, point_inverse(other));
}

fn scalar_geometricQuotient_pointAtInfinity(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return scalar_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn scalar_geometricQuotient_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return scalar_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn scalar_geometricQuotient_transflector(self_: Scalar, other: Transflector) -> Transflector {
    return scalar_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn scalar_geometricQuotient_translator(self_: Scalar, other: Translator) -> Translator {
    return scalar_geometricProduct_translator(self_, translator_inverse(other));
}

fn transflector_geometricQuotient_dualNum(self_: Transflector, other: DualNum) -> Flector {
    return transflector_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn transflector_geometricQuotient_flector(self_: Transflector, other: Flector) -> MultiVector {
    return transflector_geometricProduct_flector(self_, flector_inverse(other));
}

fn transflector_geometricQuotient_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVector {
    return transflector_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn transflector_geometricQuotient_horizon(self_: Transflector, other: Horizon) -> MultiVector {
    return transflector_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn transflector_geometricQuotient_line(self_: Transflector, other: Line) -> Flector {
    return transflector_geometricProduct_line(self_, line_inverse(other));
}

fn transflector_geometricQuotient_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Flector {
    return transflector_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn transflector_geometricQuotient_motor(self_: Transflector, other: Motor) -> Flector {
    return transflector_geometricProduct_motor(self_, motor_inverse(other));
}

fn transflector_geometricQuotient_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return transflector_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn transflector_geometricQuotient_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return transflector_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn transflector_geometricQuotient_plane(self_: Transflector, other: Plane) -> MultiVector {
    return transflector_geometricProduct_plane(self_, plane_inverse(other));
}

fn transflector_geometricQuotient_point(self_: Transflector, other: Point) -> MultiVector {
    return transflector_geometricProduct_point(self_, point_inverse(other));
}

fn transflector_geometricQuotient_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVector {
    return transflector_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn transflector_geometricQuotient_scalar(self_: Transflector, other: Scalar) -> Transflector {
    return transflector_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn transflector_geometricQuotient_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return transflector_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn transflector_geometricQuotient_translator(self_: Transflector, other: Translator) -> Flector {
    return transflector_geometricProduct_translator(self_, translator_inverse(other));
}

fn translator_geometricQuotient_dualNum(self_: Translator, other: DualNum) -> Motor {
    return translator_geometricProduct_dualNum(self_, dualNum_inverse(other));
}

fn translator_geometricQuotient_flector(self_: Translator, other: Flector) -> Flector {
    return translator_geometricProduct_flector(self_, flector_inverse(other));
}

fn translator_geometricQuotient_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Flector {
    return translator_geometricProduct_flectorAtInfinity(self_, flectorAtInfinity_inverse(other));
}

fn translator_geometricQuotient_horizon(self_: Translator, other: Horizon) -> Point {
    return translator_geometricProduct_horizon(self_, horizon_inverse(other));
}

fn translator_geometricQuotient_line(self_: Translator, other: Line) -> MultiVector {
    return translator_geometricProduct_line(self_, line_inverse(other));
}

fn translator_geometricQuotient_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return translator_geometricProduct_lineAtInfinity(self_, lineAtInfinity_inverse(other));
}

fn translator_geometricQuotient_motor(self_: Translator, other: Motor) -> MultiVector {
    return translator_geometricProduct_motor(self_, motor_inverse(other));
}

fn translator_geometricQuotient_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_geometricProduct_multiVector(self_, multiVector_inverse(other));
}

fn translator_geometricQuotient_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return translator_geometricProduct_multiVectorAtInfinity(self_, multiVectorAtInfinity_inverse(other));
}

fn translator_geometricQuotient_plane(self_: Translator, other: Plane) -> Flector {
    return translator_geometricProduct_plane(self_, plane_inverse(other));
}

fn translator_geometricQuotient_point(self_: Translator, other: Point) -> Transflector {
    return translator_geometricProduct_point(self_, point_inverse(other));
}

fn translator_geometricQuotient_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Transflector {
    return translator_geometricProduct_pointAtInfinity(self_, pointAtInfinity_inverse(other));
}

fn translator_geometricQuotient_scalar(self_: Translator, other: Scalar) -> Translator {
    return translator_geometricProduct_scalar(self_, scalar_inverse(other));
}

fn translator_geometricQuotient_transflector(self_: Translator, other: Transflector) -> Flector {
    return translator_geometricProduct_transflector(self_, transflector_inverse(other));
}

fn translator_geometricQuotient_translator(self_: Translator, other: Translator) -> MultiVector {
    return translator_geometricProduct_translator(self_, translator_inverse(other));
}

fn flector_bulkContraction_flector(self_: Flector, other: Flector) -> MultiVector {
    return flector_antiWedge_flector(self_, flector_dual(other));
}

fn flector_bulkContraction_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVector {
    return flector_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn flector_bulkContraction_horizon(self_: Flector, other: Horizon) -> Scalar {
    return flector_antiWedge_origin(self_, horizon_dual(other));
}

fn flector_bulkContraction_line(self_: Flector, other: Line) -> Point {
    return flector_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn flector_bulkContraction_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Point {
    return flector_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn flector_bulkContraction_motor(self_: Flector, other: Motor) -> Point {
    return flector_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn flector_bulkContraction_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn flector_bulkContraction_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return flector_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn flector_bulkContraction_plane(self_: Flector, other: Plane) -> Scalar {
    return flector_antiWedge_origin(self_, plane_dual(other));
}

fn flector_bulkContraction_point(self_: Flector, other: Point) -> MultiVector {
    return flector_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn flector_bulkContraction_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return flector_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn flector_bulkContraction_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return flector_antiWedge_flector(self_, transflector_dual(other));
}

fn flector_bulkContraction_translator(self_: Flector, other: Translator) -> Point {
    return flector_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn flectorAtInfinity_bulkContraction_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_flector(self_, flector_dual(other));
}

fn flectorAtInfinity_bulkContraction_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkContraction_horizon(self_: FlectorAtInfinity, other: Horizon) -> Scalar {
    return flectorAtInfinity_antiWedge_origin(self_, horizon_dual(other));
}

fn flectorAtInfinity_bulkContraction_line(self_: FlectorAtInfinity, other: Line) -> PointAtInfinity {
    return flectorAtInfinity_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn flectorAtInfinity_bulkContraction_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return flectorAtInfinity_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkContraction_motor(self_: FlectorAtInfinity, other: Motor) -> PointAtInfinity {
    return flectorAtInfinity_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn flectorAtInfinity_bulkContraction_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn flectorAtInfinity_bulkContraction_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkContraction_plane(self_: FlectorAtInfinity, other: Plane) -> Scalar {
    return flectorAtInfinity_antiWedge_origin(self_, plane_dual(other));
}

fn flectorAtInfinity_bulkContraction_point(self_: FlectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn flectorAtInfinity_bulkContraction_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkContraction_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_flector(self_, transflector_dual(other));
}

fn flectorAtInfinity_bulkContraction_translator(self_: FlectorAtInfinity, other: Translator) -> PointAtInfinity {
    return flectorAtInfinity_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn horizon_bulkContraction_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(self_, flector_dual(other));
}

fn horizon_bulkContraction_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn horizon_bulkContraction_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return horizon_antiWedge_origin(self_, horizon_dual(other));
}

fn horizon_bulkContraction_line(self_: Horizon, other: Line) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn horizon_bulkContraction_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn horizon_bulkContraction_motor(self_: Horizon, other: Motor) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn horizon_bulkContraction_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return horizon_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn horizon_bulkContraction_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn horizon_bulkContraction_plane(self_: Horizon, other: Plane) -> Scalar {
    return horizon_antiWedge_origin(self_, plane_dual(other));
}

fn horizon_bulkContraction_point(self_: Horizon, other: Point) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn horizon_bulkContraction_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn horizon_bulkContraction_transflector(self_: Horizon, other: Transflector) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(self_, transflector_dual(other));
}

fn horizon_bulkContraction_translator(self_: Horizon, other: Translator) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn line_bulkContraction_flector(self_: Line, other: Flector) -> Point {
    return line_antiWedge_flector(self_, flector_dual(other));
}

fn line_bulkContraction_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Point {
    return line_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn line_bulkContraction_line(self_: Line, other: Line) -> Scalar {
    return line_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn line_bulkContraction_lineAtInfinity(self_: Line, other: LineAtInfinity) -> Scalar {
    return line_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn line_bulkContraction_motor(self_: Line, other: Motor) -> Scalar {
    return line_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn line_bulkContraction_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return line_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn line_bulkContraction_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return line_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn line_bulkContraction_point(self_: Line, other: Point) -> Point {
    return line_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn line_bulkContraction_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Point {
    return line_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn line_bulkContraction_transflector(self_: Line, other: Transflector) -> Point {
    return line_antiWedge_flector(self_, transflector_dual(other));
}

fn line_bulkContraction_translator(self_: Line, other: Translator) -> Scalar {
    return line_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn lineAtInfinity_bulkContraction_flector(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_flector(self_, flector_dual(other));
}

fn lineAtInfinity_bulkContraction_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn lineAtInfinity_bulkContraction_line(self_: LineAtInfinity, other: Line) -> Scalar {
    return lineAtInfinity_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn lineAtInfinity_bulkContraction_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> Scalar {
    return lineAtInfinity_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn lineAtInfinity_bulkContraction_motor(self_: LineAtInfinity, other: Motor) -> Scalar {
    return lineAtInfinity_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn lineAtInfinity_bulkContraction_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return lineAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn lineAtInfinity_bulkContraction_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return lineAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn lineAtInfinity_bulkContraction_point(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn lineAtInfinity_bulkContraction_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn lineAtInfinity_bulkContraction_transflector(self_: LineAtInfinity, other: Transflector) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_flector(self_, transflector_dual(other));
}

fn lineAtInfinity_bulkContraction_translator(self_: LineAtInfinity, other: Translator) -> Scalar {
    return lineAtInfinity_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn lineAtOrigin_bulkContraction_flector(self_: LineAtOrigin, other: Flector) -> Point {
    return lineAtOrigin_antiWedge_flector(self_, flector_dual(other));
}

fn lineAtOrigin_bulkContraction_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> Point {
    return lineAtOrigin_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn lineAtOrigin_bulkContraction_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return lineAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn lineAtOrigin_bulkContraction_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return lineAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn lineAtOrigin_bulkContraction_point(self_: LineAtOrigin, other: Point) -> Origin {
    return lineAtOrigin_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn lineAtOrigin_bulkContraction_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> Origin {
    return lineAtOrigin_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn lineAtOrigin_bulkContraction_transflector(self_: LineAtOrigin, other: Transflector) -> Point {
    return lineAtOrigin_antiWedge_flector(self_, transflector_dual(other));
}

fn motor_bulkContraction_flector(self_: Motor, other: Flector) -> Flector {
    return motor_antiWedge_flector(self_, flector_dual(other));
}

fn motor_bulkContraction_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Flector {
    return motor_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn motor_bulkContraction_horizon(self_: Motor, other: Horizon) -> Origin {
    return motor_antiWedge_origin(self_, horizon_dual(other));
}

fn motor_bulkContraction_line(self_: Motor, other: Line) -> MultiVector {
    return motor_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn motor_bulkContraction_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return motor_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn motor_bulkContraction_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn motor_bulkContraction_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn motor_bulkContraction_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn motor_bulkContraction_plane(self_: Motor, other: Plane) -> Origin {
    return motor_antiWedge_origin(self_, plane_dual(other));
}

fn motor_bulkContraction_point(self_: Motor, other: Point) -> Flector {
    return motor_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn motor_bulkContraction_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Flector {
    return motor_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn motor_bulkContraction_transflector(self_: Motor, other: Transflector) -> Flector {
    return motor_antiWedge_flector(self_, transflector_dual(other));
}

fn motor_bulkContraction_translator(self_: Motor, other: Translator) -> MultiVector {
    return motor_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn multiVector_bulkContraction_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_antiWedge_flector(self_, flector_dual(other));
}

fn multiVector_bulkContraction_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn multiVector_bulkContraction_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return multiVector_antiWedge_origin(self_, horizon_dual(other));
}

fn multiVector_bulkContraction_line(self_: MultiVector, other: Line) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn multiVector_bulkContraction_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn multiVector_bulkContraction_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn multiVector_bulkContraction_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn multiVector_bulkContraction_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn multiVector_bulkContraction_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return multiVector_antiWedge_origin(self_, plane_dual(other));
}

fn multiVector_bulkContraction_point(self_: MultiVector, other: Point) -> MultiVector {
    return multiVector_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn multiVector_bulkContraction_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multiVector_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn multiVector_bulkContraction_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_antiWedge_flector(self_, transflector_dual(other));
}

fn multiVector_bulkContraction_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_flector(self_, flector_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> Scalar {
    return multiVectorAtInfinity_antiWedge_origin(self_, horizon_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_plane(self_: MultiVectorAtInfinity, other: Plane) -> Scalar {
    return multiVectorAtInfinity_antiWedge_origin(self_, plane_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_flector(self_, transflector_dual(other));
}

fn multiVectorAtInfinity_bulkContraction_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_flector(self_, flector_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> Origin {
    return multiVectorAtOrigin_antiWedge_origin(self_, horizon_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_plane(self_: MultiVectorAtOrigin, other: Plane) -> Origin {
    return multiVectorAtOrigin_antiWedge_origin(self_, plane_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_flector(self_, transflector_dual(other));
}

fn multiVectorAtOrigin_bulkContraction_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn origin_bulkContraction_flector(self_: Origin, other: Flector) -> Scalar {
    return origin_antiWedge_flector(self_, flector_dual(other));
}

fn origin_bulkContraction_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Scalar {
    return origin_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn origin_bulkContraction_multiVector(self_: Origin, other: MultiVector) -> Origin {
    return origin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn origin_bulkContraction_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> Origin {
    return origin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn origin_bulkContraction_transflector(self_: Origin, other: Transflector) -> Scalar {
    return origin_antiWedge_flector(self_, transflector_dual(other));
}

fn plane_bulkContraction_flector(self_: Plane, other: Flector) -> MultiVector {
    return plane_antiWedge_flector(self_, flector_dual(other));
}

fn plane_bulkContraction_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVector {
    return plane_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn plane_bulkContraction_horizon(self_: Plane, other: Horizon) -> Scalar {
    return plane_antiWedge_origin(self_, horizon_dual(other));
}

fn plane_bulkContraction_line(self_: Plane, other: Line) -> Point {
    return plane_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn plane_bulkContraction_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> Point {
    return plane_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn plane_bulkContraction_motor(self_: Plane, other: Motor) -> Point {
    return plane_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn plane_bulkContraction_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn plane_bulkContraction_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return plane_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn plane_bulkContraction_plane(self_: Plane, other: Plane) -> Scalar {
    return plane_antiWedge_origin(self_, plane_dual(other));
}

fn plane_bulkContraction_point(self_: Plane, other: Point) -> Line {
    return plane_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn plane_bulkContraction_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Line {
    return plane_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn plane_bulkContraction_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return plane_antiWedge_flector(self_, transflector_dual(other));
}

fn plane_bulkContraction_translator(self_: Plane, other: Translator) -> Point {
    return plane_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn planeAtOrigin_bulkContraction_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(self_, flector_dual(other));
}

fn planeAtOrigin_bulkContraction_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn planeAtOrigin_bulkContraction_line(self_: PlaneAtOrigin, other: Line) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn planeAtOrigin_bulkContraction_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn planeAtOrigin_bulkContraction_motor(self_: PlaneAtOrigin, other: Motor) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn planeAtOrigin_bulkContraction_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return planeAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn planeAtOrigin_bulkContraction_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return planeAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn planeAtOrigin_bulkContraction_point(self_: PlaneAtOrigin, other: Point) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn planeAtOrigin_bulkContraction_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn planeAtOrigin_bulkContraction_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(self_, transflector_dual(other));
}

fn planeAtOrigin_bulkContraction_translator(self_: PlaneAtOrigin, other: Translator) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn point_bulkContraction_flector(self_: Point, other: Flector) -> Scalar {
    return point_antiWedge_flector(self_, flector_dual(other));
}

fn point_bulkContraction_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Scalar {
    return point_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn point_bulkContraction_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return point_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn point_bulkContraction_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return point_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn point_bulkContraction_point(self_: Point, other: Point) -> Scalar {
    return point_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn point_bulkContraction_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Scalar {
    return point_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn point_bulkContraction_transflector(self_: Point, other: Transflector) -> Scalar {
    return point_antiWedge_flector(self_, transflector_dual(other));
}

fn pointAtInfinity_bulkContraction_flector(self_: PointAtInfinity, other: Flector) -> Scalar {
    return pointAtInfinity_antiWedge_flector(self_, flector_dual(other));
}

fn pointAtInfinity_bulkContraction_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> Scalar {
    return pointAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn pointAtInfinity_bulkContraction_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return pointAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn pointAtInfinity_bulkContraction_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn pointAtInfinity_bulkContraction_point(self_: PointAtInfinity, other: Point) -> Scalar {
    return pointAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn pointAtInfinity_bulkContraction_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> Scalar {
    return pointAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn pointAtInfinity_bulkContraction_transflector(self_: PointAtInfinity, other: Transflector) -> Scalar {
    return pointAtInfinity_antiWedge_flector(self_, transflector_dual(other));
}

fn rotor_bulkContraction_flector(self_: Rotor, other: Flector) -> Flector {
    return rotor_antiWedge_flector(self_, flector_dual(other));
}

fn rotor_bulkContraction_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> Flector {
    return rotor_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn rotor_bulkContraction_horizon(self_: Rotor, other: Horizon) -> Origin {
    return rotor_antiWedge_origin(self_, horizon_dual(other));
}

fn rotor_bulkContraction_line(self_: Rotor, other: Line) -> LineAtOrigin {
    return rotor_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn rotor_bulkContraction_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> LineAtOrigin {
    return rotor_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn rotor_bulkContraction_motor(self_: Rotor, other: Motor) -> LineAtOrigin {
    return rotor_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn rotor_bulkContraction_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn rotor_bulkContraction_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn rotor_bulkContraction_plane(self_: Rotor, other: Plane) -> Origin {
    return rotor_antiWedge_origin(self_, plane_dual(other));
}

fn rotor_bulkContraction_point(self_: Rotor, other: Point) -> Flector {
    return rotor_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn rotor_bulkContraction_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> Flector {
    return rotor_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn rotor_bulkContraction_transflector(self_: Rotor, other: Transflector) -> Flector {
    return rotor_antiWedge_flector(self_, transflector_dual(other));
}

fn rotor_bulkContraction_translator(self_: Rotor, other: Translator) -> LineAtOrigin {
    return rotor_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn transflector_bulkContraction_flector(self_: Transflector, other: Flector) -> MultiVector {
    return transflector_antiWedge_flector(self_, flector_dual(other));
}

fn transflector_bulkContraction_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVector {
    return transflector_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn transflector_bulkContraction_horizon(self_: Transflector, other: Horizon) -> Scalar {
    return transflector_antiWedge_origin(self_, horizon_dual(other));
}

fn transflector_bulkContraction_line(self_: Transflector, other: Line) -> Point {
    return transflector_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn transflector_bulkContraction_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Point {
    return transflector_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn transflector_bulkContraction_motor(self_: Transflector, other: Motor) -> Point {
    return transflector_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn transflector_bulkContraction_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return transflector_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn transflector_bulkContraction_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return transflector_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn transflector_bulkContraction_plane(self_: Transflector, other: Plane) -> Scalar {
    return transflector_antiWedge_origin(self_, plane_dual(other));
}

fn transflector_bulkContraction_point(self_: Transflector, other: Point) -> MultiVector {
    return transflector_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn transflector_bulkContraction_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVector {
    return transflector_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn transflector_bulkContraction_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return transflector_antiWedge_flector(self_, transflector_dual(other));
}

fn transflector_bulkContraction_translator(self_: Transflector, other: Translator) -> Point {
    return transflector_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn translator_bulkContraction_flector(self_: Translator, other: Flector) -> Flector {
    return translator_antiWedge_flector(self_, flector_dual(other));
}

fn translator_bulkContraction_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Flector {
    return translator_antiWedge_flector(self_, flectorAtInfinity_dual(other));
}

fn translator_bulkContraction_horizon(self_: Translator, other: Horizon) -> Origin {
    return translator_antiWedge_origin(self_, horizon_dual(other));
}

fn translator_bulkContraction_line(self_: Translator, other: Line) -> MultiVector {
    return translator_antiWedge_lineAtOrigin(self_, line_dual(other));
}

fn translator_bulkContraction_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return translator_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn translator_bulkContraction_motor(self_: Translator, other: Motor) -> MultiVector {
    return translator_antiWedge_lineAtOrigin(self_, motor_dual(other));
}

fn translator_bulkContraction_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn translator_bulkContraction_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return translator_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn translator_bulkContraction_plane(self_: Translator, other: Plane) -> Origin {
    return translator_antiWedge_origin(self_, plane_dual(other));
}

fn translator_bulkContraction_point(self_: Translator, other: Point) -> Transflector {
    return translator_antiWedge_planeAtOrigin(self_, point_dual(other));
}

fn translator_bulkContraction_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Transflector {
    return translator_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn translator_bulkContraction_transflector(self_: Translator, other: Transflector) -> Flector {
    return translator_antiWedge_flector(self_, transflector_dual(other));
}

fn translator_bulkContraction_translator(self_: Translator, other: Translator) -> MultiVector {
    return translator_antiWedge_lineAtOrigin(self_, translator_dual(other));
}

fn flector_weightContraction_flector(self_: Flector, other: Flector) -> MultiVectorAtInfinity {
    return flector_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn flector_weightContraction_line(self_: Flector, other: Line) -> PointAtInfinity {
    return flector_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn flector_weightContraction_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> PointAtInfinity {
    return flector_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn flector_weightContraction_motor(self_: Flector, other: Motor) -> MultiVectorAtInfinity {
    return flector_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn flector_weightContraction_multiVector(self_: Flector, other: MultiVector) -> MultiVectorAtInfinity {
    return flector_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn flector_weightContraction_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return flector_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn flector_weightContraction_origin(self_: Flector, other: Origin) -> MultiVectorAtInfinity {
    return flector_antiWedge_horizon(self_, origin_antiDual(other));
}

fn flector_weightContraction_plane(self_: Flector, other: Plane) -> Scalar {
    return flector_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn flector_weightContraction_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Scalar {
    return flector_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn flector_weightContraction_point(self_: Flector, other: Point) -> MultiVectorAtInfinity {
    return flector_antiWedge_horizon(self_, point_antiDual(other));
}

fn flector_weightContraction_rotor(self_: Flector, other: Rotor) -> MultiVectorAtInfinity {
    return flector_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn flector_weightContraction_transflector(self_: Flector, other: Transflector) -> Scalar {
    return flector_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn line_weightContraction_flector(self_: Line, other: Flector) -> PointAtInfinity {
    return line_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn line_weightContraction_line(self_: Line, other: Line) -> Scalar {
    return line_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn line_weightContraction_lineAtOrigin(self_: Line, other: LineAtOrigin) -> Scalar {
    return line_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn line_weightContraction_motor(self_: Line, other: Motor) -> MultiVectorAtInfinity {
    return line_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn line_weightContraction_multiVector(self_: Line, other: MultiVector) -> MultiVectorAtInfinity {
    return line_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn line_weightContraction_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return line_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn line_weightContraction_origin(self_: Line, other: Origin) -> PointAtInfinity {
    return line_antiWedge_horizon(self_, origin_antiDual(other));
}

fn line_weightContraction_point(self_: Line, other: Point) -> PointAtInfinity {
    return line_antiWedge_horizon(self_, point_antiDual(other));
}

fn line_weightContraction_rotor(self_: Line, other: Rotor) -> MultiVectorAtInfinity {
    return line_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn lineAtOrigin_weightContraction_flector(self_: LineAtOrigin, other: Flector) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn lineAtOrigin_weightContraction_line(self_: LineAtOrigin, other: Line) -> Scalar {
    return lineAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn lineAtOrigin_weightContraction_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> Scalar {
    return lineAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn lineAtOrigin_weightContraction_motor(self_: LineAtOrigin, other: Motor) -> MultiVectorAtInfinity {
    return lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn lineAtOrigin_weightContraction_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtInfinity {
    return lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn lineAtOrigin_weightContraction_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn lineAtOrigin_weightContraction_origin(self_: LineAtOrigin, other: Origin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(self_, origin_antiDual(other));
}

fn lineAtOrigin_weightContraction_point(self_: LineAtOrigin, other: Point) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(self_, point_antiDual(other));
}

fn lineAtOrigin_weightContraction_rotor(self_: LineAtOrigin, other: Rotor) -> MultiVectorAtInfinity {
    return lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn motor_weightContraction_flector(self_: Motor, other: Flector) -> FlectorAtInfinity {
    return motor_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn motor_weightContraction_line(self_: Motor, other: Line) -> MultiVectorAtInfinity {
    return motor_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn motor_weightContraction_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return motor_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn motor_weightContraction_motor(self_: Motor, other: Motor) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn motor_weightContraction_multiVector(self_: Motor, other: MultiVector) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn motor_weightContraction_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn motor_weightContraction_origin(self_: Motor, other: Origin) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(self_, origin_antiDual(other));
}

fn motor_weightContraction_plane(self_: Motor, other: Plane) -> PointAtInfinity {
    return motor_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn motor_weightContraction_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> PointAtInfinity {
    return motor_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn motor_weightContraction_point(self_: Motor, other: Point) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(self_, point_antiDual(other));
}

fn motor_weightContraction_rotor(self_: Motor, other: Rotor) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn motor_weightContraction_transflector(self_: Motor, other: Transflector) -> PointAtInfinity {
    return motor_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn multiVector_weightContraction_flector(self_: MultiVector, other: Flector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn multiVector_weightContraction_line(self_: MultiVector, other: Line) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn multiVector_weightContraction_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn multiVector_weightContraction_motor(self_: MultiVector, other: Motor) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn multiVector_weightContraction_multiVector(self_: MultiVector, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn multiVector_weightContraction_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn multiVector_weightContraction_origin(self_: MultiVector, other: Origin) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_horizon(self_, origin_antiDual(other));
}

fn multiVector_weightContraction_plane(self_: MultiVector, other: Plane) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn multiVector_weightContraction_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn multiVector_weightContraction_point(self_: MultiVector, other: Point) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_horizon(self_, point_antiDual(other));
}

fn multiVector_weightContraction_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn multiVector_weightContraction_transflector(self_: MultiVector, other: Transflector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(self_, origin_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(self_, point_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn multiVectorAtOrigin_weightContraction_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn origin_weightContraction_flector(self_: Origin, other: Flector) -> Scalar {
    return origin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn origin_weightContraction_motor(self_: Origin, other: Motor) -> Scalar {
    return origin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn origin_weightContraction_multiVector(self_: Origin, other: MultiVector) -> Scalar {
    return origin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn origin_weightContraction_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> Scalar {
    return origin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn origin_weightContraction_origin(self_: Origin, other: Origin) -> Scalar {
    return origin_antiWedge_horizon(self_, origin_antiDual(other));
}

fn origin_weightContraction_point(self_: Origin, other: Point) -> Scalar {
    return origin_antiWedge_horizon(self_, point_antiDual(other));
}

fn origin_weightContraction_rotor(self_: Origin, other: Rotor) -> Scalar {
    return origin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn plane_weightContraction_flector(self_: Plane, other: Flector) -> MultiVectorAtInfinity {
    return plane_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn plane_weightContraction_line(self_: Plane, other: Line) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn plane_weightContraction_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn plane_weightContraction_motor(self_: Plane, other: Motor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn plane_weightContraction_multiVector(self_: Plane, other: MultiVector) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn plane_weightContraction_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn plane_weightContraction_origin(self_: Plane, other: Origin) -> LineAtInfinity {
    return plane_antiWedge_horizon(self_, origin_antiDual(other));
}

fn plane_weightContraction_plane(self_: Plane, other: Plane) -> Scalar {
    return plane_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn plane_weightContraction_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Scalar {
    return plane_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn plane_weightContraction_point(self_: Plane, other: Point) -> LineAtInfinity {
    return plane_antiWedge_horizon(self_, point_antiDual(other));
}

fn plane_weightContraction_rotor(self_: Plane, other: Rotor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn plane_weightContraction_transflector(self_: Plane, other: Transflector) -> Scalar {
    return plane_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn planeAtOrigin_weightContraction_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn planeAtOrigin_weightContraction_line(self_: PlaneAtOrigin, other: Line) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn planeAtOrigin_weightContraction_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn planeAtOrigin_weightContraction_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn planeAtOrigin_weightContraction_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn planeAtOrigin_weightContraction_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn planeAtOrigin_weightContraction_origin(self_: PlaneAtOrigin, other: Origin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(self_, origin_antiDual(other));
}

fn planeAtOrigin_weightContraction_plane(self_: PlaneAtOrigin, other: Plane) -> Scalar {
    return planeAtOrigin_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn planeAtOrigin_weightContraction_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Scalar {
    return planeAtOrigin_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn planeAtOrigin_weightContraction_point(self_: PlaneAtOrigin, other: Point) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(self_, point_antiDual(other));
}

fn planeAtOrigin_weightContraction_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn planeAtOrigin_weightContraction_transflector(self_: PlaneAtOrigin, other: Transflector) -> Scalar {
    return planeAtOrigin_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn point_weightContraction_flector(self_: Point, other: Flector) -> Scalar {
    return point_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn point_weightContraction_motor(self_: Point, other: Motor) -> Scalar {
    return point_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn point_weightContraction_multiVector(self_: Point, other: MultiVector) -> Scalar {
    return point_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn point_weightContraction_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> Scalar {
    return point_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn point_weightContraction_origin(self_: Point, other: Origin) -> Scalar {
    return point_antiWedge_horizon(self_, origin_antiDual(other));
}

fn point_weightContraction_point(self_: Point, other: Point) -> Scalar {
    return point_antiWedge_horizon(self_, point_antiDual(other));
}

fn point_weightContraction_rotor(self_: Point, other: Rotor) -> Scalar {
    return point_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn rotor_weightContraction_flector(self_: Rotor, other: Flector) -> FlectorAtInfinity {
    return rotor_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn rotor_weightContraction_line(self_: Rotor, other: Line) -> MultiVectorAtInfinity {
    return rotor_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn rotor_weightContraction_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return rotor_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn rotor_weightContraction_motor(self_: Rotor, other: Motor) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn rotor_weightContraction_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn rotor_weightContraction_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn rotor_weightContraction_origin(self_: Rotor, other: Origin) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(self_, origin_antiDual(other));
}

fn rotor_weightContraction_plane(self_: Rotor, other: Plane) -> PointAtInfinity {
    return rotor_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn rotor_weightContraction_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> PointAtInfinity {
    return rotor_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn rotor_weightContraction_point(self_: Rotor, other: Point) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(self_, point_antiDual(other));
}

fn rotor_weightContraction_rotor(self_: Rotor, other: Rotor) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn rotor_weightContraction_transflector(self_: Rotor, other: Transflector) -> PointAtInfinity {
    return rotor_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn transflector_weightContraction_flector(self_: Transflector, other: Flector) -> MultiVectorAtInfinity {
    return transflector_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn transflector_weightContraction_line(self_: Transflector, other: Line) -> PointAtInfinity {
    return transflector_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn transflector_weightContraction_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> PointAtInfinity {
    return transflector_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn transflector_weightContraction_motor(self_: Transflector, other: Motor) -> MultiVectorAtInfinity {
    return transflector_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn transflector_weightContraction_multiVector(self_: Transflector, other: MultiVector) -> MultiVectorAtInfinity {
    return transflector_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn transflector_weightContraction_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return transflector_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn transflector_weightContraction_origin(self_: Transflector, other: Origin) -> LineAtInfinity {
    return transflector_antiWedge_horizon(self_, origin_antiDual(other));
}

fn transflector_weightContraction_plane(self_: Transflector, other: Plane) -> Scalar {
    return transflector_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn transflector_weightContraction_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Scalar {
    return transflector_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn transflector_weightContraction_point(self_: Transflector, other: Point) -> LineAtInfinity {
    return transflector_antiWedge_horizon(self_, point_antiDual(other));
}

fn transflector_weightContraction_rotor(self_: Transflector, other: Rotor) -> MultiVectorAtInfinity {
    return transflector_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn transflector_weightContraction_transflector(self_: Transflector, other: Transflector) -> Scalar {
    return transflector_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn translator_weightContraction_flector(self_: Translator, other: Flector) -> FlectorAtInfinity {
    return translator_antiWedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn translator_weightContraction_line(self_: Translator, other: Line) -> LineAtInfinity {
    return translator_antiWedge_lineAtInfinity(self_, line_antiDual(other));
}

fn translator_weightContraction_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> LineAtInfinity {
    return translator_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn translator_weightContraction_motor(self_: Translator, other: Motor) -> MultiVectorAtInfinity {
    return translator_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn translator_weightContraction_multiVector(self_: Translator, other: MultiVector) -> MultiVectorAtInfinity {
    return translator_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn translator_weightContraction_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return translator_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn translator_weightContraction_origin(self_: Translator, other: Origin) -> Horizon {
    return translator_antiWedge_horizon(self_, origin_antiDual(other));
}

fn translator_weightContraction_plane(self_: Translator, other: Plane) -> PointAtInfinity {
    return translator_antiWedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn translator_weightContraction_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> PointAtInfinity {
    return translator_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn translator_weightContraction_point(self_: Translator, other: Point) -> Horizon {
    return translator_antiWedge_horizon(self_, point_antiDual(other));
}

fn translator_weightContraction_rotor(self_: Translator, other: Rotor) -> MultiVectorAtInfinity {
    return translator_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn translator_weightContraction_transflector(self_: Translator, other: Transflector) -> PointAtInfinity {
    return translator_antiWedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn flector_bulkExpansion_flector(self_: Flector, other: Flector) -> Motor {
    return flector_wedge_flector(self_, flector_dual(other));
}

fn flector_bulkExpansion_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Motor {
    return flector_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn flector_bulkExpansion_horizon(self_: Flector, other: Horizon) -> Rotor {
    return flector_wedge_origin(self_, horizon_dual(other));
}

fn flector_bulkExpansion_line(self_: Flector, other: Line) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(self_, line_dual(other));
}

fn flector_bulkExpansion_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn flector_bulkExpansion_motor(self_: Flector, other: Motor) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn flector_bulkExpansion_multiVector(self_: Flector, other: MultiVector) -> MultiVectorAtOrigin {
    return flector_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn flector_bulkExpansion_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return flector_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn flector_bulkExpansion_plane(self_: Flector, other: Plane) -> Rotor {
    return flector_wedge_origin(self_, plane_dual(other));
}

fn flector_bulkExpansion_point(self_: Flector, other: Point) -> AntiScalar {
    return flector_wedge_planeAtOrigin(self_, point_dual(other));
}

fn flector_bulkExpansion_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> AntiScalar {
    return flector_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn flector_bulkExpansion_transflector(self_: Flector, other: Transflector) -> Motor {
    return flector_wedge_flector(self_, transflector_dual(other));
}

fn flector_bulkExpansion_translator(self_: Flector, other: Translator) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn flectorAtInfinity_bulkExpansion_flector(self_: FlectorAtInfinity, other: Flector) -> Motor {
    return flectorAtInfinity_wedge_flector(self_, flector_dual(other));
}

fn flectorAtInfinity_bulkExpansion_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkExpansion_horizon(self_: FlectorAtInfinity, other: Horizon) -> Rotor {
    return flectorAtInfinity_wedge_origin(self_, horizon_dual(other));
}

fn flectorAtInfinity_bulkExpansion_line(self_: FlectorAtInfinity, other: Line) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(self_, line_dual(other));
}

fn flectorAtInfinity_bulkExpansion_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkExpansion_motor(self_: FlectorAtInfinity, other: Motor) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn flectorAtInfinity_bulkExpansion_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return flectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn flectorAtInfinity_bulkExpansion_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return flectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkExpansion_plane(self_: FlectorAtInfinity, other: Plane) -> Rotor {
    return flectorAtInfinity_wedge_origin(self_, plane_dual(other));
}

fn flectorAtInfinity_bulkExpansion_point(self_: FlectorAtInfinity, other: Point) -> AntiScalar {
    return flectorAtInfinity_wedge_planeAtOrigin(self_, point_dual(other));
}

fn flectorAtInfinity_bulkExpansion_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> AntiScalar {
    return flectorAtInfinity_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn flectorAtInfinity_bulkExpansion_transflector(self_: FlectorAtInfinity, other: Transflector) -> Motor {
    return flectorAtInfinity_wedge_flector(self_, transflector_dual(other));
}

fn flectorAtInfinity_bulkExpansion_translator(self_: FlectorAtInfinity, other: Translator) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn horizon_bulkExpansion_flector(self_: Horizon, other: Flector) -> AntiScalar {
    return horizon_wedge_flector(self_, flector_dual(other));
}

fn horizon_bulkExpansion_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> AntiScalar {
    return horizon_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn horizon_bulkExpansion_horizon(self_: Horizon, other: Horizon) -> AntiScalar {
    return horizon_wedge_origin(self_, horizon_dual(other));
}

fn horizon_bulkExpansion_multiVector(self_: Horizon, other: MultiVector) -> AntiScalar {
    return horizon_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn horizon_bulkExpansion_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> AntiScalar {
    return horizon_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn horizon_bulkExpansion_plane(self_: Horizon, other: Plane) -> AntiScalar {
    return horizon_wedge_origin(self_, plane_dual(other));
}

fn horizon_bulkExpansion_transflector(self_: Horizon, other: Transflector) -> AntiScalar {
    return horizon_wedge_flector(self_, transflector_dual(other));
}

fn line_bulkExpansion_flector(self_: Line, other: Flector) -> Plane {
    return line_wedge_flector(self_, flector_dual(other));
}

fn line_bulkExpansion_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Plane {
    return line_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn line_bulkExpansion_horizon(self_: Line, other: Horizon) -> PlaneAtOrigin {
    return line_wedge_origin(self_, horizon_dual(other));
}

fn line_bulkExpansion_line(self_: Line, other: Line) -> AntiScalar {
    return line_wedge_lineAtOrigin(self_, line_dual(other));
}

fn line_bulkExpansion_lineAtInfinity(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return line_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn line_bulkExpansion_motor(self_: Line, other: Motor) -> AntiScalar {
    return line_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn line_bulkExpansion_multiVector(self_: Line, other: MultiVector) -> MultiVectorAtOrigin {
    return line_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn line_bulkExpansion_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return line_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn line_bulkExpansion_plane(self_: Line, other: Plane) -> PlaneAtOrigin {
    return line_wedge_origin(self_, plane_dual(other));
}

fn line_bulkExpansion_transflector(self_: Line, other: Transflector) -> Plane {
    return line_wedge_flector(self_, transflector_dual(other));
}

fn line_bulkExpansion_translator(self_: Line, other: Translator) -> AntiScalar {
    return line_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn lineAtInfinity_bulkExpansion_flector(self_: LineAtInfinity, other: Flector) -> Plane {
    return lineAtInfinity_wedge_flector(self_, flector_dual(other));
}

fn lineAtInfinity_bulkExpansion_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> Plane {
    return lineAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn lineAtInfinity_bulkExpansion_horizon(self_: LineAtInfinity, other: Horizon) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(self_, horizon_dual(other));
}

fn lineAtInfinity_bulkExpansion_line(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(self_, line_dual(other));
}

fn lineAtInfinity_bulkExpansion_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn lineAtInfinity_bulkExpansion_motor(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn lineAtInfinity_bulkExpansion_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return lineAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn lineAtInfinity_bulkExpansion_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return lineAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn lineAtInfinity_bulkExpansion_plane(self_: LineAtInfinity, other: Plane) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(self_, plane_dual(other));
}

fn lineAtInfinity_bulkExpansion_transflector(self_: LineAtInfinity, other: Transflector) -> Plane {
    return lineAtInfinity_wedge_flector(self_, transflector_dual(other));
}

fn lineAtInfinity_bulkExpansion_translator(self_: LineAtInfinity, other: Translator) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn lineAtOrigin_bulkExpansion_flector(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_flector(self_, flector_dual(other));
}

fn lineAtOrigin_bulkExpansion_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn lineAtOrigin_bulkExpansion_transflector(self_: LineAtOrigin, other: Transflector) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_flector(self_, transflector_dual(other));
}

fn motor_bulkExpansion_flector(self_: Motor, other: Flector) -> Plane {
    return motor_wedge_flector(self_, flector_dual(other));
}

fn motor_bulkExpansion_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Plane {
    return motor_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn motor_bulkExpansion_horizon(self_: Motor, other: Horizon) -> PlaneAtOrigin {
    return motor_wedge_origin(self_, horizon_dual(other));
}

fn motor_bulkExpansion_line(self_: Motor, other: Line) -> AntiScalar {
    return motor_wedge_lineAtOrigin(self_, line_dual(other));
}

fn motor_bulkExpansion_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return motor_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn motor_bulkExpansion_motor(self_: Motor, other: Motor) -> AntiScalar {
    return motor_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn motor_bulkExpansion_multiVector(self_: Motor, other: MultiVector) -> MultiVectorAtOrigin {
    return motor_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn motor_bulkExpansion_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return motor_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn motor_bulkExpansion_plane(self_: Motor, other: Plane) -> PlaneAtOrigin {
    return motor_wedge_origin(self_, plane_dual(other));
}

fn motor_bulkExpansion_transflector(self_: Motor, other: Transflector) -> Plane {
    return motor_wedge_flector(self_, transflector_dual(other));
}

fn motor_bulkExpansion_translator(self_: Motor, other: Translator) -> AntiScalar {
    return motor_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn multiVector_bulkExpansion_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(self_, flector_dual(other));
}

fn multiVector_bulkExpansion_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return multiVector_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn multiVector_bulkExpansion_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(self_, horizon_dual(other));
}

fn multiVector_bulkExpansion_line(self_: MultiVector, other: Line) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(self_, line_dual(other));
}

fn multiVector_bulkExpansion_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn multiVector_bulkExpansion_motor(self_: MultiVector, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn multiVector_bulkExpansion_multiVector(self_: MultiVector, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn multiVector_bulkExpansion_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn multiVector_bulkExpansion_plane(self_: MultiVector, other: Plane) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(self_, plane_dual(other));
}

fn multiVector_bulkExpansion_point(self_: MultiVector, other: Point) -> MultiVectorAtOrigin {
    return multiVector_wedge_planeAtOrigin(self_, point_dual(other));
}

fn multiVector_bulkExpansion_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVector_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn multiVector_bulkExpansion_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(self_, transflector_dual(other));
}

fn multiVector_bulkExpansion_translator(self_: MultiVector, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(self_, flector_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(self_, horizon_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(self_, line_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(self_, plane_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_planeAtOrigin(self_, point_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(self_, transflector_dual(other));
}

fn multiVectorAtInfinity_bulkExpansion_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn multiVectorAtOrigin_bulkExpansion_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_flector(self_, flector_dual(other));
}

fn multiVectorAtOrigin_bulkExpansion_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_bulkExpansion_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_flector(self_, transflector_dual(other));
}

fn origin_bulkExpansion_flector(self_: Origin, other: Flector) -> Rotor {
    return origin_wedge_flector(self_, flector_dual(other));
}

fn origin_bulkExpansion_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Rotor {
    return origin_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn origin_bulkExpansion_transflector(self_: Origin, other: Transflector) -> Rotor {
    return origin_wedge_flector(self_, transflector_dual(other));
}

fn plane_bulkExpansion_flector(self_: Plane, other: Flector) -> AntiScalar {
    return plane_wedge_flector(self_, flector_dual(other));
}

fn plane_bulkExpansion_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> AntiScalar {
    return plane_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn plane_bulkExpansion_horizon(self_: Plane, other: Horizon) -> AntiScalar {
    return plane_wedge_origin(self_, horizon_dual(other));
}

fn plane_bulkExpansion_multiVector(self_: Plane, other: MultiVector) -> AntiScalar {
    return plane_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn plane_bulkExpansion_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> AntiScalar {
    return plane_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn plane_bulkExpansion_plane(self_: Plane, other: Plane) -> AntiScalar {
    return plane_wedge_origin(self_, plane_dual(other));
}

fn plane_bulkExpansion_transflector(self_: Plane, other: Transflector) -> AntiScalar {
    return plane_wedge_flector(self_, transflector_dual(other));
}

fn planeAtOrigin_bulkExpansion_flector(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return planeAtOrigin_wedge_flector(self_, flector_dual(other));
}

fn planeAtOrigin_bulkExpansion_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> AntiScalar {
    return planeAtOrigin_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn planeAtOrigin_bulkExpansion_transflector(self_: PlaneAtOrigin, other: Transflector) -> AntiScalar {
    return planeAtOrigin_wedge_flector(self_, transflector_dual(other));
}

fn point_bulkExpansion_flector(self_: Point, other: Flector) -> Motor {
    return point_wedge_flector(self_, flector_dual(other));
}

fn point_bulkExpansion_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Motor {
    return point_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn point_bulkExpansion_horizon(self_: Point, other: Horizon) -> LineAtOrigin {
    return point_wedge_origin(self_, horizon_dual(other));
}

fn point_bulkExpansion_line(self_: Point, other: Line) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(self_, line_dual(other));
}

fn point_bulkExpansion_lineAtInfinity(self_: Point, other: LineAtInfinity) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn point_bulkExpansion_motor(self_: Point, other: Motor) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn point_bulkExpansion_multiVector(self_: Point, other: MultiVector) -> MultiVectorAtOrigin {
    return point_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn point_bulkExpansion_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return point_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn point_bulkExpansion_plane(self_: Point, other: Plane) -> LineAtOrigin {
    return point_wedge_origin(self_, plane_dual(other));
}

fn point_bulkExpansion_point(self_: Point, other: Point) -> AntiScalar {
    return point_wedge_planeAtOrigin(self_, point_dual(other));
}

fn point_bulkExpansion_pointAtInfinity(self_: Point, other: PointAtInfinity) -> AntiScalar {
    return point_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn point_bulkExpansion_transflector(self_: Point, other: Transflector) -> Motor {
    return point_wedge_flector(self_, transflector_dual(other));
}

fn point_bulkExpansion_translator(self_: Point, other: Translator) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn pointAtInfinity_bulkExpansion_flector(self_: PointAtInfinity, other: Flector) -> Motor {
    return pointAtInfinity_wedge_flector(self_, flector_dual(other));
}

fn pointAtInfinity_bulkExpansion_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> Motor {
    return pointAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn pointAtInfinity_bulkExpansion_horizon(self_: PointAtInfinity, other: Horizon) -> LineAtOrigin {
    return pointAtInfinity_wedge_origin(self_, horizon_dual(other));
}

fn pointAtInfinity_bulkExpansion_line(self_: PointAtInfinity, other: Line) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(self_, line_dual(other));
}

fn pointAtInfinity_bulkExpansion_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn pointAtInfinity_bulkExpansion_motor(self_: PointAtInfinity, other: Motor) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn pointAtInfinity_bulkExpansion_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return pointAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn pointAtInfinity_bulkExpansion_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return pointAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn pointAtInfinity_bulkExpansion_plane(self_: PointAtInfinity, other: Plane) -> LineAtOrigin {
    return pointAtInfinity_wedge_origin(self_, plane_dual(other));
}

fn pointAtInfinity_bulkExpansion_point(self_: PointAtInfinity, other: Point) -> AntiScalar {
    return pointAtInfinity_wedge_planeAtOrigin(self_, point_dual(other));
}

fn pointAtInfinity_bulkExpansion_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> AntiScalar {
    return pointAtInfinity_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn pointAtInfinity_bulkExpansion_transflector(self_: PointAtInfinity, other: Transflector) -> Motor {
    return pointAtInfinity_wedge_flector(self_, transflector_dual(other));
}

fn pointAtInfinity_bulkExpansion_translator(self_: PointAtInfinity, other: Translator) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn rotor_bulkExpansion_flector(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return rotor_wedge_flector(self_, flector_dual(other));
}

fn rotor_bulkExpansion_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> PlaneAtOrigin {
    return rotor_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn rotor_bulkExpansion_transflector(self_: Rotor, other: Transflector) -> PlaneAtOrigin {
    return rotor_wedge_flector(self_, transflector_dual(other));
}

fn transflector_bulkExpansion_flector(self_: Transflector, other: Flector) -> Motor {
    return transflector_wedge_flector(self_, flector_dual(other));
}

fn transflector_bulkExpansion_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Motor {
    return transflector_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn transflector_bulkExpansion_horizon(self_: Transflector, other: Horizon) -> Rotor {
    return transflector_wedge_origin(self_, horizon_dual(other));
}

fn transflector_bulkExpansion_line(self_: Transflector, other: Line) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(self_, line_dual(other));
}

fn transflector_bulkExpansion_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn transflector_bulkExpansion_motor(self_: Transflector, other: Motor) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn transflector_bulkExpansion_multiVector(self_: Transflector, other: MultiVector) -> MultiVectorAtOrigin {
    return transflector_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn transflector_bulkExpansion_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return transflector_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn transflector_bulkExpansion_plane(self_: Transflector, other: Plane) -> Rotor {
    return transflector_wedge_origin(self_, plane_dual(other));
}

fn transflector_bulkExpansion_point(self_: Transflector, other: Point) -> AntiScalar {
    return transflector_wedge_planeAtOrigin(self_, point_dual(other));
}

fn transflector_bulkExpansion_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> AntiScalar {
    return transflector_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other));
}

fn transflector_bulkExpansion_transflector(self_: Transflector, other: Transflector) -> Motor {
    return transflector_wedge_flector(self_, transflector_dual(other));
}

fn transflector_bulkExpansion_translator(self_: Transflector, other: Translator) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn translator_bulkExpansion_flector(self_: Translator, other: Flector) -> Plane {
    return translator_wedge_flector(self_, flector_dual(other));
}

fn translator_bulkExpansion_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Plane {
    return translator_wedge_flector(self_, flectorAtInfinity_dual(other));
}

fn translator_bulkExpansion_horizon(self_: Translator, other: Horizon) -> PlaneAtOrigin {
    return translator_wedge_origin(self_, horizon_dual(other));
}

fn translator_bulkExpansion_line(self_: Translator, other: Line) -> AntiScalar {
    return translator_wedge_lineAtOrigin(self_, line_dual(other));
}

fn translator_bulkExpansion_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> AntiScalar {
    return translator_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other));
}

fn translator_bulkExpansion_motor(self_: Translator, other: Motor) -> AntiScalar {
    return translator_wedge_lineAtOrigin(self_, motor_dual(other));
}

fn translator_bulkExpansion_multiVector(self_: Translator, other: MultiVector) -> MultiVectorAtOrigin {
    return translator_wedge_multiVectorAtOrigin(self_, multiVector_dual(other));
}

fn translator_bulkExpansion_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return translator_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other));
}

fn translator_bulkExpansion_plane(self_: Translator, other: Plane) -> PlaneAtOrigin {
    return translator_wedge_origin(self_, plane_dual(other));
}

fn translator_bulkExpansion_transflector(self_: Translator, other: Transflector) -> Plane {
    return translator_wedge_flector(self_, transflector_dual(other));
}

fn translator_bulkExpansion_translator(self_: Translator, other: Translator) -> AntiScalar {
    return translator_wedge_lineAtOrigin(self_, translator_dual(other));
}

fn flector_weightExpansion_flector(self_: Flector, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn flector_weightExpansion_line(self_: Flector, other: Line) -> Plane {
    return flector_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn flector_weightExpansion_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Plane {
    return flector_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn flector_weightExpansion_motor(self_: Flector, other: Motor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn flector_weightExpansion_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn flector_weightExpansion_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn flector_weightExpansion_origin(self_: Flector, other: Origin) -> AntiScalar {
    return flector_wedge_horizon(self_, origin_antiDual(other));
}

fn flector_weightExpansion_plane(self_: Flector, other: Plane) -> Motor {
    return flector_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn flector_weightExpansion_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Motor {
    return flector_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn flector_weightExpansion_point(self_: Flector, other: Point) -> AntiScalar {
    return flector_wedge_horizon(self_, point_antiDual(other));
}

fn flector_weightExpansion_rotor(self_: Flector, other: Rotor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn flector_weightExpansion_transflector(self_: Flector, other: Transflector) -> Motor {
    return flector_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_flector(self_: FlectorAtInfinity, other: Flector) -> LineAtInfinity {
    return flectorAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_line(self_: FlectorAtInfinity, other: Line) -> Horizon {
    return flectorAtInfinity_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> Horizon {
    return flectorAtInfinity_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_motor(self_: FlectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_plane(self_: FlectorAtInfinity, other: Plane) -> LineAtInfinity {
    return flectorAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return flectorAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_rotor(self_: FlectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn flectorAtInfinity_weightExpansion_transflector(self_: FlectorAtInfinity, other: Transflector) -> LineAtInfinity {
    return flectorAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn horizon_weightExpansion_motor(self_: Horizon, other: Motor) -> Horizon {
    return horizon_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn horizon_weightExpansion_multiVector(self_: Horizon, other: MultiVector) -> Horizon {
    return horizon_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn horizon_weightExpansion_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> Horizon {
    return horizon_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn horizon_weightExpansion_rotor(self_: Horizon, other: Rotor) -> Horizon {
    return horizon_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn line_weightExpansion_flector(self_: Line, other: Flector) -> Plane {
    return line_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn line_weightExpansion_line(self_: Line, other: Line) -> AntiScalar {
    return line_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn line_weightExpansion_lineAtOrigin(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return line_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn line_weightExpansion_motor(self_: Line, other: Motor) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn line_weightExpansion_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn line_weightExpansion_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn line_weightExpansion_plane(self_: Line, other: Plane) -> Plane {
    return line_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn line_weightExpansion_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Plane {
    return line_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn line_weightExpansion_rotor(self_: Line, other: Rotor) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn line_weightExpansion_transflector(self_: Line, other: Transflector) -> Plane {
    return line_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn lineAtInfinity_weightExpansion_flector(self_: LineAtInfinity, other: Flector) -> Horizon {
    return lineAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn lineAtInfinity_weightExpansion_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return lineAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn lineAtInfinity_weightExpansion_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return lineAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn lineAtInfinity_weightExpansion_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return lineAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn lineAtInfinity_weightExpansion_plane(self_: LineAtInfinity, other: Plane) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn lineAtInfinity_weightExpansion_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn lineAtInfinity_weightExpansion_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return lineAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn lineAtInfinity_weightExpansion_transflector(self_: LineAtInfinity, other: Transflector) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn lineAtOrigin_weightExpansion_flector(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn lineAtOrigin_weightExpansion_line(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return lineAtOrigin_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn lineAtOrigin_weightExpansion_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return lineAtOrigin_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn lineAtOrigin_weightExpansion_motor(self_: LineAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn lineAtOrigin_weightExpansion_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn lineAtOrigin_weightExpansion_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn lineAtOrigin_weightExpansion_plane(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn lineAtOrigin_weightExpansion_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn lineAtOrigin_weightExpansion_rotor(self_: LineAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn lineAtOrigin_weightExpansion_transflector(self_: LineAtOrigin, other: Transflector) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn motor_weightExpansion_flector(self_: Motor, other: Flector) -> Plane {
    return motor_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn motor_weightExpansion_line(self_: Motor, other: Line) -> AntiScalar {
    return motor_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn motor_weightExpansion_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return motor_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn motor_weightExpansion_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn motor_weightExpansion_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn motor_weightExpansion_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn motor_weightExpansion_plane(self_: Motor, other: Plane) -> Plane {
    return motor_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn motor_weightExpansion_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Plane {
    return motor_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn motor_weightExpansion_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn motor_weightExpansion_transflector(self_: Motor, other: Transflector) -> Plane {
    return motor_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn multiVector_weightExpansion_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn multiVector_weightExpansion_line(self_: MultiVector, other: Line) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn multiVector_weightExpansion_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn multiVector_weightExpansion_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn multiVector_weightExpansion_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn multiVector_weightExpansion_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn multiVector_weightExpansion_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return multiVector_wedge_horizon(self_, origin_antiDual(other));
}

fn multiVector_weightExpansion_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn multiVector_weightExpansion_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn multiVector_weightExpansion_point(self_: MultiVector, other: Point) -> MultiVector {
    return multiVector_wedge_horizon(self_, point_antiDual(other));
}

fn multiVector_weightExpansion_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn multiVector_weightExpansion_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_origin(self_: MultiVectorAtInfinity, other: Origin) -> Horizon {
    return multiVectorAtInfinity_wedge_horizon(self_, origin_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_point(self_: MultiVectorAtInfinity, other: Point) -> Horizon {
    return multiVectorAtInfinity_wedge_horizon(self_, point_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn multiVectorAtInfinity_weightExpansion_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_origin(self_: MultiVectorAtOrigin, other: Origin) -> AntiScalar {
    return multiVectorAtOrigin_wedge_horizon(self_, origin_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_point(self_: MultiVectorAtOrigin, other: Point) -> AntiScalar {
    return multiVectorAtOrigin_wedge_horizon(self_, point_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn multiVectorAtOrigin_weightExpansion_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn origin_weightExpansion_flector(self_: Origin, other: Flector) -> Rotor {
    return origin_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn origin_weightExpansion_line(self_: Origin, other: Line) -> PlaneAtOrigin {
    return origin_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn origin_weightExpansion_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return origin_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn origin_weightExpansion_motor(self_: Origin, other: Motor) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn origin_weightExpansion_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn origin_weightExpansion_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn origin_weightExpansion_origin(self_: Origin, other: Origin) -> AntiScalar {
    return origin_wedge_horizon(self_, origin_antiDual(other));
}

fn origin_weightExpansion_plane(self_: Origin, other: Plane) -> LineAtOrigin {
    return origin_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn origin_weightExpansion_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return origin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn origin_weightExpansion_point(self_: Origin, other: Point) -> AntiScalar {
    return origin_wedge_horizon(self_, point_antiDual(other));
}

fn origin_weightExpansion_rotor(self_: Origin, other: Rotor) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn origin_weightExpansion_transflector(self_: Origin, other: Transflector) -> LineAtOrigin {
    return origin_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn plane_weightExpansion_flector(self_: Plane, other: Flector) -> AntiScalar {
    return plane_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn plane_weightExpansion_motor(self_: Plane, other: Motor) -> MultiVector {
    return plane_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn plane_weightExpansion_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn plane_weightExpansion_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return plane_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn plane_weightExpansion_plane(self_: Plane, other: Plane) -> AntiScalar {
    return plane_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn plane_weightExpansion_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> AntiScalar {
    return plane_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn plane_weightExpansion_rotor(self_: Plane, other: Rotor) -> MultiVector {
    return plane_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn plane_weightExpansion_transflector(self_: Plane, other: Transflector) -> AntiScalar {
    return plane_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn planeAtOrigin_weightExpansion_flector(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return planeAtOrigin_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn planeAtOrigin_weightExpansion_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return planeAtOrigin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn planeAtOrigin_weightExpansion_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return planeAtOrigin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn planeAtOrigin_weightExpansion_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return planeAtOrigin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn planeAtOrigin_weightExpansion_plane(self_: PlaneAtOrigin, other: Plane) -> AntiScalar {
    return planeAtOrigin_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn planeAtOrigin_weightExpansion_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return planeAtOrigin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn planeAtOrigin_weightExpansion_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return planeAtOrigin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn planeAtOrigin_weightExpansion_transflector(self_: PlaneAtOrigin, other: Transflector) -> AntiScalar {
    return planeAtOrigin_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn point_weightExpansion_flector(self_: Point, other: Flector) -> Motor {
    return point_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn point_weightExpansion_line(self_: Point, other: Line) -> Plane {
    return point_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn point_weightExpansion_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Plane {
    return point_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn point_weightExpansion_motor(self_: Point, other: Motor) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn point_weightExpansion_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn point_weightExpansion_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn point_weightExpansion_origin(self_: Point, other: Origin) -> AntiScalar {
    return point_wedge_horizon(self_, origin_antiDual(other));
}

fn point_weightExpansion_plane(self_: Point, other: Plane) -> Line {
    return point_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn point_weightExpansion_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Line {
    return point_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn point_weightExpansion_point(self_: Point, other: Point) -> AntiScalar {
    return point_wedge_horizon(self_, point_antiDual(other));
}

fn point_weightExpansion_rotor(self_: Point, other: Rotor) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn point_weightExpansion_transflector(self_: Point, other: Transflector) -> Line {
    return point_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn pointAtInfinity_weightExpansion_flector(self_: PointAtInfinity, other: Flector) -> LineAtInfinity {
    return pointAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn pointAtInfinity_weightExpansion_line(self_: PointAtInfinity, other: Line) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn pointAtInfinity_weightExpansion_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn pointAtInfinity_weightExpansion_motor(self_: PointAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn pointAtInfinity_weightExpansion_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn pointAtInfinity_weightExpansion_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn pointAtInfinity_weightExpansion_plane(self_: PointAtInfinity, other: Plane) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn pointAtInfinity_weightExpansion_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn pointAtInfinity_weightExpansion_rotor(self_: PointAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn pointAtInfinity_weightExpansion_transflector(self_: PointAtInfinity, other: Transflector) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn rotor_weightExpansion_flector(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return rotor_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn rotor_weightExpansion_line(self_: Rotor, other: Line) -> AntiScalar {
    return rotor_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn rotor_weightExpansion_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return rotor_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn rotor_weightExpansion_motor(self_: Rotor, other: Motor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn rotor_weightExpansion_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn rotor_weightExpansion_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn rotor_weightExpansion_plane(self_: Rotor, other: Plane) -> PlaneAtOrigin {
    return rotor_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn rotor_weightExpansion_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return rotor_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn rotor_weightExpansion_rotor(self_: Rotor, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn rotor_weightExpansion_transflector(self_: Rotor, other: Transflector) -> PlaneAtOrigin {
    return rotor_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn transflector_weightExpansion_flector(self_: Transflector, other: Flector) -> Translator {
    return transflector_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn transflector_weightExpansion_line(self_: Transflector, other: Line) -> Horizon {
    return transflector_wedge_lineAtInfinity(self_, line_antiDual(other));
}

fn transflector_weightExpansion_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Horizon {
    return transflector_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other));
}

fn transflector_weightExpansion_motor(self_: Transflector, other: Motor) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn transflector_weightExpansion_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn transflector_weightExpansion_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn transflector_weightExpansion_plane(self_: Transflector, other: Plane) -> Translator {
    return transflector_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn transflector_weightExpansion_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Translator {
    return transflector_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn transflector_weightExpansion_rotor(self_: Transflector, other: Rotor) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn transflector_weightExpansion_transflector(self_: Transflector, other: Transflector) -> Translator {
    return transflector_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn translator_weightExpansion_flector(self_: Translator, other: Flector) -> Horizon {
    return translator_wedge_flectorAtInfinity(self_, flector_antiDual(other));
}

fn translator_weightExpansion_motor(self_: Translator, other: Motor) -> MultiVector {
    return translator_wedge_multiVectorAtInfinity(self_, motor_antiDual(other));
}

fn translator_weightExpansion_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other));
}

fn translator_weightExpansion_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return translator_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other));
}

fn translator_weightExpansion_plane(self_: Translator, other: Plane) -> Horizon {
    return translator_wedge_pointAtInfinity(self_, plane_antiDual(other));
}

fn translator_weightExpansion_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Horizon {
    return translator_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other));
}

fn translator_weightExpansion_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return translator_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other));
}

fn translator_weightExpansion_transflector(self_: Translator, other: Transflector) -> Horizon {
    return translator_wedge_pointAtInfinity(self_, transflector_antiDual(other));
}

fn flector_antiProjectOrthogonallyOnto_flector(self_: Flector, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, flector_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_line(self_: Flector, other: Line) -> Plane {
    return line_wedge_pointAtInfinity(other, flector_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(other, flector_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_motor(self_: Flector, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, flector_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, flector_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, flector_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_origin(self_: Flector, other: Origin) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(other, flector_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_plane(self_: Flector, other: Plane) -> Plane {
    return plane_wedge_scalar(other, flector_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_wedge_scalar(other, flector_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_point(self_: Flector, other: Point) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(other, flector_antiWedge_horizon(self_, point_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_rotor(self_: Flector, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, flector_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn flector_antiProjectOrthogonallyOnto_transflector(self_: Flector, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, flector_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_flector(self_: Line, other: Flector) -> Motor {
    return flector_wedge_pointAtInfinity(other, line_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_line(self_: Line, other: Line) -> Line {
    return line_wedge_scalar(other, line_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Line, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_wedge_scalar(other, line_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_motor(self_: Line, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, line_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, line_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, line_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_origin(self_: Line, other: Origin) -> LineAtOrigin {
    return origin_wedge_pointAtInfinity(other, line_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_point(self_: Line, other: Point) -> Line {
    return point_wedge_pointAtInfinity(other, line_antiWedge_horizon(self_, point_antiDual(other)));
}

fn line_antiProjectOrthogonallyOnto_rotor(self_: Line, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, line_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_flector(self_: LineAtOrigin, other: Flector) -> Motor {
    return flector_wedge_pointAtInfinity(other, lineAtOrigin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_line(self_: LineAtOrigin, other: Line) -> Line {
    return line_wedge_scalar(other, lineAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_wedge_scalar(other, lineAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_origin(self_: LineAtOrigin, other: Origin) -> LineAtOrigin {
    return origin_wedge_pointAtInfinity(other, lineAtOrigin_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_point(self_: LineAtOrigin, other: Point) -> Line {
    return point_wedge_pointAtInfinity(other, lineAtOrigin_antiWedge_horizon(self_, point_antiDual(other)));
}

fn lineAtOrigin_antiProjectOrthogonallyOnto_rotor(self_: LineAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_flector(self_: Motor, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(other, motor_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_line(self_: Motor, other: Line) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(other, motor_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(other, motor_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, motor_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, motor_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, motor_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_origin(self_: Motor, other: Origin) -> Rotor {
    return origin_wedge_flectorAtInfinity(other, motor_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_plane(self_: Motor, other: Plane) -> AntiScalar {
    return plane_wedge_pointAtInfinity(other, motor_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> AntiScalar {
    return planeAtOrigin_wedge_pointAtInfinity(other, motor_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_point(self_: Motor, other: Point) -> Motor {
    return point_wedge_flectorAtInfinity(other, motor_antiWedge_horizon(self_, point_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_rotor(self_: Motor, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, motor_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn motor_antiProjectOrthogonallyOnto_transflector(self_: Motor, other: Transflector) -> Translator {
    return transflector_wedge_pointAtInfinity(other, motor_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_origin(self_: MultiVector, other: Origin) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return planeAtOrigin_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_horizon(self_, point_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn multiVector_antiProjectOrthogonallyOnto_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(other, multiVector_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_origin(self_: MultiVectorAtOrigin, other: Origin) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return plane_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return planeAtOrigin_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_horizon(self_, point_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn multiVectorAtOrigin_antiProjectOrthogonallyOnto_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(other, multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_flector(self_: Origin, other: Flector) -> Flector {
    return flector_wedge_scalar(other, origin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_motor(self_: Origin, other: Motor) -> Motor {
    return motor_wedge_scalar(other, origin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_scalar(other, origin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_scalar(other, origin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_origin(self_: Origin, other: Origin) -> Origin {
    return origin_wedge_scalar(other, origin_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_point(self_: Origin, other: Point) -> Point {
    return point_wedge_scalar(other, origin_antiWedge_horizon(self_, point_antiDual(other)));
}

fn origin_antiProjectOrthogonallyOnto_rotor(self_: Origin, other: Rotor) -> Rotor {
    return rotor_wedge_scalar(other, origin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_flector(self_: Plane, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, plane_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_line(self_: Plane, other: Line) -> Plane {
    return line_wedge_pointAtInfinity(other, plane_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(other, plane_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_motor(self_: Plane, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, plane_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, plane_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, plane_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_origin(self_: Plane, other: Origin) -> PlaneAtOrigin {
    return origin_wedge_lineAtInfinity(other, plane_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_plane(self_: Plane, other: Plane) -> Plane {
    return plane_wedge_scalar(other, plane_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_wedge_scalar(other, plane_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_point(self_: Plane, other: Point) -> Plane {
    return point_wedge_lineAtInfinity(other, plane_antiWedge_horizon(self_, point_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_rotor(self_: Plane, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, plane_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn plane_antiProjectOrthogonallyOnto_transflector(self_: Plane, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, plane_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, planeAtOrigin_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_line(self_: PlaneAtOrigin, other: Line) -> Plane {
    return line_wedge_pointAtInfinity(other, planeAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(other, planeAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_origin(self_: PlaneAtOrigin, other: Origin) -> PlaneAtOrigin {
    return origin_wedge_lineAtInfinity(other, planeAtOrigin_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_plane(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return plane_wedge_scalar(other, planeAtOrigin_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_wedge_scalar(other, planeAtOrigin_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_point(self_: PlaneAtOrigin, other: Point) -> Plane {
    return point_wedge_lineAtInfinity(other, planeAtOrigin_antiWedge_horizon(self_, point_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn planeAtOrigin_antiProjectOrthogonallyOnto_transflector(self_: PlaneAtOrigin, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, planeAtOrigin_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_flector(self_: Point, other: Flector) -> Flector {
    return flector_wedge_scalar(other, point_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_motor(self_: Point, other: Motor) -> Motor {
    return motor_wedge_scalar(other, point_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_wedge_scalar(other, point_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_scalar(other, point_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_origin(self_: Point, other: Origin) -> Origin {
    return origin_wedge_scalar(other, point_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_point(self_: Point, other: Point) -> Point {
    return point_wedge_scalar(other, point_antiWedge_horizon(self_, point_antiDual(other)));
}

fn point_antiProjectOrthogonallyOnto_rotor(self_: Point, other: Rotor) -> Rotor {
    return rotor_wedge_scalar(other, point_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_flector(self_: Rotor, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(other, rotor_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_line(self_: Rotor, other: Line) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(other, rotor_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(other, rotor_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_motor(self_: Rotor, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, rotor_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, rotor_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, rotor_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_origin(self_: Rotor, other: Origin) -> Rotor {
    return origin_wedge_flectorAtInfinity(other, rotor_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_plane(self_: Rotor, other: Plane) -> AntiScalar {
    return plane_wedge_pointAtInfinity(other, rotor_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> AntiScalar {
    return planeAtOrigin_wedge_pointAtInfinity(other, rotor_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_point(self_: Rotor, other: Point) -> Motor {
    return point_wedge_flectorAtInfinity(other, rotor_antiWedge_horizon(self_, point_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_rotor(self_: Rotor, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, rotor_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn rotor_antiProjectOrthogonallyOnto_transflector(self_: Rotor, other: Transflector) -> Translator {
    return transflector_wedge_pointAtInfinity(other, rotor_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_flector(self_: Transflector, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, transflector_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_line(self_: Transflector, other: Line) -> Plane {
    return line_wedge_pointAtInfinity(other, transflector_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(other, transflector_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_motor(self_: Transflector, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, transflector_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, transflector_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, transflector_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_origin(self_: Transflector, other: Origin) -> PlaneAtOrigin {
    return origin_wedge_lineAtInfinity(other, transflector_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_plane(self_: Transflector, other: Plane) -> Plane {
    return plane_wedge_scalar(other, transflector_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_wedge_scalar(other, transflector_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_point(self_: Transflector, other: Point) -> Plane {
    return point_wedge_lineAtInfinity(other, transflector_antiWedge_horizon(self_, point_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_rotor(self_: Transflector, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, transflector_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn transflector_antiProjectOrthogonallyOnto_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, transflector_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_flector(self_: Translator, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(other, translator_antiWedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_line(self_: Translator, other: Line) -> AntiScalar {
    return line_wedge_lineAtInfinity(other, translator_antiWedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> AntiScalar {
    return lineAtOrigin_wedge_lineAtInfinity(other, translator_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_motor(self_: Translator, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, translator_antiWedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, translator_antiWedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(other, translator_antiWedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_origin(self_: Translator, other: Origin) -> AntiScalar {
    return origin_wedge_horizon(other, translator_antiWedge_horizon(self_, origin_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_plane(self_: Translator, other: Plane) -> AntiScalar {
    return plane_wedge_pointAtInfinity(other, translator_antiWedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> AntiScalar {
    return planeAtOrigin_wedge_pointAtInfinity(other, translator_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_point(self_: Translator, other: Point) -> AntiScalar {
    return point_wedge_horizon(other, translator_antiWedge_horizon(self_, point_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_rotor(self_: Translator, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(other, translator_antiWedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn translator_antiProjectOrthogonallyOnto_transflector(self_: Translator, other: Transflector) -> Translator {
    return transflector_wedge_pointAtInfinity(other, translator_antiWedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn flector_antiProjectViaHorizonOnto_flector(self_: Flector, other: Flector) -> MultiVector {
    return flector_wedge_multiVector(other, flector_antiWedge_flector(self_, flector_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVector {
    return flectorAtInfinity_wedge_multiVector(other, flector_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_horizon(self_: Flector, other: Horizon) -> Horizon {
    return horizon_wedge_scalar(other, flector_antiWedge_origin(self_, horizon_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_line(self_: Flector, other: Line) -> Plane {
    return line_wedge_point(other, flector_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Plane {
    return lineAtInfinity_wedge_point(other, flector_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_motor(self_: Flector, other: Motor) -> Plane {
    return motor_wedge_point(other, flector_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, flector_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, flector_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_plane(self_: Flector, other: Plane) -> Plane {
    return plane_wedge_scalar(other, flector_antiWedge_origin(self_, plane_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_point(self_: Flector, other: Point) -> MultiVector {
    return point_wedge_multiVector(other, flector_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return pointAtInfinity_wedge_multiVector(other, flector_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVector(other, flector_antiWedge_flector(self_, transflector_dual(other)));
}

fn flector_antiProjectViaHorizonOnto_translator(self_: Flector, other: Translator) -> Plane {
    return translator_wedge_point(other, flector_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_flector(self_, flector_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_horizon(self_: FlectorAtInfinity, other: Horizon) -> Horizon {
    return horizon_wedge_scalar(other, flectorAtInfinity_antiWedge_origin(self_, horizon_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_line(self_: FlectorAtInfinity, other: Line) -> Plane {
    return line_wedge_pointAtInfinity(other, flectorAtInfinity_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(other, flectorAtInfinity_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_motor(self_: FlectorAtInfinity, other: Motor) -> Plane {
    return motor_wedge_pointAtInfinity(other, flectorAtInfinity_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_plane(self_: FlectorAtInfinity, other: Plane) -> Plane {
    return plane_wedge_scalar(other, flectorAtInfinity_antiWedge_origin(self_, plane_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_point(self_: FlectorAtInfinity, other: Point) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(other, flectorAtInfinity_antiWedge_flector(self_, transflector_dual(other)));
}

fn flectorAtInfinity_antiProjectViaHorizonOnto_translator(self_: FlectorAtInfinity, other: Translator) -> Horizon {
    return translator_wedge_pointAtInfinity(other, flectorAtInfinity_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_flector(self_: Horizon, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, horizon_antiWedge_flector(self_, flector_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(other, horizon_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return horizon_wedge_scalar(other, horizon_antiWedge_origin(self_, horizon_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_line(self_: Horizon, other: Line) -> Plane {
    return line_wedge_pointAtInfinity(other, horizon_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_lineAtInfinity(self_: Horizon, other: LineAtInfinity) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(other, horizon_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_motor(self_: Horizon, other: Motor) -> Plane {
    return motor_wedge_pointAtInfinity(other, horizon_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, horizon_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(other, horizon_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_plane(self_: Horizon, other: Plane) -> Plane {
    return plane_wedge_scalar(other, horizon_antiWedge_origin(self_, plane_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_point(self_: Horizon, other: Point) -> Plane {
    return point_wedge_lineAtInfinity(other, horizon_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_pointAtInfinity(self_: Horizon, other: PointAtInfinity) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(other, horizon_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_transflector(self_: Horizon, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(other, horizon_antiWedge_flector(self_, transflector_dual(other)));
}

fn horizon_antiProjectViaHorizonOnto_translator(self_: Horizon, other: Translator) -> Horizon {
    return translator_wedge_pointAtInfinity(other, horizon_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn line_antiProjectViaHorizonOnto_flector(self_: Line, other: Flector) -> Motor {
    return flector_wedge_point(other, line_antiWedge_flector(self_, flector_dual(other)));
}

fn line_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_point(other, line_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn line_antiProjectViaHorizonOnto_line(self_: Line, other: Line) -> Line {
    return line_wedge_scalar(other, line_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn line_antiProjectViaHorizonOnto_lineAtInfinity(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_wedge_scalar(other, line_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn line_antiProjectViaHorizonOnto_motor(self_: Line, other: Motor) -> Motor {
    return motor_wedge_scalar(other, line_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn line_antiProjectViaHorizonOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, line_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn line_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, line_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn line_antiProjectViaHorizonOnto_point(self_: Line, other: Point) -> Line {
    return point_wedge_point(other, line_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn line_antiProjectViaHorizonOnto_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Line {
    return pointAtInfinity_wedge_point(other, line_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn line_antiProjectViaHorizonOnto_transflector(self_: Line, other: Transflector) -> Motor {
    return transflector_wedge_point(other, line_antiWedge_flector(self_, transflector_dual(other)));
}

fn line_antiProjectViaHorizonOnto_translator(self_: Line, other: Translator) -> Translator {
    return translator_wedge_scalar(other, line_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_flector(self_: LineAtInfinity, other: Flector) -> Motor {
    return flector_wedge_pointAtInfinity(other, lineAtInfinity_antiWedge_flector(self_, flector_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> LineAtInfinity {
    return flectorAtInfinity_wedge_pointAtInfinity(other, lineAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_line(self_: LineAtInfinity, other: Line) -> Line {
    return line_wedge_scalar(other, lineAtInfinity_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_wedge_scalar(other, lineAtInfinity_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_motor(self_: LineAtInfinity, other: Motor) -> Motor {
    return motor_wedge_scalar(other, lineAtInfinity_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, lineAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(other, lineAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_point(self_: LineAtInfinity, other: Point) -> Line {
    return point_wedge_pointAtInfinity(other, lineAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(other, lineAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_transflector(self_: LineAtInfinity, other: Transflector) -> Translator {
    return transflector_wedge_pointAtInfinity(other, lineAtInfinity_antiWedge_flector(self_, transflector_dual(other)));
}

fn lineAtInfinity_antiProjectViaHorizonOnto_translator(self_: LineAtInfinity, other: Translator) -> Translator {
    return translator_wedge_scalar(other, lineAtInfinity_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_flector(self_: LineAtOrigin, other: Flector) -> Motor {
    return flector_wedge_point(other, lineAtOrigin_antiWedge_flector(self_, flector_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_point(other, lineAtOrigin_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(other, lineAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(other, lineAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_point(self_: LineAtOrigin, other: Point) -> LineAtOrigin {
    return point_wedge_origin(other, lineAtOrigin_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> LineAtOrigin {
    return pointAtInfinity_wedge_origin(other, lineAtOrigin_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn lineAtOrigin_antiProjectViaHorizonOnto_transflector(self_: LineAtOrigin, other: Transflector) -> Motor {
    return transflector_wedge_point(other, lineAtOrigin_antiWedge_flector(self_, transflector_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_flector(self_: Motor, other: Flector) -> Motor {
    return flector_wedge_flector(other, motor_antiWedge_flector(self_, flector_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(other, motor_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_horizon(self_: Motor, other: Horizon) -> AntiScalar {
    return horizon_wedge_origin(other, motor_antiWedge_origin(self_, horizon_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_line(self_: Motor, other: Line) -> MultiVector {
    return line_wedge_multiVector(other, motor_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return lineAtInfinity_wedge_multiVector(other, motor_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_wedge_multiVector(other, motor_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, motor_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, motor_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_plane(self_: Motor, other: Plane) -> AntiScalar {
    return plane_wedge_origin(other, motor_antiWedge_origin(self_, plane_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_point(self_: Motor, other: Point) -> Motor {
    return point_wedge_flector(other, motor_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Motor {
    return pointAtInfinity_wedge_flector(other, motor_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_transflector(self_: Motor, other: Transflector) -> Motor {
    return transflector_wedge_flector(other, motor_antiWedge_flector(self_, transflector_dual(other)));
}

fn motor_antiProjectViaHorizonOnto_translator(self_: Motor, other: Translator) -> MultiVector {
    return translator_wedge_multiVector(other, motor_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_wedge_multiVector(other, multiVector_antiWedge_flector(self_, flector_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return flectorAtInfinity_wedge_multiVector(other, multiVector_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return horizon_wedge_multiVector(other, multiVector_antiWedge_origin(self_, horizon_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    return line_wedge_multiVector(other, multiVector_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return lineAtInfinity_wedge_multiVector(other, multiVector_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_wedge_multiVector(other, multiVector_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, multiVector_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, multiVector_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_wedge_multiVector(other, multiVector_antiWedge_origin(self_, plane_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    return point_wedge_multiVector(other, multiVector_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return pointAtInfinity_wedge_multiVector(other, multiVector_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVector(other, multiVector_antiWedge_flector(self_, transflector_dual(other)));
}

fn multiVector_antiProjectViaHorizonOnto_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_wedge_multiVector(other, multiVector_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_flector(self_, flector_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> Horizon {
    return horizon_wedge_scalar(other, multiVectorAtInfinity_antiWedge_origin(self_, horizon_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return line_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return lineAtInfinity_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return motor_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_plane(self_: MultiVectorAtInfinity, other: Plane) -> Plane {
    return plane_wedge_scalar(other, multiVectorAtInfinity_antiWedge_origin(self_, plane_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_flector(self_, transflector_dual(other)));
}

fn multiVectorAtInfinity_antiProjectViaHorizonOnto_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return translator_wedge_multiVectorAtInfinity(other, multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return flector_wedge_multiVector(other, multiVectorAtOrigin_antiWedge_flector(self_, flector_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return flectorAtInfinity_wedge_multiVector(other, multiVectorAtOrigin_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> AntiScalar {
    return horizon_wedge_origin(other, multiVectorAtOrigin_antiWedge_origin(self_, horizon_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return line_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return lineAtInfinity_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return motor_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_plane(self_: MultiVectorAtOrigin, other: Plane) -> AntiScalar {
    return plane_wedge_origin(other, multiVectorAtOrigin_antiWedge_origin(self_, plane_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return point_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return pointAtInfinity_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVector(other, multiVectorAtOrigin_antiWedge_flector(self_, transflector_dual(other)));
}

fn multiVectorAtOrigin_antiProjectViaHorizonOnto_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return translator_wedge_multiVectorAtOrigin(other, multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn origin_antiProjectViaHorizonOnto_flector(self_: Origin, other: Flector) -> Flector {
    return flector_wedge_scalar(other, origin_antiWedge_flector(self_, flector_dual(other)));
}

fn origin_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_wedge_scalar(other, origin_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn origin_antiProjectViaHorizonOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(other, origin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn origin_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(other, origin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn origin_antiProjectViaHorizonOnto_transflector(self_: Origin, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, origin_antiWedge_flector(self_, transflector_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_flector(self_: Plane, other: Flector) -> MultiVector {
    return flector_wedge_multiVector(other, plane_antiWedge_flector(self_, flector_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVector {
    return flectorAtInfinity_wedge_multiVector(other, plane_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_horizon(self_: Plane, other: Horizon) -> Horizon {
    return horizon_wedge_scalar(other, plane_antiWedge_origin(self_, horizon_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_line(self_: Plane, other: Line) -> Plane {
    return line_wedge_point(other, plane_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> Plane {
    return lineAtInfinity_wedge_point(other, plane_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_motor(self_: Plane, other: Motor) -> Plane {
    return motor_wedge_point(other, plane_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, plane_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, plane_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_plane(self_: Plane, other: Plane) -> Plane {
    return plane_wedge_scalar(other, plane_antiWedge_origin(self_, plane_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_point(self_: Plane, other: Point) -> Plane {
    return point_wedge_line(other, plane_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> Plane {
    return pointAtInfinity_wedge_line(other, plane_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVector(other, plane_antiWedge_flector(self_, transflector_dual(other)));
}

fn plane_antiProjectViaHorizonOnto_translator(self_: Plane, other: Translator) -> Plane {
    return translator_wedge_point(other, plane_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return flector_wedge_multiVector(other, planeAtOrigin_antiWedge_flector(self_, flector_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return flectorAtInfinity_wedge_multiVector(other, planeAtOrigin_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_line(self_: PlaneAtOrigin, other: Line) -> PlaneAtOrigin {
    return line_wedge_origin(other, planeAtOrigin_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(other, planeAtOrigin_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_motor(self_: PlaneAtOrigin, other: Motor) -> PlaneAtOrigin {
    return motor_wedge_origin(other, planeAtOrigin_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(other, planeAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(other, planeAtOrigin_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_point(self_: PlaneAtOrigin, other: Point) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(other, planeAtOrigin_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(other, planeAtOrigin_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVector(other, planeAtOrigin_antiWedge_flector(self_, transflector_dual(other)));
}

fn planeAtOrigin_antiProjectViaHorizonOnto_translator(self_: PlaneAtOrigin, other: Translator) -> PlaneAtOrigin {
    return translator_wedge_origin(other, planeAtOrigin_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn point_antiProjectViaHorizonOnto_flector(self_: Point, other: Flector) -> Flector {
    return flector_wedge_scalar(other, point_antiWedge_flector(self_, flector_dual(other)));
}

fn point_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_wedge_scalar(other, point_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn point_antiProjectViaHorizonOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, point_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn point_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, point_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn point_antiProjectViaHorizonOnto_point(self_: Point, other: Point) -> Point {
    return point_wedge_scalar(other, point_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn point_antiProjectViaHorizonOnto_pointAtInfinity(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_wedge_scalar(other, point_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn point_antiProjectViaHorizonOnto_transflector(self_: Point, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, point_antiWedge_flector(self_, transflector_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_flector(self_: PointAtInfinity, other: Flector) -> Flector {
    return flector_wedge_scalar(other, pointAtInfinity_antiWedge_flector(self_, flector_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_wedge_scalar(other, pointAtInfinity_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(other, pointAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(other, pointAtInfinity_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_point(self_: PointAtInfinity, other: Point) -> Point {
    return point_wedge_scalar(other, pointAtInfinity_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_wedge_scalar(other, pointAtInfinity_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn pointAtInfinity_antiProjectViaHorizonOnto_transflector(self_: PointAtInfinity, other: Transflector) -> Transflector {
    return transflector_wedge_scalar(other, pointAtInfinity_antiWedge_flector(self_, transflector_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_flector(self_: Rotor, other: Flector) -> Motor {
    return flector_wedge_flector(other, rotor_antiWedge_flector(self_, flector_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(other, rotor_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_horizon(self_: Rotor, other: Horizon) -> AntiScalar {
    return horizon_wedge_origin(other, rotor_antiWedge_origin(self_, horizon_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_line(self_: Rotor, other: Line) -> AntiScalar {
    return line_wedge_lineAtOrigin(other, rotor_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(other, rotor_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_motor(self_: Rotor, other: Motor) -> AntiScalar {
    return motor_wedge_lineAtOrigin(other, rotor_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(other, rotor_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(other, rotor_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_plane(self_: Rotor, other: Plane) -> AntiScalar {
    return plane_wedge_origin(other, rotor_antiWedge_origin(self_, plane_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_point(self_: Rotor, other: Point) -> Motor {
    return point_wedge_flector(other, rotor_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> Motor {
    return pointAtInfinity_wedge_flector(other, rotor_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_transflector(self_: Rotor, other: Transflector) -> Motor {
    return transflector_wedge_flector(other, rotor_antiWedge_flector(self_, transflector_dual(other)));
}

fn rotor_antiProjectViaHorizonOnto_translator(self_: Rotor, other: Translator) -> AntiScalar {
    return translator_wedge_lineAtOrigin(other, rotor_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_flector(self_: Transflector, other: Flector) -> MultiVector {
    return flector_wedge_multiVector(other, transflector_antiWedge_flector(self_, flector_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVector {
    return flectorAtInfinity_wedge_multiVector(other, transflector_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_horizon(self_: Transflector, other: Horizon) -> Horizon {
    return horizon_wedge_scalar(other, transflector_antiWedge_origin(self_, horizon_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_line(self_: Transflector, other: Line) -> Plane {
    return line_wedge_point(other, transflector_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> Plane {
    return lineAtInfinity_wedge_point(other, transflector_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_motor(self_: Transflector, other: Motor) -> Plane {
    return motor_wedge_point(other, transflector_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, transflector_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, transflector_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_plane(self_: Transflector, other: Plane) -> Plane {
    return plane_wedge_scalar(other, transflector_antiWedge_origin(self_, plane_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_point(self_: Transflector, other: Point) -> MultiVector {
    return point_wedge_multiVector(other, transflector_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> MultiVector {
    return pointAtInfinity_wedge_multiVector(other, transflector_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return transflector_wedge_multiVector(other, transflector_antiWedge_flector(self_, transflector_dual(other)));
}

fn transflector_antiProjectViaHorizonOnto_translator(self_: Transflector, other: Translator) -> Plane {
    return translator_wedge_point(other, transflector_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_flector(self_: Translator, other: Flector) -> Motor {
    return flector_wedge_flector(other, translator_antiWedge_flector(self_, flector_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(other, translator_antiWedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_horizon(self_: Translator, other: Horizon) -> AntiScalar {
    return horizon_wedge_origin(other, translator_antiWedge_origin(self_, horizon_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_line(self_: Translator, other: Line) -> MultiVector {
    return line_wedge_multiVector(other, translator_antiWedge_lineAtOrigin(self_, line_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return lineAtInfinity_wedge_multiVector(other, translator_antiWedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_motor(self_: Translator, other: Motor) -> MultiVector {
    return motor_wedge_multiVector(other, translator_antiWedge_lineAtOrigin(self_, motor_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVector(other, translator_antiWedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_multiVector(other, translator_antiWedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_plane(self_: Translator, other: Plane) -> AntiScalar {
    return plane_wedge_origin(other, translator_antiWedge_origin(self_, plane_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_point(self_: Translator, other: Point) -> Motor {
    return point_wedge_transflector(other, translator_antiWedge_planeAtOrigin(self_, point_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> Translator {
    return pointAtInfinity_wedge_transflector(other, translator_antiWedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_transflector(self_: Translator, other: Transflector) -> Motor {
    return transflector_wedge_flector(other, translator_antiWedge_flector(self_, transflector_dual(other)));
}

fn translator_antiProjectViaHorizonOnto_translator(self_: Translator, other: Translator) -> MultiVector {
    return translator_wedge_multiVector(other, translator_antiWedge_lineAtOrigin(self_, translator_dual(other)));
}

fn flector_projectOrthogonallyOnto_flector(self_: Flector, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, flector_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_line(self_: Flector, other: Line) -> Point {
    return line_antiWedge_plane(other, flector_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Point {
    return lineAtOrigin_antiWedge_plane(other, flector_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_motor(self_: Flector, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, flector_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, flector_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, flector_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_origin(self_: Flector, other: Origin) -> Origin {
    return origin_antiWedge_antiScalar(other, flector_wedge_horizon(self_, origin_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_plane(self_: Flector, other: Plane) -> Flector {
    return plane_antiWedge_motor(other, flector_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return planeAtOrigin_antiWedge_motor(other, flector_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_point(self_: Flector, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, flector_wedge_horizon(self_, point_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_rotor(self_: Flector, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, flector_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn flector_projectOrthogonallyOnto_transflector(self_: Flector, other: Transflector) -> Flector {
    return transflector_antiWedge_motor(other, flector_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_flector(self_: FlectorAtInfinity, other: Flector) -> PointAtInfinity {
    return flector_antiWedge_lineAtInfinity(other, flectorAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_line(self_: FlectorAtInfinity, other: Line) -> PointAtInfinity {
    return line_antiWedge_horizon(other, flectorAtInfinity_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(other, flectorAtInfinity_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_motor(self_: FlectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(other, flectorAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(other, flectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(other, flectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_plane(self_: FlectorAtInfinity, other: Plane) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(other, flectorAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(other, flectorAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_rotor(self_: FlectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(other, flectorAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn flectorAtInfinity_projectOrthogonallyOnto_transflector(self_: FlectorAtInfinity, other: Transflector) -> PointAtInfinity {
    return transflector_antiWedge_lineAtInfinity(other, flectorAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn horizon_projectOrthogonallyOnto_motor(self_: Horizon, other: Motor) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(other, horizon_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn horizon_projectOrthogonallyOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_horizon(other, horizon_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn horizon_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(other, horizon_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn horizon_projectOrthogonallyOnto_rotor(self_: Horizon, other: Rotor) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(other, horizon_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn line_projectOrthogonallyOnto_flector(self_: Line, other: Flector) -> MultiVector {
    return flector_antiWedge_plane(other, line_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn line_projectOrthogonallyOnto_line(self_: Line, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, line_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn line_projectOrthogonallyOnto_lineAtOrigin(self_: Line, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_antiWedge_antiScalar(other, line_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn line_projectOrthogonallyOnto_motor(self_: Line, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, line_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn line_projectOrthogonallyOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, line_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn line_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, line_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn line_projectOrthogonallyOnto_plane(self_: Line, other: Plane) -> Line {
    return plane_antiWedge_plane(other, line_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn line_projectOrthogonallyOnto_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Line {
    return planeAtOrigin_antiWedge_plane(other, line_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn line_projectOrthogonallyOnto_rotor(self_: Line, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, line_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn line_projectOrthogonallyOnto_transflector(self_: Line, other: Transflector) -> MultiVector {
    return transflector_antiWedge_plane(other, line_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_flector(self_: LineAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return flector_antiWedge_horizon(other, lineAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(other, lineAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(other, lineAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(other, lineAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_plane(self_: LineAtInfinity, other: Plane) -> LineAtInfinity {
    return plane_antiWedge_horizon(other, lineAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(other, lineAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(other, lineAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn lineAtInfinity_projectOrthogonallyOnto_transflector(self_: LineAtInfinity, other: Transflector) -> LineAtInfinity {
    return transflector_antiWedge_horizon(other, lineAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_flector(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_line(self_: LineAtOrigin, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, lineAtOrigin_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_antiWedge_antiScalar(other, lineAtOrigin_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, lineAtOrigin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, lineAtOrigin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(other, lineAtOrigin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_plane(self_: LineAtOrigin, other: Plane) -> Line {
    return plane_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_rotor(self_: LineAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(other, lineAtOrigin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn lineAtOrigin_projectOrthogonallyOnto_transflector(self_: LineAtOrigin, other: Transflector) -> MultiVector {
    return transflector_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_flector(self_: Motor, other: Flector) -> MultiVector {
    return flector_antiWedge_plane(other, motor_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_line(self_: Motor, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, motor_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_antiWedge_antiScalar(other, motor_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_motor(self_: Motor, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, motor_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, motor_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, motor_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_plane(self_: Motor, other: Plane) -> Line {
    return plane_antiWedge_plane(other, motor_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Line {
    return planeAtOrigin_antiWedge_plane(other, motor_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, motor_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn motor_projectOrthogonallyOnto_transflector(self_: Motor, other: Transflector) -> MultiVector {
    return transflector_antiWedge_plane(other, motor_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_antiWedge_multiVector(other, multiVector_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    return line_antiWedge_multiVector(other, multiVector_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return lineAtOrigin_antiWedge_multiVector(other, multiVector_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, multiVector_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, multiVector_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, multiVector_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return origin_antiWedge_multiVector(other, multiVector_wedge_horizon(self_, origin_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_antiWedge_multiVector(other, multiVector_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return planeAtOrigin_antiWedge_multiVector(other, multiVector_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    return point_antiWedge_multiVector(other, multiVector_wedge_horizon(self_, point_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, multiVector_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn multiVector_projectOrthogonallyOnto_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return transflector_antiWedge_multiVector(other, multiVector_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return flector_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return line_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return lineAtOrigin_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_origin(self_: MultiVectorAtInfinity, other: Origin) -> Scalar {
    return origin_antiWedge_horizon(other, multiVectorAtInfinity_wedge_horizon(self_, origin_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_point(self_: MultiVectorAtInfinity, other: Point) -> Scalar {
    return point_antiWedge_horizon(other, multiVectorAtInfinity_wedge_horizon(self_, point_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn multiVectorAtInfinity_projectOrthogonallyOnto_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return transflector_antiWedge_multiVectorAtInfinity(other, multiVectorAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return flector_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return line_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return lineAtOrigin_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_origin(self_: MultiVectorAtOrigin, other: Origin) -> Origin {
    return origin_antiWedge_antiScalar(other, multiVectorAtOrigin_wedge_horizon(self_, origin_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return plane_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return planeAtOrigin_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_point(self_: MultiVectorAtOrigin, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, multiVectorAtOrigin_wedge_horizon(self_, point_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn multiVectorAtOrigin_projectOrthogonallyOnto_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return transflector_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_flector(self_: Origin, other: Flector) -> Flector {
    return flector_antiWedge_rotor(other, origin_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_line(self_: Origin, other: Line) -> Point {
    return line_antiWedge_planeAtOrigin(other, origin_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_lineAtOrigin(self_: Origin, other: LineAtOrigin) -> Origin {
    return lineAtOrigin_antiWedge_planeAtOrigin(other, origin_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_motor(self_: Origin, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, origin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, origin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(other, origin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_origin(self_: Origin, other: Origin) -> Origin {
    return origin_antiWedge_antiScalar(other, origin_wedge_horizon(self_, origin_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_plane(self_: Origin, other: Plane) -> Point {
    return plane_antiWedge_lineAtOrigin(other, origin_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_planeAtOrigin(self_: Origin, other: PlaneAtOrigin) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(other, origin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_point(self_: Origin, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, origin_wedge_horizon(self_, point_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_rotor(self_: Origin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(other, origin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn origin_projectOrthogonallyOnto_transflector(self_: Origin, other: Transflector) -> Point {
    return transflector_antiWedge_lineAtOrigin(other, origin_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_flector(self_: Plane, other: Flector) -> Flector {
    return flector_antiWedge_antiScalar(other, plane_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_motor(self_: Plane, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, plane_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, plane_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, plane_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_plane(self_: Plane, other: Plane) -> Plane {
    return plane_antiWedge_antiScalar(other, plane_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_antiWedge_antiScalar(other, plane_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_rotor(self_: Plane, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, plane_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn plane_projectOrthogonallyOnto_transflector(self_: Plane, other: Transflector) -> Transflector {
    return transflector_antiWedge_antiScalar(other, plane_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_flector(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return flector_antiWedge_antiScalar(other, planeAtOrigin_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, planeAtOrigin_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, planeAtOrigin_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(other, planeAtOrigin_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_plane(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return plane_antiWedge_antiScalar(other, planeAtOrigin_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return planeAtOrigin_antiWedge_antiScalar(other, planeAtOrigin_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(other, planeAtOrigin_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn planeAtOrigin_projectOrthogonallyOnto_transflector(self_: PlaneAtOrigin, other: Transflector) -> Transflector {
    return transflector_antiWedge_antiScalar(other, planeAtOrigin_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn point_projectOrthogonallyOnto_flector(self_: Point, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, point_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn point_projectOrthogonallyOnto_line(self_: Point, other: Line) -> Point {
    return line_antiWedge_plane(other, point_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn point_projectOrthogonallyOnto_lineAtOrigin(self_: Point, other: LineAtOrigin) -> Point {
    return lineAtOrigin_antiWedge_plane(other, point_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn point_projectOrthogonallyOnto_motor(self_: Point, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, point_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn point_projectOrthogonallyOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, point_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn point_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, point_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn point_projectOrthogonallyOnto_origin(self_: Point, other: Origin) -> Origin {
    return origin_antiWedge_antiScalar(other, point_wedge_horizon(self_, origin_antiDual(other)));
}

fn point_projectOrthogonallyOnto_plane(self_: Point, other: Plane) -> Point {
    return plane_antiWedge_line(other, point_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn point_projectOrthogonallyOnto_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> Point {
    return planeAtOrigin_antiWedge_line(other, point_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn point_projectOrthogonallyOnto_point(self_: Point, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, point_wedge_horizon(self_, point_antiDual(other)));
}

fn point_projectOrthogonallyOnto_rotor(self_: Point, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, point_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn point_projectOrthogonallyOnto_transflector(self_: Point, other: Transflector) -> Point {
    return transflector_antiWedge_line(other, point_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_flector(self_: PointAtInfinity, other: Flector) -> PointAtInfinity {
    return flector_antiWedge_lineAtInfinity(other, pointAtInfinity_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_line(self_: PointAtInfinity, other: Line) -> PointAtInfinity {
    return line_antiWedge_horizon(other, pointAtInfinity_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(other, pointAtInfinity_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_motor(self_: PointAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return motor_antiWedge_multiVectorAtInfinity(other, pointAtInfinity_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(other, pointAtInfinity_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(other, pointAtInfinity_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_plane(self_: PointAtInfinity, other: Plane) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(other, pointAtInfinity_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(other, pointAtInfinity_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_rotor(self_: PointAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return rotor_antiWedge_multiVectorAtInfinity(other, pointAtInfinity_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn pointAtInfinity_projectOrthogonallyOnto_transflector(self_: PointAtInfinity, other: Transflector) -> PointAtInfinity {
    return transflector_antiWedge_lineAtInfinity(other, pointAtInfinity_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_flector(self_: Rotor, other: Flector) -> MultiVector {
    return flector_antiWedge_planeAtOrigin(other, rotor_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_line(self_: Rotor, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, rotor_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return lineAtOrigin_antiWedge_antiScalar(other, rotor_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_motor(self_: Rotor, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, rotor_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, rotor_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(other, rotor_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_plane(self_: Rotor, other: Plane) -> Line {
    return plane_antiWedge_planeAtOrigin(other, rotor_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(other, rotor_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_rotor(self_: Rotor, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(other, rotor_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn rotor_projectOrthogonallyOnto_transflector(self_: Rotor, other: Transflector) -> MultiVector {
    return transflector_antiWedge_planeAtOrigin(other, rotor_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_flector(self_: Transflector, other: Flector) -> Flector {
    return flector_antiWedge_translator(other, transflector_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_line(self_: Transflector, other: Line) -> PointAtInfinity {
    return line_antiWedge_horizon(other, transflector_wedge_lineAtInfinity(self_, line_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(other, transflector_wedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_motor(self_: Transflector, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, transflector_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, transflector_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, transflector_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_plane(self_: Transflector, other: Plane) -> Transflector {
    return plane_antiWedge_translator(other, transflector_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> Transflector {
    return planeAtOrigin_antiWedge_translator(other, transflector_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_rotor(self_: Transflector, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, transflector_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn transflector_projectOrthogonallyOnto_transflector(self_: Transflector, other: Transflector) -> Transflector {
    return transflector_antiWedge_translator(other, transflector_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_flector(self_: Translator, other: Flector) -> MultiVectorAtInfinity {
    return flector_antiWedge_horizon(other, translator_wedge_flectorAtInfinity(self_, flector_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_motor(self_: Translator, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVector(other, translator_wedge_multiVectorAtInfinity(self_, motor_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVector(other, translator_wedge_multiVectorAtInfinity(self_, multiVector_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_multiVector(other, translator_wedge_multiVectorAtInfinity(self_, multiVectorAtOrigin_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_plane(self_: Translator, other: Plane) -> LineAtInfinity {
    return plane_antiWedge_horizon(other, translator_wedge_pointAtInfinity(self_, plane_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(other, translator_wedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return rotor_antiWedge_multiVector(other, translator_wedge_multiVectorAtInfinity(self_, rotor_antiDual(other)));
}

fn translator_projectOrthogonallyOnto_transflector(self_: Translator, other: Transflector) -> LineAtInfinity {
    return transflector_antiWedge_horizon(other, translator_wedge_pointAtInfinity(self_, transflector_antiDual(other)));
}

fn flector_projectViaOriginOnto_flector(self_: Flector, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, flector_wedge_flector(self_, flector_dual(other)));
}

fn flector_projectViaOriginOnto_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_motor(other, flector_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn flector_projectViaOriginOnto_horizon(self_: Flector, other: Horizon) -> FlectorAtInfinity {
    return horizon_antiWedge_rotor(other, flector_wedge_origin(self_, horizon_dual(other)));
}

fn flector_projectViaOriginOnto_line(self_: Flector, other: Line) -> Point {
    return line_antiWedge_planeAtOrigin(other, flector_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn flector_projectViaOriginOnto_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(other, flector_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn flector_projectViaOriginOnto_motor(self_: Flector, other: Motor) -> Flector {
    return motor_antiWedge_planeAtOrigin(other, flector_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn flector_projectViaOriginOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, flector_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn flector_projectViaOriginOnto_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, flector_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn flector_projectViaOriginOnto_plane(self_: Flector, other: Plane) -> Flector {
    return plane_antiWedge_rotor(other, flector_wedge_origin(self_, plane_dual(other)));
}

fn flector_projectViaOriginOnto_point(self_: Flector, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, flector_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn flector_projectViaOriginOnto_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_antiWedge_antiScalar(other, flector_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn flector_projectViaOriginOnto_transflector(self_: Flector, other: Transflector) -> Flector {
    return transflector_antiWedge_motor(other, flector_wedge_flector(self_, transflector_dual(other)));
}

fn flector_projectViaOriginOnto_translator(self_: Flector, other: Translator) -> Transflector {
    return translator_antiWedge_planeAtOrigin(other, flector_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_flector(self_: FlectorAtInfinity, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, flectorAtInfinity_wedge_flector(self_, flector_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_motor(other, flectorAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_horizon(self_: FlectorAtInfinity, other: Horizon) -> FlectorAtInfinity {
    return horizon_antiWedge_rotor(other, flectorAtInfinity_wedge_origin(self_, horizon_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_line(self_: FlectorAtInfinity, other: Line) -> Point {
    return line_antiWedge_planeAtOrigin(other, flectorAtInfinity_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(other, flectorAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_motor(self_: FlectorAtInfinity, other: Motor) -> Flector {
    return motor_antiWedge_planeAtOrigin(other, flectorAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, flectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, flectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_plane(self_: FlectorAtInfinity, other: Plane) -> Flector {
    return plane_antiWedge_rotor(other, flectorAtInfinity_wedge_origin(self_, plane_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_point(self_: FlectorAtInfinity, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, flectorAtInfinity_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_antiWedge_antiScalar(other, flectorAtInfinity_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_transflector(self_: FlectorAtInfinity, other: Transflector) -> Flector {
    return transflector_antiWedge_motor(other, flectorAtInfinity_wedge_flector(self_, transflector_dual(other)));
}

fn flectorAtInfinity_projectViaOriginOnto_translator(self_: FlectorAtInfinity, other: Translator) -> Transflector {
    return translator_antiWedge_planeAtOrigin(other, flectorAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn horizon_projectViaOriginOnto_flector(self_: Horizon, other: Flector) -> Flector {
    return flector_antiWedge_antiScalar(other, horizon_wedge_flector(self_, flector_dual(other)));
}

fn horizon_projectViaOriginOnto_flectorAtInfinity(self_: Horizon, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_antiScalar(other, horizon_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn horizon_projectViaOriginOnto_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return horizon_antiWedge_antiScalar(other, horizon_wedge_origin(self_, horizon_dual(other)));
}

fn horizon_projectViaOriginOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_antiScalar(other, horizon_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn horizon_projectViaOriginOnto_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_antiScalar(other, horizon_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn horizon_projectViaOriginOnto_plane(self_: Horizon, other: Plane) -> Plane {
    return plane_antiWedge_antiScalar(other, horizon_wedge_origin(self_, plane_dual(other)));
}

fn horizon_projectViaOriginOnto_transflector(self_: Horizon, other: Transflector) -> Transflector {
    return transflector_antiWedge_antiScalar(other, horizon_wedge_flector(self_, transflector_dual(other)));
}

fn line_projectViaOriginOnto_flector(self_: Line, other: Flector) -> MultiVector {
    return flector_antiWedge_plane(other, line_wedge_flector(self_, flector_dual(other)));
}

fn line_projectViaOriginOnto_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_plane(other, line_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn line_projectViaOriginOnto_horizon(self_: Line, other: Horizon) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(other, line_wedge_origin(self_, horizon_dual(other)));
}

fn line_projectViaOriginOnto_line(self_: Line, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, line_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn line_projectViaOriginOnto_lineAtInfinity(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_antiWedge_antiScalar(other, line_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn line_projectViaOriginOnto_motor(self_: Line, other: Motor) -> Motor {
    return motor_antiWedge_antiScalar(other, line_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn line_projectViaOriginOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, line_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn line_projectViaOriginOnto_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, line_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn line_projectViaOriginOnto_plane(self_: Line, other: Plane) -> Line {
    return plane_antiWedge_planeAtOrigin(other, line_wedge_origin(self_, plane_dual(other)));
}

fn line_projectViaOriginOnto_transflector(self_: Line, other: Transflector) -> MultiVector {
    return transflector_antiWedge_plane(other, line_wedge_flector(self_, transflector_dual(other)));
}

fn line_projectViaOriginOnto_translator(self_: Line, other: Translator) -> Translator {
    return translator_antiWedge_antiScalar(other, line_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_flector(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return flector_antiWedge_plane(other, lineAtInfinity_wedge_flector(self_, flector_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_plane(other, lineAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_horizon(self_: LineAtInfinity, other: Horizon) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(other, lineAtInfinity_wedge_origin(self_, horizon_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_line(self_: LineAtInfinity, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, lineAtInfinity_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_lineAtInfinity(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_antiWedge_antiScalar(other, lineAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_motor(self_: LineAtInfinity, other: Motor) -> Motor {
    return motor_antiWedge_antiScalar(other, lineAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, lineAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, lineAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_plane(self_: LineAtInfinity, other: Plane) -> Line {
    return plane_antiWedge_planeAtOrigin(other, lineAtInfinity_wedge_origin(self_, plane_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_transflector(self_: LineAtInfinity, other: Transflector) -> MultiVector {
    return transflector_antiWedge_plane(other, lineAtInfinity_wedge_flector(self_, transflector_dual(other)));
}

fn lineAtInfinity_projectViaOriginOnto_translator(self_: LineAtInfinity, other: Translator) -> Translator {
    return translator_antiWedge_antiScalar(other, lineAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn lineAtOrigin_projectViaOriginOnto_flector(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_flector(self_, flector_dual(other)));
}

fn lineAtOrigin_projectViaOriginOnto_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn lineAtOrigin_projectViaOriginOnto_transflector(self_: LineAtOrigin, other: Transflector) -> MultiVector {
    return transflector_antiWedge_planeAtOrigin(other, lineAtOrigin_wedge_flector(self_, transflector_dual(other)));
}

fn motor_projectViaOriginOnto_flector(self_: Motor, other: Flector) -> MultiVector {
    return flector_antiWedge_plane(other, motor_wedge_flector(self_, flector_dual(other)));
}

fn motor_projectViaOriginOnto_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_plane(other, motor_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn motor_projectViaOriginOnto_horizon(self_: Motor, other: Horizon) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(other, motor_wedge_origin(self_, horizon_dual(other)));
}

fn motor_projectViaOriginOnto_line(self_: Motor, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, motor_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn motor_projectViaOriginOnto_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_antiWedge_antiScalar(other, motor_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn motor_projectViaOriginOnto_motor(self_: Motor, other: Motor) -> Motor {
    return motor_antiWedge_antiScalar(other, motor_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn motor_projectViaOriginOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, motor_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn motor_projectViaOriginOnto_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, motor_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn motor_projectViaOriginOnto_plane(self_: Motor, other: Plane) -> Line {
    return plane_antiWedge_planeAtOrigin(other, motor_wedge_origin(self_, plane_dual(other)));
}

fn motor_projectViaOriginOnto_transflector(self_: Motor, other: Transflector) -> MultiVector {
    return transflector_antiWedge_plane(other, motor_wedge_flector(self_, transflector_dual(other)));
}

fn motor_projectViaOriginOnto_translator(self_: Motor, other: Translator) -> Translator {
    return translator_antiWedge_antiScalar(other, motor_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn multiVector_projectViaOriginOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_antiWedge_multiVector(other, multiVector_wedge_flector(self_, flector_dual(other)));
}

fn multiVector_projectViaOriginOnto_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_multiVector(other, multiVector_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn multiVector_projectViaOriginOnto_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtInfinity {
    return horizon_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_origin(self_, horizon_dual(other)));
}

fn multiVector_projectViaOriginOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    return line_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn multiVector_projectViaOriginOnto_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return lineAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn multiVector_projectViaOriginOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn multiVector_projectViaOriginOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn multiVector_projectViaOriginOnto_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn multiVector_projectViaOriginOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_origin(self_, plane_dual(other)));
}

fn multiVector_projectViaOriginOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    return point_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn multiVector_projectViaOriginOnto_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn multiVector_projectViaOriginOnto_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return transflector_antiWedge_multiVector(other, multiVector_wedge_flector(self_, transflector_dual(other)));
}

fn multiVector_projectViaOriginOnto_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_antiWedge_multiVectorAtOrigin(other, multiVector_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return flector_antiWedge_multiVector(other, multiVectorAtInfinity_wedge_flector(self_, flector_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_multiVector(other, multiVectorAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> MultiVectorAtInfinity {
    return horizon_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_origin(self_, horizon_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return line_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return lineAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return plane_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_origin(self_, plane_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return point_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return pointAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return transflector_antiWedge_multiVector(other, multiVectorAtInfinity_wedge_flector(self_, transflector_dual(other)));
}

fn multiVectorAtInfinity_projectViaOriginOnto_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return translator_antiWedge_multiVectorAtOrigin(other, multiVectorAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn multiVectorAtOrigin_projectViaOriginOnto_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return flector_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_flector(self_, flector_dual(other)));
}

fn multiVectorAtOrigin_projectViaOriginOnto_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn multiVectorAtOrigin_projectViaOriginOnto_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return transflector_antiWedge_multiVectorAtOrigin(other, multiVectorAtOrigin_wedge_flector(self_, transflector_dual(other)));
}

fn origin_projectViaOriginOnto_flector(self_: Origin, other: Flector) -> Flector {
    return flector_antiWedge_rotor(other, origin_wedge_flector(self_, flector_dual(other)));
}

fn origin_projectViaOriginOnto_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_rotor(other, origin_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn origin_projectViaOriginOnto_transflector(self_: Origin, other: Transflector) -> Flector {
    return transflector_antiWedge_rotor(other, origin_wedge_flector(self_, transflector_dual(other)));
}

fn plane_projectViaOriginOnto_flector(self_: Plane, other: Flector) -> Flector {
    return flector_antiWedge_antiScalar(other, plane_wedge_flector(self_, flector_dual(other)));
}

fn plane_projectViaOriginOnto_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_antiScalar(other, plane_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn plane_projectViaOriginOnto_horizon(self_: Plane, other: Horizon) -> Horizon {
    return horizon_antiWedge_antiScalar(other, plane_wedge_origin(self_, horizon_dual(other)));
}

fn plane_projectViaOriginOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_antiScalar(other, plane_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn plane_projectViaOriginOnto_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_antiScalar(other, plane_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn plane_projectViaOriginOnto_plane(self_: Plane, other: Plane) -> Plane {
    return plane_antiWedge_antiScalar(other, plane_wedge_origin(self_, plane_dual(other)));
}

fn plane_projectViaOriginOnto_transflector(self_: Plane, other: Transflector) -> Transflector {
    return transflector_antiWedge_antiScalar(other, plane_wedge_flector(self_, transflector_dual(other)));
}

fn planeAtOrigin_projectViaOriginOnto_flector(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return flector_antiWedge_antiScalar(other, planeAtOrigin_wedge_flector(self_, flector_dual(other)));
}

fn planeAtOrigin_projectViaOriginOnto_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_antiScalar(other, planeAtOrigin_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn planeAtOrigin_projectViaOriginOnto_transflector(self_: PlaneAtOrigin, other: Transflector) -> Transflector {
    return transflector_antiWedge_antiScalar(other, planeAtOrigin_wedge_flector(self_, transflector_dual(other)));
}

fn point_projectViaOriginOnto_flector(self_: Point, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, point_wedge_flector(self_, flector_dual(other)));
}

fn point_projectViaOriginOnto_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_motor(other, point_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn point_projectViaOriginOnto_horizon(self_: Point, other: Horizon) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(other, point_wedge_origin(self_, horizon_dual(other)));
}

fn point_projectViaOriginOnto_line(self_: Point, other: Line) -> Point {
    return line_antiWedge_planeAtOrigin(other, point_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn point_projectViaOriginOnto_lineAtInfinity(self_: Point, other: LineAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(other, point_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn point_projectViaOriginOnto_motor(self_: Point, other: Motor) -> Flector {
    return motor_antiWedge_planeAtOrigin(other, point_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn point_projectViaOriginOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, point_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn point_projectViaOriginOnto_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, point_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn point_projectViaOriginOnto_plane(self_: Point, other: Plane) -> Point {
    return plane_antiWedge_lineAtOrigin(other, point_wedge_origin(self_, plane_dual(other)));
}

fn point_projectViaOriginOnto_point(self_: Point, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, point_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn point_projectViaOriginOnto_pointAtInfinity(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_antiWedge_antiScalar(other, point_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn point_projectViaOriginOnto_transflector(self_: Point, other: Transflector) -> Flector {
    return transflector_antiWedge_motor(other, point_wedge_flector(self_, transflector_dual(other)));
}

fn point_projectViaOriginOnto_translator(self_: Point, other: Translator) -> Transflector {
    return translator_antiWedge_planeAtOrigin(other, point_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_flector(self_: PointAtInfinity, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, pointAtInfinity_wedge_flector(self_, flector_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_motor(other, pointAtInfinity_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_horizon(self_: PointAtInfinity, other: Horizon) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(other, pointAtInfinity_wedge_origin(self_, horizon_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_line(self_: PointAtInfinity, other: Line) -> Point {
    return line_antiWedge_planeAtOrigin(other, pointAtInfinity_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(other, pointAtInfinity_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_motor(self_: PointAtInfinity, other: Motor) -> Flector {
    return motor_antiWedge_planeAtOrigin(other, pointAtInfinity_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, pointAtInfinity_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, pointAtInfinity_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_plane(self_: PointAtInfinity, other: Plane) -> Point {
    return plane_antiWedge_lineAtOrigin(other, pointAtInfinity_wedge_origin(self_, plane_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_point(self_: PointAtInfinity, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, pointAtInfinity_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_antiWedge_antiScalar(other, pointAtInfinity_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_transflector(self_: PointAtInfinity, other: Transflector) -> Flector {
    return transflector_antiWedge_motor(other, pointAtInfinity_wedge_flector(self_, transflector_dual(other)));
}

fn pointAtInfinity_projectViaOriginOnto_translator(self_: PointAtInfinity, other: Translator) -> Transflector {
    return translator_antiWedge_planeAtOrigin(other, pointAtInfinity_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn rotor_projectViaOriginOnto_flector(self_: Rotor, other: Flector) -> MultiVector {
    return flector_antiWedge_planeAtOrigin(other, rotor_wedge_flector(self_, flector_dual(other)));
}

fn rotor_projectViaOriginOnto_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_planeAtOrigin(other, rotor_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn rotor_projectViaOriginOnto_transflector(self_: Rotor, other: Transflector) -> MultiVector {
    return transflector_antiWedge_planeAtOrigin(other, rotor_wedge_flector(self_, transflector_dual(other)));
}

fn transflector_projectViaOriginOnto_flector(self_: Transflector, other: Flector) -> Flector {
    return flector_antiWedge_motor(other, transflector_wedge_flector(self_, flector_dual(other)));
}

fn transflector_projectViaOriginOnto_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> FlectorAtInfinity {
    return flectorAtInfinity_antiWedge_motor(other, transflector_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn transflector_projectViaOriginOnto_horizon(self_: Transflector, other: Horizon) -> FlectorAtInfinity {
    return horizon_antiWedge_rotor(other, transflector_wedge_origin(self_, horizon_dual(other)));
}

fn transflector_projectViaOriginOnto_line(self_: Transflector, other: Line) -> Point {
    return line_antiWedge_planeAtOrigin(other, transflector_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn transflector_projectViaOriginOnto_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(other, transflector_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn transflector_projectViaOriginOnto_motor(self_: Transflector, other: Motor) -> Flector {
    return motor_antiWedge_planeAtOrigin(other, transflector_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn transflector_projectViaOriginOnto_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, transflector_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn transflector_projectViaOriginOnto_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, transflector_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn transflector_projectViaOriginOnto_plane(self_: Transflector, other: Plane) -> Flector {
    return plane_antiWedge_rotor(other, transflector_wedge_origin(self_, plane_dual(other)));
}

fn transflector_projectViaOriginOnto_point(self_: Transflector, other: Point) -> Point {
    return point_antiWedge_antiScalar(other, transflector_wedge_planeAtOrigin(self_, point_dual(other)));
}

fn transflector_projectViaOriginOnto_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> PointAtInfinity {
    return pointAtInfinity_antiWedge_antiScalar(other, transflector_wedge_planeAtOrigin(self_, pointAtInfinity_dual(other)));
}

fn transflector_projectViaOriginOnto_transflector(self_: Transflector, other: Transflector) -> Flector {
    return transflector_antiWedge_motor(other, transflector_wedge_flector(self_, transflector_dual(other)));
}

fn transflector_projectViaOriginOnto_translator(self_: Transflector, other: Translator) -> Transflector {
    return translator_antiWedge_planeAtOrigin(other, transflector_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn translator_projectViaOriginOnto_flector(self_: Translator, other: Flector) -> MultiVector {
    return flector_antiWedge_plane(other, translator_wedge_flector(self_, flector_dual(other)));
}

fn translator_projectViaOriginOnto_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_antiWedge_plane(other, translator_wedge_flector(self_, flectorAtInfinity_dual(other)));
}

fn translator_projectViaOriginOnto_horizon(self_: Translator, other: Horizon) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(other, translator_wedge_origin(self_, horizon_dual(other)));
}

fn translator_projectViaOriginOnto_line(self_: Translator, other: Line) -> Line {
    return line_antiWedge_antiScalar(other, translator_wedge_lineAtOrigin(self_, line_dual(other)));
}

fn translator_projectViaOriginOnto_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return lineAtInfinity_antiWedge_antiScalar(other, translator_wedge_lineAtOrigin(self_, lineAtInfinity_dual(other)));
}

fn translator_projectViaOriginOnto_motor(self_: Translator, other: Motor) -> Motor {
    return motor_antiWedge_antiScalar(other, translator_wedge_lineAtOrigin(self_, motor_dual(other)));
}

fn translator_projectViaOriginOnto_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(other, translator_wedge_multiVectorAtOrigin(self_, multiVector_dual(other)));
}

fn translator_projectViaOriginOnto_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(other, translator_wedge_multiVectorAtOrigin(self_, multiVectorAtInfinity_dual(other)));
}

fn translator_projectViaOriginOnto_plane(self_: Translator, other: Plane) -> Line {
    return plane_antiWedge_planeAtOrigin(other, translator_wedge_origin(self_, plane_dual(other)));
}

fn translator_projectViaOriginOnto_transflector(self_: Translator, other: Transflector) -> MultiVector {
    return transflector_antiWedge_plane(other, translator_wedge_flector(self_, transflector_dual(other)));
}

fn translator_projectViaOriginOnto_translator(self_: Translator, other: Translator) -> Translator {
    return translator_antiWedge_antiScalar(other, translator_wedge_lineAtOrigin(self_, translator_dual(other)));
}

fn flector_antiRejectOrthogonallyFrom_flector(self_: Flector, other: Flector) -> FlectorAtInfinity {
    return motor_antiWedge_flectorAtInfinity(flector_wedge_flector(self_, other), flector_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_line(self_: Flector, other: Line) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(flector_wedge_line(self_, other), line_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(flector_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_motor(self_: Flector, other: Motor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(flector_wedge_motor(self_, other), motor_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(flector_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(flector_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_origin(self_: Flector, other: Origin) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(flector_wedge_origin(self_, other), origin_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_plane(self_: Flector, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(flector_wedge_plane(self_, other), plane_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(flector_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_point(self_: Flector, other: Point) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(flector_wedge_point(self_, other), point_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_rotor(self_: Flector, other: Rotor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(flector_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn flector_antiRejectOrthogonallyFrom_transflector(self_: Flector, other: Transflector) -> PointAtInfinity {
    return motor_antiWedge_pointAtInfinity(flector_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_flector(self_: FlectorAtInfinity, other: Flector) -> FlectorAtInfinity {
    return motor_antiWedge_flectorAtInfinity(flectorAtInfinity_wedge_flector(self_, other), flector_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_line(self_: FlectorAtInfinity, other: Line) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(flectorAtInfinity_wedge_line(self_, other), line_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(flectorAtInfinity_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_motor(self_: FlectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(flectorAtInfinity_wedge_motor(self_, other), motor_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(flectorAtInfinity_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(flectorAtInfinity_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_origin(self_: FlectorAtInfinity, other: Origin) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(flectorAtInfinity_wedge_origin(self_, other), origin_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_plane(self_: FlectorAtInfinity, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(flectorAtInfinity_wedge_plane(self_, other), plane_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(flectorAtInfinity_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_point(self_: FlectorAtInfinity, other: Point) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(flectorAtInfinity_wedge_point(self_, other), point_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_rotor(self_: FlectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(flectorAtInfinity_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn flectorAtInfinity_antiRejectOrthogonallyFrom_transflector(self_: FlectorAtInfinity, other: Transflector) -> PointAtInfinity {
    return translator_antiWedge_pointAtInfinity(flectorAtInfinity_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn horizon_antiRejectOrthogonallyFrom_flector(self_: Horizon, other: Flector) -> FlectorAtInfinity {
    return antiScalar_antiWedge_flectorAtInfinity(horizon_wedge_flector(self_, other), flector_antiDual(other));
}

fn horizon_antiRejectOrthogonallyFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(horizon_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn horizon_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(horizon_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn horizon_antiRejectOrthogonallyFrom_origin(self_: Horizon, other: Origin) -> Horizon {
    return antiScalar_antiWedge_horizon(horizon_wedge_origin(self_, other), origin_antiDual(other));
}

fn horizon_antiRejectOrthogonallyFrom_point(self_: Horizon, other: Point) -> Horizon {
    return antiScalar_antiWedge_horizon(horizon_wedge_point(self_, other), point_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_flector(self_: Line, other: Flector) -> MultiVectorAtInfinity {
    return plane_antiWedge_flectorAtInfinity(line_wedge_flector(self_, other), flector_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_line(self_: Line, other: Line) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(line_wedge_line(self_, other), line_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_lineAtOrigin(self_: Line, other: LineAtOrigin) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(line_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_motor(self_: Line, other: Motor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(line_wedge_motor(self_, other), motor_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_multiVector(self_: Line, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(line_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(line_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_origin(self_: Line, other: Origin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(line_wedge_origin(self_, other), origin_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_point(self_: Line, other: Point) -> LineAtInfinity {
    return plane_antiWedge_horizon(line_wedge_point(self_, other), point_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_rotor(self_: Line, other: Rotor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(line_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn line_antiRejectOrthogonallyFrom_transflector(self_: Line, other: Transflector) -> Scalar {
    return plane_antiWedge_pointAtInfinity(line_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_flector(self_: LineAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return plane_antiWedge_flectorAtInfinity(lineAtInfinity_wedge_flector(self_, other), flector_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_line(self_: LineAtInfinity, other: Line) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(lineAtInfinity_wedge_line(self_, other), line_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(lineAtInfinity_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(lineAtInfinity_wedge_motor(self_, other), motor_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(lineAtInfinity_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(lineAtInfinity_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_origin(self_: LineAtInfinity, other: Origin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(lineAtInfinity_wedge_origin(self_, other), origin_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_point(self_: LineAtInfinity, other: Point) -> LineAtInfinity {
    return plane_antiWedge_horizon(lineAtInfinity_wedge_point(self_, other), point_antiDual(other));
}

fn lineAtInfinity_antiRejectOrthogonallyFrom_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(lineAtInfinity_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn lineAtOrigin_antiRejectOrthogonallyFrom_flector(self_: LineAtOrigin, other: Flector) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_flectorAtInfinity(lineAtOrigin_wedge_flector(self_, other), flector_antiDual(other));
}

fn lineAtOrigin_antiRejectOrthogonallyFrom_line(self_: LineAtOrigin, other: Line) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(lineAtOrigin_wedge_line(self_, other), line_antiDual(other));
}

fn lineAtOrigin_antiRejectOrthogonallyFrom_motor(self_: LineAtOrigin, other: Motor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(lineAtOrigin_wedge_motor(self_, other), motor_antiDual(other));
}

fn lineAtOrigin_antiRejectOrthogonallyFrom_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(lineAtOrigin_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn lineAtOrigin_antiRejectOrthogonallyFrom_point(self_: LineAtOrigin, other: Point) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(lineAtOrigin_wedge_point(self_, other), point_antiDual(other));
}

fn lineAtOrigin_antiRejectOrthogonallyFrom_transflector(self_: LineAtOrigin, other: Transflector) -> Scalar {
    return planeAtOrigin_antiWedge_pointAtInfinity(lineAtOrigin_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_flector(self_: Motor, other: Flector) -> MultiVectorAtInfinity {
    return plane_antiWedge_flectorAtInfinity(motor_wedge_flector(self_, other), flector_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_line(self_: Motor, other: Line) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(motor_wedge_line(self_, other), line_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(motor_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_motor(self_: Motor, other: Motor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(motor_wedge_motor(self_, other), motor_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(motor_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(motor_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_origin(self_: Motor, other: Origin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(motor_wedge_origin(self_, other), origin_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_point(self_: Motor, other: Point) -> LineAtInfinity {
    return plane_antiWedge_horizon(motor_wedge_point(self_, other), point_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_rotor(self_: Motor, other: Rotor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(motor_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn motor_antiRejectOrthogonallyFrom_transflector(self_: Motor, other: Transflector) -> Scalar {
    return plane_antiWedge_pointAtInfinity(motor_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_flector(self_: MultiVector, other: Flector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_flectorAtInfinity(multiVector_wedge_flector(self_, other), flector_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_line(self_: MultiVector, other: Line) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_lineAtInfinity(multiVector_wedge_line(self_, other), line_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_lineAtInfinity(multiVector_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_motor(self_: MultiVector, other: Motor) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(multiVector_wedge_motor(self_, other), motor_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(multiVector_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(multiVector_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_origin(self_: MultiVector, other: Origin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(multiVector_wedge_origin(self_, other), origin_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_plane(self_: MultiVector, other: Plane) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(multiVector_wedge_plane(self_, other), plane_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_pointAtInfinity(multiVector_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_point(self_: MultiVector, other: Point) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_horizon(multiVector_wedge_point(self_, other), point_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_rotor(self_: MultiVector, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(multiVector_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn multiVector_antiRejectOrthogonallyFrom_transflector(self_: MultiVector, other: Transflector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(multiVector_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_flectorAtInfinity(multiVectorAtInfinity_wedge_flector(self_, other), flector_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_lineAtInfinity(multiVectorAtInfinity_wedge_line(self_, other), line_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_lineAtInfinity(multiVectorAtInfinity_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(multiVectorAtInfinity_wedge_motor(self_, other), motor_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(multiVectorAtInfinity_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(multiVectorAtInfinity_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_origin(self_: MultiVectorAtInfinity, other: Origin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(multiVectorAtInfinity_wedge_origin(self_, other), origin_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(multiVectorAtInfinity_wedge_plane(self_, other), plane_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_pointAtInfinity(multiVectorAtInfinity_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_horizon(multiVectorAtInfinity_wedge_point(self_, other), point_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(multiVectorAtInfinity_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn multiVectorAtInfinity_antiRejectOrthogonallyFrom_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_pointAtInfinity(multiVectorAtInfinity_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_flectorAtInfinity(multiVectorAtOrigin_wedge_flector(self_, other), flector_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_lineAtInfinity(multiVectorAtOrigin_wedge_line(self_, other), line_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(multiVectorAtOrigin_wedge_motor(self_, other), motor_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(multiVectorAtOrigin_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_plane(self_: MultiVectorAtOrigin, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(multiVectorAtOrigin_wedge_plane(self_, other), plane_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_horizon(multiVectorAtOrigin_wedge_point(self_, other), point_antiDual(other));
}

fn multiVectorAtOrigin_antiRejectOrthogonallyFrom_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_pointAtInfinity(multiVectorAtOrigin_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_flector(self_: Origin, other: Flector) -> FlectorAtInfinity {
    return rotor_antiWedge_flectorAtInfinity(origin_wedge_flector(self_, other), flector_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_line(self_: Origin, other: Line) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(origin_wedge_line(self_, other), line_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_motor(self_: Origin, other: Motor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(origin_wedge_motor(self_, other), motor_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(origin_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_plane(self_: Origin, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(origin_wedge_plane(self_, other), plane_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_point(self_: Origin, other: Point) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(origin_wedge_point(self_, other), point_antiDual(other));
}

fn origin_antiRejectOrthogonallyFrom_transflector(self_: Origin, other: Transflector) -> PointAtInfinity {
    return rotor_antiWedge_pointAtInfinity(origin_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn plane_antiRejectOrthogonallyFrom_flector(self_: Plane, other: Flector) -> FlectorAtInfinity {
    return antiScalar_antiWedge_flectorAtInfinity(plane_wedge_flector(self_, other), flector_antiDual(other));
}

fn plane_antiRejectOrthogonallyFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(plane_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn plane_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(plane_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn plane_antiRejectOrthogonallyFrom_origin(self_: Plane, other: Origin) -> Horizon {
    return antiScalar_antiWedge_horizon(plane_wedge_origin(self_, other), origin_antiDual(other));
}

fn plane_antiRejectOrthogonallyFrom_point(self_: Plane, other: Point) -> Horizon {
    return antiScalar_antiWedge_horizon(plane_wedge_point(self_, other), point_antiDual(other));
}

fn plane_antiRejectOrthogonallyFrom_transflector(self_: Plane, other: Transflector) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(plane_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn planeAtOrigin_antiRejectOrthogonallyFrom_flector(self_: PlaneAtOrigin, other: Flector) -> FlectorAtInfinity {
    return antiScalar_antiWedge_flectorAtInfinity(planeAtOrigin_wedge_flector(self_, other), flector_antiDual(other));
}

fn planeAtOrigin_antiRejectOrthogonallyFrom_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(planeAtOrigin_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn planeAtOrigin_antiRejectOrthogonallyFrom_point(self_: PlaneAtOrigin, other: Point) -> Horizon {
    return antiScalar_antiWedge_horizon(planeAtOrigin_wedge_point(self_, other), point_antiDual(other));
}

fn planeAtOrigin_antiRejectOrthogonallyFrom_transflector(self_: PlaneAtOrigin, other: Transflector) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(planeAtOrigin_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_flector(self_: Point, other: Flector) -> FlectorAtInfinity {
    return motor_antiWedge_flectorAtInfinity(point_wedge_flector(self_, other), flector_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_line(self_: Point, other: Line) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(point_wedge_line(self_, other), line_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_lineAtOrigin(self_: Point, other: LineAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(point_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_motor(self_: Point, other: Motor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(point_wedge_motor(self_, other), motor_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_multiVector(self_: Point, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(point_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(point_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_origin(self_: Point, other: Origin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(point_wedge_origin(self_, other), origin_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_plane(self_: Point, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(point_wedge_plane(self_, other), plane_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(point_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_point(self_: Point, other: Point) -> PointAtInfinity {
    return line_antiWedge_horizon(point_wedge_point(self_, other), point_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_rotor(self_: Point, other: Rotor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(point_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn point_antiRejectOrthogonallyFrom_transflector(self_: Point, other: Transflector) -> PointAtInfinity {
    return motor_antiWedge_pointAtInfinity(point_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_flector(self_: PointAtInfinity, other: Flector) -> FlectorAtInfinity {
    return motor_antiWedge_flectorAtInfinity(pointAtInfinity_wedge_flector(self_, other), flector_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_line(self_: PointAtInfinity, other: Line) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(pointAtInfinity_wedge_line(self_, other), line_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_lineAtOrigin(self_: PointAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(pointAtInfinity_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_motor(self_: PointAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(pointAtInfinity_wedge_motor(self_, other), motor_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(pointAtInfinity_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(pointAtInfinity_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_origin(self_: PointAtInfinity, other: Origin) -> PointAtInfinity {
    return lineAtOrigin_antiWedge_horizon(pointAtInfinity_wedge_origin(self_, other), origin_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_plane(self_: PointAtInfinity, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(pointAtInfinity_wedge_plane(self_, other), plane_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(pointAtInfinity_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_point(self_: PointAtInfinity, other: Point) -> PointAtInfinity {
    return line_antiWedge_horizon(pointAtInfinity_wedge_point(self_, other), point_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_rotor(self_: PointAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(pointAtInfinity_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn pointAtInfinity_antiRejectOrthogonallyFrom_transflector(self_: PointAtInfinity, other: Transflector) -> PointAtInfinity {
    return translator_antiWedge_pointAtInfinity(pointAtInfinity_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn rotor_antiRejectOrthogonallyFrom_flector(self_: Rotor, other: Flector) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_flectorAtInfinity(rotor_wedge_flector(self_, other), flector_antiDual(other));
}

fn rotor_antiRejectOrthogonallyFrom_line(self_: Rotor, other: Line) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(rotor_wedge_line(self_, other), line_antiDual(other));
}

fn rotor_antiRejectOrthogonallyFrom_motor(self_: Rotor, other: Motor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(rotor_wedge_motor(self_, other), motor_antiDual(other));
}

fn rotor_antiRejectOrthogonallyFrom_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(rotor_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn rotor_antiRejectOrthogonallyFrom_point(self_: Rotor, other: Point) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(rotor_wedge_point(self_, other), point_antiDual(other));
}

fn rotor_antiRejectOrthogonallyFrom_transflector(self_: Rotor, other: Transflector) -> Scalar {
    return planeAtOrigin_antiWedge_pointAtInfinity(rotor_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_flector(self_: Transflector, other: Flector) -> FlectorAtInfinity {
    return motor_antiWedge_flectorAtInfinity(transflector_wedge_flector(self_, other), flector_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_line(self_: Transflector, other: Line) -> PointAtInfinity {
    return plane_antiWedge_lineAtInfinity(transflector_wedge_line(self_, other), line_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> PointAtInfinity {
    return planeAtOrigin_antiWedge_lineAtInfinity(transflector_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_motor(self_: Transflector, other: Motor) -> MultiVectorAtInfinity {
    return plane_antiWedge_multiVectorAtInfinity(transflector_wedge_motor(self_, other), motor_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_multiVector(self_: Transflector, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(transflector_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(transflector_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_origin(self_: Transflector, other: Origin) -> FlectorAtInfinity {
    return rotor_antiWedge_horizon(transflector_wedge_origin(self_, other), origin_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_plane(self_: Transflector, other: Plane) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(transflector_wedge_plane(self_, other), plane_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> PointAtInfinity {
    return antiScalar_antiWedge_pointAtInfinity(transflector_wedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_point(self_: Transflector, other: Point) -> FlectorAtInfinity {
    return motor_antiWedge_horizon(transflector_wedge_point(self_, other), point_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_rotor(self_: Transflector, other: Rotor) -> MultiVectorAtInfinity {
    return planeAtOrigin_antiWedge_multiVectorAtInfinity(transflector_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn transflector_antiRejectOrthogonallyFrom_transflector(self_: Transflector, other: Transflector) -> PointAtInfinity {
    return translator_antiWedge_pointAtInfinity(transflector_wedge_transflector(self_, other), transflector_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_flector(self_: Translator, other: Flector) -> MultiVectorAtInfinity {
    return plane_antiWedge_flectorAtInfinity(translator_wedge_flector(self_, other), flector_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_line(self_: Translator, other: Line) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(translator_wedge_line(self_, other), line_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> LineAtInfinity {
    return antiScalar_antiWedge_lineAtInfinity(translator_wedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_motor(self_: Translator, other: Motor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(translator_wedge_motor(self_, other), motor_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_multiVector(self_: Translator, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVector_antiWedge_multiVectorAtInfinity(translator_wedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(translator_wedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_origin(self_: Translator, other: Origin) -> LineAtInfinity {
    return planeAtOrigin_antiWedge_horizon(translator_wedge_origin(self_, other), origin_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_point(self_: Translator, other: Point) -> LineAtInfinity {
    return plane_antiWedge_horizon(translator_wedge_point(self_, other), point_antiDual(other));
}

fn translator_antiRejectOrthogonallyFrom_rotor(self_: Translator, other: Rotor) -> MultiVectorAtInfinity {
    return antiScalar_antiWedge_multiVectorAtInfinity(translator_wedge_rotor(self_, other), rotor_antiDual(other));
}

fn flector_antiRejectViaHorizonFrom_flector(self_: Flector, other: Flector) -> Flector {
    return motor_antiWedge_flector(flector_wedge_flector(self_, other), flector_dual(other));
}

fn flector_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> Flector {
    return motor_antiWedge_flector(flector_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn flector_antiRejectViaHorizonFrom_horizon(self_: Flector, other: Horizon) -> Origin {
    return antiScalar_antiWedge_origin(flector_wedge_horizon(self_, other), horizon_dual(other));
}

fn flector_antiRejectViaHorizonFrom_line(self_: Flector, other: Line) -> Point {
    return plane_antiWedge_lineAtOrigin(flector_wedge_line(self_, other), line_dual(other));
}

fn flector_antiRejectViaHorizonFrom_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> Point {
    return plane_antiWedge_lineAtOrigin(flector_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn flector_antiRejectViaHorizonFrom_motor(self_: Flector, other: Motor) -> Point {
    return plane_antiWedge_lineAtOrigin(flector_wedge_motor(self_, other), motor_dual(other));
}

fn flector_antiRejectViaHorizonFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(flector_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn flector_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(flector_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn flector_antiRejectViaHorizonFrom_plane(self_: Flector, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(flector_wedge_plane(self_, other), plane_dual(other));
}

fn flector_antiRejectViaHorizonFrom_point(self_: Flector, other: Point) -> Flector {
    return motor_antiWedge_planeAtOrigin(flector_wedge_point(self_, other), point_dual(other));
}

fn flector_antiRejectViaHorizonFrom_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> Flector {
    return motor_antiWedge_planeAtOrigin(flector_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn flector_antiRejectViaHorizonFrom_transflector(self_: Flector, other: Transflector) -> Flector {
    return motor_antiWedge_flector(flector_wedge_transflector(self_, other), transflector_dual(other));
}

fn flector_antiRejectViaHorizonFrom_translator(self_: Flector, other: Translator) -> Point {
    return plane_antiWedge_lineAtOrigin(flector_wedge_translator(self_, other), translator_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_flector(self_: FlectorAtInfinity, other: Flector) -> Flector {
    return motor_antiWedge_flector(flectorAtInfinity_wedge_flector(self_, other), flector_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_flectorAtInfinity(self_: FlectorAtInfinity, other: FlectorAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_flector(flectorAtInfinity_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_line(self_: FlectorAtInfinity, other: Line) -> Point {
    return plane_antiWedge_lineAtOrigin(flectorAtInfinity_wedge_line(self_, other), line_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_lineAtInfinity(self_: FlectorAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(flectorAtInfinity_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_motor(self_: FlectorAtInfinity, other: Motor) -> Point {
    return plane_antiWedge_lineAtOrigin(flectorAtInfinity_wedge_motor(self_, other), motor_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(flectorAtInfinity_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: FlectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(flectorAtInfinity_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_plane(self_: FlectorAtInfinity, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(flectorAtInfinity_wedge_plane(self_, other), plane_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_point(self_: FlectorAtInfinity, other: Point) -> Flector {
    return motor_antiWedge_planeAtOrigin(flectorAtInfinity_wedge_point(self_, other), point_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_pointAtInfinity(self_: FlectorAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(flectorAtInfinity_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_transflector(self_: FlectorAtInfinity, other: Transflector) -> Flector {
    return translator_antiWedge_flector(flectorAtInfinity_wedge_transflector(self_, other), transflector_dual(other));
}

fn flectorAtInfinity_antiRejectViaHorizonFrom_translator(self_: FlectorAtInfinity, other: Translator) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(flectorAtInfinity_wedge_translator(self_, other), translator_dual(other));
}

fn horizon_antiRejectViaHorizonFrom_flector(self_: Horizon, other: Flector) -> Flector {
    return antiScalar_antiWedge_flector(horizon_wedge_flector(self_, other), flector_dual(other));
}

fn horizon_antiRejectViaHorizonFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(horizon_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn horizon_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Horizon, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_antiWedge_multiVectorAtOrigin(horizon_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn horizon_antiRejectViaHorizonFrom_point(self_: Horizon, other: Point) -> PlaneAtOrigin {
    return antiScalar_antiWedge_planeAtOrigin(horizon_wedge_point(self_, other), point_dual(other));
}

fn line_antiRejectViaHorizonFrom_flector(self_: Line, other: Flector) -> MultiVector {
    return plane_antiWedge_flector(line_wedge_flector(self_, other), flector_dual(other));
}

fn line_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> MultiVector {
    return plane_antiWedge_flector(line_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn line_antiRejectViaHorizonFrom_line(self_: Line, other: Line) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(line_wedge_line(self_, other), line_dual(other));
}

fn line_antiRejectViaHorizonFrom_lineAtInfinity(self_: Line, other: LineAtInfinity) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(line_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn line_antiRejectViaHorizonFrom_motor(self_: Line, other: Motor) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(line_wedge_motor(self_, other), motor_dual(other));
}

fn line_antiRejectViaHorizonFrom_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(line_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn line_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(line_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn line_antiRejectViaHorizonFrom_point(self_: Line, other: Point) -> Line {
    return plane_antiWedge_planeAtOrigin(line_wedge_point(self_, other), point_dual(other));
}

fn line_antiRejectViaHorizonFrom_pointAtInfinity(self_: Line, other: PointAtInfinity) -> Line {
    return plane_antiWedge_planeAtOrigin(line_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn line_antiRejectViaHorizonFrom_transflector(self_: Line, other: Transflector) -> MultiVector {
    return plane_antiWedge_flector(line_wedge_transflector(self_, other), transflector_dual(other));
}

fn line_antiRejectViaHorizonFrom_translator(self_: Line, other: Translator) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(line_wedge_translator(self_, other), translator_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_flector(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return plane_antiWedge_flector(lineAtInfinity_wedge_flector(self_, other), flector_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_flectorAtInfinity(self_: LineAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(lineAtInfinity_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_line(self_: LineAtInfinity, other: Line) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(lineAtInfinity_wedge_line(self_, other), line_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_motor(self_: LineAtInfinity, other: Motor) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(lineAtInfinity_wedge_motor(self_, other), motor_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(lineAtInfinity_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: LineAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(lineAtInfinity_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_point(self_: LineAtInfinity, other: Point) -> Line {
    return plane_antiWedge_planeAtOrigin(lineAtInfinity_wedge_point(self_, other), point_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_pointAtInfinity(self_: LineAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(lineAtInfinity_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn lineAtInfinity_antiRejectViaHorizonFrom_transflector(self_: LineAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(lineAtInfinity_wedge_transflector(self_, other), transflector_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_flector(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(lineAtOrigin_wedge_flector(self_, other), flector_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(lineAtOrigin_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_line(self_: LineAtOrigin, other: Line) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(lineAtOrigin_wedge_line(self_, other), line_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(lineAtOrigin_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_motor(self_: LineAtOrigin, other: Motor) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(lineAtOrigin_wedge_motor(self_, other), motor_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(lineAtOrigin_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(lineAtOrigin_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_point(self_: LineAtOrigin, other: Point) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(lineAtOrigin_wedge_point(self_, other), point_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_pointAtInfinity(self_: LineAtOrigin, other: PointAtInfinity) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(lineAtOrigin_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_transflector(self_: LineAtOrigin, other: Transflector) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(lineAtOrigin_wedge_transflector(self_, other), transflector_dual(other));
}

fn lineAtOrigin_antiRejectViaHorizonFrom_translator(self_: LineAtOrigin, other: Translator) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(lineAtOrigin_wedge_translator(self_, other), translator_dual(other));
}

fn motor_antiRejectViaHorizonFrom_flector(self_: Motor, other: Flector) -> MultiVector {
    return plane_antiWedge_flector(motor_wedge_flector(self_, other), flector_dual(other));
}

fn motor_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> MultiVector {
    return plane_antiWedge_flector(motor_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn motor_antiRejectViaHorizonFrom_line(self_: Motor, other: Line) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(motor_wedge_line(self_, other), line_dual(other));
}

fn motor_antiRejectViaHorizonFrom_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(motor_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn motor_antiRejectViaHorizonFrom_motor(self_: Motor, other: Motor) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(motor_wedge_motor(self_, other), motor_dual(other));
}

fn motor_antiRejectViaHorizonFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(motor_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn motor_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(motor_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn motor_antiRejectViaHorizonFrom_point(self_: Motor, other: Point) -> Line {
    return plane_antiWedge_planeAtOrigin(motor_wedge_point(self_, other), point_dual(other));
}

fn motor_antiRejectViaHorizonFrom_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> Line {
    return plane_antiWedge_planeAtOrigin(motor_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn motor_antiRejectViaHorizonFrom_transflector(self_: Motor, other: Transflector) -> MultiVector {
    return plane_antiWedge_flector(motor_wedge_transflector(self_, other), transflector_dual(other));
}

fn motor_antiRejectViaHorizonFrom_translator(self_: Motor, other: Translator) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(motor_wedge_translator(self_, other), translator_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_antiWedge_flector(multiVector_wedge_flector(self_, other), flector_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_flector(multiVector_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return multiVector_antiWedge_origin(multiVector_wedge_horizon(self_, other), horizon_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_line(self_: MultiVector, other: Line) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVector_wedge_line(self_, other), line_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVector_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVector_wedge_motor(self_, other), motor_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(multiVector_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(multiVector_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return multiVector_antiWedge_origin(multiVector_wedge_plane(self_, other), plane_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_point(self_: MultiVector, other: Point) -> MultiVector {
    return multiVector_antiWedge_planeAtOrigin(multiVector_wedge_point(self_, other), point_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multiVector_antiWedge_planeAtOrigin(multiVector_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_antiWedge_flector(multiVector_wedge_transflector(self_, other), transflector_dual(other));
}

fn multiVector_antiRejectViaHorizonFrom_translator(self_: MultiVector, other: Translator) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVector_wedge_translator(self_, other), translator_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return multiVector_antiWedge_flector(multiVectorAtInfinity_wedge_flector(self_, other), flector_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_flectorAtInfinity(self_: MultiVectorAtInfinity, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_flector(multiVectorAtInfinity_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_horizon(self_: MultiVectorAtInfinity, other: Horizon) -> Scalar {
    return horizon_antiWedge_origin(multiVectorAtInfinity_wedge_horizon(self_, other), horizon_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVectorAtInfinity_wedge_line(self_, other), line_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_lineAtInfinity(self_: MultiVectorAtInfinity, other: LineAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_lineAtOrigin(multiVectorAtInfinity_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVectorAtInfinity_wedge_motor(self_, other), motor_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(multiVectorAtInfinity_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: MultiVectorAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVector {
    return multiVector_antiWedge_origin(multiVectorAtInfinity_wedge_plane(self_, other), plane_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_point(self_: MultiVectorAtInfinity, other: Point) -> MultiVector {
    return multiVector_antiWedge_planeAtOrigin(multiVectorAtInfinity_wedge_point(self_, other), point_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_pointAtInfinity(self_: MultiVectorAtInfinity, other: PointAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_planeAtOrigin(multiVectorAtInfinity_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return multiVector_antiWedge_flector(multiVectorAtInfinity_wedge_transflector(self_, other), transflector_dual(other));
}

fn multiVectorAtInfinity_antiRejectViaHorizonFrom_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVector {
    return multiVector_antiWedge_lineAtOrigin(multiVectorAtInfinity_wedge_translator(self_, other), translator_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_flector(multiVectorAtOrigin_wedge_flector(self_, other), flector_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_flector(multiVectorAtOrigin_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> Origin {
    return antiScalar_antiWedge_origin(multiVectorAtOrigin_wedge_horizon(self_, other), horizon_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(multiVectorAtOrigin_wedge_line(self_, other), line_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(multiVectorAtOrigin_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(multiVectorAtOrigin_wedge_motor(self_, other), motor_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(multiVectorAtOrigin_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(multiVectorAtOrigin_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_plane(self_: MultiVectorAtOrigin, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(multiVectorAtOrigin_wedge_plane(self_, other), plane_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_planeAtOrigin(multiVectorAtOrigin_wedge_point(self_, other), point_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_planeAtOrigin(multiVectorAtOrigin_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return multiVectorAtOrigin_antiWedge_flector(multiVectorAtOrigin_wedge_transflector(self_, other), transflector_dual(other));
}

fn multiVectorAtOrigin_antiRejectViaHorizonFrom_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_lineAtOrigin(multiVectorAtOrigin_wedge_translator(self_, other), translator_dual(other));
}

fn origin_antiRejectViaHorizonFrom_flector(self_: Origin, other: Flector) -> Flector {
    return rotor_antiWedge_flector(origin_wedge_flector(self_, other), flector_dual(other));
}

fn origin_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Flector {
    return rotor_antiWedge_flector(origin_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn origin_antiRejectViaHorizonFrom_horizon(self_: Origin, other: Horizon) -> Origin {
    return antiScalar_antiWedge_origin(origin_wedge_horizon(self_, other), horizon_dual(other));
}

fn origin_antiRejectViaHorizonFrom_line(self_: Origin, other: Line) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(origin_wedge_line(self_, other), line_dual(other));
}

fn origin_antiRejectViaHorizonFrom_lineAtInfinity(self_: Origin, other: LineAtInfinity) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(origin_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn origin_antiRejectViaHorizonFrom_motor(self_: Origin, other: Motor) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(origin_wedge_motor(self_, other), motor_dual(other));
}

fn origin_antiRejectViaHorizonFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(origin_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn origin_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(origin_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn origin_antiRejectViaHorizonFrom_plane(self_: Origin, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(origin_wedge_plane(self_, other), plane_dual(other));
}

fn origin_antiRejectViaHorizonFrom_point(self_: Origin, other: Point) -> Origin {
    return lineAtOrigin_antiWedge_planeAtOrigin(origin_wedge_point(self_, other), point_dual(other));
}

fn origin_antiRejectViaHorizonFrom_pointAtInfinity(self_: Origin, other: PointAtInfinity) -> Origin {
    return lineAtOrigin_antiWedge_planeAtOrigin(origin_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn origin_antiRejectViaHorizonFrom_transflector(self_: Origin, other: Transflector) -> Flector {
    return rotor_antiWedge_flector(origin_wedge_transflector(self_, other), transflector_dual(other));
}

fn origin_antiRejectViaHorizonFrom_translator(self_: Origin, other: Translator) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(origin_wedge_translator(self_, other), translator_dual(other));
}

fn plane_antiRejectViaHorizonFrom_flector(self_: Plane, other: Flector) -> Flector {
    return antiScalar_antiWedge_flector(plane_wedge_flector(self_, other), flector_dual(other));
}

fn plane_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> Flector {
    return antiScalar_antiWedge_flector(plane_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn plane_antiRejectViaHorizonFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(plane_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn plane_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(plane_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn plane_antiRejectViaHorizonFrom_point(self_: Plane, other: Point) -> PlaneAtOrigin {
    return antiScalar_antiWedge_planeAtOrigin(plane_wedge_point(self_, other), point_dual(other));
}

fn plane_antiRejectViaHorizonFrom_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> PlaneAtOrigin {
    return antiScalar_antiWedge_planeAtOrigin(plane_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn plane_antiRejectViaHorizonFrom_transflector(self_: Plane, other: Transflector) -> Flector {
    return antiScalar_antiWedge_flector(plane_wedge_transflector(self_, other), transflector_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_flector(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return antiScalar_antiWedge_flector(planeAtOrigin_wedge_flector(self_, other), flector_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> Flector {
    return antiScalar_antiWedge_flector(planeAtOrigin_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(planeAtOrigin_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(planeAtOrigin_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_point(self_: PlaneAtOrigin, other: Point) -> PlaneAtOrigin {
    return antiScalar_antiWedge_planeAtOrigin(planeAtOrigin_wedge_point(self_, other), point_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return antiScalar_antiWedge_planeAtOrigin(planeAtOrigin_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn planeAtOrigin_antiRejectViaHorizonFrom_transflector(self_: PlaneAtOrigin, other: Transflector) -> Flector {
    return antiScalar_antiWedge_flector(planeAtOrigin_wedge_transflector(self_, other), transflector_dual(other));
}

fn point_antiRejectViaHorizonFrom_flector(self_: Point, other: Flector) -> Flector {
    return motor_antiWedge_flector(point_wedge_flector(self_, other), flector_dual(other));
}

fn point_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Flector {
    return motor_antiWedge_flector(point_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn point_antiRejectViaHorizonFrom_horizon(self_: Point, other: Horizon) -> Origin {
    return antiScalar_antiWedge_origin(point_wedge_horizon(self_, other), horizon_dual(other));
}

fn point_antiRejectViaHorizonFrom_line(self_: Point, other: Line) -> Point {
    return plane_antiWedge_lineAtOrigin(point_wedge_line(self_, other), line_dual(other));
}

fn point_antiRejectViaHorizonFrom_lineAtInfinity(self_: Point, other: LineAtInfinity) -> Point {
    return plane_antiWedge_lineAtOrigin(point_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn point_antiRejectViaHorizonFrom_motor(self_: Point, other: Motor) -> Point {
    return plane_antiWedge_lineAtOrigin(point_wedge_motor(self_, other), motor_dual(other));
}

fn point_antiRejectViaHorizonFrom_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(point_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn point_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(point_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn point_antiRejectViaHorizonFrom_plane(self_: Point, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(point_wedge_plane(self_, other), plane_dual(other));
}

fn point_antiRejectViaHorizonFrom_point(self_: Point, other: Point) -> Point {
    return line_antiWedge_planeAtOrigin(point_wedge_point(self_, other), point_dual(other));
}

fn point_antiRejectViaHorizonFrom_pointAtInfinity(self_: Point, other: PointAtInfinity) -> Point {
    return line_antiWedge_planeAtOrigin(point_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn point_antiRejectViaHorizonFrom_transflector(self_: Point, other: Transflector) -> Flector {
    return motor_antiWedge_flector(point_wedge_transflector(self_, other), transflector_dual(other));
}

fn point_antiRejectViaHorizonFrom_translator(self_: Point, other: Translator) -> Point {
    return plane_antiWedge_lineAtOrigin(point_wedge_translator(self_, other), translator_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_flector(self_: PointAtInfinity, other: Flector) -> Flector {
    return motor_antiWedge_flector(pointAtInfinity_wedge_flector(self_, other), flector_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_flectorAtInfinity(self_: PointAtInfinity, other: FlectorAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_flector(pointAtInfinity_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_line(self_: PointAtInfinity, other: Line) -> Point {
    return plane_antiWedge_lineAtOrigin(pointAtInfinity_wedge_line(self_, other), line_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_lineAtInfinity(self_: PointAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(pointAtInfinity_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_motor(self_: PointAtInfinity, other: Motor) -> Point {
    return plane_antiWedge_lineAtOrigin(pointAtInfinity_wedge_motor(self_, other), motor_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(pointAtInfinity_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: PointAtInfinity, other: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(pointAtInfinity_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_plane(self_: PointAtInfinity, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(pointAtInfinity_wedge_plane(self_, other), plane_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_point(self_: PointAtInfinity, other: Point) -> Point {
    return line_antiWedge_planeAtOrigin(pointAtInfinity_wedge_point(self_, other), point_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_pointAtInfinity(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return lineAtInfinity_antiWedge_planeAtOrigin(pointAtInfinity_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_transflector(self_: PointAtInfinity, other: Transflector) -> Flector {
    return translator_antiWedge_flector(pointAtInfinity_wedge_transflector(self_, other), transflector_dual(other));
}

fn pointAtInfinity_antiRejectViaHorizonFrom_translator(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(pointAtInfinity_wedge_translator(self_, other), translator_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_flector(self_: Rotor, other: Flector) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(rotor_wedge_flector(self_, other), flector_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(rotor_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_line(self_: Rotor, other: Line) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(rotor_wedge_line(self_, other), line_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(rotor_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_motor(self_: Rotor, other: Motor) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(rotor_wedge_motor(self_, other), motor_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(rotor_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(rotor_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_point(self_: Rotor, other: Point) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(rotor_wedge_point(self_, other), point_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> LineAtOrigin {
    return planeAtOrigin_antiWedge_planeAtOrigin(rotor_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_transflector(self_: Rotor, other: Transflector) -> MultiVector {
    return planeAtOrigin_antiWedge_flector(rotor_wedge_transflector(self_, other), transflector_dual(other));
}

fn rotor_antiRejectViaHorizonFrom_translator(self_: Rotor, other: Translator) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(rotor_wedge_translator(self_, other), translator_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_flector(self_: Transflector, other: Flector) -> Flector {
    return motor_antiWedge_flector(transflector_wedge_flector(self_, other), flector_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> Flector {
    return translator_antiWedge_flector(transflector_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_line(self_: Transflector, other: Line) -> Point {
    return plane_antiWedge_lineAtOrigin(transflector_wedge_line(self_, other), line_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(transflector_wedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_motor(self_: Transflector, other: Motor) -> Point {
    return plane_antiWedge_lineAtOrigin(transflector_wedge_motor(self_, other), motor_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(transflector_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(transflector_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_plane(self_: Transflector, other: Plane) -> Origin {
    return antiScalar_antiWedge_origin(transflector_wedge_plane(self_, other), plane_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_point(self_: Transflector, other: Point) -> Flector {
    return motor_antiWedge_planeAtOrigin(transflector_wedge_point(self_, other), point_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> Transflector {
    return translator_antiWedge_planeAtOrigin(transflector_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_transflector(self_: Transflector, other: Transflector) -> Flector {
    return translator_antiWedge_flector(transflector_wedge_transflector(self_, other), transflector_dual(other));
}

fn transflector_antiRejectViaHorizonFrom_translator(self_: Transflector, other: Translator) -> PointAtInfinity {
    return horizon_antiWedge_lineAtOrigin(transflector_wedge_translator(self_, other), translator_dual(other));
}

fn translator_antiRejectViaHorizonFrom_flector(self_: Translator, other: Flector) -> MultiVector {
    return plane_antiWedge_flector(translator_wedge_flector(self_, other), flector_dual(other));
}

fn translator_antiRejectViaHorizonFrom_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(translator_wedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn translator_antiRejectViaHorizonFrom_line(self_: Translator, other: Line) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(translator_wedge_line(self_, other), line_dual(other));
}

fn translator_antiRejectViaHorizonFrom_motor(self_: Translator, other: Motor) -> LineAtOrigin {
    return antiScalar_antiWedge_lineAtOrigin(translator_wedge_motor(self_, other), motor_dual(other));
}

fn translator_antiRejectViaHorizonFrom_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(translator_wedge_multiVector(self_, other), multiVector_dual(other));
}

fn translator_antiRejectViaHorizonFrom_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(translator_wedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn translator_antiRejectViaHorizonFrom_point(self_: Translator, other: Point) -> Line {
    return plane_antiWedge_planeAtOrigin(translator_wedge_point(self_, other), point_dual(other));
}

fn translator_antiRejectViaHorizonFrom_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> LineAtInfinity {
    return horizon_antiWedge_planeAtOrigin(translator_wedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn translator_antiRejectViaHorizonFrom_transflector(self_: Translator, other: Transflector) -> MultiVectorAtInfinity {
    return horizon_antiWedge_flector(translator_wedge_transflector(self_, other), transflector_dual(other));
}

fn flector_rejectOrthogonallyFrom_flector(self_: Flector, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(flector_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_line(self_: Flector, other: Line) -> Plane {
    return point_wedge_lineAtInfinity(flector_antiWedge_line(self_, other), line_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_lineAtOrigin(self_: Flector, other: LineAtOrigin) -> Plane {
    return point_wedge_lineAtInfinity(flector_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_motor(self_: Flector, other: Motor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(flector_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(flector_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Flector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(flector_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_origin(self_: Flector, other: Origin) -> Horizon {
    return scalar_wedge_horizon(flector_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_plane(self_: Flector, other: Plane) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(flector_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_planeAtOrigin(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(flector_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_point(self_: Flector, other: Point) -> Horizon {
    return scalar_wedge_horizon(flector_antiWedge_point(self_, other), point_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_rotor(self_: Flector, other: Rotor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(flector_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn flector_rejectOrthogonallyFrom_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(flector_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_flectorAtInfinity(flectorAtInfinity_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_line(self_: FlectorAtInfinity, other: Line) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(flectorAtInfinity_antiWedge_line(self_, other), line_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_lineAtOrigin(self_: FlectorAtInfinity, other: LineAtOrigin) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(flectorAtInfinity_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_motor(self_: FlectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(flectorAtInfinity_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(flectorAtInfinity_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: FlectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(flectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_origin(self_: FlectorAtInfinity, other: Origin) -> Horizon {
    return scalar_wedge_horizon(flectorAtInfinity_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(flectorAtInfinity_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_planeAtOrigin(self_: FlectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(flectorAtInfinity_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_point(self_: FlectorAtInfinity, other: Point) -> Horizon {
    return scalar_wedge_horizon(flectorAtInfinity_antiWedge_point(self_, other), point_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_rotor(self_: FlectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(flectorAtInfinity_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn flectorAtInfinity_rejectOrthogonallyFrom_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(flectorAtInfinity_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_flector(self_: Horizon, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_flectorAtInfinity(horizon_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_line(self_: Horizon, other: Line) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(horizon_antiWedge_line(self_, other), line_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_lineAtOrigin(self_: Horizon, other: LineAtOrigin) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(horizon_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_motor(self_: Horizon, other: Motor) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(horizon_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(horizon_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Horizon, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(horizon_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_origin(self_: Horizon, other: Origin) -> Horizon {
    return scalar_wedge_horizon(horizon_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_plane(self_: Horizon, other: Plane) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(horizon_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_planeAtOrigin(self_: Horizon, other: PlaneAtOrigin) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(horizon_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_point(self_: Horizon, other: Point) -> Horizon {
    return scalar_wedge_horizon(horizon_antiWedge_point(self_, other), point_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_rotor(self_: Horizon, other: Rotor) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(horizon_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn horizon_rejectOrthogonallyFrom_transflector(self_: Horizon, other: Transflector) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(horizon_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn line_rejectOrthogonallyFrom_flector(self_: Line, other: Flector) -> Motor {
    return point_wedge_flectorAtInfinity(line_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn line_rejectOrthogonallyFrom_line(self_: Line, other: Line) -> LineAtInfinity {
    return scalar_wedge_lineAtInfinity(line_antiWedge_line(self_, other), line_antiDual(other));
}

fn line_rejectOrthogonallyFrom_lineAtOrigin(self_: Line, other: LineAtOrigin) -> LineAtInfinity {
    return scalar_wedge_lineAtInfinity(line_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn line_rejectOrthogonallyFrom_motor(self_: Line, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(line_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn line_rejectOrthogonallyFrom_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(line_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn line_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Line, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(line_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn line_rejectOrthogonallyFrom_plane(self_: Line, other: Plane) -> Line {
    return point_wedge_pointAtInfinity(line_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn line_rejectOrthogonallyFrom_planeAtOrigin(self_: Line, other: PlaneAtOrigin) -> Line {
    return point_wedge_pointAtInfinity(line_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn line_rejectOrthogonallyFrom_rotor(self_: Line, other: Rotor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(line_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn line_rejectOrthogonallyFrom_transflector(self_: Line, other: Transflector) -> Line {
    return point_wedge_pointAtInfinity(line_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_flector(self_: LineAtInfinity, other: Flector) -> LineAtInfinity {
    return pointAtInfinity_wedge_flectorAtInfinity(lineAtInfinity_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_line(self_: LineAtInfinity, other: Line) -> LineAtInfinity {
    return scalar_wedge_lineAtInfinity(lineAtInfinity_antiWedge_line(self_, other), line_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_lineAtOrigin(self_: LineAtInfinity, other: LineAtOrigin) -> LineAtInfinity {
    return scalar_wedge_lineAtInfinity(lineAtInfinity_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(lineAtInfinity_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(lineAtInfinity_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: LineAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(lineAtInfinity_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_plane(self_: LineAtInfinity, other: Plane) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(lineAtInfinity_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_planeAtOrigin(self_: LineAtInfinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(lineAtInfinity_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_rotor(self_: LineAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(lineAtInfinity_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn lineAtInfinity_rejectOrthogonallyFrom_transflector(self_: LineAtInfinity, other: Transflector) -> LineAtInfinity {
    return pointAtInfinity_wedge_pointAtInfinity(lineAtInfinity_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_flector(self_: LineAtOrigin, other: Flector) -> Motor {
    return point_wedge_flectorAtInfinity(lineAtOrigin_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_line(self_: LineAtOrigin, other: Line) -> LineAtInfinity {
    return scalar_wedge_lineAtInfinity(lineAtOrigin_antiWedge_line(self_, other), line_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_motor(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(lineAtOrigin_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(lineAtOrigin_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: LineAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(lineAtOrigin_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_plane(self_: LineAtOrigin, other: Plane) -> Line {
    return point_wedge_pointAtInfinity(lineAtOrigin_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_planeAtOrigin(self_: LineAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return origin_wedge_pointAtInfinity(lineAtOrigin_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_rotor(self_: LineAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return lineAtOrigin_wedge_multiVectorAtInfinity(lineAtOrigin_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn lineAtOrigin_rejectOrthogonallyFrom_transflector(self_: LineAtOrigin, other: Transflector) -> Line {
    return point_wedge_pointAtInfinity(lineAtOrigin_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_flector(self_: Motor, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(motor_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_line(self_: Motor, other: Line) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(motor_antiWedge_line(self_, other), line_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_lineAtOrigin(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(motor_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_motor(self_: Motor, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(motor_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(motor_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Motor, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(motor_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_origin(self_: Motor, other: Origin) -> AntiScalar {
    return origin_wedge_horizon(motor_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_plane(self_: Motor, other: Plane) -> Motor {
    return flector_wedge_pointAtInfinity(motor_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_planeAtOrigin(self_: Motor, other: PlaneAtOrigin) -> Motor {
    return flector_wedge_pointAtInfinity(motor_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_point(self_: Motor, other: Point) -> AntiScalar {
    return point_wedge_horizon(motor_antiWedge_point(self_, other), point_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_rotor(self_: Motor, other: Rotor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(motor_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn motor_rejectOrthogonallyFrom_transflector(self_: Motor, other: Transflector) -> Motor {
    return flector_wedge_pointAtInfinity(motor_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(multiVector_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_line(self_: MultiVector, other: Line) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(multiVector_antiWedge_line(self_, other), line_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_lineAtOrigin(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(multiVector_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_motor(self_: MultiVector, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(multiVector_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(multiVector_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: MultiVector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(multiVector_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return multiVector_wedge_horizon(multiVector_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_plane(self_: MultiVector, other: Plane) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(multiVector_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_planeAtOrigin(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(multiVector_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_point(self_: MultiVector, other: Point) -> MultiVector {
    return multiVector_wedge_horizon(multiVector_antiWedge_point(self_, other), point_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_rotor(self_: MultiVector, other: Rotor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(multiVector_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn multiVector_rejectOrthogonallyFrom_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(multiVector_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_flectorAtInfinity(multiVectorAtInfinity_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_lineAtInfinity(multiVectorAtInfinity_antiWedge_line(self_, other), line_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_lineAtOrigin(self_: MultiVectorAtInfinity, other: LineAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_lineAtInfinity(multiVectorAtInfinity_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(multiVectorAtInfinity_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(multiVectorAtInfinity_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: MultiVectorAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(multiVectorAtInfinity_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_origin(self_: MultiVectorAtInfinity, other: Origin) -> Horizon {
    return scalar_wedge_horizon(multiVectorAtInfinity_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(multiVectorAtInfinity_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_planeAtOrigin(self_: MultiVectorAtInfinity, other: PlaneAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(multiVectorAtInfinity_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_point(self_: MultiVectorAtInfinity, other: Point) -> Horizon {
    return scalar_wedge_horizon(multiVectorAtInfinity_antiWedge_point(self_, other), point_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_rotor(self_: MultiVectorAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(multiVectorAtInfinity_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn multiVectorAtInfinity_rejectOrthogonallyFrom_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_pointAtInfinity(multiVectorAtInfinity_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(multiVectorAtOrigin_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(multiVectorAtOrigin_antiWedge_line(self_, other), line_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_lineAtOrigin(self_: MultiVectorAtOrigin, other: LineAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_lineAtInfinity(multiVectorAtOrigin_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(multiVectorAtOrigin_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(multiVectorAtOrigin_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: MultiVectorAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_origin(self_: MultiVectorAtOrigin, other: Origin) -> AntiScalar {
    return origin_wedge_horizon(multiVectorAtOrigin_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(multiVectorAtOrigin_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_planeAtOrigin(self_: MultiVectorAtOrigin, other: PlaneAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_pointAtInfinity(multiVectorAtOrigin_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVector {
    return multiVector_wedge_horizon(multiVectorAtOrigin_antiWedge_point(self_, other), point_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_rotor(self_: MultiVectorAtOrigin, other: Rotor) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(multiVectorAtOrigin_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn multiVectorAtOrigin_rejectOrthogonallyFrom_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(multiVectorAtOrigin_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_flector(self_: Origin, other: Flector) -> FlectorAtInfinity {
    return scalar_wedge_flectorAtInfinity(origin_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_motor(self_: Origin, other: Motor) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(origin_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(origin_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Origin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(origin_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_plane(self_: Origin, other: Plane) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(origin_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_rotor(self_: Origin, other: Rotor) -> MultiVectorAtOrigin {
    return origin_wedge_multiVectorAtInfinity(origin_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn origin_rejectOrthogonallyFrom_transflector(self_: Origin, other: Transflector) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(origin_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_flector(self_: Plane, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(plane_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_line(self_: Plane, other: Line) -> Plane {
    return point_wedge_lineAtInfinity(plane_antiWedge_line(self_, other), line_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> Plane {
    return point_wedge_lineAtInfinity(plane_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_motor(self_: Plane, other: Motor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(plane_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(plane_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Plane, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(plane_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_origin(self_: Plane, other: Origin) -> Horizon {
    return scalar_wedge_horizon(plane_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_plane(self_: Plane, other: Plane) -> Plane {
    return line_wedge_pointAtInfinity(plane_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return line_wedge_pointAtInfinity(plane_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_point(self_: Plane, other: Point) -> Horizon {
    return scalar_wedge_horizon(plane_antiWedge_point(self_, other), point_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_rotor(self_: Plane, other: Rotor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(plane_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn plane_rejectOrthogonallyFrom_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(plane_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(planeAtOrigin_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_line(self_: PlaneAtOrigin, other: Line) -> Plane {
    return point_wedge_lineAtInfinity(planeAtOrigin_antiWedge_line(self_, other), line_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> PlaneAtOrigin {
    return origin_wedge_lineAtInfinity(planeAtOrigin_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_motor(self_: PlaneAtOrigin, other: Motor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(planeAtOrigin_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(planeAtOrigin_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: PlaneAtOrigin, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(planeAtOrigin_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_plane(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return line_wedge_pointAtInfinity(planeAtOrigin_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return lineAtOrigin_wedge_pointAtInfinity(planeAtOrigin_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_point(self_: PlaneAtOrigin, other: Point) -> Horizon {
    return scalar_wedge_horizon(planeAtOrigin_antiWedge_point(self_, other), point_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_rotor(self_: PlaneAtOrigin, other: Rotor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(planeAtOrigin_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn planeAtOrigin_rejectOrthogonallyFrom_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(planeAtOrigin_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn point_rejectOrthogonallyFrom_flector(self_: Point, other: Flector) -> FlectorAtInfinity {
    return scalar_wedge_flectorAtInfinity(point_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn point_rejectOrthogonallyFrom_motor(self_: Point, other: Motor) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(point_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn point_rejectOrthogonallyFrom_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(point_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn point_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Point, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(point_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn point_rejectOrthogonallyFrom_plane(self_: Point, other: Plane) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(point_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn point_rejectOrthogonallyFrom_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(point_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn point_rejectOrthogonallyFrom_rotor(self_: Point, other: Rotor) -> MultiVector {
    return point_wedge_multiVectorAtInfinity(point_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn point_rejectOrthogonallyFrom_transflector(self_: Point, other: Transflector) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(point_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_flector(self_: PointAtInfinity, other: Flector) -> FlectorAtInfinity {
    return scalar_wedge_flectorAtInfinity(pointAtInfinity_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_motor(self_: PointAtInfinity, other: Motor) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(pointAtInfinity_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(pointAtInfinity_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: PointAtInfinity, other: MultiVectorAtOrigin) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(pointAtInfinity_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_plane(self_: PointAtInfinity, other: Plane) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(pointAtInfinity_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_planeAtOrigin(self_: PointAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(pointAtInfinity_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_rotor(self_: PointAtInfinity, other: Rotor) -> MultiVectorAtInfinity {
    return pointAtInfinity_wedge_multiVectorAtInfinity(pointAtInfinity_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn pointAtInfinity_rejectOrthogonallyFrom_transflector(self_: PointAtInfinity, other: Transflector) -> PointAtInfinity {
    return scalar_wedge_pointAtInfinity(pointAtInfinity_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_flector(self_: Rotor, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(rotor_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_line(self_: Rotor, other: Line) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(rotor_antiWedge_line(self_, other), line_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_lineAtOrigin(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return lineAtOrigin_wedge_lineAtInfinity(rotor_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_motor(self_: Rotor, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(rotor_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_multiVector(self_: Rotor, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(rotor_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Rotor, other: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_wedge_multiVectorAtInfinity(rotor_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_origin(self_: Rotor, other: Origin) -> AntiScalar {
    return origin_wedge_horizon(rotor_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_plane(self_: Rotor, other: Plane) -> Motor {
    return flector_wedge_pointAtInfinity(rotor_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_planeAtOrigin(self_: Rotor, other: PlaneAtOrigin) -> Motor {
    return flector_wedge_pointAtInfinity(rotor_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_point(self_: Rotor, other: Point) -> AntiScalar {
    return point_wedge_horizon(rotor_antiWedge_point(self_, other), point_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_rotor(self_: Rotor, other: Rotor) -> MultiVectorAtOrigin {
    return rotor_wedge_multiVectorAtInfinity(rotor_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn rotor_rejectOrthogonallyFrom_transflector(self_: Rotor, other: Transflector) -> Motor {
    return flector_wedge_pointAtInfinity(rotor_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_flector(self_: Transflector, other: Flector) -> MultiVector {
    return multiVector_wedge_flectorAtInfinity(transflector_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_line(self_: Transflector, other: Line) -> Plane {
    return point_wedge_lineAtInfinity(transflector_antiWedge_line(self_, other), line_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_lineAtOrigin(self_: Transflector, other: LineAtOrigin) -> Plane {
    return point_wedge_lineAtInfinity(transflector_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_motor(self_: Transflector, other: Motor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(transflector_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_multiVector(self_: Transflector, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(transflector_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Transflector, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(transflector_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_origin(self_: Transflector, other: Origin) -> Horizon {
    return scalar_wedge_horizon(transflector_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_plane(self_: Transflector, other: Plane) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(transflector_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_planeAtOrigin(self_: Transflector, other: PlaneAtOrigin) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(transflector_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_point(self_: Transflector, other: Point) -> Horizon {
    return scalar_wedge_horizon(transflector_antiWedge_point(self_, other), point_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_rotor(self_: Transflector, other: Rotor) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(transflector_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn transflector_rejectOrthogonallyFrom_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return multiVector_wedge_pointAtInfinity(transflector_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_flector(self_: Translator, other: Flector) -> Motor {
    return flector_wedge_flectorAtInfinity(translator_antiWedge_flector(self_, other), flector_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_line(self_: Translator, other: Line) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(translator_antiWedge_line(self_, other), line_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_lineAtOrigin(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return multiVector_wedge_lineAtInfinity(translator_antiWedge_lineAtOrigin(self_, other), lineAtOrigin_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_motor(self_: Translator, other: Motor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(translator_antiWedge_motor(self_, other), motor_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_multiVector(self_: Translator, other: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(translator_antiWedge_multiVector(self_, other), multiVector_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_multiVectorAtOrigin(self_: Translator, other: MultiVectorAtOrigin) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(translator_antiWedge_multiVectorAtOrigin(self_, other), multiVectorAtOrigin_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_origin(self_: Translator, other: Origin) -> AntiScalar {
    return origin_wedge_horizon(translator_antiWedge_origin(self_, other), origin_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_plane(self_: Translator, other: Plane) -> Translator {
    return transflector_wedge_pointAtInfinity(translator_antiWedge_plane(self_, other), plane_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_planeAtOrigin(self_: Translator, other: PlaneAtOrigin) -> Translator {
    return transflector_wedge_pointAtInfinity(translator_antiWedge_planeAtOrigin(self_, other), planeAtOrigin_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_point(self_: Translator, other: Point) -> AntiScalar {
    return point_wedge_horizon(translator_antiWedge_point(self_, other), point_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_rotor(self_: Translator, other: Rotor) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(translator_antiWedge_rotor(self_, other), rotor_antiDual(other));
}

fn translator_rejectOrthogonallyFrom_transflector(self_: Translator, other: Transflector) -> Translator {
    return transflector_wedge_pointAtInfinity(translator_antiWedge_transflector(self_, other), transflector_antiDual(other));
}

fn flector_rejectViaOriginFrom_flector(self_: Flector, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(flector_antiWedge_flector(self_, other), flector_dual(other));
}

fn flector_rejectViaOriginFrom_flectorAtInfinity(self_: Flector, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(flector_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn flector_rejectViaOriginFrom_horizon(self_: Flector, other: Horizon) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(flector_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn flector_rejectViaOriginFrom_line(self_: Flector, other: Line) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(flector_antiWedge_line(self_, other), line_dual(other));
}

fn flector_rejectViaOriginFrom_lineAtInfinity(self_: Flector, other: LineAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(flector_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn flector_rejectViaOriginFrom_motor(self_: Flector, other: Motor) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(flector_antiWedge_motor(self_, other), motor_dual(other));
}

fn flector_rejectViaOriginFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(flector_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn flector_rejectViaOriginFrom_multiVectorAtInfinity(self_: Flector, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(flector_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn flector_rejectViaOriginFrom_plane(self_: Flector, other: Plane) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(flector_antiWedge_plane(self_, other), plane_dual(other));
}

fn flector_rejectViaOriginFrom_point(self_: Flector, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(flector_antiWedge_point(self_, other), point_dual(other));
}

fn flector_rejectViaOriginFrom_pointAtInfinity(self_: Flector, other: PointAtInfinity) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(flector_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn flector_rejectViaOriginFrom_transflector(self_: Flector, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(flector_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn flector_rejectViaOriginFrom_translator(self_: Flector, other: Translator) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(flector_antiWedge_translator(self_, other), translator_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_flector(self_: FlectorAtInfinity, other: Flector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(flectorAtInfinity_antiWedge_flector(self_, other), flector_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_line(self_: FlectorAtInfinity, other: Line) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(flectorAtInfinity_antiWedge_line(self_, other), line_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_motor(self_: FlectorAtInfinity, other: Motor) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(flectorAtInfinity_antiWedge_motor(self_, other), motor_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_multiVector(self_: FlectorAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(flectorAtInfinity_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_plane(self_: FlectorAtInfinity, other: Plane) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(flectorAtInfinity_antiWedge_plane(self_, other), plane_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_point(self_: FlectorAtInfinity, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(flectorAtInfinity_antiWedge_point(self_, other), point_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_transflector(self_: FlectorAtInfinity, other: Transflector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(flectorAtInfinity_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn flectorAtInfinity_rejectViaOriginFrom_translator(self_: FlectorAtInfinity, other: Translator) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(flectorAtInfinity_antiWedge_translator(self_, other), translator_dual(other));
}

fn horizon_rejectViaOriginFrom_flector(self_: Horizon, other: Flector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(horizon_antiWedge_flector(self_, other), flector_dual(other));
}

fn horizon_rejectViaOriginFrom_line(self_: Horizon, other: Line) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(horizon_antiWedge_line(self_, other), line_dual(other));
}

fn horizon_rejectViaOriginFrom_motor(self_: Horizon, other: Motor) -> PlaneAtOrigin {
    return flectorAtInfinity_wedge_lineAtOrigin(horizon_antiWedge_motor(self_, other), motor_dual(other));
}

fn horizon_rejectViaOriginFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(horizon_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn horizon_rejectViaOriginFrom_plane(self_: Horizon, other: Plane) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(horizon_antiWedge_plane(self_, other), plane_dual(other));
}

fn horizon_rejectViaOriginFrom_point(self_: Horizon, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(horizon_antiWedge_point(self_, other), point_dual(other));
}

fn horizon_rejectViaOriginFrom_transflector(self_: Horizon, other: Transflector) -> Plane {
    return lineAtInfinity_wedge_flector(horizon_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn line_rejectViaOriginFrom_flector(self_: Line, other: Flector) -> Motor {
    return point_wedge_flector(line_antiWedge_flector(self_, other), flector_dual(other));
}

fn line_rejectViaOriginFrom_flectorAtInfinity(self_: Line, other: FlectorAtInfinity) -> Motor {
    return pointAtInfinity_wedge_flector(line_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn line_rejectViaOriginFrom_horizon(self_: Line, other: Horizon) -> LineAtOrigin {
    return pointAtInfinity_wedge_origin(line_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn line_rejectViaOriginFrom_line(self_: Line, other: Line) -> LineAtOrigin {
    return scalar_wedge_lineAtOrigin(line_antiWedge_line(self_, other), line_dual(other));
}

fn line_rejectViaOriginFrom_lineAtInfinity(self_: Line, other: LineAtInfinity) -> LineAtOrigin {
    return scalar_wedge_lineAtOrigin(line_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn line_rejectViaOriginFrom_motor(self_: Line, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(line_antiWedge_motor(self_, other), motor_dual(other));
}

fn line_rejectViaOriginFrom_multiVector(self_: Line, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(line_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn line_rejectViaOriginFrom_multiVectorAtInfinity(self_: Line, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(line_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn line_rejectViaOriginFrom_plane(self_: Line, other: Plane) -> LineAtOrigin {
    return point_wedge_origin(line_antiWedge_plane(self_, other), plane_dual(other));
}

fn line_rejectViaOriginFrom_transflector(self_: Line, other: Transflector) -> Motor {
    return point_wedge_flector(line_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn line_rejectViaOriginFrom_translator(self_: Line, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(line_antiWedge_translator(self_, other), translator_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_flector(self_: LineAtInfinity, other: Flector) -> Motor {
    return pointAtInfinity_wedge_flector(lineAtInfinity_antiWedge_flector(self_, other), flector_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_line(self_: LineAtInfinity, other: Line) -> LineAtOrigin {
    return scalar_wedge_lineAtOrigin(lineAtInfinity_antiWedge_line(self_, other), line_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_motor(self_: LineAtInfinity, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(lineAtInfinity_antiWedge_motor(self_, other), motor_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_multiVector(self_: LineAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(lineAtInfinity_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_plane(self_: LineAtInfinity, other: Plane) -> LineAtOrigin {
    return pointAtInfinity_wedge_origin(lineAtInfinity_antiWedge_plane(self_, other), plane_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_transflector(self_: LineAtInfinity, other: Transflector) -> Motor {
    return pointAtInfinity_wedge_flector(lineAtInfinity_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn lineAtInfinity_rejectViaOriginFrom_translator(self_: LineAtInfinity, other: Translator) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(lineAtInfinity_antiWedge_translator(self_, other), translator_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_flector(self_: LineAtOrigin, other: Flector) -> Motor {
    return point_wedge_flector(lineAtOrigin_antiWedge_flector(self_, other), flector_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_flectorAtInfinity(self_: LineAtOrigin, other: FlectorAtInfinity) -> Motor {
    return pointAtInfinity_wedge_flector(lineAtOrigin_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_horizon(self_: LineAtOrigin, other: Horizon) -> LineAtOrigin {
    return pointAtInfinity_wedge_origin(lineAtOrigin_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_line(self_: LineAtOrigin, other: Line) -> LineAtOrigin {
    return scalar_wedge_lineAtOrigin(lineAtOrigin_antiWedge_line(self_, other), line_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_lineAtInfinity(self_: LineAtOrigin, other: LineAtInfinity) -> LineAtOrigin {
    return scalar_wedge_lineAtOrigin(lineAtOrigin_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_motor(self_: LineAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(lineAtOrigin_antiWedge_motor(self_, other), motor_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_multiVector(self_: LineAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(lineAtOrigin_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_multiVectorAtInfinity(self_: LineAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(lineAtOrigin_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_plane(self_: LineAtOrigin, other: Plane) -> LineAtOrigin {
    return point_wedge_origin(lineAtOrigin_antiWedge_plane(self_, other), plane_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_transflector(self_: LineAtOrigin, other: Transflector) -> Motor {
    return point_wedge_flector(lineAtOrigin_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn lineAtOrigin_rejectViaOriginFrom_translator(self_: LineAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(lineAtOrigin_antiWedge_translator(self_, other), translator_dual(other));
}

fn motor_rejectViaOriginFrom_flector(self_: Motor, other: Flector) -> Motor {
    return flector_wedge_flector(motor_antiWedge_flector(self_, other), flector_dual(other));
}

fn motor_rejectViaOriginFrom_flectorAtInfinity(self_: Motor, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(motor_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn motor_rejectViaOriginFrom_horizon(self_: Motor, other: Horizon) -> Rotor {
    return flectorAtInfinity_wedge_origin(motor_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn motor_rejectViaOriginFrom_line(self_: Motor, other: Line) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(motor_antiWedge_line(self_, other), line_dual(other));
}

fn motor_rejectViaOriginFrom_lineAtInfinity(self_: Motor, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(motor_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn motor_rejectViaOriginFrom_motor(self_: Motor, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(motor_antiWedge_motor(self_, other), motor_dual(other));
}

fn motor_rejectViaOriginFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(motor_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn motor_rejectViaOriginFrom_multiVectorAtInfinity(self_: Motor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(motor_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn motor_rejectViaOriginFrom_plane(self_: Motor, other: Plane) -> Rotor {
    return flector_wedge_origin(motor_antiWedge_plane(self_, other), plane_dual(other));
}

fn motor_rejectViaOriginFrom_point(self_: Motor, other: Point) -> AntiScalar {
    return point_wedge_planeAtOrigin(motor_antiWedge_point(self_, other), point_dual(other));
}

fn motor_rejectViaOriginFrom_pointAtInfinity(self_: Motor, other: PointAtInfinity) -> AntiScalar {
    return pointAtInfinity_wedge_planeAtOrigin(motor_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn motor_rejectViaOriginFrom_transflector(self_: Motor, other: Transflector) -> Motor {
    return flector_wedge_flector(motor_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn motor_rejectViaOriginFrom_translator(self_: Motor, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(motor_antiWedge_translator(self_, other), translator_dual(other));
}

fn multiVector_rejectViaOriginFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(multiVector_antiWedge_flector(self_, other), flector_dual(other));
}

fn multiVector_rejectViaOriginFrom_flectorAtInfinity(self_: MultiVector, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(multiVector_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn multiVector_rejectViaOriginFrom_horizon(self_: MultiVector, other: Horizon) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(multiVector_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn multiVector_rejectViaOriginFrom_line(self_: MultiVector, other: Line) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(multiVector_antiWedge_line(self_, other), line_dual(other));
}

fn multiVector_rejectViaOriginFrom_lineAtInfinity(self_: MultiVector, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(multiVector_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn multiVector_rejectViaOriginFrom_motor(self_: MultiVector, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(multiVector_antiWedge_motor(self_, other), motor_dual(other));
}

fn multiVector_rejectViaOriginFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(multiVector_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn multiVector_rejectViaOriginFrom_multiVectorAtInfinity(self_: MultiVector, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(multiVector_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn multiVector_rejectViaOriginFrom_plane(self_: MultiVector, other: Plane) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(multiVector_antiWedge_plane(self_, other), plane_dual(other));
}

fn multiVector_rejectViaOriginFrom_point(self_: MultiVector, other: Point) -> MultiVectorAtOrigin {
    return multiVector_wedge_planeAtOrigin(multiVector_antiWedge_point(self_, other), point_dual(other));
}

fn multiVector_rejectViaOriginFrom_pointAtInfinity(self_: MultiVector, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_planeAtOrigin(multiVector_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn multiVector_rejectViaOriginFrom_transflector(self_: MultiVector, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(multiVector_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn multiVector_rejectViaOriginFrom_translator(self_: MultiVector, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(multiVector_antiWedge_translator(self_, other), translator_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_flector(self_: MultiVectorAtInfinity, other: Flector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(multiVectorAtInfinity_antiWedge_flector(self_, other), flector_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_line(self_: MultiVectorAtInfinity, other: Line) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(multiVectorAtInfinity_antiWedge_line(self_, other), line_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_motor(self_: MultiVectorAtInfinity, other: Motor) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(multiVectorAtInfinity_antiWedge_motor(self_, other), motor_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_multiVector(self_: MultiVectorAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(multiVectorAtInfinity_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_plane(self_: MultiVectorAtInfinity, other: Plane) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(multiVectorAtInfinity_antiWedge_plane(self_, other), plane_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_point(self_: MultiVectorAtInfinity, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(multiVectorAtInfinity_antiWedge_point(self_, other), point_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_transflector(self_: MultiVectorAtInfinity, other: Transflector) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(multiVectorAtInfinity_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn multiVectorAtInfinity_rejectViaOriginFrom_translator(self_: MultiVectorAtInfinity, other: Translator) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(multiVectorAtInfinity_antiWedge_translator(self_, other), translator_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_flector(self_: MultiVectorAtOrigin, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(multiVectorAtOrigin_antiWedge_flector(self_, other), flector_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_flectorAtInfinity(self_: MultiVectorAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(multiVectorAtOrigin_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_horizon(self_: MultiVectorAtOrigin, other: Horizon) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_origin(multiVectorAtOrigin_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_line(self_: MultiVectorAtOrigin, other: Line) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(multiVectorAtOrigin_antiWedge_line(self_, other), line_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_lineAtInfinity(self_: MultiVectorAtOrigin, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(multiVectorAtOrigin_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_motor(self_: MultiVectorAtOrigin, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(multiVectorAtOrigin_antiWedge_motor(self_, other), motor_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_multiVector(self_: MultiVectorAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(multiVectorAtOrigin_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_multiVectorAtInfinity(self_: MultiVectorAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(multiVectorAtOrigin_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_plane(self_: MultiVectorAtOrigin, other: Plane) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(multiVectorAtOrigin_antiWedge_plane(self_, other), plane_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_point(self_: MultiVectorAtOrigin, other: Point) -> MultiVectorAtOrigin {
    return multiVector_wedge_planeAtOrigin(multiVectorAtOrigin_antiWedge_point(self_, other), point_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_pointAtInfinity(self_: MultiVectorAtOrigin, other: PointAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_planeAtOrigin(multiVectorAtOrigin_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_transflector(self_: MultiVectorAtOrigin, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(multiVectorAtOrigin_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn multiVectorAtOrigin_rejectViaOriginFrom_translator(self_: MultiVectorAtOrigin, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(multiVectorAtOrigin_antiWedge_translator(self_, other), translator_dual(other));
}

fn origin_rejectViaOriginFrom_flector(self_: Origin, other: Flector) -> Flector {
    return scalar_wedge_flector(origin_antiWedge_flector(self_, other), flector_dual(other));
}

fn origin_rejectViaOriginFrom_flectorAtInfinity(self_: Origin, other: FlectorAtInfinity) -> Flector {
    return scalar_wedge_flector(origin_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn origin_rejectViaOriginFrom_horizon(self_: Origin, other: Horizon) -> Origin {
    return scalar_wedge_origin(origin_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn origin_rejectViaOriginFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(origin_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn origin_rejectViaOriginFrom_multiVectorAtInfinity(self_: Origin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return scalar_wedge_multiVectorAtOrigin(origin_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn origin_rejectViaOriginFrom_plane(self_: Origin, other: Plane) -> Origin {
    return scalar_wedge_origin(origin_antiWedge_plane(self_, other), plane_dual(other));
}

fn origin_rejectViaOriginFrom_transflector(self_: Origin, other: Transflector) -> Flector {
    return scalar_wedge_flector(origin_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn plane_rejectViaOriginFrom_flector(self_: Plane, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(plane_antiWedge_flector(self_, other), flector_dual(other));
}

fn plane_rejectViaOriginFrom_flectorAtInfinity(self_: Plane, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(plane_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn plane_rejectViaOriginFrom_horizon(self_: Plane, other: Horizon) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(plane_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn plane_rejectViaOriginFrom_line(self_: Plane, other: Line) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(plane_antiWedge_line(self_, other), line_dual(other));
}

fn plane_rejectViaOriginFrom_lineAtInfinity(self_: Plane, other: LineAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(plane_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn plane_rejectViaOriginFrom_motor(self_: Plane, other: Motor) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(plane_antiWedge_motor(self_, other), motor_dual(other));
}

fn plane_rejectViaOriginFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(plane_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn plane_rejectViaOriginFrom_multiVectorAtInfinity(self_: Plane, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(plane_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn plane_rejectViaOriginFrom_plane(self_: Plane, other: Plane) -> PlaneAtOrigin {
    return line_wedge_origin(plane_antiWedge_plane(self_, other), plane_dual(other));
}

fn plane_rejectViaOriginFrom_point(self_: Plane, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(plane_antiWedge_point(self_, other), point_dual(other));
}

fn plane_rejectViaOriginFrom_pointAtInfinity(self_: Plane, other: PointAtInfinity) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(plane_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn plane_rejectViaOriginFrom_transflector(self_: Plane, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(plane_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn plane_rejectViaOriginFrom_translator(self_: Plane, other: Translator) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(plane_antiWedge_translator(self_, other), translator_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_flector(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(planeAtOrigin_antiWedge_flector(self_, other), flector_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_flectorAtInfinity(self_: PlaneAtOrigin, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(planeAtOrigin_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_horizon(self_: PlaneAtOrigin, other: Horizon) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(planeAtOrigin_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_line(self_: PlaneAtOrigin, other: Line) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(planeAtOrigin_antiWedge_line(self_, other), line_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_lineAtInfinity(self_: PlaneAtOrigin, other: LineAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(planeAtOrigin_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_motor(self_: PlaneAtOrigin, other: Motor) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(planeAtOrigin_antiWedge_motor(self_, other), motor_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_multiVector(self_: PlaneAtOrigin, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(planeAtOrigin_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_multiVectorAtInfinity(self_: PlaneAtOrigin, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(planeAtOrigin_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_plane(self_: PlaneAtOrigin, other: Plane) -> PlaneAtOrigin {
    return line_wedge_origin(planeAtOrigin_antiWedge_plane(self_, other), plane_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_point(self_: PlaneAtOrigin, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(planeAtOrigin_antiWedge_point(self_, other), point_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_pointAtInfinity(self_: PlaneAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(planeAtOrigin_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_transflector(self_: PlaneAtOrigin, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(planeAtOrigin_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn planeAtOrigin_rejectViaOriginFrom_translator(self_: PlaneAtOrigin, other: Translator) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(planeAtOrigin_antiWedge_translator(self_, other), translator_dual(other));
}

fn point_rejectViaOriginFrom_flector(self_: Point, other: Flector) -> Flector {
    return scalar_wedge_flector(point_antiWedge_flector(self_, other), flector_dual(other));
}

fn point_rejectViaOriginFrom_flectorAtInfinity(self_: Point, other: FlectorAtInfinity) -> Flector {
    return scalar_wedge_flector(point_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn point_rejectViaOriginFrom_horizon(self_: Point, other: Horizon) -> Origin {
    return scalar_wedge_origin(point_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn point_rejectViaOriginFrom_motor(self_: Point, other: Motor) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(point_antiWedge_motor(self_, other), motor_dual(other));
}

fn point_rejectViaOriginFrom_multiVector(self_: Point, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(point_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn point_rejectViaOriginFrom_multiVectorAtInfinity(self_: Point, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return scalar_wedge_multiVectorAtOrigin(point_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn point_rejectViaOriginFrom_plane(self_: Point, other: Plane) -> Origin {
    return scalar_wedge_origin(point_antiWedge_plane(self_, other), plane_dual(other));
}

fn point_rejectViaOriginFrom_transflector(self_: Point, other: Transflector) -> Flector {
    return scalar_wedge_flector(point_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn point_rejectViaOriginFrom_translator(self_: Point, other: Translator) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(point_antiWedge_translator(self_, other), translator_dual(other));
}

fn pointAtInfinity_rejectViaOriginFrom_flector(self_: PointAtInfinity, other: Flector) -> Flector {
    return scalar_wedge_flector(pointAtInfinity_antiWedge_flector(self_, other), flector_dual(other));
}

fn pointAtInfinity_rejectViaOriginFrom_motor(self_: PointAtInfinity, other: Motor) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(pointAtInfinity_antiWedge_motor(self_, other), motor_dual(other));
}

fn pointAtInfinity_rejectViaOriginFrom_multiVector(self_: PointAtInfinity, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(pointAtInfinity_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn pointAtInfinity_rejectViaOriginFrom_plane(self_: PointAtInfinity, other: Plane) -> Origin {
    return scalar_wedge_origin(pointAtInfinity_antiWedge_plane(self_, other), plane_dual(other));
}

fn pointAtInfinity_rejectViaOriginFrom_transflector(self_: PointAtInfinity, other: Transflector) -> Flector {
    return scalar_wedge_flector(pointAtInfinity_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn pointAtInfinity_rejectViaOriginFrom_translator(self_: PointAtInfinity, other: Translator) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(pointAtInfinity_antiWedge_translator(self_, other), translator_dual(other));
}

fn rotor_rejectViaOriginFrom_flector(self_: Rotor, other: Flector) -> Motor {
    return flector_wedge_flector(rotor_antiWedge_flector(self_, other), flector_dual(other));
}

fn rotor_rejectViaOriginFrom_flectorAtInfinity(self_: Rotor, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(rotor_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn rotor_rejectViaOriginFrom_horizon(self_: Rotor, other: Horizon) -> Rotor {
    return flectorAtInfinity_wedge_origin(rotor_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn rotor_rejectViaOriginFrom_line(self_: Rotor, other: Line) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(rotor_antiWedge_line(self_, other), line_dual(other));
}

fn rotor_rejectViaOriginFrom_lineAtInfinity(self_: Rotor, other: LineAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_lineAtOrigin(rotor_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn rotor_rejectViaOriginFrom_motor(self_: Rotor, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(rotor_antiWedge_motor(self_, other), motor_dual(other));
}

fn rotor_rejectViaOriginFrom_multiVector(self_: Rotor, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(rotor_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn rotor_rejectViaOriginFrom_multiVectorAtInfinity(self_: Rotor, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(rotor_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn rotor_rejectViaOriginFrom_plane(self_: Rotor, other: Plane) -> Rotor {
    return flector_wedge_origin(rotor_antiWedge_plane(self_, other), plane_dual(other));
}

fn rotor_rejectViaOriginFrom_point(self_: Rotor, other: Point) -> AntiScalar {
    return point_wedge_planeAtOrigin(rotor_antiWedge_point(self_, other), point_dual(other));
}

fn rotor_rejectViaOriginFrom_pointAtInfinity(self_: Rotor, other: PointAtInfinity) -> AntiScalar {
    return pointAtInfinity_wedge_planeAtOrigin(rotor_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn rotor_rejectViaOriginFrom_transflector(self_: Rotor, other: Transflector) -> Motor {
    return flector_wedge_flector(rotor_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn rotor_rejectViaOriginFrom_translator(self_: Rotor, other: Translator) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(rotor_antiWedge_translator(self_, other), translator_dual(other));
}

fn transflector_rejectViaOriginFrom_flector(self_: Transflector, other: Flector) -> MultiVector {
    return multiVector_wedge_flector(transflector_antiWedge_flector(self_, other), flector_dual(other));
}

fn transflector_rejectViaOriginFrom_flectorAtInfinity(self_: Transflector, other: FlectorAtInfinity) -> MultiVector {
    return multiVectorAtInfinity_wedge_flector(transflector_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn transflector_rejectViaOriginFrom_horizon(self_: Transflector, other: Horizon) -> PlaneAtOrigin {
    return lineAtInfinity_wedge_origin(transflector_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn transflector_rejectViaOriginFrom_line(self_: Transflector, other: Line) -> PlaneAtOrigin {
    return point_wedge_lineAtOrigin(transflector_antiWedge_line(self_, other), line_dual(other));
}

fn transflector_rejectViaOriginFrom_lineAtInfinity(self_: Transflector, other: LineAtInfinity) -> PlaneAtOrigin {
    return pointAtInfinity_wedge_lineAtOrigin(transflector_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn transflector_rejectViaOriginFrom_motor(self_: Transflector, other: Motor) -> PlaneAtOrigin {
    return flector_wedge_lineAtOrigin(transflector_antiWedge_motor(self_, other), motor_dual(other));
}

fn transflector_rejectViaOriginFrom_multiVector(self_: Transflector, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(transflector_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn transflector_rejectViaOriginFrom_multiVectorAtInfinity(self_: Transflector, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(transflector_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn transflector_rejectViaOriginFrom_plane(self_: Transflector, other: Plane) -> MultiVectorAtOrigin {
    return multiVector_wedge_origin(transflector_antiWedge_plane(self_, other), plane_dual(other));
}

fn transflector_rejectViaOriginFrom_point(self_: Transflector, other: Point) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(transflector_antiWedge_point(self_, other), point_dual(other));
}

fn transflector_rejectViaOriginFrom_pointAtInfinity(self_: Transflector, other: PointAtInfinity) -> PlaneAtOrigin {
    return scalar_wedge_planeAtOrigin(transflector_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn transflector_rejectViaOriginFrom_transflector(self_: Transflector, other: Transflector) -> MultiVector {
    return multiVector_wedge_flector(transflector_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn transflector_rejectViaOriginFrom_translator(self_: Transflector, other: Translator) -> PlaneAtOrigin {
    return transflector_wedge_lineAtOrigin(transflector_antiWedge_translator(self_, other), translator_dual(other));
}

fn translator_rejectViaOriginFrom_flector(self_: Translator, other: Flector) -> Motor {
    return flector_wedge_flector(translator_antiWedge_flector(self_, other), flector_dual(other));
}

fn translator_rejectViaOriginFrom_flectorAtInfinity(self_: Translator, other: FlectorAtInfinity) -> Motor {
    return flectorAtInfinity_wedge_flector(translator_antiWedge_flectorAtInfinity(self_, other), flectorAtInfinity_dual(other));
}

fn translator_rejectViaOriginFrom_horizon(self_: Translator, other: Horizon) -> AntiScalar {
    return horizon_wedge_origin(translator_antiWedge_horizon(self_, other), horizon_dual(other));
}

fn translator_rejectViaOriginFrom_line(self_: Translator, other: Line) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(translator_antiWedge_line(self_, other), line_dual(other));
}

fn translator_rejectViaOriginFrom_lineAtInfinity(self_: Translator, other: LineAtInfinity) -> AntiScalar {
    return lineAtInfinity_wedge_lineAtOrigin(translator_antiWedge_lineAtInfinity(self_, other), lineAtInfinity_dual(other));
}

fn translator_rejectViaOriginFrom_motor(self_: Translator, other: Motor) -> MultiVectorAtOrigin {
    return multiVector_wedge_lineAtOrigin(translator_antiWedge_motor(self_, other), motor_dual(other));
}

fn translator_rejectViaOriginFrom_multiVector(self_: Translator, other: MultiVector) -> MultiVectorAtOrigin {
    return multiVector_wedge_multiVectorAtOrigin(translator_antiWedge_multiVector(self_, other), multiVector_dual(other));
}

fn translator_rejectViaOriginFrom_multiVectorAtInfinity(self_: Translator, other: MultiVectorAtInfinity) -> MultiVectorAtOrigin {
    return multiVectorAtInfinity_wedge_multiVectorAtOrigin(translator_antiWedge_multiVectorAtInfinity(self_, other), multiVectorAtInfinity_dual(other));
}

fn translator_rejectViaOriginFrom_plane(self_: Translator, other: Plane) -> Rotor {
    return transflector_wedge_origin(translator_antiWedge_plane(self_, other), plane_dual(other));
}

fn translator_rejectViaOriginFrom_point(self_: Translator, other: Point) -> AntiScalar {
    return point_wedge_planeAtOrigin(translator_antiWedge_point(self_, other), point_dual(other));
}

fn translator_rejectViaOriginFrom_pointAtInfinity(self_: Translator, other: PointAtInfinity) -> AntiScalar {
    return pointAtInfinity_wedge_planeAtOrigin(translator_antiWedge_pointAtInfinity(self_, other), pointAtInfinity_dual(other));
}

fn translator_rejectViaOriginFrom_transflector(self_: Translator, other: Transflector) -> Motor {
    return transflector_wedge_flector(translator_antiWedge_transflector(self_, other), transflector_dual(other));
}

fn translator_rejectViaOriginFrom_translator(self_: Translator, other: Translator) -> AntiScalar {
    return translator_wedge_lineAtOrigin(translator_antiWedge_translator(self_, other), translator_dual(other));
}

fn dualNum_antiSupport(self_: DualNum) -> Horizon {
    return dualNum_wedge_horizon(self_, horizon_antiWedge_antiScalar(origin_rightComplement(origin_unit()), dualNum_dual(self_)));
}

fn flector_antiSupport(self_: Flector) -> MultiVector {
    return flector_wedge_multiVectorAtInfinity(self_, horizon_antiWedge_flector(origin_rightComplement(origin_unit()), flector_dual(self_)));
}

fn flectorAtInfinity_antiSupport(self_: FlectorAtInfinity) -> MultiVectorAtInfinity {
    return flectorAtInfinity_wedge_multiVectorAtInfinity(self_, horizon_antiWedge_flector(origin_rightComplement(origin_unit()), flectorAtInfinity_dual(self_)));
}

fn horizon_antiSupport(self_: Horizon) -> Horizon {
    return horizon_wedge_scalar(self_, horizon_antiWedge_origin(origin_rightComplement(origin_unit()), horizon_dual(self_)));
}

fn line_antiSupport(self_: Line) -> Plane {
    return line_wedge_pointAtInfinity(self_, horizon_antiWedge_lineAtOrigin(origin_rightComplement(origin_unit()), line_dual(self_)));
}

fn lineAtInfinity_antiSupport(self_: LineAtInfinity) -> Horizon {
    return lineAtInfinity_wedge_pointAtInfinity(self_, horizon_antiWedge_lineAtOrigin(origin_rightComplement(origin_unit()), lineAtInfinity_dual(self_)));
}

fn motor_antiSupport(self_: Motor) -> Plane {
    return motor_wedge_pointAtInfinity(self_, horizon_antiWedge_lineAtOrigin(origin_rightComplement(origin_unit()), motor_dual(self_)));
}

fn multiVector_antiSupport(self_: MultiVector) -> MultiVector {
    return multiVector_wedge_multiVectorAtInfinity(self_, horizon_antiWedge_multiVectorAtOrigin(origin_rightComplement(origin_unit()), multiVector_dual(self_)));
}

fn multiVectorAtInfinity_antiSupport(self_: MultiVectorAtInfinity) -> MultiVectorAtInfinity {
    return multiVectorAtInfinity_wedge_multiVectorAtInfinity(self_, horizon_antiWedge_multiVectorAtOrigin(origin_rightComplement(origin_unit()), multiVectorAtInfinity_dual(self_)));
}

fn plane_antiSupport(self_: Plane) -> Plane {
    return plane_wedge_scalar(self_, horizon_antiWedge_origin(origin_rightComplement(origin_unit()), plane_dual(self_)));
}

fn point_antiSupport(self_: Point) -> Plane {
    return point_wedge_lineAtInfinity(self_, horizon_antiWedge_planeAtOrigin(origin_rightComplement(origin_unit()), point_dual(self_)));
}

fn pointAtInfinity_antiSupport(self_: PointAtInfinity) -> Horizon {
    return pointAtInfinity_wedge_lineAtInfinity(self_, horizon_antiWedge_planeAtOrigin(origin_rightComplement(origin_unit()), pointAtInfinity_dual(self_)));
}

fn scalar_antiSupport(self_: Scalar) -> Horizon {
    return scalar_wedge_horizon(self_, horizon_antiWedge_antiScalar(origin_rightComplement(origin_unit()), scalar_dual(self_)));
}

fn transflector_antiSupport(self_: Transflector) -> MultiVector {
    return transflector_wedge_multiVectorAtInfinity(self_, horizon_antiWedge_flector(origin_rightComplement(origin_unit()), transflector_dual(self_)));
}

fn translator_antiSupport(self_: Translator) -> Horizon {
    return translator_wedge_pointAtInfinity(self_, horizon_antiWedge_lineAtOrigin(origin_rightComplement(origin_unit()), translator_dual(self_)));
}

fn flector_support(self_: Flector) -> Flector {
    return flector_antiWedge_rotor(self_, origin_wedge_flectorAtInfinity(origin_unit(), flector_antiDual(self_)));
}

fn line_support(self_: Line) -> Point {
    return line_antiWedge_planeAtOrigin(self_, origin_wedge_lineAtInfinity(origin_unit(), line_antiDual(self_)));
}

fn lineAtOrigin_support(self_: LineAtOrigin) -> Origin {
    return lineAtOrigin_antiWedge_planeAtOrigin(self_, origin_wedge_lineAtInfinity(origin_unit(), lineAtOrigin_antiDual(self_)));
}

fn motor_support(self_: Motor) -> MultiVector {
    return motor_antiWedge_multiVectorAtOrigin(self_, origin_wedge_multiVectorAtInfinity(origin_unit(), motor_antiDual(self_)));
}

fn multiVector_support(self_: MultiVector) -> MultiVector {
    return multiVector_antiWedge_multiVectorAtOrigin(self_, origin_wedge_multiVectorAtInfinity(origin_unit(), multiVector_antiDual(self_)));
}

fn multiVectorAtOrigin_support(self_: MultiVectorAtOrigin) -> MultiVectorAtOrigin {
    return multiVectorAtOrigin_antiWedge_multiVectorAtOrigin(self_, origin_wedge_multiVectorAtInfinity(origin_unit(), multiVectorAtOrigin_antiDual(self_)));
}

fn origin_support(self_: Origin) -> Origin {
    return origin_antiWedge_antiScalar(self_, origin_wedge_horizon(origin_unit(), origin_antiDual(self_)));
}

fn plane_support(self_: Plane) -> Point {
    return plane_antiWedge_lineAtOrigin(self_, origin_wedge_pointAtInfinity(origin_unit(), plane_antiDual(self_)));
}

fn planeAtOrigin_support(self_: PlaneAtOrigin) -> Origin {
    return planeAtOrigin_antiWedge_lineAtOrigin(self_, origin_wedge_pointAtInfinity(origin_unit(), planeAtOrigin_antiDual(self_)));
}

fn point_support(self_: Point) -> Point {
    return point_antiWedge_antiScalar(self_, origin_wedge_horizon(origin_unit(), point_antiDual(self_)));
}

fn rotor_support(self_: Rotor) -> MultiVectorAtOrigin {
    return rotor_antiWedge_multiVectorAtOrigin(self_, origin_wedge_multiVectorAtInfinity(origin_unit(), rotor_antiDual(self_)));
}

fn transflector_support(self_: Transflector) -> Point {
    return transflector_antiWedge_lineAtOrigin(self_, origin_wedge_pointAtInfinity(origin_unit(), transflector_antiDual(self_)));
}

fn line_cosineAngle_line(self_: Line, other: Line) -> DualNum {
    return scalar_add_antiScalar(line_antiWedge_lineAtInfinity(self_, line_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(line_weightNorm(self_), line_weightNorm(other)));
}

fn line_cosineAngle_lineAtOrigin(self_: Line, other: LineAtOrigin) -> DualNum {
    return scalar_add_antiScalar(line_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(line_weightNorm(self_), lineAtOrigin_weightNorm(other)));
}

fn line_cosineAngle_origin(self_: Line, other: Origin) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(line_antiWedge_horizon(self_, origin_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(line_weightNorm(self_), origin_weightNorm(other)));
}

fn line_cosineAngle_point(self_: Line, other: Point) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(line_antiWedge_horizon(self_, point_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(line_weightNorm(self_), point_weightNorm(other)));
}

fn lineAtOrigin_cosineAngle_line(self_: LineAtOrigin, other: Line) -> DualNum {
    return scalar_add_antiScalar(lineAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(lineAtOrigin_weightNorm(self_), line_weightNorm(other)));
}

fn lineAtOrigin_cosineAngle_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> DualNum {
    return scalar_add_antiScalar(lineAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(lineAtOrigin_weightNorm(self_), lineAtOrigin_weightNorm(other)));
}

fn lineAtOrigin_cosineAngle_origin(self_: LineAtOrigin, other: Origin) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(lineAtOrigin_antiWedge_horizon(self_, origin_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(lineAtOrigin_weightNorm(self_), origin_weightNorm(other)));
}

fn lineAtOrigin_cosineAngle_point(self_: LineAtOrigin, other: Point) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(lineAtOrigin_antiWedge_horizon(self_, point_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(lineAtOrigin_weightNorm(self_), point_weightNorm(other)));
}

fn origin_cosineAngle_origin(self_: Origin, other: Origin) -> DualNum {
    return scalar_add_antiScalar(origin_antiWedge_horizon(self_, origin_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(origin_weightNorm(self_), origin_weightNorm(other)));
}

fn origin_cosineAngle_point(self_: Origin, other: Point) -> DualNum {
    return scalar_add_antiScalar(origin_antiWedge_horizon(self_, point_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(origin_weightNorm(self_), point_weightNorm(other)));
}

fn plane_cosineAngle_line(self_: Plane, other: Line) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(plane_antiWedge_lineAtInfinity(self_, line_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(plane_weightNorm(self_), line_weightNorm(other)));
}

fn plane_cosineAngle_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(plane_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(plane_weightNorm(self_), lineAtOrigin_weightNorm(other)));
}

fn plane_cosineAngle_origin(self_: Plane, other: Origin) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(plane_antiWedge_horizon(self_, origin_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(plane_weightNorm(self_), origin_weightNorm(other)));
}

fn plane_cosineAngle_plane(self_: Plane, other: Plane) -> DualNum {
    return scalar_add_antiScalar(plane_antiWedge_pointAtInfinity(self_, plane_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(plane_weightNorm(self_), plane_weightNorm(other)));
}

fn plane_cosineAngle_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> DualNum {
    return scalar_add_antiScalar(plane_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(plane_weightNorm(self_), planeAtOrigin_weightNorm(other)));
}

fn plane_cosineAngle_point(self_: Plane, other: Point) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(plane_antiWedge_horizon(self_, point_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(plane_weightNorm(self_), point_weightNorm(other)));
}

fn planeAtOrigin_cosineAngle_line(self_: PlaneAtOrigin, other: Line) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(planeAtOrigin_antiWedge_lineAtInfinity(self_, line_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(planeAtOrigin_weightNorm(self_), line_weightNorm(other)));
}

fn planeAtOrigin_cosineAngle_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(planeAtOrigin_antiWedge_lineAtInfinity(self_, lineAtOrigin_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(planeAtOrigin_weightNorm(self_), lineAtOrigin_weightNorm(other)));
}

fn planeAtOrigin_cosineAngle_origin(self_: PlaneAtOrigin, other: Origin) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(planeAtOrigin_antiWedge_horizon(self_, origin_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(planeAtOrigin_weightNorm(self_), origin_weightNorm(other)));
}

fn planeAtOrigin_cosineAngle_plane(self_: PlaneAtOrigin, other: Plane) -> DualNum {
    return scalar_add_antiScalar(planeAtOrigin_antiWedge_pointAtInfinity(self_, plane_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(planeAtOrigin_weightNorm(self_), plane_weightNorm(other)));
}

fn planeAtOrigin_cosineAngle_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> DualNum {
    return scalar_add_antiScalar(planeAtOrigin_antiWedge_pointAtInfinity(self_, planeAtOrigin_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(planeAtOrigin_weightNorm(self_), planeAtOrigin_weightNorm(other)));
}

fn planeAtOrigin_cosineAngle_point(self_: PlaneAtOrigin, other: Point) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(planeAtOrigin_antiWedge_horizon(self_, point_antiDual(other))), antiScalar_geometricAntiProduct_antiScalar(planeAtOrigin_weightNorm(self_), point_weightNorm(other)));
}

fn point_cosineAngle_origin(self_: Point, other: Origin) -> DualNum {
    return scalar_add_antiScalar(point_antiWedge_horizon(self_, origin_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(point_weightNorm(self_), origin_weightNorm(other)));
}

fn point_cosineAngle_point(self_: Point, other: Point) -> DualNum {
    return scalar_add_antiScalar(point_antiWedge_horizon(self_, point_antiDual(other)), antiScalar_geometricAntiProduct_antiScalar(point_weightNorm(self_), point_weightNorm(other)));
}

fn line_distance_line(self_: Line, other: Line) -> DualNum {
    return scalar_add_antiScalar(line_antiWedge_line(self_, other), plane_weightNorm(line_wedge_pointAtInfinity(self_, line_attitude(other))));
}

fn line_distance_lineAtOrigin(self_: Line, other: LineAtOrigin) -> DualNum {
    return scalar_add_antiScalar(line_antiWedge_lineAtOrigin(self_, other), plane_weightNorm(line_wedge_pointAtInfinity(self_, lineAtOrigin_attitude(other))));
}

fn line_distance_origin(self_: Line, other: Origin) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(planeAtOrigin_attitude(line_wedge_origin(self_, other))), line_weightNorm(line_wedge_scalar(self_, origin_attitude(other))));
}

fn line_distance_point(self_: Line, other: Point) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(plane_attitude(line_wedge_point(self_, other))), line_weightNorm(line_wedge_scalar(self_, point_attitude(other))));
}

fn lineAtOrigin_distance_line(self_: LineAtOrigin, other: Line) -> DualNum {
    return scalar_add_antiScalar(lineAtOrigin_antiWedge_line(self_, other), planeAtOrigin_weightNorm(lineAtOrigin_wedge_pointAtInfinity(self_, line_attitude(other))));
}

fn lineAtOrigin_distance_point(self_: LineAtOrigin, other: Point) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(planeAtOrigin_attitude(lineAtOrigin_wedge_point(self_, other))), lineAtOrigin_weightNorm(lineAtOrigin_wedge_scalar(self_, point_attitude(other))));
}

fn origin_distance_line(self_: Origin, other: Line) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(planeAtOrigin_attitude(origin_wedge_line(self_, other))), lineAtOrigin_weightNorm(origin_wedge_pointAtInfinity(self_, line_attitude(other))));
}

fn origin_distance_plane(self_: Origin, other: Plane) -> DualNum {
    return scalar_add_antiScalar(origin_antiWedge_plane(self_, other), planeAtOrigin_weightNorm(origin_wedge_lineAtInfinity(self_, plane_attitude(other))));
}

fn origin_distance_point(self_: Origin, other: Point) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(lineAtOrigin_attitude(origin_wedge_point(self_, other))), origin_weightNorm(origin_wedge_scalar(self_, point_attitude(other))));
}

fn plane_distance_origin(self_: Plane, other: Origin) -> DualNum {
    return scalar_add_antiScalar(plane_antiWedge_origin(self_, other), plane_weightNorm(plane_wedge_scalar(self_, origin_attitude(other))));
}

fn plane_distance_point(self_: Plane, other: Point) -> DualNum {
    return scalar_add_antiScalar(plane_antiWedge_point(self_, other), plane_weightNorm(plane_wedge_scalar(self_, point_attitude(other))));
}

fn planeAtOrigin_distance_point(self_: PlaneAtOrigin, other: Point) -> DualNum {
    return scalar_add_antiScalar(planeAtOrigin_antiWedge_point(self_, other), planeAtOrigin_weightNorm(planeAtOrigin_wedge_scalar(self_, point_attitude(other))));
}

fn point_distance_line(self_: Point, other: Line) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(plane_attitude(point_wedge_line(self_, other))), line_weightNorm(point_wedge_pointAtInfinity(self_, line_attitude(other))));
}

fn point_distance_lineAtOrigin(self_: Point, other: LineAtOrigin) -> DualNum {
    return scalar_add_antiScalar(lineAtInfinity_bulkNorm(planeAtOrigin_attitude(point_wedge_lineAtOrigin(self_, other))), line_weightNorm(point_wedge_pointAtInfinity(self_, lineAtOrigin_attitude(other))));
}

fn point_distance_origin(self_: Point, other: Origin) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(lineAtOrigin_attitude(point_wedge_origin(self_, other))), point_weightNorm(point_wedge_scalar(self_, origin_attitude(other))));
}

fn point_distance_plane(self_: Point, other: Plane) -> DualNum {
    return scalar_add_antiScalar(point_antiWedge_plane(self_, other), plane_weightNorm(point_wedge_lineAtInfinity(self_, plane_attitude(other))));
}

fn point_distance_planeAtOrigin(self_: Point, other: PlaneAtOrigin) -> DualNum {
    return scalar_add_antiScalar(point_antiWedge_planeAtOrigin(self_, other), plane_weightNorm(point_wedge_lineAtInfinity(self_, planeAtOrigin_attitude(other))));
}

fn point_distance_point(self_: Point, other: Point) -> DualNum {
    return scalar_add_antiScalar(pointAtInfinity_bulkNorm(line_attitude(point_wedge_point(self_, other))), point_weightNorm(point_wedge_scalar(self_, point_attitude(other))));
}

fn line_sineAngle_line(self_: Line, other: Line) -> DualNum {
    let cos: DualNum = line_cosineAngle_line(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn line_sineAngle_lineAtOrigin(self_: Line, other: LineAtOrigin) -> DualNum {
    let cos: DualNum = line_cosineAngle_lineAtOrigin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn line_sineAngle_origin(self_: Line, other: Origin) -> DualNum {
    let cos: DualNum = line_cosineAngle_origin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn line_sineAngle_point(self_: Line, other: Point) -> DualNum {
    let cos: DualNum = line_cosineAngle_point(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn lineAtOrigin_sineAngle_line(self_: LineAtOrigin, other: Line) -> DualNum {
    let cos: DualNum = lineAtOrigin_cosineAngle_line(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn lineAtOrigin_sineAngle_lineAtOrigin(self_: LineAtOrigin, other: LineAtOrigin) -> DualNum {
    let cos: DualNum = lineAtOrigin_cosineAngle_lineAtOrigin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn lineAtOrigin_sineAngle_origin(self_: LineAtOrigin, other: Origin) -> DualNum {
    let cos: DualNum = lineAtOrigin_cosineAngle_origin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn lineAtOrigin_sineAngle_point(self_: LineAtOrigin, other: Point) -> DualNum {
    let cos: DualNum = lineAtOrigin_cosineAngle_point(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn origin_sineAngle_origin(self_: Origin, other: Origin) -> DualNum {
    let cos: DualNum = origin_cosineAngle_origin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn origin_sineAngle_point(self_: Origin, other: Point) -> DualNum {
    let cos: DualNum = origin_cosineAngle_point(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn plane_sineAngle_line(self_: Plane, other: Line) -> DualNum {
    let cos: DualNum = plane_cosineAngle_line(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn plane_sineAngle_lineAtOrigin(self_: Plane, other: LineAtOrigin) -> DualNum {
    let cos: DualNum = plane_cosineAngle_lineAtOrigin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn plane_sineAngle_origin(self_: Plane, other: Origin) -> DualNum {
    let cos: DualNum = plane_cosineAngle_origin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn plane_sineAngle_plane(self_: Plane, other: Plane) -> DualNum {
    let cos: DualNum = plane_cosineAngle_plane(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn plane_sineAngle_planeAtOrigin(self_: Plane, other: PlaneAtOrigin) -> DualNum {
    let cos: DualNum = plane_cosineAngle_planeAtOrigin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn plane_sineAngle_point(self_: Plane, other: Point) -> DualNum {
    let cos: DualNum = plane_cosineAngle_point(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn planeAtOrigin_sineAngle_line(self_: PlaneAtOrigin, other: Line) -> DualNum {
    let cos: DualNum = planeAtOrigin_cosineAngle_line(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn planeAtOrigin_sineAngle_lineAtOrigin(self_: PlaneAtOrigin, other: LineAtOrigin) -> DualNum {
    let cos: DualNum = planeAtOrigin_cosineAngle_lineAtOrigin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn planeAtOrigin_sineAngle_origin(self_: PlaneAtOrigin, other: Origin) -> DualNum {
    let cos: DualNum = planeAtOrigin_cosineAngle_origin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn planeAtOrigin_sineAngle_plane(self_: PlaneAtOrigin, other: Plane) -> DualNum {
    let cos: DualNum = planeAtOrigin_cosineAngle_plane(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn planeAtOrigin_sineAngle_planeAtOrigin(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> DualNum {
    let cos: DualNum = planeAtOrigin_cosineAngle_planeAtOrigin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn planeAtOrigin_sineAngle_point(self_: PlaneAtOrigin, other: Point) -> DualNum {
    let cos: DualNum = planeAtOrigin_cosineAngle_point(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn point_sineAngle_origin(self_: Point, other: Origin) -> DualNum {
    let cos: DualNum = point_cosineAngle_origin(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

fn point_sineAngle_point(self_: Point, other: Point) -> DualNum {
    let cos: DualNum = point_cosineAngle_point(self_, other);
    let cos_squared: DualNum = dualNum_geometricProduct_dualNum(cos, cos);
    let sub: DualNum = dualNum_sub_dualNum(dualNum_unit(), cos_squared);
    return dualNum_sqrt(sub);
}

