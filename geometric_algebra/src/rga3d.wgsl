struct Scalar {
    // 1
     g0: f32,
}

struct AntiScalar {
    // e1234
     g0: f32,
}

struct Magnitude {
    // 1, e1234
     g0: vec2<f32>,
}

struct Point {
    // e1, e2, e3, e4
     g0: vec4<f32>,
}

struct Origin {
    // e4
     g0: f32,
}

struct PointAtInfinity {
    // e1, e2, e3
     g0: vec3<f32>,
}

struct Line {
    // -e14, -e24, -e34
     g0: vec3<f32>,
    // e23, -e13, e12
     g1: vec3<f32>,
}

struct LineAtOrigin {
    // -e14, -e24, -e34
     g0: vec3<f32>,
}

struct LineAtInfinity {
    // e23, -e13, e12
     g0: vec3<f32>,
}

struct Plane {
    // e234, -e134, e124, -e123
     g0: vec4<f32>,
}

struct PlaneAtOrigin {
    // e234, -e134, e124
     g0: vec3<f32>,
}

struct Horizon {
    // -e123
     g0: f32,
}

struct Motor {
    // -e14, -e24, -e34, e1234
     g0: vec4<f32>,
    // e23, -e13, e12
     g1: vec3<f32>,
}

struct Rotor {
    // -e14, -e24, -e34, e1234
     g0: vec4<f32>,
}

struct Translator {
    // e23, -e13, e12, e1234
     g0: vec4<f32>,
}

struct Flector {
    // e1, e2, e3, e4
     g0: vec4<f32>,
    // e234, -e134, e124, -e123
     g1: vec4<f32>,
}

struct MultiVector {
    // 1, e1234
     g0: vec2<f32>,
    // e1, e2, e3, e4
     g1: vec4<f32>,
    // -e14, -e24, -e34
     g2: vec3<f32>,
    // e23, -e13, e12
     g3: vec3<f32>,
    // e234, -e134, e124, -e123
     g4: vec4<f32>,
}

fn anti_scalar_one() -> AntiScalar {
    return AntiScalar(0.0);
}

fn flector_one() -> Flector {
    return Flector(vec4<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_one() -> Horizon {
    return Horizon(0.0);
}

fn line_one() -> Line {
    return Line(vec3<f32>(0.0), vec3<f32>(0.0));
}

fn line_at_infinity_one() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0));
}

fn line_at_origin_one() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0));
}

fn magnitude_one() -> Magnitude {
    return Magnitude(vec2<f32>(1.0, 0.0));
}

fn motor_one() -> Motor {
    return Motor(vec4<f32>(0.0), vec3<f32>(0.0));
}

fn multi_vector_one() -> MultiVector {
    return MultiVector(vec2<f32>(1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_one() -> Origin {
    return Origin(0.0);
}

fn plane_one() -> Plane {
    return Plane(vec4<f32>(0.0));
}

fn plane_at_origin_one() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0));
}

fn point_one() -> Point {
    return Point(vec4<f32>(0.0));
}

fn point_at_infinity_one() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0));
}

fn rotor_one() -> Rotor {
    return Rotor(vec4<f32>(0.0));
}

fn scalar_one() -> Scalar {
    return Scalar(1.0);
}

fn translator_one() -> Translator {
    return Translator(vec4<f32>(0.0));
}

fn anti_scalar_zero() -> AntiScalar {
    return AntiScalar(0.0);
}

fn flector_zero() -> Flector {
    return Flector(vec4<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_zero() -> Horizon {
    return Horizon(0.0);
}

fn line_zero() -> Line {
    return Line(vec3<f32>(0.0), vec3<f32>(0.0));
}

fn line_at_infinity_zero() -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0));
}

fn line_at_origin_zero() -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0));
}

fn magnitude_zero() -> Magnitude {
    return Magnitude(vec2<f32>(0.0));
}

fn motor_zero() -> Motor {
    return Motor(vec4<f32>(0.0), vec3<f32>(0.0));
}

fn multi_vector_zero() -> MultiVector {
    return MultiVector(vec2<f32>(0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_zero() -> Origin {
    return Origin(0.0);
}

fn plane_zero() -> Plane {
    return Plane(vec4<f32>(0.0));
}

fn plane_at_origin_zero() -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0));
}

fn point_zero() -> Point {
    return Point(vec4<f32>(0.0));
}

fn point_at_infinity_zero() -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0));
}

fn rotor_zero() -> Rotor {
    return Rotor(vec4<f32>(0.0));
}

fn scalar_zero() -> Scalar {
    return Scalar(0.0);
}

fn translator_zero() -> Translator {
    return Translator(vec4<f32>(0.0));
}

fn anti_scalar_neg(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * -1.0);
}

fn flector_neg(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn horizon_neg(self_: Horizon) -> Horizon {
    return Horizon(self_.g0 * -1.0);
}

fn line_neg(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec3<f32>(-1.0));
}

fn line_at_infinity_neg(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_neg(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn magnitude_neg(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(-1.0));
}

fn motor_neg(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0), self_.g1 * vec3<f32>(-1.0));
}

fn multi_vector_neg(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(-1.0), self_.g1 * vec4<f32>(-1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0), self_.g3 * vec3<f32>(-1.0), self_.g4 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn origin_neg(self_: Origin) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn plane_neg(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn plane_at_origin_neg(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn point_neg(self_: Point) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn point_at_infinity_neg(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn rotor_neg(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, -1.0));
}

fn scalar_neg(self_: Scalar) -> Scalar {
    return Scalar(self_.g0 * -1.0);
}

fn translator_neg(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0));
}

fn anti_scalar_anti_scalar_add(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 + other.g0);
}

fn anti_scalar_line_add(self_: AntiScalar, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), other.g1);
}

fn anti_scalar_line_at_infinity_add(self_: AntiScalar, other: LineAtInfinity) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_line_at_origin_add(self_: AntiScalar, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_magnitude_add(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) + other.g0);
}

fn anti_scalar_motor_add(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0, other.g1);
}

fn anti_scalar_multi_vector_add(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0) + other.g0, other.g1, other.g2, other.g3, other.g4);
}

fn anti_scalar_rotor_add(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn anti_scalar_scalar_add(self_: AntiScalar, other: Scalar) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) + vec2<f32>(other.g0, 0.0));
}

fn anti_scalar_translator_add(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn flector_flector_add(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn flector_horizon_add(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g0, self_.g1 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_multi_vector_add(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, self_.g0 + other.g1, other.g2, other.g3, self_.g1 + other.g4);
}

fn flector_origin_add(self_: Flector, other: Origin) -> Flector {
    return Flector(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn flector_plane_add(self_: Flector, other: Plane) -> Flector {
    return Flector(self_.g0, self_.g1 + other.g0);
}

fn flector_plane_at_origin_add(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0, self_.g1 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_point_add(self_: Flector, other: Point) -> Flector {
    return Flector(self_.g0 + other.g0, self_.g1);
}

fn flector_point_at_infinity_add(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn horizon_flector_add(self_: Horizon, other: Flector) -> Flector {
    return Flector(other.g0, vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g1);
}

fn horizon_horizon_add(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 + other.g0);
}

fn horizon_multi_vector_add(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g4);
}

fn horizon_plane_add(self_: Horizon, other: Plane) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn horizon_plane_at_origin_add(self_: Horizon, other: PlaneAtOrigin) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn line_anti_scalar_add(self_: Line, other: AntiScalar) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn line_line_add(self_: Line, other: Line) -> Line {
    return Line(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn line_line_at_infinity_add(self_: Line, other: LineAtInfinity) -> Line {
    return Line(self_.g0, self_.g1 + other.g0);
}

fn line_line_at_origin_add(self_: Line, other: LineAtOrigin) -> Line {
    return Line(self_.g0 + other.g0, self_.g1);
}

fn line_motor_add(self_: Line, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, self_.g1 + other.g1);
}

fn line_multi_vector_add(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, self_.g0 + other.g2, self_.g1 + other.g3, other.g4);
}

fn line_rotor_add(self_: Line, other: Rotor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, self_.g1);
}

fn line_translator_add(self_: Line, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn line_at_infinity_anti_scalar_add(self_: LineAtInfinity, other: AntiScalar) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_infinity_line_add(self_: LineAtInfinity, other: Line) -> Line {
    return Line(other.g0, self_.g0 + other.g1);
}

fn line_at_infinity_line_at_infinity_add(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 + other.g0);
}

fn line_at_infinity_line_at_origin_add(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return Line(other.g0, self_.g0);
}

fn line_at_infinity_motor_add(self_: LineAtInfinity, other: Motor) -> Motor {
    return Motor(other.g0, self_.g0 + other.g1);
}

fn line_at_infinity_multi_vector_add(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, self_.g0 + other.g3, other.g4);
}

fn line_at_infinity_rotor_add(self_: LineAtInfinity, other: Rotor) -> Motor {
    return Motor(other.g0, self_.g0);
}

fn line_at_infinity_translator_add(self_: LineAtInfinity, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn line_at_origin_anti_scalar_add(self_: LineAtOrigin, other: AntiScalar) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_origin_line_add(self_: LineAtOrigin, other: Line) -> Line {
    return Line(self_.g0 + other.g0, other.g1);
}

fn line_at_origin_line_at_infinity_add(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return Line(self_.g0, other.g0);
}

fn line_at_origin_line_at_origin_add(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 + other.g0);
}

fn line_at_origin_motor_add(self_: LineAtOrigin, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, other.g1);
}

fn line_at_origin_multi_vector_add(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, self_.g0 + other.g2, other.g3, other.g4);
}

fn line_at_origin_rotor_add(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn line_at_origin_translator_add(self_: LineAtOrigin, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn magnitude_anti_scalar_add(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 + vec2<f32>(0.0, other.g0));
}

fn magnitude_magnitude_add(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 + other.g0);
}

fn magnitude_multi_vector_add(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 + other.g0, other.g1, other.g2, other.g3, other.g4);
}

fn magnitude_scalar_add(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 + vec2<f32>(other.g0, 0.0));
}

fn motor_anti_scalar_add(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn motor_line_add(self_: Motor, other: Line) -> Motor {
    return Motor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 + other.g1);
}

fn motor_line_at_infinity_add(self_: Motor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, self_.g1 + other.g0);
}

fn motor_line_at_origin_add(self_: Motor, other: LineAtOrigin) -> Motor {
    return Motor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn motor_motor_add(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0 + other.g0, self_.g1 + other.g1);
}

fn motor_multi_vector_add(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) + other.g0, other.g1, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g2, self_.g1 + other.g3, other.g4);
}

fn motor_rotor_add(self_: Motor, other: Rotor) -> Motor {
    return Motor(self_.g0 + other.g0, self_.g1);
}

fn motor_translator_add(self_: Motor, other: Translator) -> Motor {
    return Motor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn multi_vector_anti_scalar_add(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0), self_.g1, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_flector_add(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 + other.g0, self_.g2, self_.g3, self_.g4 + other.g1);
}

fn multi_vector_horizon_add(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_add(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 + other.g0, self_.g3 + other.g1, self_.g4);
}

fn multi_vector_line_at_infinity_add(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3 + other.g0, self_.g4);
}

fn multi_vector_line_at_origin_add(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 + other.g0, self_.g3, self_.g4);
}

fn multi_vector_magnitude_add(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(self_.g0 + other.g0, self_.g1, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_motor_add(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g3 + other.g1, self_.g4);
}

fn multi_vector_multi_vector_add(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 + other.g0, self_.g1 + other.g1, self_.g2 + other.g2, self_.g3 + other.g3, self_.g4 + other.g4);
}

fn multi_vector_origin_add(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 + vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g2, self_.g3, self_.g4);
}

fn multi_vector_plane_add(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4 + other.g0);
}

fn multi_vector_plane_at_origin_add(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_point_add(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 + other.g0, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_point_at_infinity_add(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g2, self_.g3, self_.g4);
}

fn multi_vector_rotor_add(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g3, self_.g4);
}

fn multi_vector_scalar_add(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(other.g0, 0.0), self_.g1, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_translator_add(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 + vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3 + vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g4);
}

fn origin_flector_add(self_: Origin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0, other.g1);
}

fn origin_multi_vector_add(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g1, other.g2, other.g3, other.g4);
}

fn origin_origin_add(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 + other.g0);
}

fn origin_point_add(self_: Origin, other: Point) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + other.g0);
}

fn origin_point_at_infinity_add(self_: Origin, other: PointAtInfinity) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_flector_add(self_: Plane, other: Flector) -> Flector {
    return Flector(other.g0, self_.g0 + other.g1);
}

fn plane_horizon_add(self_: Plane, other: Horizon) -> Plane {
    return Plane(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_multi_vector_add(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, self_.g0 + other.g4);
}

fn plane_plane_add(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0 + other.g0);
}

fn plane_plane_at_origin_add(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return Plane(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_point_add(self_: Plane, other: Point) -> Flector {
    return Flector(other.g0, self_.g0);
}

fn plane_at_origin_flector_add(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return Flector(other.g0, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g1);
}

fn plane_at_origin_horizon_add(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_at_origin_multi_vector_add(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, other.g1, other.g2, other.g3, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g4);
}

fn plane_at_origin_plane_add(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn plane_at_origin_plane_at_origin_add(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 + other.g0);
}

fn point_flector_add(self_: Point, other: Flector) -> Flector {
    return Flector(self_.g0 + other.g0, other.g1);
}

fn point_multi_vector_add(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, self_.g0 + other.g1, other.g2, other.g3, other.g4);
}

fn point_origin_add(self_: Point, other: Origin) -> Point {
    return Point(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn point_plane_add(self_: Point, other: Plane) -> Flector {
    return Flector(self_.g0, other.g0);
}

fn point_point_add(self_: Point, other: Point) -> Point {
    return Point(self_.g0 + other.g0);
}

fn point_point_at_infinity_add(self_: Point, other: PointAtInfinity) -> Point {
    return Point(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_infinity_flector_add(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0, other.g1);
}

fn point_at_infinity_multi_vector_add(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(other.g0, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g1, other.g2, other.g3, other.g4);
}

fn point_at_infinity_origin_add(self_: PointAtInfinity, other: Origin) -> Point {
    return Point(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn point_at_infinity_point_add(self_: PointAtInfinity, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) + other.g0);
}

fn point_at_infinity_point_at_infinity_add(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 + other.g0);
}

fn rotor_anti_scalar_add(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_add(self_: Rotor, other: Line) -> Motor {
    return Motor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), other.g1);
}

fn rotor_line_at_infinity_add(self_: Rotor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, other.g0);
}

fn rotor_line_at_origin_add(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_motor_add(self_: Rotor, other: Motor) -> Motor {
    return Motor(self_.g0 + other.g0, other.g1);
}

fn rotor_multi_vector_add(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) + other.g0, other.g1, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g2, other.g3, other.g4);
}

fn rotor_rotor_add(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0 + other.g0);
}

fn rotor_translator_add(self_: Rotor, other: Translator) -> Motor {
    return Motor(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn scalar_anti_scalar_add(self_: Scalar, other: AntiScalar) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) + vec2<f32>(0.0, other.g0));
}

fn scalar_magnitude_add(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) + other.g0);
}

fn scalar_multi_vector_add(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0, 0.0) + other.g0, other.g1, other.g2, other.g3, other.g4);
}

fn scalar_scalar_add(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 + other.g0);
}

fn translator_anti_scalar_add(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 + vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn translator_line_add(self_: Translator, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g1);
}

fn translator_line_at_infinity_add(self_: Translator, other: LineAtInfinity) -> Translator {
    return Translator(self_.g0 + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_line_at_origin_add(self_: Translator, other: LineAtOrigin) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_motor_add(self_: Translator, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g1);
}

fn translator_multi_vector_add(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) + other.g0, other.g1, other.g2, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) + other.g3, other.g4);
}

fn translator_rotor_add(self_: Translator, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) + other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_translator_add(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0 + other.g0);
}

fn anti_scalar_anti_scalar_div(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn flector_flector_div(self_: Flector, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn horizon_horizon_div(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn line_line_div(self_: Line, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn line_at_infinity_line_at_infinity_div(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn line_at_origin_line_at_origin_div(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn magnitude_magnitude_div(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x, self_.g0.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g0.x, other.g0.y) * vec2<f32>(1.0, 1.0));
}

fn motor_motor_div(self_: Motor, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g1.x, other.g1.y, other.g1.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn multi_vector_multi_vector_div(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x, self_.g0.y) * vec2<f32>(1.0, 1.0) / vec2<f32>(other.g0.x, other.g0.y) * vec2<f32>(1.0, 1.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g2.x, other.g2.y, other.g2.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g3.x, self_.g3.y, self_.g3.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g3.x, other.g3.y, other.g3.z) * vec3<f32>(1.0, 1.0, 1.0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g4.x, other.g4.y, other.g4.z, other.g4.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn origin_origin_div(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn plane_plane_div(self_: Plane, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn plane_at_origin_plane_at_origin_div(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn point_point_div(self_: Point, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn point_at_infinity_point_at_infinity_div(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0) / vec3<f32>(other.g0.x, other.g0.y, other.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn rotor_rotor_div(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn scalar_scalar_div(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * 1.0 / other.g0 * 1.0);
}

fn translator_translator_div(self_: Translator, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0) / vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn flector_horizon_into(self_: Flector) -> Horizon {
    return Horizon(self_.g1.w);
}

fn flector_origin_into(self_: Flector) -> Origin {
    return Origin(self_.g0.w);
}

fn flector_plane_into(self_: Flector) -> Plane {
    return Plane(self_.g1);
}

fn flector_plane_at_origin_into(self_: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z));
}

fn flector_point_into(self_: Flector) -> Point {
    return Point(self_.g0);
}

fn flector_point_at_infinity_into(self_: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn line_line_at_infinity_into(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(self_.g1);
}

fn line_line_at_origin_into(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(self_.g0);
}

fn magnitude_anti_scalar_into(self_: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.y);
}

fn magnitude_scalar_into(self_: Magnitude) -> Scalar {
    return Scalar(self_.g0.x);
}

fn motor_anti_scalar_into(self_: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn motor_line_into(self_: Motor) -> Line {
    return Line(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z), self_.g1);
}

fn motor_line_at_infinity_into(self_: Motor) -> LineAtInfinity {
    return LineAtInfinity(self_.g1);
}

fn motor_line_at_origin_into(self_: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn motor_rotor_into(self_: Motor) -> Rotor {
    return Rotor(self_.g0);
}

fn motor_translator_into(self_: Motor) -> Translator {
    return Translator(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g0.w));
}

fn multi_vector_anti_scalar_into(self_: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.y);
}

fn multi_vector_flector_into(self_: MultiVector) -> Flector {
    return Flector(self_.g1, self_.g4);
}

fn multi_vector_horizon_into(self_: MultiVector) -> Horizon {
    return Horizon(self_.g4.w);
}

fn multi_vector_line_into(self_: MultiVector) -> Line {
    return Line(self_.g2, self_.g3);
}

fn multi_vector_line_at_infinity_into(self_: MultiVector) -> LineAtInfinity {
    return LineAtInfinity(self_.g3);
}

fn multi_vector_line_at_origin_into(self_: MultiVector) -> LineAtOrigin {
    return LineAtOrigin(self_.g2);
}

fn multi_vector_magnitude_into(self_: MultiVector) -> Magnitude {
    return Magnitude(self_.g0);
}

fn multi_vector_motor_into(self_: MultiVector) -> Motor {
    return Motor(vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g0.y), self_.g3);
}

fn multi_vector_origin_into(self_: MultiVector) -> Origin {
    return Origin(self_.g1.w);
}

fn multi_vector_plane_into(self_: MultiVector) -> Plane {
    return Plane(self_.g4);
}

fn multi_vector_plane_at_origin_into(self_: MultiVector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z));
}

fn multi_vector_point_into(self_: MultiVector) -> Point {
    return Point(self_.g1);
}

fn multi_vector_point_at_infinity_into(self_: MultiVector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z));
}

fn multi_vector_rotor_into(self_: MultiVector) -> Rotor {
    return Rotor(vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g0.y));
}

fn multi_vector_scalar_into(self_: MultiVector) -> Scalar {
    return Scalar(self_.g0.x);
}

fn multi_vector_translator_into(self_: MultiVector) -> Translator {
    return Translator(vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g0.y));
}

fn plane_horizon_into(self_: Plane) -> Horizon {
    return Horizon(self_.g0.w);
}

fn plane_plane_at_origin_into(self_: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn point_origin_into(self_: Point) -> Origin {
    return Origin(self_.g0.w);
}

fn point_point_at_infinity_into(self_: Point) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn rotor_anti_scalar_into(self_: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn rotor_line_at_origin_into(self_: Rotor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_anti_scalar_into(self_: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w);
}

fn translator_line_at_infinity_into(self_: Translator) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn anti_scalar_anti_scalar_mul(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn flector_flector_mul(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn horizon_horizon_mul(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn line_line_mul(self_: Line, other: Line) -> Line {
    return Line(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn line_at_infinity_line_at_infinity_mul(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * other.g0);
}

fn line_at_origin_line_at_origin_mul(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * other.g0);
}

fn magnitude_magnitude_mul(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 * other.g0);
}

fn motor_motor_mul(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0 * other.g0, self_.g1 * other.g1);
}

fn multi_vector_multi_vector_mul(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 * other.g0, self_.g1 * other.g1, self_.g2 * other.g2, self_.g3 * other.g3, self_.g4 * other.g4);
}

fn origin_origin_mul(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn plane_plane_mul(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0 * other.g0);
}

fn plane_at_origin_plane_at_origin_mul(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * other.g0);
}

fn point_point_mul(self_: Point, other: Point) -> Point {
    return Point(self_.g0 * other.g0);
}

fn point_at_infinity_point_at_infinity_mul(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * other.g0);
}

fn rotor_rotor_mul(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0 * other.g0);
}

fn scalar_scalar_mul(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn translator_translator_mul(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0 * other.g0);
}

fn anti_scalar_anti_scalar_sub(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 - other.g0);
}

fn anti_scalar_line_sub(self_: AntiScalar, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0) - other.g1);
}

fn anti_scalar_line_at_infinity_sub(self_: AntiScalar, other: LineAtInfinity) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_line_at_origin_sub(self_: AntiScalar, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn anti_scalar_magnitude_sub(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) - other.g0);
}

fn anti_scalar_motor_sub(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0, vec3<f32>(0.0) - other.g1);
}

fn anti_scalar_multi_vector_sub(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn anti_scalar_rotor_sub(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn anti_scalar_scalar_sub(self_: AntiScalar, other: Scalar) -> Magnitude {
    return Magnitude(vec2<f32>(0.0, self_.g0) - vec2<f32>(other.g0, 0.0));
}

fn anti_scalar_translator_sub(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn flector_flector_sub(self_: Flector, other: Flector) -> Flector {
    return Flector(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn flector_horizon_sub(self_: Flector, other: Horizon) -> Flector {
    return Flector(self_.g0, self_.g1 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn flector_multi_vector_sub(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, self_.g0 - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, self_.g1 - other.g4);
}

fn flector_origin_sub(self_: Flector, other: Origin) -> Flector {
    return Flector(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn flector_plane_sub(self_: Flector, other: Plane) -> Flector {
    return Flector(self_.g0, self_.g1 - other.g0);
}

fn flector_plane_at_origin_sub(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return Flector(self_.g0, self_.g1 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_point_sub(self_: Flector, other: Point) -> Flector {
    return Flector(self_.g0 - other.g0, self_.g1);
}

fn flector_point_at_infinity_sub(self_: Flector, other: PointAtInfinity) -> Flector {
    return Flector(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn horizon_flector_sub(self_: Horizon, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g1);
}

fn horizon_horizon_sub(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.g0 - other.g0);
}

fn horizon_multi_vector_sub(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g4);
}

fn horizon_plane_sub(self_: Horizon, other: Plane) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn horizon_plane_at_origin_sub(self_: Horizon, other: PlaneAtOrigin) -> Plane {
    return Plane(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn line_anti_scalar_sub(self_: Line, other: AntiScalar) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn line_line_sub(self_: Line, other: Line) -> Line {
    return Line(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn line_line_at_infinity_sub(self_: Line, other: LineAtInfinity) -> Line {
    return Line(self_.g0, self_.g1 - other.g0);
}

fn line_line_at_origin_sub(self_: Line, other: LineAtOrigin) -> Line {
    return Line(self_.g0 - other.g0, self_.g1);
}

fn line_motor_sub(self_: Line, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, self_.g1 - other.g1);
}

fn line_multi_vector_sub(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0) - other.g1, self_.g0 - other.g2, self_.g1 - other.g3, vec4<f32>(0.0) - other.g4);
}

fn line_rotor_sub(self_: Line, other: Rotor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, self_.g1);
}

fn line_translator_sub(self_: Line, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn line_at_infinity_anti_scalar_sub(self_: LineAtInfinity, other: AntiScalar) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_infinity_line_sub(self_: LineAtInfinity, other: Line) -> Line {
    return Line(vec3<f32>(0.0) - other.g0, self_.g0 - other.g1);
}

fn line_at_infinity_line_at_infinity_sub(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 - other.g0);
}

fn line_at_infinity_line_at_origin_sub(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(0.0) - other.g0, self_.g0);
}

fn line_at_infinity_motor_sub(self_: LineAtInfinity, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0) - other.g0, self_.g0 - other.g1);
}

fn line_at_infinity_multi_vector_sub(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, self_.g0 - other.g3, vec4<f32>(0.0) - other.g4);
}

fn line_at_infinity_rotor_sub(self_: LineAtInfinity, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0) - other.g0, self_.g0);
}

fn line_at_infinity_translator_sub(self_: LineAtInfinity, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn line_at_origin_anti_scalar_sub(self_: LineAtOrigin, other: AntiScalar) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn line_at_origin_line_sub(self_: LineAtOrigin, other: Line) -> Line {
    return Line(self_.g0 - other.g0, vec3<f32>(0.0) - other.g1);
}

fn line_at_origin_line_at_infinity_sub(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return Line(self_.g0, vec3<f32>(0.0) - other.g0);
}

fn line_at_origin_line_at_origin_sub(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 - other.g0);
}

fn line_at_origin_motor_sub(self_: LineAtOrigin, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, vec3<f32>(0.0) - other.g1);
}

fn line_at_origin_multi_vector_sub(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0) - other.g1, self_.g0 - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn line_at_origin_rotor_sub(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn line_at_origin_translator_sub(self_: LineAtOrigin, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn magnitude_anti_scalar_sub(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 - vec2<f32>(0.0, other.g0));
}

fn magnitude_magnitude_sub(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(self_.g0 - other.g0);
}

fn magnitude_multi_vector_sub(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn magnitude_scalar_sub(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 - vec2<f32>(other.g0, 0.0));
}

fn motor_anti_scalar_sub(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g1);
}

fn motor_line_sub(self_: Motor, other: Line) -> Motor {
    return Motor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 - other.g1);
}

fn motor_line_at_infinity_sub(self_: Motor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, self_.g1 - other.g0);
}

fn motor_line_at_origin_sub(self_: Motor, other: LineAtOrigin) -> Motor {
    return Motor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1);
}

fn motor_motor_sub(self_: Motor, other: Motor) -> Motor {
    return Motor(self_.g0 - other.g0, self_.g1 - other.g1);
}

fn motor_multi_vector_sub(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g2, self_.g1 - other.g3, vec4<f32>(0.0) - other.g4);
}

fn motor_rotor_sub(self_: Motor, other: Rotor) -> Motor {
    return Motor(self_.g0 - other.g0, self_.g1);
}

fn motor_translator_sub(self_: Motor, other: Translator) -> Motor {
    return Motor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), self_.g1 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn multi_vector_anti_scalar_sub(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0), self_.g1, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_flector_sub(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 - other.g0, self_.g2, self_.g3, self_.g4 - other.g1);
}

fn multi_vector_horizon_sub(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_sub(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 - other.g0, self_.g3 - other.g1, self_.g4);
}

fn multi_vector_line_at_infinity_sub(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3 - other.g0, self_.g4);
}

fn multi_vector_line_at_origin_sub(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 - other.g0, self_.g3, self_.g4);
}

fn multi_vector_magnitude_sub(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(self_.g0 - other.g0, self_.g1, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_motor_sub(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g3 - other.g1, self_.g4);
}

fn multi_vector_multi_vector_sub(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(self_.g0 - other.g0, self_.g1 - other.g1, self_.g2 - other.g2, self_.g3 - other.g3, self_.g4 - other.g4);
}

fn multi_vector_origin_sub(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 - vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g2, self_.g3, self_.g4);
}

fn multi_vector_plane_sub(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4 - other.g0);
}

fn multi_vector_plane_at_origin_sub(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2, self_.g3, self_.g4 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_point_sub(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 - other.g0, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_point_at_infinity_sub(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g2, self_.g3, self_.g4);
}

fn multi_vector_rotor_sub(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g3, self_.g4);
}

fn multi_vector_scalar_sub(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(other.g0, 0.0), self_.g1, self_.g2, self_.g3, self_.g4);
}

fn multi_vector_translator_sub(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 - vec2<f32>(0.0, other.g0.w), self_.g1, self_.g2, self_.g3 - vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g4);
}

fn origin_flector_sub(self_: Origin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0, vec4<f32>(0.0) - other.g1);
}

fn origin_multi_vector_sub(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn origin_origin_sub(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.g0 - other.g0);
}

fn origin_point_sub(self_: Origin, other: Point) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - other.g0);
}

fn origin_point_at_infinity_sub(self_: Origin, other: PointAtInfinity) -> Point {
    return Point(vec4<f32>(0.0, 0.0, 0.0, self_.g0) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_flector_sub(self_: Plane, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, self_.g0 - other.g1);
}

fn plane_horizon_sub(self_: Plane, other: Horizon) -> Plane {
    return Plane(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_multi_vector_sub(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, self_.g0 - other.g4);
}

fn plane_plane_sub(self_: Plane, other: Plane) -> Plane {
    return Plane(self_.g0 - other.g0);
}

fn plane_plane_at_origin_sub(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return Plane(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_point_sub(self_: Plane, other: Point) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, self_.g0);
}

fn plane_at_origin_flector_sub(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(0.0) - other.g0, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g1);
}

fn plane_at_origin_horizon_sub(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn plane_at_origin_multi_vector_sub(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g4);
}

fn plane_at_origin_plane_sub(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn plane_at_origin_plane_at_origin_sub(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 - other.g0);
}

fn point_flector_sub(self_: Point, other: Flector) -> Flector {
    return Flector(self_.g0 - other.g0, vec4<f32>(0.0) - other.g1);
}

fn point_multi_vector_sub(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, self_.g0 - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn point_origin_sub(self_: Point, other: Origin) -> Point {
    return Point(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn point_plane_sub(self_: Point, other: Plane) -> Flector {
    return Flector(self_.g0, vec4<f32>(0.0) - other.g0);
}

fn point_point_sub(self_: Point, other: Point) -> Point {
    return Point(self_.g0 - other.g0);
}

fn point_point_at_infinity_sub(self_: Point, other: PointAtInfinity) -> Point {
    return Point(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_infinity_flector_sub(self_: PointAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0, vec4<f32>(0.0) - other.g1);
}

fn point_at_infinity_multi_vector_sub(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - other.g0, vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn point_at_infinity_origin_sub(self_: PointAtInfinity, other: Origin) -> Point {
    return Point(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn point_at_infinity_point_sub(self_: PointAtInfinity, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, 0.0) - other.g0);
}

fn point_at_infinity_point_at_infinity_sub(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 - other.g0);
}

fn rotor_anti_scalar_sub(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_sub(self_: Rotor, other: Line) -> Motor {
    return Motor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0) - other.g1);
}

fn rotor_line_at_infinity_sub(self_: Rotor, other: LineAtInfinity) -> Motor {
    return Motor(self_.g0, vec3<f32>(0.0) - other.g0);
}

fn rotor_line_at_origin_sub(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_motor_sub(self_: Rotor, other: Motor) -> Motor {
    return Motor(self_.g0 - other.g0, vec3<f32>(0.0) - other.g1);
}

fn rotor_multi_vector_sub(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn rotor_rotor_sub(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0 - other.g0);
}

fn rotor_translator_sub(self_: Rotor, other: Translator) -> Motor {
    return Motor(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn scalar_anti_scalar_sub(self_: Scalar, other: AntiScalar) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) - vec2<f32>(0.0, other.g0));
}

fn scalar_magnitude_sub(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0, 0.0) - other.g0);
}

fn scalar_multi_vector_sub(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0, 0.0) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(0.0) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn scalar_scalar_sub(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 - other.g0);
}

fn translator_anti_scalar_sub(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 - vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn translator_line_sub(self_: Translator, other: Line) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g1);
}

fn translator_line_at_infinity_sub(self_: Translator, other: LineAtInfinity) -> Translator {
    return Translator(self_.g0 - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_line_at_origin_sub(self_: Translator, other: LineAtOrigin) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_motor_sub(self_: Translator, other: Motor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g1);
}

fn translator_multi_vector_sub(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0, self_.g0.w) - other.g0, vec4<f32>(0.0) - other.g1, vec3<f32>(0.0) - other.g2, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) - other.g3, vec4<f32>(0.0) - other.g4);
}

fn translator_rotor_sub(self_: Translator, other: Rotor) -> Motor {
    return Motor(vec4<f32>(0.0, 0.0, 0.0, self_.g0.w) - other.g0, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z));
}

fn translator_translator_sub(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0 - other.g0);
}

fn anti_scalar_anti_scalar_anti_wedge_dot(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_flector_anti_wedge_dot(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_anti_wedge_dot(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_line_anti_wedge_dot(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_anti_wedge_dot(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_anti_wedge_dot(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_anti_wedge_dot(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_anti_wedge_dot(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_anti_wedge_dot(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn anti_scalar_origin_anti_wedge_dot(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_anti_wedge_dot(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_anti_wedge_dot(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_anti_wedge_dot(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_anti_wedge_dot(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_rotor_anti_wedge_dot(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_scalar_anti_wedge_dot(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_translator_anti_wedge_dot(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn flector_anti_scalar_anti_wedge_dot(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_flector_anti_wedge_dot(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn flector_horizon_anti_wedge_dot(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_line_anti_wedge_dot(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn flector_line_at_infinity_anti_wedge_dot(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn flector_line_at_origin_anti_wedge_dot(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn flector_magnitude_anti_wedge_dot(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y) + self_.g1.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_motor_anti_wedge_dot(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn flector_multi_vector_anti_wedge_dot(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn flector_origin_anti_wedge_dot(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_plane_anti_wedge_dot(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_plane_at_origin_anti_wedge_dot(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(0.0));
}

fn flector_point_anti_wedge_dot(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn flector_point_at_infinity_anti_wedge_dot(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn flector_rotor_anti_wedge_dot(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g1.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn flector_scalar_anti_wedge_dot(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g1.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn flector_translator_anti_wedge_dot(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_anti_scalar_anti_wedge_dot(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_flector_anti_wedge_dot(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn horizon_line_anti_wedge_dot(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_anti_wedge_dot(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_anti_wedge_dot(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.y);
}

fn horizon_motor_anti_wedge_dot(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_anti_wedge_dot(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn horizon_origin_anti_wedge_dot(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_plane_anti_wedge_dot(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_anti_wedge_dot(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_anti_wedge_dot(self_: Horizon, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_rotor_anti_wedge_dot(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_translator_anti_wedge_dot(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn line_anti_scalar_anti_wedge_dot(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_flector_anti_wedge_dot(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_horizon_anti_wedge_dot(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_anti_wedge_dot(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_infinity_anti_wedge_dot(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_origin_anti_wedge_dot(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_magnitude_anti_wedge_dot(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g0 * vec3<f32>(other.g0.x) + self_.g1 * vec3<f32>(other.g0.y));
}

fn line_motor_anti_wedge_dot(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_multi_vector_anti_wedge_dot(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_origin_anti_wedge_dot(self_: Line, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn line_plane_anti_wedge_dot(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_plane_at_origin_anti_wedge_dot(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_point_anti_wedge_dot(self_: Line, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_point_at_infinity_anti_wedge_dot(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_rotor_anti_wedge_dot(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_scalar_anti_wedge_dot(self_: Line, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_translator_anti_wedge_dot(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_anti_scalar_anti_wedge_dot(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_flector_anti_wedge_dot(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_line_anti_wedge_dot(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_line_at_origin_anti_wedge_dot(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_magnitude_anti_wedge_dot(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_infinity_motor_anti_wedge_dot(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_at_infinity_multi_vector_anti_wedge_dot(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_origin_anti_wedge_dot(self_: LineAtInfinity, other: Origin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_plane_anti_wedge_dot(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_plane_at_origin_anti_wedge_dot(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_point_anti_wedge_dot(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_infinity_rotor_anti_wedge_dot(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_at_infinity_translator_anti_wedge_dot(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_anti_wedge_dot(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_flector_anti_wedge_dot(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_horizon_anti_wedge_dot(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_anti_wedge_dot(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_line_at_infinity_anti_wedge_dot(self_: LineAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_line_at_origin_anti_wedge_dot(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, -1.0));
}

fn line_at_origin_magnitude_anti_wedge_dot(self_: LineAtOrigin, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_motor_anti_wedge_dot(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_multi_vector_anti_wedge_dot(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_origin_anti_wedge_dot(self_: LineAtOrigin, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_plane_anti_wedge_dot(self_: LineAtOrigin, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_plane_at_origin_anti_wedge_dot(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_point_anti_wedge_dot(self_: LineAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_origin_point_at_infinity_anti_wedge_dot(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_origin_rotor_anti_wedge_dot(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_scalar_anti_wedge_dot(self_: LineAtOrigin, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_translator_anti_wedge_dot(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn magnitude_anti_scalar_anti_wedge_dot(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_flector_anti_wedge_dot(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g0.y) * other.g1);
}

fn magnitude_horizon_anti_wedge_dot(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.y * other.g0);
}

fn magnitude_line_anti_wedge_dot(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1);
}

fn magnitude_line_at_infinity_anti_wedge_dot(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_line_at_origin_anti_wedge_dot(self_: Magnitude, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_anti_wedge_dot(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_anti_wedge_dot(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(0.0));
}

fn magnitude_multi_vector_anti_wedge_dot(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) + vec4<f32>(self_.g0.y) * other.g4);
}

fn magnitude_origin_anti_wedge_dot(self_: Magnitude, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn magnitude_plane_anti_wedge_dot(self_: Magnitude, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_plane_at_origin_anti_wedge_dot(self_: Magnitude, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn magnitude_point_anti_wedge_dot(self_: Magnitude, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn magnitude_point_at_infinity_anti_wedge_dot(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_rotor_anti_wedge_dot(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn magnitude_scalar_anti_wedge_dot(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn magnitude_translator_anti_wedge_dot(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn motor_anti_scalar_anti_wedge_dot(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_flector_anti_wedge_dot(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_horizon_anti_wedge_dot(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_line_anti_wedge_dot(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn motor_line_at_infinity_anti_wedge_dot(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn motor_line_at_origin_anti_wedge_dot(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn motor_magnitude_anti_wedge_dot(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x) + self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn motor_motor_anti_wedge_dot(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn motor_multi_vector_anti_wedge_dot(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g0.w) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g4 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_origin_anti_wedge_dot(self_: Motor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn motor_plane_anti_wedge_dot(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_plane_at_origin_anti_wedge_dot(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_point_anti_wedge_dot(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_point_at_infinity_anti_wedge_dot(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_rotor_anti_wedge_dot(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn motor_scalar_anti_wedge_dot(self_: Motor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn motor_translator_anti_wedge_dot(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn multi_vector_anti_scalar_anti_wedge_dot(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_flector_anti_wedge_dot(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g0.y) * other.g1 + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_horizon_anti_wedge_dot(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_anti_wedge_dot(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn multi_vector_line_at_infinity_anti_wedge_dot(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn multi_vector_line_at_origin_anti_wedge_dot(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn multi_vector_magnitude_anti_wedge_dot(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec4<f32>(other.g0.y) + self_.g4.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), self_.g2 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.x) + self_.g3 * vec3<f32>(other.g0.y), vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4 * vec4<f32>(other.g0.y));
}

fn multi_vector_motor_anti_wedge_dot(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn multi_vector_multi_vector_anti_wedge_dot(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g0.y) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.y) * other.g2 - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) + vec4<f32>(self_.g0.y) * other.g4 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn multi_vector_origin_anti_wedge_dot(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_plane_anti_wedge_dot(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_plane_at_origin_anti_wedge_dot(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) - vec3<f32>(self_.g4.w) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_point_anti_wedge_dot(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_point_at_infinity_anti_wedge_dot(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.w) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_rotor_anti_wedge_dot(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g1.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g4.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn multi_vector_scalar_anti_wedge_dot(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0), self_.g4.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec3<f32>(0.0), self_.g2 * vec3<f32>(other.g0), vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_translator_anti_wedge_dot(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g1.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + self_.g3 * vec3<f32>(other.g0.w), vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn origin_anti_scalar_anti_wedge_dot(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_flector_anti_wedge_dot(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn origin_horizon_anti_wedge_dot(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn origin_line_anti_wedge_dot(self_: Origin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn origin_line_at_infinity_anti_wedge_dot(self_: Origin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn origin_line_at_origin_anti_wedge_dot(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_anti_wedge_dot(self_: Origin, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn origin_motor_anti_wedge_dot(self_: Origin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn origin_multi_vector_anti_wedge_dot(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn origin_origin_anti_wedge_dot(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn origin_plane_anti_wedge_dot(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_plane_at_origin_anti_wedge_dot(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn origin_point_anti_wedge_dot(self_: Origin, other: Point) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn origin_point_at_infinity_anti_wedge_dot(self_: Origin, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn origin_rotor_anti_wedge_dot(self_: Origin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn origin_scalar_anti_wedge_dot(self_: Origin, other: Scalar) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn origin_translator_anti_wedge_dot(self_: Origin, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn plane_anti_scalar_anti_wedge_dot(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_flector_anti_wedge_dot(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn plane_horizon_anti_wedge_dot(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_anti_wedge_dot(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn plane_line_at_infinity_anti_wedge_dot(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_line_at_origin_anti_wedge_dot(self_: Plane, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn plane_magnitude_anti_wedge_dot(self_: Plane, other: Magnitude) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_motor_anti_wedge_dot(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_multi_vector_anti_wedge_dot(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn plane_origin_anti_wedge_dot(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_plane_anti_wedge_dot(self_: Plane, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_anti_wedge_dot(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_anti_wedge_dot(self_: Plane, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_point_at_infinity_anti_wedge_dot(self_: Plane, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_rotor_anti_wedge_dot(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_scalar_anti_wedge_dot(self_: Plane, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_translator_anti_wedge_dot(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_at_origin_anti_scalar_anti_wedge_dot(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_flector_anti_wedge_dot(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn plane_at_origin_horizon_anti_wedge_dot(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_anti_wedge_dot(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn plane_at_origin_line_at_infinity_anti_wedge_dot(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_at_origin_line_at_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn plane_at_origin_magnitude_anti_wedge_dot(self_: PlaneAtOrigin, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn plane_at_origin_motor_anti_wedge_dot(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_at_origin_multi_vector_anti_wedge_dot(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_at_origin_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_plane_anti_wedge_dot(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_anti_wedge_dot(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0));
}

fn plane_at_origin_point_anti_wedge_dot(self_: PlaneAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_at_origin_point_at_infinity_anti_wedge_dot(self_: PlaneAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_at_origin_rotor_anti_wedge_dot(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0));
}

fn plane_at_origin_scalar_anti_wedge_dot(self_: PlaneAtOrigin, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_translator_anti_wedge_dot(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z));
}

fn point_anti_scalar_anti_wedge_dot(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_flector_anti_wedge_dot(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn point_horizon_anti_wedge_dot(self_: Point, other: Horizon) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn point_line_anti_wedge_dot(self_: Point, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_line_at_infinity_anti_wedge_dot(self_: Point, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn point_line_at_origin_anti_wedge_dot(self_: Point, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_magnitude_anti_wedge_dot(self_: Point, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_motor_anti_wedge_dot(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_multi_vector_anti_wedge_dot(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_origin_anti_wedge_dot(self_: Point, other: Origin) -> Translator {
    return Translator(vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g0));
}

fn point_plane_anti_wedge_dot(self_: Point, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_plane_at_origin_anti_wedge_dot(self_: Point, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_point_anti_wedge_dot(self_: Point, other: Point) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_point_at_infinity_anti_wedge_dot(self_: Point, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn point_rotor_anti_wedge_dot(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_scalar_anti_wedge_dot(self_: Point, other: Scalar) -> Horizon {
    return Horizon(0.0 - self_.g0.w * other.g0);
}

fn point_translator_anti_wedge_dot(self_: Point, other: Translator) -> Point {
    return Point(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn point_at_infinity_anti_scalar_anti_wedge_dot(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_flector_anti_wedge_dot(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec4<f32>(0.0));
}

fn point_at_infinity_line_anti_wedge_dot(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_origin_anti_wedge_dot(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_magnitude_anti_wedge_dot(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn point_at_infinity_motor_anti_wedge_dot(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_multi_vector_anti_wedge_dot(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_origin_anti_wedge_dot(self_: PointAtInfinity, other: Origin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_plane_anti_wedge_dot(self_: PointAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_plane_at_origin_anti_wedge_dot(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_point_anti_wedge_dot(self_: PointAtInfinity, other: Point) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_rotor_anti_wedge_dot(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_translator_anti_wedge_dot(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn rotor_anti_scalar_anti_wedge_dot(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_flector_anti_wedge_dot(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_anti_wedge_dot(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_anti_wedge_dot(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_line_at_infinity_anti_wedge_dot(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn rotor_line_at_origin_anti_wedge_dot(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_magnitude_anti_wedge_dot(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(0.0));
}

fn rotor_motor_anti_wedge_dot(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_multi_vector_anti_wedge_dot(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g4);
}

fn rotor_origin_anti_wedge_dot(self_: Rotor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn rotor_plane_anti_wedge_dot(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_anti_wedge_dot(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_anti_wedge_dot(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn rotor_point_at_infinity_anti_wedge_dot(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn rotor_rotor_anti_wedge_dot(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_scalar_anti_wedge_dot(self_: Rotor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn rotor_translator_anti_wedge_dot(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_anti_scalar_anti_wedge_dot(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_flector_anti_wedge_dot(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn scalar_line_anti_wedge_dot(self_: Scalar, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_anti_wedge_dot(self_: Scalar, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_anti_wedge_dot(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_motor_anti_wedge_dot(self_: Scalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_multi_vector_anti_wedge_dot(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g2, vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w));
}

fn scalar_origin_anti_wedge_dot(self_: Scalar, other: Origin) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_plane_anti_wedge_dot(self_: Scalar, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn scalar_plane_at_origin_anti_wedge_dot(self_: Scalar, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_anti_wedge_dot(self_: Scalar, other: Point) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn scalar_rotor_anti_wedge_dot(self_: Scalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_translator_anti_wedge_dot(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn translator_anti_scalar_anti_wedge_dot(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_flector_anti_wedge_dot(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_anti_wedge_dot(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_line_anti_wedge_dot(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_line_at_infinity_anti_wedge_dot(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_anti_wedge_dot(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn translator_magnitude_anti_wedge_dot(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn translator_motor_anti_wedge_dot(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_multi_vector_anti_wedge_dot(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g4);
}

fn translator_origin_anti_wedge_dot(self_: Translator, other: Origin) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn translator_plane_anti_wedge_dot(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_anti_wedge_dot(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn translator_point_anti_wedge_dot(self_: Translator, other: Point) -> Point {
    return Point(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_infinity_anti_wedge_dot(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_rotor_anti_wedge_dot(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn translator_scalar_anti_wedge_dot(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn translator_translator_anti_wedge_dot(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_anti_scalar_geometric_anti_product(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_flector_geometric_anti_product(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_geometric_anti_product(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_line_geometric_anti_product(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_geometric_anti_product(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_geometric_anti_product(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_geometric_anti_product(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_geometric_anti_product(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_geometric_anti_product(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn anti_scalar_origin_geometric_anti_product(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_geometric_anti_product(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_geometric_anti_product(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_geometric_anti_product(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_geometric_anti_product(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_rotor_geometric_anti_product(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_scalar_geometric_anti_product(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_translator_geometric_anti_product(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn flector_anti_scalar_geometric_anti_product(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_flector_geometric_anti_product(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn flector_horizon_geometric_anti_product(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_line_geometric_anti_product(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn flector_line_at_infinity_geometric_anti_product(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn flector_line_at_origin_geometric_anti_product(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn flector_magnitude_geometric_anti_product(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y) + self_.g1.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_motor_geometric_anti_product(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn flector_multi_vector_geometric_anti_product(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn flector_origin_geometric_anti_product(self_: Flector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_plane_geometric_anti_product(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_plane_at_origin_geometric_anti_product(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(0.0));
}

fn flector_point_geometric_anti_product(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn flector_point_at_infinity_geometric_anti_product(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn flector_rotor_geometric_anti_product(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g1.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn flector_scalar_geometric_anti_product(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g1.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn flector_translator_geometric_anti_product(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_anti_scalar_geometric_anti_product(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_flector_geometric_anti_product(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn horizon_line_geometric_anti_product(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_geometric_anti_product(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_geometric_anti_product(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.y);
}

fn horizon_motor_geometric_anti_product(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_geometric_anti_product(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn horizon_origin_geometric_anti_product(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_plane_geometric_anti_product(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_geometric_anti_product(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_geometric_anti_product(self_: Horizon, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_rotor_geometric_anti_product(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_translator_geometric_anti_product(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn line_anti_scalar_geometric_anti_product(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_flector_geometric_anti_product(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_horizon_geometric_anti_product(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_geometric_anti_product(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_infinity_geometric_anti_product(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_origin_geometric_anti_product(self_: Line, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_magnitude_geometric_anti_product(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g0 * vec3<f32>(other.g0.x) + self_.g1 * vec3<f32>(other.g0.y));
}

fn line_motor_geometric_anti_product(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_multi_vector_geometric_anti_product(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_origin_geometric_anti_product(self_: Line, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn line_plane_geometric_anti_product(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_plane_at_origin_geometric_anti_product(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_point_geometric_anti_product(self_: Line, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_point_at_infinity_geometric_anti_product(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_rotor_geometric_anti_product(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_scalar_geometric_anti_product(self_: Line, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_translator_geometric_anti_product(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_anti_scalar_geometric_anti_product(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_flector_geometric_anti_product(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_line_geometric_anti_product(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_line_at_origin_geometric_anti_product(self_: LineAtInfinity, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_magnitude_geometric_anti_product(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_infinity_motor_geometric_anti_product(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_at_infinity_multi_vector_geometric_anti_product(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_origin_geometric_anti_product(self_: LineAtInfinity, other: Origin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_plane_geometric_anti_product(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_plane_at_origin_geometric_anti_product(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_point_geometric_anti_product(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_infinity_rotor_geometric_anti_product(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn line_at_infinity_translator_geometric_anti_product(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_geometric_anti_product(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_flector_geometric_anti_product(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_horizon_geometric_anti_product(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_geometric_anti_product(self_: LineAtOrigin, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_line_at_infinity_geometric_anti_product(self_: LineAtOrigin, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_line_at_origin_geometric_anti_product(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, -1.0));
}

fn line_at_origin_magnitude_geometric_anti_product(self_: LineAtOrigin, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_motor_geometric_anti_product(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_multi_vector_geometric_anti_product(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_origin_geometric_anti_product(self_: LineAtOrigin, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_plane_geometric_anti_product(self_: LineAtOrigin, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_plane_at_origin_geometric_anti_product(self_: LineAtOrigin, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_point_geometric_anti_product(self_: LineAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_origin_point_at_infinity_geometric_anti_product(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_origin_rotor_geometric_anti_product(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0));
}

fn line_at_origin_scalar_geometric_anti_product(self_: LineAtOrigin, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_translator_geometric_anti_product(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn magnitude_anti_scalar_geometric_anti_product(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_flector_geometric_anti_product(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g0.y) * other.g1);
}

fn magnitude_horizon_geometric_anti_product(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.y * other.g0);
}

fn magnitude_line_geometric_anti_product(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1);
}

fn magnitude_line_at_infinity_geometric_anti_product(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_line_at_origin_geometric_anti_product(self_: Magnitude, other: LineAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_geometric_anti_product(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_geometric_anti_product(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(0.0));
}

fn magnitude_multi_vector_geometric_anti_product(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) + vec4<f32>(self_.g0.y) * other.g4);
}

fn magnitude_origin_geometric_anti_product(self_: Magnitude, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn magnitude_plane_geometric_anti_product(self_: Magnitude, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_plane_at_origin_geometric_anti_product(self_: Magnitude, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn magnitude_point_geometric_anti_product(self_: Magnitude, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn magnitude_point_at_infinity_geometric_anti_product(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_rotor_geometric_anti_product(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn magnitude_scalar_geometric_anti_product(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn magnitude_translator_geometric_anti_product(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn motor_anti_scalar_geometric_anti_product(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_flector_geometric_anti_product(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_horizon_geometric_anti_product(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_line_geometric_anti_product(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn motor_line_at_infinity_geometric_anti_product(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn motor_line_at_origin_geometric_anti_product(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn motor_magnitude_geometric_anti_product(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x) + self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn motor_motor_geometric_anti_product(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn motor_multi_vector_geometric_anti_product(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g0.w) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g4 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_origin_geometric_anti_product(self_: Motor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn motor_plane_geometric_anti_product(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_plane_at_origin_geometric_anti_product(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_point_geometric_anti_product(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_point_at_infinity_geometric_anti_product(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_rotor_geometric_anti_product(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn motor_scalar_geometric_anti_product(self_: Motor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn motor_translator_geometric_anti_product(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn multi_vector_anti_scalar_geometric_anti_product(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_flector_geometric_anti_product(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g0.y) * other.g1 + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_horizon_geometric_anti_product(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_geometric_anti_product(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn multi_vector_line_at_infinity_geometric_anti_product(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn multi_vector_line_at_origin_geometric_anti_product(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn multi_vector_magnitude_geometric_anti_product(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec4<f32>(other.g0.y) + self_.g4.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), self_.g2 * vec3<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.x) + self_.g3 * vec3<f32>(other.g0.y), vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4 * vec4<f32>(other.g0.y));
}

fn multi_vector_motor_geometric_anti_product(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn multi_vector_multi_vector_geometric_anti_product(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0) - vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0) + vec4<f32>(self_.g0.y) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.y) * other.g2 - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) + vec4<f32>(self_.g0.y) * other.g4 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn multi_vector_origin_geometric_anti_product(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_plane_geometric_anti_product(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_plane_at_origin_geometric_anti_product(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) - vec3<f32>(self_.g4.w) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_point_geometric_anti_product(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_point_at_infinity_geometric_anti_product(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.w) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_rotor_geometric_anti_product(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g1.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g4.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn multi_vector_scalar_geometric_anti_product(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.y) * vec2<f32>(other.g0, 0.0), self_.g4.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec3<f32>(0.0), self_.g2 * vec3<f32>(other.g0), vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_translator_geometric_anti_product(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g1.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + self_.g3 * vec3<f32>(other.g0.w), vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn origin_anti_scalar_geometric_anti_product(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_flector_geometric_anti_product(self_: Origin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn origin_horizon_geometric_anti_product(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn origin_line_geometric_anti_product(self_: Origin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn origin_line_at_infinity_geometric_anti_product(self_: Origin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn origin_line_at_origin_geometric_anti_product(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_geometric_anti_product(self_: Origin, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn origin_motor_geometric_anti_product(self_: Origin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn origin_multi_vector_geometric_anti_product(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn origin_origin_geometric_anti_product(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn origin_plane_geometric_anti_product(self_: Origin, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_plane_at_origin_geometric_anti_product(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn origin_point_geometric_anti_product(self_: Origin, other: Point) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn origin_point_at_infinity_geometric_anti_product(self_: Origin, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn origin_rotor_geometric_anti_product(self_: Origin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn origin_scalar_geometric_anti_product(self_: Origin, other: Scalar) -> Horizon {
    return Horizon(0.0 - self_.g0 * other.g0);
}

fn origin_translator_geometric_anti_product(self_: Origin, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn plane_anti_scalar_geometric_anti_product(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_flector_geometric_anti_product(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn plane_horizon_geometric_anti_product(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_geometric_anti_product(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn plane_line_at_infinity_geometric_anti_product(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_line_at_origin_geometric_anti_product(self_: Plane, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn plane_magnitude_geometric_anti_product(self_: Plane, other: Magnitude) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_motor_geometric_anti_product(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_multi_vector_geometric_anti_product(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn plane_origin_geometric_anti_product(self_: Plane, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_plane_geometric_anti_product(self_: Plane, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_geometric_anti_product(self_: Plane, other: PlaneAtOrigin) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_geometric_anti_product(self_: Plane, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_point_at_infinity_geometric_anti_product(self_: Plane, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_rotor_geometric_anti_product(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_scalar_geometric_anti_product(self_: Plane, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_translator_geometric_anti_product(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn plane_at_origin_anti_scalar_geometric_anti_product(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_flector_geometric_anti_product(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn plane_at_origin_horizon_geometric_anti_product(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_geometric_anti_product(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn plane_at_origin_line_at_infinity_geometric_anti_product(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z));
}

fn plane_at_origin_line_at_origin_geometric_anti_product(self_: PlaneAtOrigin, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn plane_at_origin_magnitude_geometric_anti_product(self_: PlaneAtOrigin, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn plane_at_origin_motor_geometric_anti_product(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_at_origin_multi_vector_geometric_anti_product(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) * vec2<f32>(-1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(-1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(1.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(-1.0, 1.0, 1.0, 1.0));
}

fn plane_at_origin_origin_geometric_anti_product(self_: PlaneAtOrigin, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_plane_geometric_anti_product(self_: PlaneAtOrigin, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_geometric_anti_product(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, 1.0));
}

fn plane_at_origin_point_geometric_anti_product(self_: PlaneAtOrigin, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_at_origin_point_at_infinity_geometric_anti_product(self_: PlaneAtOrigin, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn plane_at_origin_rotor_geometric_anti_product(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0));
}

fn plane_at_origin_scalar_geometric_anti_product(self_: PlaneAtOrigin, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_translator_geometric_anti_product(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z));
}

fn point_anti_scalar_geometric_anti_product(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_flector_geometric_anti_product(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, other.g0.w) * vec2<f32>(1.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn point_horizon_geometric_anti_product(self_: Point, other: Horizon) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn point_line_geometric_anti_product(self_: Point, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_line_at_infinity_geometric_anti_product(self_: Point, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn point_line_at_origin_geometric_anti_product(self_: Point, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_magnitude_geometric_anti_product(self_: Point, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_motor_geometric_anti_product(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_multi_vector_geometric_anti_product(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, other.g1.w) * vec2<f32>(1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_origin_geometric_anti_product(self_: Point, other: Origin) -> Translator {
    return Translator(vec4<f32>(0.0) - self_.g0 * vec4<f32>(other.g0));
}

fn point_plane_geometric_anti_product(self_: Point, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_plane_at_origin_geometric_anti_product(self_: Point, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_point_geometric_anti_product(self_: Point, other: Point) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_point_at_infinity_geometric_anti_product(self_: Point, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn point_rotor_geometric_anti_product(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + self_.g0.zzzw * other.g0.yxww * vec4<f32>(-1.0, 1.0, 1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_scalar_geometric_anti_product(self_: Point, other: Scalar) -> Horizon {
    return Horizon(0.0 - self_.g0.w * other.g0);
}

fn point_translator_geometric_anti_product(self_: Point, other: Translator) -> Point {
    return Point(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn point_at_infinity_anti_scalar_geometric_anti_product(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_flector_geometric_anti_product(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(1.0, -1.0, -1.0), vec4<f32>(0.0));
}

fn point_at_infinity_line_geometric_anti_product(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_origin_geometric_anti_product(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_magnitude_geometric_anti_product(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn point_at_infinity_motor_geometric_anti_product(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_multi_vector_geometric_anti_product(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(1.0, -1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g2.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g2.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g2.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_origin_geometric_anti_product(self_: PointAtInfinity, other: Origin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_plane_geometric_anti_product(self_: PointAtInfinity, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_plane_at_origin_geometric_anti_product(self_: PointAtInfinity, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_point_geometric_anti_product(self_: PointAtInfinity, other: Point) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_rotor_geometric_anti_product(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_translator_geometric_anti_product(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn rotor_anti_scalar_geometric_anti_product(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_flector_geometric_anti_product(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_geometric_anti_product(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_geometric_anti_product(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_line_at_infinity_geometric_anti_product(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn rotor_line_at_origin_geometric_anti_product(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_magnitude_geometric_anti_product(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(0.0));
}

fn rotor_motor_geometric_anti_product(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_multi_vector_geometric_anti_product(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g4);
}

fn rotor_origin_geometric_anti_product(self_: Rotor, other: Origin) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn rotor_plane_geometric_anti_product(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_geometric_anti_product(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_geometric_anti_product(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn rotor_point_at_infinity_geometric_anti_product(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn rotor_rotor_geometric_anti_product(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_scalar_geometric_anti_product(self_: Rotor, other: Scalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn rotor_translator_geometric_anti_product(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_anti_scalar_geometric_anti_product(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_flector_geometric_anti_product(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn scalar_line_geometric_anti_product(self_: Scalar, other: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_geometric_anti_product(self_: Scalar, other: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_geometric_anti_product(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_motor_geometric_anti_product(self_: Scalar, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_multi_vector_geometric_anti_product(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.y, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g4.x, other.g4.y, other.g4.z, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * other.g2, vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w));
}

fn scalar_origin_geometric_anti_product(self_: Scalar, other: Origin) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_plane_geometric_anti_product(self_: Scalar, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn scalar_plane_at_origin_geometric_anti_product(self_: Scalar, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_geometric_anti_product(self_: Scalar, other: Point) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn scalar_rotor_geometric_anti_product(self_: Scalar, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_translator_geometric_anti_product(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn translator_anti_scalar_geometric_anti_product(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_flector_geometric_anti_product(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_geometric_anti_product(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_line_geometric_anti_product(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_line_at_infinity_geometric_anti_product(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_geometric_anti_product(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn translator_magnitude_geometric_anti_product(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn translator_motor_geometric_anti_product(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_multi_vector_geometric_anti_product(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g4.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g4.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g4);
}

fn translator_origin_geometric_anti_product(self_: Translator, other: Origin) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn translator_plane_geometric_anti_product(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_geometric_anti_product(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn translator_point_geometric_anti_product(self_: Translator, other: Point) -> Point {
    return Point(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_infinity_geometric_anti_product(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_rotor_geometric_anti_product(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(-1.0, 1.0, 1.0), vec4<f32>(0.0));
}

fn translator_scalar_geometric_anti_product(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn translator_translator_geometric_anti_product(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_flector_geometric_product(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn anti_scalar_horizon_geometric_product(self_: AntiScalar, other: Horizon) -> Origin {
    return Origin(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_line_geometric_product(self_: AntiScalar, other: Line) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_geometric_product(self_: AntiScalar, other: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_geometric_product(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_motor_geometric_product(self_: AntiScalar, other: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_geometric_product(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0) * other.g3, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn anti_scalar_plane_geometric_product(self_: AntiScalar, other: Plane) -> Origin {
    return Origin(0.0 - self_.g0 * other.g0.w);
}

fn anti_scalar_point_geometric_product(self_: AntiScalar, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn anti_scalar_point_at_infinity_geometric_product(self_: AntiScalar, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_scalar_geometric_product(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_translator_geometric_product(self_: AntiScalar, other: Translator) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn flector_anti_scalar_geometric_product(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn flector_flector_geometric_product(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_horizon_geometric_product(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_line_geometric_product(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_line_at_infinity_geometric_product(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn flector_line_at_origin_geometric_product(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_magnitude_geometric_product(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), self_.g0.xyzx * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_motor_geometric_product(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_multi_vector_geometric_product(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.w) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn flector_origin_geometric_product(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn flector_plane_geometric_product(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn flector_plane_at_origin_geometric_product(self_: Flector, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn flector_point_geometric_product(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_point_at_infinity_geometric_product(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(0.0));
}

fn flector_rotor_geometric_product(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_scalar_geometric_product(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_translator_geometric_product(self_: Flector, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn horizon_anti_scalar_geometric_product(self_: Horizon, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn horizon_flector_geometric_product(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn horizon_horizon_geometric_product(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_line_geometric_product(self_: Horizon, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_line_at_infinity_geometric_product(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_geometric_product(self_: Horizon, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_geometric_product(self_: Horizon, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x));
}

fn horizon_motor_geometric_product(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_multi_vector_geometric_product(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn horizon_origin_geometric_product(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn horizon_plane_geometric_product(self_: Horizon, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_plane_at_origin_geometric_product(self_: Horizon, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_geometric_product(self_: Horizon, other: Point) -> Translator {
    return Translator(vec4<f32>(0.0) - vec4<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_infinity_geometric_product(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_rotor_geometric_product(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_scalar_geometric_product(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_translator_geometric_product(self_: Horizon, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn line_anti_scalar_geometric_product(self_: Line, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn line_flector_geometric_product(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_horizon_geometric_product(self_: Line, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn line_line_geometric_product(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_infinity_geometric_product(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_origin_geometric_product(self_: Line, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_magnitude_geometric_product(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.x) + self_.g1 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.x));
}

fn line_motor_geometric_product(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_multi_vector_geometric_product(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_origin_geometric_product(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn line_plane_geometric_product(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_plane_at_origin_geometric_product(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_point_geometric_product(self_: Line, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_point_at_infinity_geometric_product(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_rotor_geometric_product(self_: Line, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_scalar_geometric_product(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_translator_geometric_product(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_anti_scalar_geometric_product(self_: LineAtInfinity, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_flector_geometric_product(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_at_infinity_horizon_geometric_product(self_: LineAtInfinity, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_line_geometric_product(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_line_at_infinity_geometric_product(self_: LineAtInfinity, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_line_at_origin_geometric_product(self_: LineAtInfinity, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_infinity_magnitude_geometric_product(self_: LineAtInfinity, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_infinity_motor_geometric_product(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_multi_vector_geometric_product(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_at_infinity_origin_geometric_product(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_plane_geometric_product(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_at_infinity_plane_at_origin_geometric_product(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_at_infinity_point_geometric_product(self_: LineAtInfinity, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_point_at_infinity_geometric_product(self_: LineAtInfinity, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_rotor_geometric_product(self_: LineAtInfinity, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_at_infinity_scalar_geometric_product(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_translator_geometric_product(self_: LineAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_flector_geometric_product(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0));
}

fn line_at_origin_horizon_geometric_product(self_: LineAtOrigin, other: Horizon) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_geometric_product(self_: LineAtOrigin, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_origin_line_at_infinity_geometric_product(self_: LineAtOrigin, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_origin_magnitude_geometric_product(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_motor_geometric_product(self_: LineAtOrigin, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_origin_multi_vector_geometric_product(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0));
}

fn line_at_origin_plane_geometric_product(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_point_geometric_product(self_: LineAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_point_at_infinity_geometric_product(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_scalar_geometric_product(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_translator_geometric_product(self_: LineAtOrigin, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn magnitude_anti_scalar_geometric_product(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn magnitude_flector_geometric_product(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_horizon_geometric_product(self_: Magnitude, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn magnitude_line_geometric_product(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_line_at_infinity_geometric_product(self_: Magnitude, other: LineAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_line_at_origin_geometric_product(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_geometric_product(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x));
}

fn magnitude_motor_geometric_product(self_: Magnitude, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_multi_vector_geometric_product(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3, vec3<f32>(self_.g0.x) * other.g3, vec4<f32>(self_.g0.x) * other.g4 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_origin_geometric_product(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.x * other.g0);
}

fn magnitude_plane_geometric_product(self_: Magnitude, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_plane_at_origin_geometric_product(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_geometric_product(self_: Magnitude, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_point_at_infinity_geometric_product(self_: Magnitude, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_rotor_geometric_product(self_: Magnitude, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_scalar_geometric_product(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_translator_geometric_product(self_: Magnitude, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.y, self_.g0.y, self_.g0.y, self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn motor_anti_scalar_geometric_product(self_: Motor, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn motor_flector_geometric_product(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_horizon_geometric_product(self_: Motor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn motor_line_geometric_product(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn motor_line_at_infinity_geometric_product(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn motor_line_at_origin_geometric_product(self_: Motor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn motor_magnitude_geometric_product(self_: Motor, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), self_.g1 * vec3<f32>(other.g0.x));
}

fn motor_motor_geometric_product(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn motor_multi_vector_geometric_product(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_origin_geometric_product(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn motor_plane_geometric_product(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn motor_plane_at_origin_geometric_product(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn motor_point_geometric_product(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_point_at_infinity_geometric_product(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_rotor_geometric_product(self_: Motor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_scalar_geometric_product(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_translator_geometric_product(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn multi_vector_anti_scalar_geometric_product(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0), vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g3 * vec3<f32>(other.g0), vec3<f32>(0.0), self_.g1.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_flector_geometric_product(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g4.w) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn multi_vector_horizon_geometric_product(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn multi_vector_line_geometric_product(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_line_at_infinity_geometric_product(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_line_at_origin_geometric_product(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_magnitude_geometric_product(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), self_.g1 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), self_.g2 * vec3<f32>(other.g0.x) + self_.g3 * vec3<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.x), self_.g1.xyzx * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + self_.g4 * vec4<f32>(other.g0.x));
}

fn multi_vector_motor_geometric_product(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_multi_vector_geometric_product(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g4.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g4.w) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0.x) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * other.g4 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn multi_vector_origin_geometric_product(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_plane_geometric_product(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_plane_at_origin_geometric_product(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g4.w) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_point_geometric_product(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_point_at_infinity_geometric_product(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(self_.g1.w) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g4.w) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_rotor_geometric_product(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_scalar_geometric_product(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_translator_geometric_product(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * other.g0, vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + self_.g3 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn origin_flector_geometric_product(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w));
}

fn origin_horizon_geometric_product(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_line_geometric_product(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_line_at_infinity_geometric_product(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_geometric_product(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.x);
}

fn origin_motor_geometric_product(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_multi_vector_geometric_product(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g4.w), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn origin_plane_geometric_product(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn origin_point_geometric_product(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn origin_point_at_infinity_geometric_product(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_scalar_geometric_product(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_translator_geometric_product(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_anti_scalar_geometric_product(self_: Plane, other: AntiScalar) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn plane_flector_geometric_product(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn plane_horizon_geometric_product(self_: Plane, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_line_geometric_product(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_line_at_infinity_geometric_product(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_line_at_origin_geometric_product(self_: Plane, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_magnitude_geometric_product(self_: Plane, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_motor_geometric_product(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_multi_vector_geometric_product(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn plane_origin_geometric_product(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn plane_plane_geometric_product(self_: Plane, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_plane_at_origin_geometric_product(self_: Plane, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_geometric_product(self_: Plane, other: Point) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_point_at_infinity_geometric_product(self_: Plane, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_rotor_geometric_product(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_scalar_geometric_product(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_translator_geometric_product(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_flector_geometric_product(self_: PlaneAtOrigin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn plane_at_origin_horizon_geometric_product(self_: PlaneAtOrigin, other: Horizon) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_geometric_product(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_line_at_infinity_geometric_product(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_magnitude_geometric_product(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn plane_at_origin_motor_geometric_product(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_multi_vector_geometric_product(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0));
}

fn plane_at_origin_plane_geometric_product(self_: PlaneAtOrigin, other: Plane) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_point_geometric_product(self_: PlaneAtOrigin, other: Point) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn plane_at_origin_point_at_infinity_geometric_product(self_: PlaneAtOrigin, other: PointAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn plane_at_origin_scalar_geometric_product(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_translator_geometric_product(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn point_anti_scalar_geometric_product(self_: Point, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn point_flector_geometric_product(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(0.0));
}

fn point_horizon_geometric_product(self_: Point, other: Horizon) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0) * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn point_line_geometric_product(self_: Point, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_line_at_infinity_geometric_product(self_: Point, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_line_at_origin_geometric_product(self_: Point, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn point_magnitude_geometric_product(self_: Point, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x), self_.g0.xyzx * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn point_motor_geometric_product(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_multi_vector_geometric_product(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn point_origin_geometric_product(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn point_plane_geometric_product(self_: Point, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w));
}

fn point_plane_at_origin_geometric_product(self_: Point, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn point_point_geometric_product(self_: Point, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_point_at_infinity_geometric_product(self_: Point, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_rotor_geometric_product(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0));
}

fn point_scalar_geometric_product(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_translator_geometric_product(self_: Point, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_infinity_anti_scalar_geometric_product(self_: PointAtInfinity, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_flector_geometric_product(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(0.0));
}

fn point_at_infinity_horizon_geometric_product(self_: PointAtInfinity, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_line_geometric_product(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_infinity_geometric_product(self_: PointAtInfinity, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_origin_geometric_product(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn point_at_infinity_magnitude_geometric_product(self_: PointAtInfinity, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn point_at_infinity_motor_geometric_product(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn point_at_infinity_multi_vector_geometric_product(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn point_at_infinity_origin_geometric_product(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_plane_geometric_product(self_: PointAtInfinity, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_plane_at_origin_geometric_product(self_: PointAtInfinity, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn point_at_infinity_point_geometric_product(self_: PointAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_point_at_infinity_geometric_product(self_: PointAtInfinity, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_rotor_geometric_product(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0));
}

fn point_at_infinity_scalar_geometric_product(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_translator_geometric_product(self_: PointAtInfinity, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn rotor_flector_geometric_product(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_horizon_geometric_product(self_: Rotor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_line_geometric_product(self_: Rotor, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn rotor_line_at_infinity_geometric_product(self_: Rotor, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_magnitude_geometric_product(self_: Rotor, other: Magnitude) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0.x));
}

fn rotor_motor_geometric_product(self_: Rotor, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn rotor_multi_vector_geometric_product(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_plane_geometric_product(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_point_geometric_product(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_point_at_infinity_geometric_product(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_scalar_geometric_product(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_translator_geometric_product(self_: Rotor, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn scalar_anti_scalar_geometric_product(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_flector_geometric_product(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_geometric_product(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_line_geometric_product(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_geometric_product(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_geometric_product(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_geometric_product(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_geometric_product(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_geometric_product(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn scalar_origin_geometric_product(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_geometric_product(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_geometric_product(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_geometric_product(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_geometric_product(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_rotor_geometric_product(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_scalar_geometric_product(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_translator_geometric_product(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn translator_anti_scalar_geometric_product(self_: Translator, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_flector_geometric_product(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn translator_horizon_geometric_product(self_: Translator, other: Horizon) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn translator_line_geometric_product(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn translator_line_at_infinity_geometric_product(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn translator_line_at_origin_geometric_product(self_: Translator, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn translator_magnitude_geometric_product(self_: Translator, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, other.g0.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x));
}

fn translator_motor_geometric_product(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn translator_multi_vector_geometric_product(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn translator_origin_geometric_product(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_plane_geometric_product(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn translator_plane_at_origin_geometric_product(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn translator_point_geometric_product(self_: Translator, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn translator_point_at_infinity_geometric_product(self_: Translator, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) - self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z));
}

fn translator_rotor_geometric_product(self_: Translator, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn translator_scalar_geometric_product(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_translator_geometric_product(self_: Translator, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn anti_scalar_flector_wedge_dot(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn anti_scalar_horizon_wedge_dot(self_: AntiScalar, other: Horizon) -> Origin {
    return Origin(0.0 - self_.g0 * other.g0);
}

fn anti_scalar_line_wedge_dot(self_: AntiScalar, other: Line) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_wedge_dot(self_: AntiScalar, other: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_wedge_dot(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_motor_wedge_dot(self_: AntiScalar, other: Motor) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_wedge_dot(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0) * other.g3, vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn anti_scalar_plane_wedge_dot(self_: AntiScalar, other: Plane) -> Origin {
    return Origin(0.0 - self_.g0 * other.g0.w);
}

fn anti_scalar_point_wedge_dot(self_: AntiScalar, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn anti_scalar_point_at_infinity_wedge_dot(self_: AntiScalar, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_scalar_wedge_dot(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_translator_wedge_dot(self_: AntiScalar, other: Translator) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn flector_anti_scalar_wedge_dot(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn flector_flector_wedge_dot(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_horizon_wedge_dot(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_line_wedge_dot(self_: Flector, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_line_at_infinity_wedge_dot(self_: Flector, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn flector_line_at_origin_wedge_dot(self_: Flector, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_magnitude_wedge_dot(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), self_.g0.xyzx * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_motor_wedge_dot(self_: Flector, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_multi_vector_wedge_dot(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.w) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn flector_origin_wedge_dot(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn flector_plane_wedge_dot(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn flector_plane_at_origin_wedge_dot(self_: Flector, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn flector_point_wedge_dot(self_: Flector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_point_at_infinity_wedge_dot(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(0.0));
}

fn flector_rotor_wedge_dot(self_: Flector, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_scalar_wedge_dot(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_translator_wedge_dot(self_: Flector, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn horizon_anti_scalar_wedge_dot(self_: Horizon, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn horizon_flector_wedge_dot(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn horizon_horizon_wedge_dot(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_line_wedge_dot(self_: Horizon, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_line_at_infinity_wedge_dot(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_wedge_dot(self_: Horizon, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_wedge_dot(self_: Horizon, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x));
}

fn horizon_motor_wedge_dot(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_multi_vector_wedge_dot(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn horizon_origin_wedge_dot(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn horizon_plane_wedge_dot(self_: Horizon, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn horizon_plane_at_origin_wedge_dot(self_: Horizon, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_wedge_dot(self_: Horizon, other: Point) -> Translator {
    return Translator(vec4<f32>(0.0) - vec4<f32>(self_.g0) * other.g0);
}

fn horizon_point_at_infinity_wedge_dot(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_rotor_wedge_dot(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn horizon_scalar_wedge_dot(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_translator_wedge_dot(self_: Horizon, other: Translator) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn line_anti_scalar_wedge_dot(self_: Line, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn line_flector_wedge_dot(self_: Line, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_horizon_wedge_dot(self_: Line, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn line_line_wedge_dot(self_: Line, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_infinity_wedge_dot(self_: Line, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_line_at_origin_wedge_dot(self_: Line, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_magnitude_wedge_dot(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.x) + self_.g1 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.x));
}

fn line_motor_wedge_dot(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_multi_vector_wedge_dot(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_origin_wedge_dot(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn line_plane_wedge_dot(self_: Line, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_plane_at_origin_wedge_dot(self_: Line, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_point_wedge_dot(self_: Line, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_point_at_infinity_wedge_dot(self_: Line, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_rotor_wedge_dot(self_: Line, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_scalar_wedge_dot(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_translator_wedge_dot(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_anti_scalar_wedge_dot(self_: LineAtInfinity, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_flector_wedge_dot(self_: LineAtInfinity, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_at_infinity_horizon_wedge_dot(self_: LineAtInfinity, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_line_wedge_dot(self_: LineAtInfinity, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_line_at_infinity_wedge_dot(self_: LineAtInfinity, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_line_at_origin_wedge_dot(self_: LineAtInfinity, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_infinity_magnitude_wedge_dot(self_: LineAtInfinity, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_infinity_motor_wedge_dot(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_infinity_multi_vector_wedge_dot(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_at_infinity_origin_wedge_dot(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_plane_wedge_dot(self_: LineAtInfinity, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_at_infinity_plane_at_origin_wedge_dot(self_: LineAtInfinity, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn line_at_infinity_point_wedge_dot(self_: LineAtInfinity, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_point_at_infinity_wedge_dot(self_: LineAtInfinity, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_at_infinity_rotor_wedge_dot(self_: LineAtInfinity, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn line_at_infinity_scalar_wedge_dot(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_translator_wedge_dot(self_: LineAtInfinity, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn line_at_origin_flector_wedge_dot(self_: LineAtOrigin, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0));
}

fn line_at_origin_horizon_wedge_dot(self_: LineAtOrigin, other: Horizon) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_wedge_dot(self_: LineAtOrigin, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_origin_line_at_infinity_wedge_dot(self_: LineAtOrigin, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_origin_magnitude_wedge_dot(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_motor_wedge_dot(self_: LineAtOrigin, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn line_at_origin_multi_vector_wedge_dot(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0));
}

fn line_at_origin_plane_wedge_dot(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_point_wedge_dot(self_: LineAtOrigin, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_point_at_infinity_wedge_dot(self_: LineAtOrigin, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_scalar_wedge_dot(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_translator_wedge_dot(self_: LineAtOrigin, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn magnitude_anti_scalar_wedge_dot(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn magnitude_flector_wedge_dot(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_horizon_wedge_dot(self_: Magnitude, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn magnitude_line_wedge_dot(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_line_at_infinity_wedge_dot(self_: Magnitude, other: LineAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_line_at_origin_wedge_dot(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_wedge_dot(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x));
}

fn magnitude_motor_wedge_dot(self_: Magnitude, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0), vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_multi_vector_wedge_dot(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3, vec3<f32>(self_.g0.x) * other.g3, vec4<f32>(self_.g0.x) * other.g4 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_origin_wedge_dot(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.x * other.g0);
}

fn magnitude_plane_wedge_dot(self_: Magnitude, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_plane_at_origin_wedge_dot(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_wedge_dot(self_: Magnitude, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_point_at_infinity_wedge_dot(self_: Magnitude, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn magnitude_rotor_wedge_dot(self_: Magnitude, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_scalar_wedge_dot(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_translator_wedge_dot(self_: Magnitude, other: Translator) -> Motor {
    return Motor(vec4<f32>(self_.g0.y, self_.g0.y, self_.g0.y, self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn motor_anti_scalar_wedge_dot(self_: Motor, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn motor_flector_wedge_dot(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_horizon_wedge_dot(self_: Motor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn motor_line_wedge_dot(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn motor_line_at_infinity_wedge_dot(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn motor_line_at_origin_wedge_dot(self_: Motor, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn motor_magnitude_wedge_dot(self_: Motor, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), self_.g1 * vec3<f32>(other.g0.x));
}

fn motor_motor_wedge_dot(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn motor_multi_vector_wedge_dot(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x) - vec2<f32>(self_.g1.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g1.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g1.z) * vec2<f32>(other.g3.z, other.g2.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_origin_wedge_dot(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn motor_plane_wedge_dot(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn motor_plane_at_origin_wedge_dot(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn motor_point_wedge_dot(self_: Motor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_point_at_infinity_wedge_dot(self_: Motor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_rotor_wedge_dot(self_: Motor, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g1.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn motor_scalar_wedge_dot(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_translator_wedge_dot(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn multi_vector_anti_scalar_wedge_dot(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0), vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0), self_.g3 * vec3<f32>(other.g0), vec3<f32>(0.0), self_.g1.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_flector_wedge_dot(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g4.w) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn multi_vector_horizon_wedge_dot(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0) + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn multi_vector_line_wedge_dot(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_line_at_infinity_wedge_dot(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * other.g0 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_line_at_origin_wedge_dot(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * other.g0 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_magnitude_wedge_dot(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), self_.g1 * vec4<f32>(other.g0.x) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), self_.g2 * vec3<f32>(other.g0.x) + self_.g3 * vec3<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.x), self_.g1.xyzx * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0) + self_.g4 * vec4<f32>(other.g0.x));
}

fn multi_vector_motor_wedge_dot(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g0.y) * other.g1 + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * other.g1 + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_multi_vector_wedge_dot(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, other.g4.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g3.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g3.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g3.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g4.w) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(self_.g0.x) * other.g2 + vec3<f32>(self_.g0.y) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + vec3<f32>(self_.g2.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g4.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(self_.g0.x) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * other.g4 + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g4.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn multi_vector_origin_wedge_dot(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_plane_wedge_dot(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_plane_at_origin_wedge_dot(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g4.w) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_point_wedge_dot(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_point_at_infinity_wedge_dot(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(self_.g1.w) * other.g0 + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) - vec3<f32>(self_.g4.w) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_rotor_wedge_dot(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_scalar_wedge_dot(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_translator_wedge_dot(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * other.g0, vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g2.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g2.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g2.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + self_.g3 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + vec3<f32>(self_.g3.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g3.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g3.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn origin_flector_wedge_dot(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w));
}

fn origin_horizon_wedge_dot(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_line_wedge_dot(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_line_at_infinity_wedge_dot(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_wedge_dot(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.x);
}

fn origin_motor_wedge_dot(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_multi_vector_wedge_dot(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g4.w), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn origin_plane_wedge_dot(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn origin_point_wedge_dot(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn origin_point_at_infinity_wedge_dot(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_scalar_wedge_dot(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_translator_wedge_dot(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_anti_scalar_wedge_dot(self_: Plane, other: AntiScalar) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn plane_flector_wedge_dot(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn plane_horizon_wedge_dot(self_: Plane, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_line_wedge_dot(self_: Plane, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g1.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_line_at_infinity_wedge_dot(self_: Plane, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_line_at_origin_wedge_dot(self_: Plane, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_magnitude_wedge_dot(self_: Plane, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_motor_wedge_dot(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, other.g0.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_multi_vector_wedge_dot(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) - vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, other.g1.w), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, other.g0.y), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, other.g0.x));
}

fn plane_origin_wedge_dot(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn plane_plane_wedge_dot(self_: Plane, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn plane_plane_at_origin_wedge_dot(self_: Plane, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_wedge_dot(self_: Plane, other: Point) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_point_at_infinity_wedge_dot(self_: Plane, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_rotor_wedge_dot(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_scalar_wedge_dot(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_translator_wedge_dot(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_flector_wedge_dot(self_: PlaneAtOrigin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn plane_at_origin_horizon_wedge_dot(self_: PlaneAtOrigin, other: Horizon) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_wedge_dot(self_: PlaneAtOrigin, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_line_at_infinity_wedge_dot(self_: PlaneAtOrigin, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_magnitude_wedge_dot(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn plane_at_origin_motor_wedge_dot(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn plane_at_origin_multi_vector_wedge_dot(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g3.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g3.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g3.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0));
}

fn plane_at_origin_plane_wedge_dot(self_: PlaneAtOrigin, other: Plane) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_point_wedge_dot(self_: PlaneAtOrigin, other: Point) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn plane_at_origin_point_at_infinity_wedge_dot(self_: PlaneAtOrigin, other: PointAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn plane_at_origin_scalar_wedge_dot(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_translator_wedge_dot(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn point_anti_scalar_wedge_dot(self_: Point, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn point_flector_wedge_dot(self_: Point, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(0.0));
}

fn point_horizon_wedge_dot(self_: Point, other: Horizon) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0) * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn point_line_wedge_dot(self_: Point, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_line_at_infinity_wedge_dot(self_: Point, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_line_at_origin_wedge_dot(self_: Point, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn point_magnitude_wedge_dot(self_: Point, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x), self_.g0.xyzx * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn point_motor_wedge_dot(self_: Point, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_multi_vector_wedge_dot(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn point_origin_wedge_dot(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn point_plane_wedge_dot(self_: Point, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w));
}

fn point_plane_at_origin_wedge_dot(self_: Point, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn point_point_wedge_dot(self_: Point, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_point_at_infinity_wedge_dot(self_: Point, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_rotor_wedge_dot(self_: Point, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0));
}

fn point_scalar_wedge_dot(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_translator_wedge_dot(self_: Point, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn point_at_infinity_anti_scalar_wedge_dot(self_: PointAtInfinity, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_flector_wedge_dot(self_: PointAtInfinity, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, other.g1.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, other.g1.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, other.g1.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g0.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g0.w) * vec3<f32>(-1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g0.z, other.g0.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g1.w, other.g0.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(0.0));
}

fn point_at_infinity_horizon_wedge_dot(self_: PointAtInfinity, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_line_wedge_dot(self_: PointAtInfinity, other: Line) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_infinity_wedge_dot(self_: PointAtInfinity, other: LineAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_origin_wedge_dot(self_: PointAtInfinity, other: LineAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn point_at_infinity_magnitude_wedge_dot(self_: PointAtInfinity, other: Magnitude) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn point_at_infinity_motor_wedge_dot(self_: PointAtInfinity, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn point_at_infinity_multi_vector_wedge_dot(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g4.z), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, other.g0.x, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, other.g0.x, other.g2.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g1.w, other.g4.z, other.g4.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, other.g1.w, other.g4.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, other.g1.w) * vec3<f32>(-1.0, 1.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g4.w, other.g1.z, other.g1.y) * vec3<f32>(-1.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, other.g4.w, other.g1.x) * vec3<f32>(1.0, -1.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, other.g4.w) * vec3<f32>(-1.0, 1.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.y, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, other.g0.y, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, other.g0.y, other.g3.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn point_at_infinity_origin_wedge_dot(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_plane_wedge_dot(self_: PointAtInfinity, other: Plane) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_plane_at_origin_wedge_dot(self_: PointAtInfinity, other: PlaneAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, -1.0, 1.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(1.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(-1.0, 1.0, 0.0, 1.0));
}

fn point_at_infinity_point_wedge_dot(self_: PointAtInfinity, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_point_at_infinity_wedge_dot(self_: PointAtInfinity, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(0.0));
}

fn point_at_infinity_rotor_wedge_dot(self_: PointAtInfinity, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g0.w, other.g0.x, 0.0) * vec4<f32>(-1.0, 1.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g0.w, 0.0) * vec4<f32>(1.0, -1.0, 1.0, 0.0));
}

fn point_at_infinity_scalar_wedge_dot(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_translator_wedge_dot(self_: PointAtInfinity, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn rotor_flector_wedge_dot(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_horizon_wedge_dot(self_: Rotor, other: Horizon) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0), self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_line_wedge_dot(self_: Rotor, other: Line) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn rotor_line_at_infinity_wedge_dot(self_: Rotor, other: LineAtInfinity) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_magnitude_wedge_dot(self_: Rotor, other: Magnitude) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0.x));
}

fn rotor_motor_wedge_dot(self_: Rotor, other: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn rotor_multi_vector_wedge_dot(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g1.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g1.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g1.z) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, 0.0) * vec4<f32>(-1.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, 0.0) * vec4<f32>(1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, 0.0) * vec4<f32>(-1.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_plane_wedge_dot(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_point_wedge_dot(self_: Rotor, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_point_at_infinity_wedge_dot(self_: Rotor, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn rotor_scalar_wedge_dot(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_translator_wedge_dot(self_: Rotor, other: Translator) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn scalar_anti_scalar_wedge_dot(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_flector_wedge_dot(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_wedge_dot(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_line_wedge_dot(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_wedge_dot(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_wedge_dot(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_wedge_dot(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_wedge_dot(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_wedge_dot(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn scalar_origin_wedge_dot(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_wedge_dot(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_wedge_dot(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_wedge_dot(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_wedge_dot(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_rotor_wedge_dot(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_scalar_wedge_dot(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_translator_wedge_dot(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn translator_anti_scalar_wedge_dot(self_: Translator, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_flector_wedge_dot(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, other.g1.w, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g1.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g0.w, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g0.w, other.g0.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn translator_horizon_wedge_dot(self_: Translator, other: Horizon) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn translator_line_wedge_dot(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn translator_line_at_infinity_wedge_dot(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn translator_line_at_origin_wedge_dot(self_: Translator, other: LineAtOrigin) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn translator_magnitude_wedge_dot(self_: Translator, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, other.g0.x), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x));
}

fn translator_motor_wedge_dot(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, other.g0.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, other.g0.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, other.g0.z), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.w, other.g0.z, other.g0.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, other.g0.w, other.g0.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, other.g0.w) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn translator_multi_vector_wedge_dot(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(0.0) - vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, other.g2.x) - vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, other.g2.y) - vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, other.g2.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, other.g1.z, other.g1.y, other.g4.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, other.g4.w, other.g1.x, other.g4.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, other.g4.w, other.g4.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g4.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.y, other.g2.z, other.g2.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g2.z, other.g0.y, other.g2.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g2.y, other.g2.x, other.g0.y) * vec3<f32>(1.0, -1.0, 1.0) + vec3<f32>(self_.g0.w) * other.g3, vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g3.z, other.g3.y) * vec3<f32>(1.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g3.z, other.g0.x, other.g3.x) * vec3<f32>(-1.0, 1.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g3.y, other.g3.x, other.g0.x) * vec3<f32>(1.0, -1.0, 1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, other.g4.z, other.g4.y, other.g1.x) * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, other.g1.w, other.g4.x, other.g1.y) * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, other.g1.w, other.g1.z) * vec4<f32>(1.0, -1.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn translator_origin_wedge_dot(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_plane_wedge_dot(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn translator_plane_at_origin_wedge_dot(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn translator_point_wedge_dot(self_: Translator, other: Point) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0));
}

fn translator_point_at_infinity_wedge_dot(self_: Translator, other: PointAtInfinity) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) - self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z));
}

fn translator_rotor_wedge_dot(self_: Translator, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0.wzyx * vec4<f32>(1.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * other.g0.zwxy * vec4<f32>(-1.0, 1.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * other.g0.yxwz * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn translator_scalar_wedge_dot(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_translator_wedge_dot(self_: Translator, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec4<f32>(0.0));
}

fn anti_scalar_anti_scalar_anti_wedge(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_flector_anti_wedge(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_anti_wedge(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_line_anti_wedge(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_anti_wedge(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_anti_wedge(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_anti_wedge(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_anti_wedge(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_anti_wedge(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn anti_scalar_origin_anti_wedge(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_anti_wedge(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_anti_wedge(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_anti_wedge(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_anti_wedge(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_rotor_anti_wedge(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_scalar_anti_wedge(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_translator_anti_wedge(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn flector_anti_scalar_anti_wedge(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_flector_anti_wedge(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn flector_horizon_anti_wedge(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_line_anti_wedge(self_: Flector, other: Line) -> Point {
    return Point(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_line_at_infinity_anti_wedge(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn flector_line_at_origin_anti_wedge(self_: Flector, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flector_magnitude_anti_wedge(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_motor_anti_wedge(self_: Flector, other: Motor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_multi_vector_anti_wedge(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), self_.g0 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g4.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_origin_anti_wedge(self_: Flector, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g1.w * other.g0);
}

fn flector_plane_anti_wedge(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_plane_at_origin_anti_wedge(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(0.0));
}

fn flector_point_anti_wedge(self_: Flector, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z - self_.g1.w * other.g0.w);
}

fn flector_point_at_infinity_anti_wedge(self_: Flector, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn flector_rotor_anti_wedge(self_: Flector, other: Rotor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_translator_anti_wedge(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn horizon_anti_scalar_anti_wedge(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_flector_anti_wedge(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn horizon_line_anti_wedge(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_anti_wedge(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_anti_wedge(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.y);
}

fn horizon_motor_anti_wedge(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_anti_wedge(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn horizon_origin_anti_wedge(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_plane_anti_wedge(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_anti_wedge(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_anti_wedge(self_: Horizon, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_rotor_anti_wedge(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_translator_anti_wedge(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn line_anti_scalar_anti_wedge(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_flector_anti_wedge(self_: Line, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_horizon_anti_wedge(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_anti_wedge(self_: Line, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_at_infinity_anti_wedge(self_: Line, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_anti_wedge(self_: Line, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_anti_wedge(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y));
}

fn line_motor_anti_wedge(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_multi_vector_anti_wedge(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn line_plane_anti_wedge(self_: Line, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_plane_at_origin_anti_wedge(self_: Line, other: PlaneAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_rotor_anti_wedge(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_translator_anti_wedge(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_anti_scalar_anti_wedge(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_flector_anti_wedge(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_infinity_line_anti_wedge(self_: LineAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_line_at_origin_anti_wedge(self_: LineAtInfinity, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_anti_wedge(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_infinity_motor_anti_wedge(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_multi_vector_anti_wedge(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn line_at_infinity_plane_anti_wedge(self_: LineAtInfinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_infinity_plane_at_origin_anti_wedge(self_: LineAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_infinity_rotor_anti_wedge(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_translator_anti_wedge(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_anti_wedge(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_flector_anti_wedge(self_: LineAtOrigin, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_origin_horizon_anti_wedge(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_anti_wedge(self_: LineAtOrigin, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_at_infinity_anti_wedge(self_: LineAtOrigin, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_magnitude_anti_wedge(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_origin_motor_anti_wedge(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_multi_vector_anti_wedge(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_plane_anti_wedge(self_: LineAtOrigin, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_origin_plane_at_origin_anti_wedge(self_: LineAtOrigin, other: PlaneAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_rotor_anti_wedge(self_: LineAtOrigin, other: Rotor) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_translator_anti_wedge(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn magnitude_anti_scalar_anti_wedge(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_flector_anti_wedge(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * other.g1);
}

fn magnitude_horizon_anti_wedge(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.y * other.g0);
}

fn magnitude_line_anti_wedge(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1);
}

fn magnitude_line_at_infinity_anti_wedge(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_line_at_origin_anti_wedge(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_magnitude_anti_wedge(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_anti_wedge(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(0.0));
}

fn magnitude_multi_vector_anti_wedge(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.y) * other.g3, vec4<f32>(self_.g0.y) * other.g4);
}

fn magnitude_origin_anti_wedge(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.y * other.g0);
}

fn magnitude_plane_anti_wedge(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_plane_at_origin_anti_wedge(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_anti_wedge(self_: Magnitude, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_at_infinity_anti_wedge(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_rotor_anti_wedge(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn magnitude_scalar_anti_wedge(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn magnitude_translator_anti_wedge(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn motor_anti_scalar_anti_wedge(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_flector_anti_wedge(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g1);
}

fn motor_horizon_anti_wedge(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_line_anti_wedge(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn motor_line_at_infinity_anti_wedge(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn motor_line_at_origin_anti_wedge(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn motor_magnitude_anti_wedge(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn motor_motor_anti_wedge(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g0.w) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn motor_multi_vector_anti_wedge(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3 + self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(self_.g0.w) * other.g4);
}

fn motor_origin_anti_wedge(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn motor_plane_anti_wedge(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_plane_at_origin_anti_wedge(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn motor_point_anti_wedge(self_: Motor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_point_at_infinity_anti_wedge(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn motor_rotor_anti_wedge(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn motor_scalar_anti_wedge(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn motor_translator_anti_wedge(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn multi_vector_anti_scalar_anti_wedge(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_flector_anti_wedge(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.y) * other.g1);
}

fn multi_vector_horizon_anti_wedge(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_anti_wedge(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(0.0));
}

fn multi_vector_line_at_infinity_anti_wedge(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec4<f32>(0.0));
}

fn multi_vector_line_at_origin_anti_wedge(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_magnitude_anti_wedge(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec4<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.y), self_.g4 * vec4<f32>(other.g0.y));
}

fn multi_vector_motor_anti_wedge(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * other.g1 + self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec4<f32>(other.g0.w));
}

fn multi_vector_multi_vector_anti_wedge(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g4.w, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g1 + self_.g1 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.y) * other.g2 + self_.g2 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.y) * other.g3 + self_.g3 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g4.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.y) * other.g4 + self_.g4 * vec4<f32>(other.g0.y));
}

fn multi_vector_origin_anti_wedge(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_plane_anti_wedge(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * other.g0);
}

fn multi_vector_plane_at_origin_anti_wedge(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4.w) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_point_anti_wedge(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_point_at_infinity_anti_wedge(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_rotor_anti_wedge(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g2 * vec3<f32>(other.g0.w), self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec4<f32>(other.g0.w));
}

fn multi_vector_scalar_anti_wedge(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn multi_vector_translator_anti_wedge(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec4<f32>(other.g0.w));
}

fn origin_anti_scalar_anti_wedge(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_flector_anti_wedge(self_: Origin, other: Flector) -> Scalar {
    return Scalar(self_.g0 * other.g1.w);
}

fn origin_horizon_anti_wedge(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn origin_magnitude_anti_wedge(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.y);
}

fn origin_motor_anti_wedge(self_: Origin, other: Motor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_multi_vector_anti_wedge(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g4.w, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_plane_anti_wedge(self_: Origin, other: Plane) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn origin_rotor_anti_wedge(self_: Origin, other: Rotor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_translator_anti_wedge(self_: Origin, other: Translator) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn plane_anti_scalar_anti_wedge(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_flector_anti_wedge(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn plane_horizon_anti_wedge(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_anti_wedge(self_: Plane, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_line_at_infinity_anti_wedge(self_: Plane, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn plane_line_at_origin_anti_wedge(self_: Plane, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn plane_magnitude_anti_wedge(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_motor_anti_wedge(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_multi_vector_anti_wedge(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g4.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_origin_anti_wedge(self_: Plane, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn plane_plane_anti_wedge(self_: Plane, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_anti_wedge(self_: Plane, other: PlaneAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_anti_wedge(self_: Plane, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_point_at_infinity_anti_wedge(self_: Plane, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_rotor_anti_wedge(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_translator_anti_wedge(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_at_origin_anti_scalar_anti_wedge(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_flector_anti_wedge(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), self_.g0 * vec3<f32>(other.g1.w), vec4<f32>(0.0));
}

fn plane_at_origin_horizon_anti_wedge(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_anti_wedge(self_: PlaneAtOrigin, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn plane_at_origin_line_at_infinity_anti_wedge(self_: PlaneAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn plane_at_origin_line_at_origin_anti_wedge(self_: PlaneAtOrigin, other: LineAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_magnitude_anti_wedge(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn plane_at_origin_motor_anti_wedge(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_multi_vector_anti_wedge(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), self_.g0 * vec3<f32>(other.g4.w), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn plane_at_origin_plane_anti_wedge(self_: PlaneAtOrigin, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_anti_wedge(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn plane_at_origin_point_anti_wedge(self_: PlaneAtOrigin, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_point_at_infinity_anti_wedge(self_: PlaneAtOrigin, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_rotor_anti_wedge(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_translator_anti_wedge(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn point_anti_scalar_anti_wedge(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_flector_anti_wedge(self_: Point, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g0.w * other.g1.w);
}

fn point_horizon_anti_wedge(self_: Point, other: Horizon) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn point_magnitude_anti_wedge(self_: Point, other: Magnitude) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.y));
}

fn point_motor_anti_wedge(self_: Point, other: Motor) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.w));
}

fn point_multi_vector_anti_wedge(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, 0.0), self_.g0 * vec4<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_plane_anti_wedge(self_: Point, other: Plane) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn point_plane_at_origin_anti_wedge(self_: Point, other: PlaneAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_rotor_anti_wedge(self_: Point, other: Rotor) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.w));
}

fn point_translator_anti_wedge(self_: Point, other: Translator) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.w));
}

fn point_at_infinity_anti_scalar_anti_wedge(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_flector_anti_wedge(self_: PointAtInfinity, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn point_at_infinity_magnitude_anti_wedge(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn point_at_infinity_motor_anti_wedge(self_: PointAtInfinity, other: Motor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_multi_vector_anti_wedge(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_at_infinity_plane_anti_wedge(self_: PointAtInfinity, other: Plane) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_plane_at_origin_anti_wedge(self_: PointAtInfinity, other: PlaneAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_rotor_anti_wedge(self_: PointAtInfinity, other: Rotor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_translator_anti_wedge(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn rotor_anti_scalar_anti_wedge(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_flector_anti_wedge(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_anti_wedge(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_anti_wedge(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_line_at_infinity_anti_wedge(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn rotor_line_at_origin_anti_wedge(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_magnitude_anti_wedge(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_motor_anti_wedge(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_multi_vector_anti_wedge(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.w) * other.g4);
}

fn rotor_origin_anti_wedge(self_: Rotor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn rotor_plane_anti_wedge(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_anti_wedge(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_anti_wedge(self_: Rotor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_point_at_infinity_anti_wedge(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_rotor_anti_wedge(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_scalar_anti_wedge(self_: Rotor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn rotor_translator_anti_wedge(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_anti_scalar_anti_wedge(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_magnitude_anti_wedge(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_motor_anti_wedge(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_multi_vector_anti_wedge(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_rotor_anti_wedge(self_: Scalar, other: Rotor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_translator_anti_wedge(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn translator_anti_scalar_anti_wedge(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_flector_anti_wedge(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_anti_wedge(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_line_anti_wedge(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_line_at_infinity_anti_wedge(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_anti_wedge(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn translator_magnitude_anti_wedge(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn translator_motor_anti_wedge(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_multi_vector_anti_wedge(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.w) * other.g4);
}

fn translator_origin_anti_wedge(self_: Translator, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn translator_plane_anti_wedge(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_anti_wedge(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_point_anti_wedge(self_: Translator, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_infinity_anti_wedge(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_rotor_anti_wedge(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn translator_scalar_anti_wedge(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn translator_translator_anti_wedge(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_magnitude_join(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_multi_vector_join(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_scalar_join(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn flector_flector_join(self_: Flector, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g1.x) * vec4<f32>(-1.0, 0.0, 0.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g1.y) * vec4<f32>(0.0, -1.0, 0.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g1.z) * vec4<f32>(0.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn flector_horizon_join(self_: Flector, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn flector_line_join(self_: Flector, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flector_line_at_infinity_join(self_: Flector, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flector_line_at_origin_join(self_: Flector, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn flector_magnitude_join(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_motor_join(self_: Flector, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flector_multi_vector_join(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), self_.g0 * vec4<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_origin_join(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn flector_plane_join(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn flector_plane_at_origin_join(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn flector_point_join(self_: Flector, other: Point) -> Motor {
    return Motor(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn flector_point_at_infinity_join(self_: Flector, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn flector_rotor_join(self_: Flector, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn flector_scalar_join(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_translator_join(self_: Flector, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn horizon_flector_join(self_: Horizon, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_magnitude_join(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.x);
}

fn horizon_multi_vector_join(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x));
}

fn horizon_origin_join(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn horizon_point_join(self_: Horizon, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_scalar_join(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn line_flector_join(self_: Line, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_line_join(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_at_infinity_join(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_join(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_join(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn line_motor_join(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_multi_vector_join(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_origin_join(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn line_point_join(self_: Line, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_point_at_infinity_join(self_: Line, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_rotor_join(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_scalar_join(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_translator_join(self_: Line, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_flector_join(self_: LineAtInfinity, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_line_join(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_line_at_origin_join(self_: LineAtInfinity, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_join(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_infinity_motor_join(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_multi_vector_join(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_origin_join(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_point_join(self_: LineAtInfinity, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_point_at_infinity_join(self_: LineAtInfinity, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_rotor_join(self_: LineAtInfinity, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_scalar_join(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_flector_join(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_origin_line_join(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_at_infinity_join(self_: LineAtOrigin, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_magnitude_join(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_motor_join(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_multi_vector_join(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_point_join(self_: LineAtOrigin, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_origin_point_at_infinity_join(self_: LineAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_origin_scalar_join(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_translator_join(self_: LineAtOrigin, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn magnitude_anti_scalar_join(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn magnitude_flector_join(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.x) * other.g1);
}

fn magnitude_horizon_join(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.x * other.g0);
}

fn magnitude_line_join(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_line_at_infinity_join(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_line_at_origin_join(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_join(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x));
}

fn magnitude_motor_join(self_: Magnitude, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_multi_vector_join(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2, vec3<f32>(self_.g0.x) * other.g3, vec4<f32>(self_.g0.x) * other.g4);
}

fn magnitude_origin_join(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.x * other.g0);
}

fn magnitude_plane_join(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_plane_at_origin_join(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_join(self_: Magnitude, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_at_infinity_join(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_rotor_join(self_: Magnitude, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_scalar_join(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_translator_join(self_: Magnitude, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x) * other.g0);
}

fn motor_flector_join(self_: Motor, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_line_join(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_line_at_infinity_join(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn motor_line_at_origin_join(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_magnitude_join(self_: Motor, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn motor_motor_join(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_multi_vector_join(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_origin_join(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn motor_point_join(self_: Motor, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_point_at_infinity_join(self_: Motor, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_rotor_join(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_scalar_join(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_translator_join(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn multi_vector_anti_scalar_join(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn multi_vector_flector_join(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_horizon_join(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_join(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn multi_vector_line_at_infinity_join(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn multi_vector_line_at_origin_join(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_magnitude_join(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), self_.g1 * vec4<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x), self_.g3 * vec3<f32>(other.g0.x), self_.g4 * vec4<f32>(other.g0.x));
}

fn multi_vector_motor_join(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn multi_vector_multi_vector_join(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g1 + self_.g1 * vec4<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g2 - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + self_.g2 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + self_.g3 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * other.g4 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + self_.g4 * vec4<f32>(other.g0.x));
}

fn multi_vector_origin_join(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_plane_join(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0);
}

fn multi_vector_plane_at_origin_join(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_point_join(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_point_at_infinity_join(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_rotor_join(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_scalar_join(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_translator_join(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn origin_flector_join(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w));
}

fn origin_horizon_join(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_line_join(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_line_at_infinity_join(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_join(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.x);
}

fn origin_motor_join(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_multi_vector_join(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g4.w), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn origin_plane_join(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn origin_point_join(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn origin_point_at_infinity_join(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_scalar_join(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_translator_join(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_flector_join(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_magnitude_join(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_multi_vector_join(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_origin_join(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn plane_point_join(self_: Plane, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_point_at_infinity_join(self_: Plane, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_scalar_join(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_at_origin_flector_join(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_magnitude_join(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn plane_at_origin_multi_vector_join(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0));
}

fn plane_at_origin_point_join(self_: PlaneAtOrigin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_point_at_infinity_join(self_: PlaneAtOrigin, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_scalar_join(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_flector_join(self_: Point, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g1.x) * vec4<f32>(-1.0, 0.0, 0.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g1.y) * vec4<f32>(0.0, -1.0, 0.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g1.z) * vec4<f32>(0.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_horizon_join(self_: Point, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn point_line_join(self_: Point, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_line_at_infinity_join(self_: Point, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_line_at_origin_join(self_: Point, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_magnitude_join(self_: Point, other: Magnitude) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.x));
}

fn point_motor_join(self_: Point, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_multi_vector_join(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w), self_.g0 * vec4<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn point_origin_join(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn point_plane_join(self_: Point, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn point_plane_at_origin_join(self_: Point, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_point_join(self_: Point, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_point_at_infinity_join(self_: Point, other: PointAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_rotor_join(self_: Point, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_scalar_join(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_translator_join(self_: Point, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_at_infinity_flector_join(self_: PointAtInfinity, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g1.x) * vec4<f32>(-1.0, 0.0, 0.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g1.y) * vec4<f32>(0.0, -1.0, 0.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g1.z) * vec4<f32>(0.0, 0.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_at_infinity_line_join(self_: PointAtInfinity, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_infinity_join(self_: PointAtInfinity, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_line_at_origin_join(self_: PointAtInfinity, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_at_infinity_magnitude_join(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn point_at_infinity_motor_join(self_: PointAtInfinity, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_multi_vector_join(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_origin_join(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_plane_join(self_: PointAtInfinity, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_plane_at_origin_join(self_: PointAtInfinity, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_point_join(self_: PointAtInfinity, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_at_infinity_point_at_infinity_join(self_: PointAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_at_infinity_rotor_join(self_: PointAtInfinity, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_at_infinity_scalar_join(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_translator_join(self_: PointAtInfinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_flector_join(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn rotor_line_join(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_line_at_infinity_join(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_magnitude_join(self_: Rotor, other: Magnitude) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0.x));
}

fn rotor_motor_join(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_multi_vector_join(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn rotor_point_join(self_: Rotor, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn rotor_point_at_infinity_join(self_: Rotor, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn rotor_scalar_join(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_translator_join(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn scalar_anti_scalar_join(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_flector_join(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_join(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_line_join(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_join(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_join(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_join(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_join(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_join(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn scalar_origin_join(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_join(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_join(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_join(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_join(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_rotor_join(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_scalar_join(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_translator_join(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn translator_flector_join(self_: Translator, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn translator_line_join(self_: Translator, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_line_at_origin_join(self_: Translator, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_magnitude_join(self_: Translator, other: Magnitude) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0.x));
}

fn translator_motor_join(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_multi_vector_join(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn translator_origin_join(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_point_join(self_: Translator, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn translator_point_at_infinity_join(self_: Translator, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_rotor_join(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_scalar_join(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn anti_scalar_anti_scalar_meet(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_flector_meet(self_: AntiScalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn anti_scalar_horizon_meet(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn anti_scalar_line_meet(self_: AntiScalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_line_at_infinity_meet(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_line_at_origin_meet(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_magnitude_meet(self_: AntiScalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn anti_scalar_motor_meet(self_: AntiScalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn anti_scalar_multi_vector_meet(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn anti_scalar_origin_meet(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn anti_scalar_plane_meet(self_: AntiScalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_plane_at_origin_meet(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_meet(self_: AntiScalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_point_at_infinity_meet(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn anti_scalar_rotor_meet(self_: AntiScalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn anti_scalar_scalar_meet(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn anti_scalar_translator_meet(self_: AntiScalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn flector_anti_scalar_meet(self_: Flector, other: AntiScalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_flector_meet(self_: Flector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn flector_horizon_meet(self_: Flector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec4<f32>(0.0));
}

fn flector_line_meet(self_: Flector, other: Line) -> Point {
    return Point(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn flector_line_at_infinity_meet(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn flector_line_at_origin_meet(self_: Flector, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flector_magnitude_meet(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.y), self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_motor_meet(self_: Flector, other: Motor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_multi_vector_meet(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), self_.g0 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g4.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), self_.g1 * vec4<f32>(other.g0.y));
}

fn flector_origin_meet(self_: Flector, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g1.w * other.g0);
}

fn flector_plane_meet(self_: Flector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn flector_plane_at_origin_meet(self_: Flector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g1.w) * other.g0, vec4<f32>(0.0));
}

fn flector_point_meet(self_: Flector, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z - self_.g1.w * other.g0.w);
}

fn flector_point_at_infinity_meet(self_: Flector, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn flector_rotor_meet(self_: Flector, other: Rotor) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn flector_translator_meet(self_: Flector, other: Translator) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g1 * vec4<f32>(other.g0.w));
}

fn horizon_anti_scalar_meet(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn horizon_flector_meet(self_: Horizon, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn horizon_line_meet(self_: Horizon, other: Line) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_line_at_origin_meet(self_: Horizon, other: LineAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn horizon_magnitude_meet(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.y);
}

fn horizon_motor_meet(self_: Horizon, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_multi_vector_meet(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y));
}

fn horizon_origin_meet(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_plane_meet(self_: Horizon, other: Plane) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn horizon_plane_at_origin_meet(self_: Horizon, other: PlaneAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(0.0) - vec3<f32>(self_.g0) * other.g0);
}

fn horizon_point_meet(self_: Horizon, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_rotor_meet(self_: Horizon, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w));
}

fn horizon_translator_meet(self_: Horizon, other: Translator) -> Horizon {
    return Horizon(self_.g0 * other.g0.w);
}

fn line_anti_scalar_meet(self_: Line, other: AntiScalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_flector_meet(self_: Line, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_horizon_meet(self_: Line, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_line_meet(self_: Line, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_at_infinity_meet(self_: Line, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_meet(self_: Line, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_meet(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y));
}

fn line_motor_meet(self_: Line, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_multi_vector_meet(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), self_.g0 * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn line_plane_meet(self_: Line, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_plane_at_origin_meet(self_: Line, other: PlaneAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_rotor_meet(self_: Line, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_translator_meet(self_: Line, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_anti_scalar_meet(self_: LineAtInfinity, other: AntiScalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_flector_meet(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_infinity_line_meet(self_: LineAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_line_at_origin_meet(self_: LineAtInfinity, other: LineAtOrigin) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_meet(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_infinity_motor_meet(self_: LineAtInfinity, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_multi_vector_meet(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn line_at_infinity_plane_meet(self_: LineAtInfinity, other: Plane) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_infinity_plane_at_origin_meet(self_: LineAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_infinity_rotor_meet(self_: LineAtInfinity, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn line_at_infinity_translator_meet(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_anti_scalar_meet(self_: LineAtOrigin, other: AntiScalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_flector_meet(self_: LineAtOrigin, other: Flector) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_origin_horizon_meet(self_: LineAtOrigin, other: Horizon) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_line_meet(self_: LineAtOrigin, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_at_infinity_meet(self_: LineAtOrigin, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_magnitude_meet(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn line_at_origin_motor_meet(self_: LineAtOrigin, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_multi_vector_meet(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), self_.g0 * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn line_at_origin_plane_meet(self_: LineAtOrigin, other: Plane) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_origin_plane_at_origin_meet(self_: LineAtOrigin, other: PlaneAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_rotor_meet(self_: LineAtOrigin, other: Rotor) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.w));
}

fn line_at_origin_translator_meet(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn magnitude_anti_scalar_meet(self_: Magnitude, other: AntiScalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_flector_meet(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * other.g1);
}

fn magnitude_horizon_meet(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.y * other.g0);
}

fn magnitude_line_meet(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1);
}

fn magnitude_line_at_infinity_meet(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_line_at_origin_meet(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_magnitude_meet(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0);
}

fn magnitude_motor_meet(self_: Magnitude, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(0.0));
}

fn magnitude_multi_vector_meet(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, vec4<f32>(self_.g0.y) * other.g1, vec3<f32>(self_.g0.y) * other.g2, vec3<f32>(self_.g0.y) * other.g3, vec4<f32>(self_.g0.y) * other.g4);
}

fn magnitude_origin_meet(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.y * other.g0);
}

fn magnitude_plane_meet(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_plane_at_origin_meet(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_meet(self_: Magnitude, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.y) * other.g0);
}

fn magnitude_point_at_infinity_meet(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.y) * other.g0);
}

fn magnitude_rotor_meet(self_: Magnitude, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn magnitude_scalar_meet(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn magnitude_translator_meet(self_: Magnitude, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn motor_anti_scalar_meet(self_: Motor, other: AntiScalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_flector_meet(self_: Motor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g1);
}

fn motor_horizon_meet(self_: Motor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn motor_line_meet(self_: Motor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn motor_line_at_infinity_meet(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn motor_line_at_origin_meet(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn motor_magnitude_meet(self_: Motor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn motor_motor_meet(self_: Motor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g0.w) * vec2<f32>(-1.0, 1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1 + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn motor_multi_vector_meet(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3 + self_.g1 * vec3<f32>(other.g0.y), vec4<f32>(self_.g0.w) * other.g4);
}

fn motor_origin_meet(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn motor_plane_meet(self_: Motor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_plane_at_origin_meet(self_: Motor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn motor_point_meet(self_: Motor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.w) * other.g0);
}

fn motor_point_at_infinity_meet(self_: Motor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn motor_rotor_meet(self_: Motor, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn motor_scalar_meet(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn motor_translator_meet(self_: Motor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g1 * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn multi_vector_anti_scalar_meet(self_: MultiVector, other: AntiScalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_flector_meet(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g1.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g1.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g1.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g1.w, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g0 + vec4<f32>(self_.g2.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(self_.g0.y) * other.g1);
}

fn multi_vector_horizon_meet(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(other.g0, 0.0), vec4<f32>(self_.g2.x, self_.g2.y, self_.g2.z, self_.g2.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_meet(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(self_.g0.y) * other.g1, vec4<f32>(0.0));
}

fn multi_vector_line_at_infinity_meet(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.y) * other.g0, vec4<f32>(0.0));
}

fn multi_vector_line_at_origin_meet(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_magnitude_meet(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0, self_.g1 * vec4<f32>(other.g0.y), self_.g2 * vec3<f32>(other.g0.y), self_.g3 * vec3<f32>(other.g0.y), self_.g4 * vec4<f32>(other.g0.y));
}

fn multi_vector_motor_meet(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * other.g1 + self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec4<f32>(other.g0.w));
}

fn multi_vector_multi_vector_meet(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g0.y) * other.g0 + vec2<f32>(self_.g1.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g4.w, 0.0) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g1 + self_.g1 * vec4<f32>(other.g0.y) + vec4<f32>(self_.g2.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g4.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.y) * other.g2 + self_.g2 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.y) * other.g3 + self_.g3 * vec3<f32>(other.g0.y) + vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g4.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), vec4<f32>(self_.g0.y) * other.g4 + self_.g4 * vec4<f32>(other.g0.y));
}

fn multi_vector_origin_meet(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.w) * vec2<f32>(other.g0, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_plane_meet(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0) + vec2<f32>(self_.g1.w) * vec2<f32>(other.g0.w, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g4.x, self_.g4.y, self_.g4.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g4.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g0.y) * other.g0);
}

fn multi_vector_plane_at_origin_meet(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(other.g0.x, 0.0) + vec2<f32>(self_.g1.y) * vec2<f32>(other.g0.y, 0.0) + vec2<f32>(self_.g1.z) * vec2<f32>(other.g0.z, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g2.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g3.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g3.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec3<f32>(self_.g4.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g4.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g4.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g4.w) * other.g0, vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_point_meet(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * other.g0, vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_point_at_infinity_meet(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g4.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn multi_vector_rotor_meet(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g3.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g4.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g4.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g2 * vec3<f32>(other.g0.w), self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec4<f32>(other.g0.w));
}

fn multi_vector_scalar_meet(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0.y * other.g0);
}

fn multi_vector_translator_meet(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g2.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), self_.g1 * vec4<f32>(other.g0.w) + vec4<f32>(self_.g4.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g4.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g4.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g2 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z) + self_.g3 * vec3<f32>(other.g0.w), self_.g4 * vec4<f32>(other.g0.w));
}

fn origin_anti_scalar_meet(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_flector_meet(self_: Origin, other: Flector) -> Scalar {
    return Scalar(self_.g0 * other.g1.w);
}

fn origin_horizon_meet(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn origin_magnitude_meet(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.y);
}

fn origin_motor_meet(self_: Origin, other: Motor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_multi_vector_meet(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(other.g4.w, 0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn origin_plane_meet(self_: Origin, other: Plane) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn origin_rotor_meet(self_: Origin, other: Rotor) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn origin_translator_meet(self_: Origin, other: Translator) -> Origin {
    return Origin(self_.g0 * other.g0.w);
}

fn plane_anti_scalar_meet(self_: Plane, other: AntiScalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_flector_meet(self_: Plane, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g0.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec4<f32>(0.0));
}

fn plane_horizon_meet(self_: Plane, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn plane_line_meet(self_: Plane, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn plane_line_at_infinity_meet(self_: Plane, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn plane_line_at_origin_meet(self_: Plane, other: LineAtOrigin) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn plane_magnitude_meet(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_motor_meet(self_: Plane, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_multi_vector_meet(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g1.w, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g2.x, other.g2.y, other.g2.z, 0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g4.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g4.x, other.g4.y, other.g4.z), self_.g0 * vec4<f32>(other.g0.y));
}

fn plane_origin_meet(self_: Plane, other: Origin) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn plane_plane_meet(self_: Plane, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) - vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_plane_at_origin_meet(self_: Plane, other: PlaneAtOrigin) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(0.0) - vec3<f32>(self_.g0.w) * other.g0);
}

fn plane_point_meet(self_: Plane, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_point_at_infinity_meet(self_: Plane, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_rotor_meet(self_: Plane, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_translator_meet(self_: Plane, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), self_.g0 * vec4<f32>(other.g0.w));
}

fn plane_at_origin_anti_scalar_meet(self_: PlaneAtOrigin, other: AntiScalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_flector_meet(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), self_.g0 * vec3<f32>(other.g1.w), vec4<f32>(0.0));
}

fn plane_at_origin_horizon_meet(self_: PlaneAtOrigin, other: Horizon) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn plane_at_origin_line_meet(self_: PlaneAtOrigin, other: Line) -> Point {
    return Point(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn plane_at_origin_line_at_infinity_meet(self_: PlaneAtOrigin, other: LineAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn plane_at_origin_line_at_origin_meet(self_: PlaneAtOrigin, other: LineAtOrigin) -> Origin {
    return Origin(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_magnitude_meet(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.y));
}

fn plane_at_origin_motor_meet(self_: PlaneAtOrigin, other: Motor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, other.g0.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, other.g0.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, other.g0.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_multi_vector_meet(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g3.z, other.g3.y, other.g2.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g3.z, 0.0, other.g3.x, other.g2.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g3.y, other.g3.x, 0.0, other.g2.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g4.z, other.g4.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g4.z, 0.0, other.g4.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g4.y, other.g4.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), self_.g0 * vec3<f32>(other.g4.w), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0));
}

fn plane_at_origin_plane_meet(self_: PlaneAtOrigin, other: Plane) -> Line {
    return Line(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0), self_.g0 * vec3<f32>(other.g0.w));
}

fn plane_at_origin_plane_at_origin_meet(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn plane_at_origin_point_meet(self_: PlaneAtOrigin, other: Point) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_point_at_infinity_meet(self_: PlaneAtOrigin, other: PointAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_rotor_meet(self_: PlaneAtOrigin, other: Rotor) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn plane_at_origin_translator_meet(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0));
}

fn point_anti_scalar_meet(self_: Point, other: AntiScalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_flector_meet(self_: Point, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z + self_.g0.w * other.g1.w);
}

fn point_horizon_meet(self_: Point, other: Horizon) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn point_magnitude_meet(self_: Point, other: Magnitude) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.y));
}

fn point_motor_meet(self_: Point, other: Motor) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.w));
}

fn point_multi_vector_meet(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0) + vec2<f32>(self_.g0.w) * vec2<f32>(other.g4.w, 0.0), self_.g0 * vec4<f32>(other.g0.y), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_plane_meet(self_: Point, other: Plane) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn point_plane_at_origin_meet(self_: Point, other: PlaneAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_rotor_meet(self_: Point, other: Rotor) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.w));
}

fn point_translator_meet(self_: Point, other: Translator) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.w));
}

fn point_at_infinity_anti_scalar_meet(self_: PointAtInfinity, other: AntiScalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_flector_meet(self_: PointAtInfinity, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn point_at_infinity_magnitude_meet(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.y));
}

fn point_at_infinity_motor_meet(self_: PointAtInfinity, other: Motor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_multi_vector_meet(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g4.x, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g4.y, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g4.z, 0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.y, other.g0.y, other.g0.y, 0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn point_at_infinity_plane_meet(self_: PointAtInfinity, other: Plane) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_plane_at_origin_meet(self_: PointAtInfinity, other: PlaneAtOrigin) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_rotor_meet(self_: PointAtInfinity, other: Rotor) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn point_at_infinity_translator_meet(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.w));
}

fn rotor_anti_scalar_meet(self_: Rotor, other: AntiScalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_flector_meet(self_: Rotor, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn rotor_horizon_meet(self_: Rotor, other: Horizon) -> Flector {
    return Flector(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn rotor_line_meet(self_: Rotor, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g1.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_line_at_infinity_meet(self_: Rotor, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0));
}

fn rotor_line_at_origin_meet(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_magnitude_meet(self_: Rotor, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec3<f32>(0.0), vec4<f32>(0.0));
}

fn rotor_motor_meet(self_: Rotor, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g1.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g1.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g1.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn rotor_multi_vector_meet(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g3.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g3.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g3.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(other.g4.w, 0.0, 0.0, other.g4.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g4.w, 0.0, other.g4.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g4.w, other.g4.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.w) * other.g4);
}

fn rotor_origin_meet(self_: Rotor, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn rotor_plane_meet(self_: Rotor, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_plane_at_origin_meet(self_: Rotor, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn rotor_point_meet(self_: Rotor, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_point_at_infinity_meet(self_: Rotor, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn rotor_rotor_meet(self_: Rotor, other: Rotor) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn rotor_scalar_meet(self_: Rotor, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn rotor_translator_meet(self_: Rotor, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(0.0));
}

fn scalar_anti_scalar_meet(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_magnitude_meet(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_motor_meet(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_multi_vector_meet(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g0.y);
}

fn scalar_rotor_meet(self_: Scalar, other: Rotor) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn scalar_translator_meet(self_: Scalar, other: Translator) -> Scalar {
    return Scalar(self_.g0 * other.g0.w);
}

fn translator_anti_scalar_meet(self_: Translator, other: AntiScalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn translator_flector_meet(self_: Translator, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.w) * other.g1);
}

fn translator_horizon_meet(self_: Translator, other: Horizon) -> Horizon {
    return Horizon(self_.g0.w * other.g0);
}

fn translator_line_meet(self_: Translator, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_line_at_infinity_meet(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_line_at_origin_meet(self_: Translator, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g0.z, 0.0) * vec2<f32>(-1.0, 0.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(0.0), vec4<f32>(0.0));
}

fn translator_magnitude_meet(self_: Translator, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y), vec4<f32>(0.0));
}

fn translator_motor_meet(self_: Translator, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * other.g1, vec4<f32>(0.0));
}

fn translator_multi_vector_meet(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g2.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g2.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z) * vec2<f32>(other.g2.z, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.w) * other.g0, vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g4.z, other.g4.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g4.z, 0.0, other.g4.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g4.y, other.g4.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g0.w) * other.g1, vec3<f32>(self_.g0.w) * other.g2, vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.y) + vec3<f32>(self_.g0.w) * other.g3, vec4<f32>(self_.g0.w) * other.g4);
}

fn translator_origin_meet(self_: Translator, other: Origin) -> Origin {
    return Origin(self_.g0.w * other.g0);
}

fn translator_plane_meet(self_: Translator, other: Plane) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_plane_at_origin_meet(self_: Translator, other: PlaneAtOrigin) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0), vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn translator_point_meet(self_: Translator, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.w) * other.g0);
}

fn translator_point_at_infinity_meet(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.w) * other.g0);
}

fn translator_rotor_meet(self_: Translator, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(other.g0.x, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.y) * vec2<f32>(other.g0.y, 0.0) * vec2<f32>(-1.0, 0.0) + vec2<f32>(self_.g0.z, self_.g0.w) * vec2<f32>(other.g0.z, other.g0.w) * vec2<f32>(-1.0, 1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w), vec4<f32>(0.0));
}

fn translator_scalar_meet(self_: Translator, other: Scalar) -> Scalar {
    return Scalar(self_.g0.w * other.g0);
}

fn translator_translator_meet(self_: Translator, other: Translator) -> Translator {
    return Translator(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) + vec4<f32>(self_.g0.w) * other.g0);
}

fn anti_scalar_magnitude_wedge(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_multi_vector_wedge(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.x);
}

fn anti_scalar_scalar_wedge(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn flector_flector_wedge(self_: Flector, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g1.x) * vec4<f32>(-1.0, 0.0, 0.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g1.y) * vec4<f32>(0.0, -1.0, 0.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g1.z) * vec4<f32>(0.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn flector_horizon_wedge(self_: Flector, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn flector_line_wedge(self_: Flector, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flector_line_at_infinity_wedge(self_: Flector, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn flector_line_at_origin_wedge(self_: Flector, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn flector_magnitude_wedge(self_: Flector, other: Magnitude) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_motor_wedge(self_: Flector, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn flector_multi_vector_wedge(self_: Flector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), self_.g0 * vec4<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + self_.g1 * vec4<f32>(other.g0.x));
}

fn flector_origin_wedge(self_: Flector, other: Origin) -> Rotor {
    return Rotor(self_.g0.xyzx * vec4<f32>(other.g0, other.g0, other.g0, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn flector_plane_wedge(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn flector_plane_at_origin_wedge(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn flector_point_wedge(self_: Flector, other: Point) -> Motor {
    return Motor(self_.g0.xyzx * vec4<f32>(other.g0.w, other.g0.w, other.g0.w, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, other.g0.w) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn flector_point_at_infinity_wedge(self_: Flector, other: PointAtInfinity) -> Motor {
    return Motor(vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn flector_rotor_wedge(self_: Flector, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn flector_scalar_wedge(self_: Flector, other: Scalar) -> Flector {
    return Flector(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec4<f32>(other.g0));
}

fn flector_translator_wedge(self_: Flector, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn horizon_flector_wedge(self_: Horizon, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_magnitude_wedge(self_: Horizon, other: Magnitude) -> Horizon {
    return Horizon(self_.g0 * other.g0.x);
}

fn horizon_multi_vector_wedge(self_: Horizon, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x));
}

fn horizon_origin_wedge(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn horizon_point_wedge(self_: Horizon, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn horizon_scalar_wedge(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn line_flector_wedge(self_: Line, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_line_wedge(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_line_at_infinity_wedge(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_wedge(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_magnitude_wedge(self_: Line, other: Magnitude) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn line_motor_wedge(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_multi_vector_wedge(self_: Line, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_origin_wedge(self_: Line, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn line_point_wedge(self_: Line, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_point_at_infinity_wedge(self_: Line, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn line_rotor_wedge(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_scalar_wedge(self_: Line, other: Scalar) -> Line {
    return Line(self_.g0 * vec3<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn line_translator_wedge(self_: Line, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_flector_wedge(self_: LineAtInfinity, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_line_wedge(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_line_at_origin_wedge(self_: LineAtInfinity, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_magnitude_wedge(self_: LineAtInfinity, other: Magnitude) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_infinity_motor_wedge(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_multi_vector_wedge(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_origin_wedge(self_: LineAtInfinity, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_infinity_point_wedge(self_: LineAtInfinity, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn line_at_infinity_point_at_infinity_wedge(self_: LineAtInfinity, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_rotor_wedge(self_: LineAtInfinity, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_scalar_wedge(self_: LineAtInfinity, other: Scalar) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_flector_wedge(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_origin_line_wedge(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_line_at_infinity_wedge(self_: LineAtOrigin, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_magnitude_wedge(self_: LineAtOrigin, other: Magnitude) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn line_at_origin_motor_wedge(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_origin_multi_vector_wedge(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), self_.g0 * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn line_at_origin_point_wedge(self_: LineAtOrigin, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_origin_point_at_infinity_wedge(self_: LineAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn line_at_origin_scalar_wedge(self_: LineAtOrigin, other: Scalar) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn line_at_origin_translator_wedge(self_: LineAtOrigin, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn magnitude_anti_scalar_wedge(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn magnitude_flector_wedge(self_: Magnitude, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g0.x) * other.g1);
}

fn magnitude_horizon_wedge(self_: Magnitude, other: Horizon) -> Horizon {
    return Horizon(self_.g0.x * other.g0);
}

fn magnitude_line_wedge(self_: Magnitude, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_line_at_infinity_wedge(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_line_at_origin_wedge(self_: Magnitude, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_magnitude_wedge(self_: Magnitude, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x));
}

fn magnitude_motor_wedge(self_: Magnitude, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1);
}

fn magnitude_multi_vector_wedge(self_: Magnitude, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), vec4<f32>(self_.g0.x) * other.g1, vec3<f32>(self_.g0.x) * other.g2, vec3<f32>(self_.g0.x) * other.g3, vec4<f32>(self_.g0.x) * other.g4);
}

fn magnitude_origin_wedge(self_: Magnitude, other: Origin) -> Origin {
    return Origin(self_.g0.x * other.g0);
}

fn magnitude_plane_wedge(self_: Magnitude, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_plane_at_origin_wedge(self_: Magnitude, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_wedge(self_: Magnitude, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_point_at_infinity_wedge(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x) * other.g0);
}

fn magnitude_rotor_wedge(self_: Magnitude, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x) * other.g0);
}

fn magnitude_scalar_wedge(self_: Magnitude, other: Scalar) -> Magnitude {
    return Magnitude(self_.g0 * vec2<f32>(other.g0));
}

fn magnitude_translator_wedge(self_: Magnitude, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0.x) * other.g0);
}

fn motor_flector_wedge(self_: Motor, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_line_wedge(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_line_at_infinity_wedge(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn motor_line_at_origin_wedge(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_magnitude_wedge(self_: Motor, other: Magnitude) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x));
}

fn motor_motor_wedge(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_multi_vector_wedge(self_: Motor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), self_.g1 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_origin_wedge(self_: Motor, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g1 * vec3<f32>(other.g0));
}

fn motor_point_wedge(self_: Motor, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn motor_point_at_infinity_wedge(self_: Motor, other: PointAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn motor_rotor_wedge(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_scalar_wedge(self_: Motor, other: Scalar) -> Motor {
    return Motor(self_.g0 * vec4<f32>(other.g0), self_.g1 * vec3<f32>(other.g0));
}

fn motor_translator_wedge(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn multi_vector_anti_scalar_wedge(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0);
}

fn multi_vector_flector_wedge(self_: MultiVector, other: Flector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g1.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g1.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g1.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g1.w) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * other.g1 + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_horizon_wedge(self_: MultiVector, other: Horizon) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0));
}

fn multi_vector_line_wedge(self_: MultiVector, other: Line) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn multi_vector_line_at_infinity_wedge(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn multi_vector_line_at_origin_wedge(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_magnitude_wedge(self_: MultiVector, other: Magnitude) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x), self_.g1 * vec4<f32>(other.g0.x), self_.g2 * vec3<f32>(other.g0.x), self_.g3 * vec3<f32>(other.g0.x), self_.g4 * vec4<f32>(other.g0.x));
}

fn multi_vector_motor_wedge(self_: MultiVector, other: Motor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * other.g1, vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn multi_vector_multi_vector_wedge(self_: MultiVector, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * other.g0 + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g4.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g1 + self_.g1 * vec4<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g2 - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g1.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z) + self_.g2 * vec3<f32>(other.g0.x), vec3<f32>(self_.g0.x) * other.g3 + vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0) + self_.g3 * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * other.g4 + vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g1.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0) + vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0) + self_.g4 * vec4<f32>(other.g0.x));
}

fn multi_vector_origin_wedge(self_: MultiVector, other: Origin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0), vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0), vec3<f32>(0.0), vec4<f32>(self_.g3.x, self_.g3.y, self_.g3.z, self_.g3.x) * vec4<f32>(other.g0, other.g0, other.g0, 0.0));
}

fn multi_vector_plane_wedge(self_: MultiVector, other: Plane) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z) + vec2<f32>(self_.g1.w) * vec2<f32>(0.0, other.g0.w), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * other.g0);
}

fn multi_vector_plane_at_origin_wedge(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g1.x) * vec2<f32>(0.0, other.g0.x) + vec2<f32>(self_.g1.y) * vec2<f32>(0.0, other.g0.y) + vec2<f32>(self_.g1.z) * vec2<f32>(0.0, other.g0.z), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0));
}

fn multi_vector_point_wedge(self_: MultiVector, other: Point) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.w) * vec2<f32>(0.0, other.g0.w) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * other.g0, vec3<f32>(0.0) - vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g1.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn multi_vector_point_at_infinity_wedge(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g4.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g4.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, 0.0), vec3<f32>(self_.g1.w) * other.g0, vec3<f32>(self_.g1.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g1.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g1.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g2.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g2.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g2.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0) + vec4<f32>(self_.g3.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g3.z) * vec4<f32>(0.0, 0.0, 0.0, other.g0.z) * vec4<f32>(0.0, 0.0, 0.0, -1.0));
}

fn multi_vector_rotor_wedge(self_: MultiVector, other: Rotor) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g3.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g3.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(0.0), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, 0.0) * vec4<f32>(0.0, 1.0, -1.0, 0.0) + vec4<f32>(self_.g1.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, 0.0) * vec4<f32>(-1.0, 0.0, 1.0, 0.0) + vec4<f32>(self_.g1.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, 0.0) * vec4<f32>(1.0, -1.0, 0.0, 0.0));
}

fn multi_vector_scalar_wedge(self_: MultiVector, other: Scalar) -> MultiVector {
    return MultiVector(self_.g0 * vec2<f32>(other.g0), self_.g1 * vec4<f32>(other.g0), self_.g2 * vec3<f32>(other.g0), self_.g3 * vec3<f32>(other.g0), self_.g4 * vec4<f32>(other.g0));
}

fn multi_vector_translator_wedge(self_: MultiVector, other: Translator) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g0.w) + vec2<f32>(self_.g2.x) * vec2<f32>(0.0, other.g0.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.y) * vec2<f32>(0.0, other.g0.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g2.z) * vec2<f32>(0.0, other.g0.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec4<f32>(self_.g1.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g1.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g1.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn origin_flector_wedge(self_: Origin, other: Flector) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w));
}

fn origin_horizon_wedge(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn origin_line_wedge(self_: Origin, other: Line) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_line_at_infinity_wedge(self_: Origin, other: LineAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_magnitude_wedge(self_: Origin, other: Magnitude) -> Origin {
    return Origin(self_.g0 * other.g0.x);
}

fn origin_motor_wedge(self_: Origin, other: Motor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g1);
}

fn origin_multi_vector_wedge(self_: Origin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * vec2<f32>(0.0, other.g4.w), vec4<f32>(self_.g0) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x), vec3<f32>(self_.g0) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(0.0), vec4<f32>(self_.g0) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn origin_plane_wedge(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn origin_point_wedge(self_: Origin, other: Point) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn origin_point_at_infinity_wedge(self_: Origin, other: PointAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn origin_scalar_wedge(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn origin_translator_wedge(self_: Origin, other: Translator) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z));
}

fn plane_flector_wedge(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_magnitude_wedge(self_: Plane, other: Magnitude) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_multi_vector_wedge(self_: Plane, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g1.w) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), self_.g0 * vec4<f32>(other.g0.x));
}

fn plane_origin_wedge(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn plane_point_wedge(self_: Plane, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z - self_.g0.w * other.g0.w);
}

fn plane_point_at_infinity_wedge(self_: Plane, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_scalar_wedge(self_: Plane, other: Scalar) -> Plane {
    return Plane(self_.g0 * vec4<f32>(other.g0));
}

fn plane_at_origin_flector_wedge(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_magnitude_wedge(self_: PlaneAtOrigin, other: Magnitude) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0.x));
}

fn plane_at_origin_multi_vector_wedge(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g1.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g1.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g1.z) * vec2<f32>(0.0, -1.0), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(0.0), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0));
}

fn plane_at_origin_point_wedge(self_: PlaneAtOrigin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_point_at_infinity_wedge(self_: PlaneAtOrigin, other: PointAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn plane_at_origin_scalar_wedge(self_: PlaneAtOrigin, other: Scalar) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(other.g0));
}

fn point_flector_wedge(self_: Point, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g1.x) * vec4<f32>(-1.0, 0.0, 0.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g1.y) * vec4<f32>(0.0, -1.0, 0.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g1.z) * vec4<f32>(0.0, 0.0, -1.0, 1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_horizon_wedge(self_: Point, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn point_line_wedge(self_: Point, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_line_at_infinity_wedge(self_: Point, other: LineAtInfinity) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * vec4<f32>(other.g0.x, other.g0.y, other.g0.z, other.g0.z) * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_line_at_origin_wedge(self_: Point, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_magnitude_wedge(self_: Point, other: Magnitude) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0.x));
}

fn point_motor_wedge(self_: Point, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g1.x, other.g1.y, other.g1.z, 0.0));
}

fn point_multi_vector_wedge(self_: Point, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g4.w), self_.g0 * vec4<f32>(other.g0.x), vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g1.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g1.x, other.g1.y, other.g1.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0) + vec4<f32>(self_.g0.w) * vec4<f32>(other.g3.x, other.g3.y, other.g3.z, 0.0));
}

fn point_origin_wedge(self_: Point, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn point_plane_wedge(self_: Point, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn point_plane_at_origin_wedge(self_: Point, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_point_wedge(self_: Point, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.w) + vec3<f32>(self_.g0.w) * vec3<f32>(other.g0.x, other.g0.y, other.g0.z), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_point_at_infinity_wedge(self_: Point, other: PointAtInfinity) -> Line {
    return Line(vec3<f32>(self_.g0.w) * other.g0, vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_rotor_wedge(self_: Point, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_scalar_wedge(self_: Point, other: Scalar) -> Point {
    return Point(self_.g0 * vec4<f32>(other.g0));
}

fn point_translator_wedge(self_: Point, other: Translator) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, 0.0, 0.0, other.g0.x) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, 0.0, 0.0, other.g0.y) * vec4<f32>(0.0, 0.0, 0.0, -1.0) + self_.g0.wwwz * other.g0.xyzz * vec4<f32>(1.0, 1.0, 1.0, -1.0));
}

fn point_at_infinity_flector_wedge(self_: PointAtInfinity, other: Flector) -> Motor {
    return Motor(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g1.x) * vec4<f32>(-1.0, 0.0, 0.0, 1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g1.y) * vec4<f32>(0.0, -1.0, 0.0, 1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g1.z) * vec4<f32>(0.0, 0.0, -1.0, 1.0), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_at_infinity_line_wedge(self_: PointAtInfinity, other: Line) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_line_at_infinity_wedge(self_: PointAtInfinity, other: LineAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn point_at_infinity_line_at_origin_wedge(self_: PointAtInfinity, other: LineAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_at_infinity_magnitude_wedge(self_: PointAtInfinity, other: Magnitude) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0.x));
}

fn point_at_infinity_motor_wedge(self_: PointAtInfinity, other: Motor) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g0.z, other.g0.y, other.g1.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g0.z, 0.0, other.g0.x, other.g1.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g0.y, other.g0.x, 0.0, other.g1.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_multi_vector_wedge(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g4.x) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g4.y) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g4.z), vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.x) * vec4<f32>(other.g0.x, other.g0.x, other.g0.x, 0.0), vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g1.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g1.z, other.g1.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g1.z, 0.0, other.g1.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g1.y, other.g1.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g2.z, other.g2.y, other.g3.x) * vec4<f32>(0.0, 1.0, -1.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g2.z, 0.0, other.g2.x, other.g3.y) * vec4<f32>(-1.0, 0.0, 1.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g2.y, other.g2.x, 0.0, other.g3.z) * vec4<f32>(1.0, -1.0, 0.0, -1.0));
}

fn point_at_infinity_origin_wedge(self_: PointAtInfinity, other: Origin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_plane_wedge(self_: PointAtInfinity, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_plane_at_origin_wedge(self_: PointAtInfinity, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_point_wedge(self_: PointAtInfinity, other: Point) -> Line {
    return Line(vec3<f32>(0.0) - self_.g0 * vec3<f32>(other.g0.w), vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_at_infinity_point_at_infinity_wedge(self_: PointAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn point_at_infinity_rotor_wedge(self_: PointAtInfinity, other: Rotor) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, 1.0, -1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(-1.0, 0.0, 1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(1.0, -1.0, 0.0));
}

fn point_at_infinity_scalar_wedge(self_: PointAtInfinity, other: Scalar) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(other.g0));
}

fn point_at_infinity_translator_wedge(self_: PointAtInfinity, other: Translator) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_flector_wedge(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn rotor_line_wedge(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_line_at_infinity_wedge(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_magnitude_wedge(self_: Rotor, other: Magnitude) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0.x));
}

fn rotor_motor_wedge(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn rotor_multi_vector_wedge(self_: Rotor, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g3.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g3.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g3.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec3<f32>(0.0), vec4<f32>(self_.g0.x) * vec4<f32>(0.0, other.g1.z, other.g1.y, 0.0) * vec4<f32>(0.0, -1.0, 1.0, 0.0) + vec4<f32>(self_.g0.y) * vec4<f32>(other.g1.z, 0.0, other.g1.x, 0.0) * vec4<f32>(1.0, 0.0, -1.0, 0.0) + vec4<f32>(self_.g0.z) * vec4<f32>(other.g1.y, other.g1.x, 0.0, 0.0) * vec4<f32>(-1.0, 1.0, 0.0, 0.0));
}

fn rotor_point_wedge(self_: Rotor, other: Point) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn rotor_point_at_infinity_wedge(self_: Rotor, other: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x) * vec3<f32>(0.0, other.g0.z, other.g0.y) * vec3<f32>(0.0, -1.0, 1.0) + vec3<f32>(self_.g0.y) * vec3<f32>(other.g0.z, 0.0, other.g0.x) * vec3<f32>(1.0, 0.0, -1.0) + vec3<f32>(self_.g0.z) * vec3<f32>(other.g0.y, other.g0.x, 0.0) * vec3<f32>(-1.0, 1.0, 0.0));
}

fn rotor_scalar_wedge(self_: Rotor, other: Scalar) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(other.g0));
}

fn rotor_translator_wedge(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn scalar_anti_scalar_wedge(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn scalar_flector_wedge(self_: Scalar, other: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1);
}

fn scalar_horizon_wedge(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.g0 * other.g0);
}

fn scalar_line_wedge(self_: Scalar, other: Line) -> Line {
    return Line(vec3<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_line_at_infinity_wedge(self_: Scalar, other: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_line_at_origin_wedge(self_: Scalar, other: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_magnitude_wedge(self_: Scalar, other: Magnitude) -> Magnitude {
    return Magnitude(vec2<f32>(self_.g0) * other.g0);
}

fn scalar_motor_wedge(self_: Scalar, other: Motor) -> Motor {
    return Motor(vec4<f32>(self_.g0) * other.g0, vec3<f32>(self_.g0) * other.g1);
}

fn scalar_multi_vector_wedge(self_: Scalar, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0) * other.g0, vec4<f32>(self_.g0) * other.g1, vec3<f32>(self_.g0) * other.g2, vec3<f32>(self_.g0) * other.g3, vec4<f32>(self_.g0) * other.g4);
}

fn scalar_origin_wedge(self_: Scalar, other: Origin) -> Origin {
    return Origin(self_.g0 * other.g0);
}

fn scalar_plane_wedge(self_: Scalar, other: Plane) -> Plane {
    return Plane(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_plane_at_origin_wedge(self_: Scalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_point_wedge(self_: Scalar, other: Point) -> Point {
    return Point(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_point_at_infinity_wedge(self_: Scalar, other: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0) * other.g0);
}

fn scalar_rotor_wedge(self_: Scalar, other: Rotor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0) * other.g0);
}

fn scalar_scalar_wedge(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn scalar_translator_wedge(self_: Scalar, other: Translator) -> Translator {
    return Translator(vec4<f32>(self_.g0) * other.g0);
}

fn translator_flector_wedge(self_: Translator, other: Flector) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn translator_line_wedge(self_: Translator, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_line_at_origin_wedge(self_: Translator, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_magnitude_wedge(self_: Translator, other: Magnitude) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0.x));
}

fn translator_motor_wedge(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_multi_vector_wedge(self_: Translator, other: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x) * vec2<f32>(0.0, other.g2.x) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.y) * vec2<f32>(0.0, other.g2.y) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.z) * vec2<f32>(0.0, other.g2.z) * vec2<f32>(0.0, -1.0) + vec2<f32>(self_.g0.w) * vec2<f32>(0.0, other.g0.x), vec4<f32>(0.0), vec3<f32>(0.0), vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0.x), vec4<f32>(self_.g0.x) * vec4<f32>(other.g1.w, 0.0, 0.0, other.g1.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g1.w, 0.0, other.g1.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g1.w, other.g1.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn translator_origin_wedge(self_: Translator, other: Origin) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(other.g0));
}

fn translator_point_wedge(self_: Translator, other: Point) -> Plane {
    return Plane(vec4<f32>(self_.g0.x) * vec4<f32>(other.g0.w, 0.0, 0.0, other.g0.x) * vec4<f32>(1.0, 0.0, 0.0, -1.0) + vec4<f32>(self_.g0.y) * vec4<f32>(0.0, other.g0.w, 0.0, other.g0.y) * vec4<f32>(0.0, 1.0, 0.0, -1.0) + vec4<f32>(self_.g0.z) * vec4<f32>(0.0, 0.0, other.g0.w, other.g0.z) * vec4<f32>(0.0, 0.0, 1.0, -1.0));
}

fn translator_point_at_infinity_wedge(self_: Translator, other: PointAtInfinity) -> Horizon {
    return Horizon(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_rotor_wedge(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_scalar_wedge(self_: Translator, other: Scalar) -> Translator {
    return Translator(self_.g0 * vec4<f32>(other.g0));
}

fn anti_scalar_anti_scalar_anti_dot(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0);
}

fn anti_scalar_magnitude_anti_dot(self_: AntiScalar, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.y);
}

fn anti_scalar_motor_anti_dot(self_: AntiScalar, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn anti_scalar_multi_vector_anti_dot(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.y);
}

fn anti_scalar_rotor_anti_dot(self_: AntiScalar, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn anti_scalar_translator_anti_dot(self_: AntiScalar, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0 * other.g0.w);
}

fn flector_flector_anti_dot(self_: Flector, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w + self_.g1.x * other.g1.x + self_.g1.y * other.g1.y + self_.g1.z * other.g1.z);
}

fn flector_multi_vector_anti_dot(self_: Flector, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g1.w + self_.g1.x * other.g4.x + self_.g1.y * other.g4.y + self_.g1.z * other.g4.z);
}

fn flector_origin_anti_dot(self_: Flector, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn flector_plane_anti_dot(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn flector_plane_at_origin_anti_dot(self_: Flector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn flector_point_anti_dot(self_: Flector, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w);
}

fn line_line_anti_dot(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_line_at_origin_anti_dot(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_motor_anti_dot(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_multi_vector_anti_dot(self_: Line, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z);
}

fn line_rotor_anti_dot(self_: Line, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_line_anti_dot(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_line_at_origin_anti_dot(self_: LineAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_motor_anti_dot(self_: LineAtOrigin, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_origin_multi_vector_anti_dot(self_: LineAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z);
}

fn line_at_origin_rotor_anti_dot(self_: LineAtOrigin, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn magnitude_anti_scalar_anti_dot(self_: Magnitude, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0);
}

fn magnitude_magnitude_anti_dot(self_: Magnitude, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.y);
}

fn magnitude_motor_anti_dot(self_: Magnitude, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn magnitude_multi_vector_anti_dot(self_: Magnitude, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.y);
}

fn magnitude_rotor_anti_dot(self_: Magnitude, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn magnitude_translator_anti_dot(self_: Magnitude, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn motor_anti_scalar_anti_dot(self_: Motor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn motor_line_anti_dot(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn motor_line_at_origin_anti_dot(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn motor_magnitude_anti_dot(self_: Motor, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn motor_motor_anti_dot(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn motor_multi_vector_anti_dot(self_: Motor, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z + self_.g0.w * other.g0.y);
}

fn motor_rotor_anti_dot(self_: Motor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn motor_translator_anti_dot(self_: Motor, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn multi_vector_anti_scalar_anti_dot(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0);
}

fn multi_vector_flector_anti_dot(self_: MultiVector, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.w * other.g0.w + self_.g4.x * other.g1.x + self_.g4.y * other.g1.y + self_.g4.z * other.g1.z);
}

fn multi_vector_line_anti_dot(self_: MultiVector, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn multi_vector_line_at_origin_anti_dot(self_: MultiVector, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn multi_vector_magnitude_anti_dot(self_: MultiVector, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.y);
}

fn multi_vector_motor_anti_dot(self_: MultiVector, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn multi_vector_multi_vector_anti_dot(self_: MultiVector, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.y - self_.g1.w * other.g1.w - self_.g2.x * other.g2.x - self_.g2.y * other.g2.y - self_.g2.z * other.g2.z + self_.g4.x * other.g4.x + self_.g4.y * other.g4.y + self_.g4.z * other.g4.z);
}

fn multi_vector_origin_anti_dot(self_: MultiVector, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.w * other.g0);
}

fn multi_vector_plane_anti_dot(self_: MultiVector, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g4.x * other.g0.x + self_.g4.y * other.g0.y + self_.g4.z * other.g0.z);
}

fn multi_vector_plane_at_origin_anti_dot(self_: MultiVector, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g4.x * other.g0.x + self_.g4.y * other.g0.y + self_.g4.z * other.g0.z);
}

fn multi_vector_point_anti_dot(self_: MultiVector, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g1.w * other.g0.w);
}

fn multi_vector_rotor_anti_dot(self_: MultiVector, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w - self_.g2.x * other.g0.x - self_.g2.y * other.g0.y - self_.g2.z * other.g0.z);
}

fn multi_vector_translator_anti_dot(self_: MultiVector, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.y * other.g0.w);
}

fn origin_flector_anti_dot(self_: Origin, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn origin_multi_vector_anti_dot(self_: Origin, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g1.w);
}

fn origin_origin_anti_dot(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0);
}

fn origin_point_anti_dot(self_: Origin, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0 * other.g0.w);
}

fn plane_flector_anti_dot(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn plane_multi_vector_anti_dot(self_: Plane, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g4.x + self_.g0.y * other.g4.y + self_.g0.z * other.g4.z);
}

fn plane_plane_anti_dot(self_: Plane, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_plane_at_origin_anti_dot(self_: Plane, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_flector_anti_dot(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn plane_at_origin_multi_vector_anti_dot(self_: PlaneAtOrigin, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g4.x + self_.g0.y * other.g4.y + self_.g0.z * other.g4.z);
}

fn plane_at_origin_plane_anti_dot(self_: PlaneAtOrigin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn plane_at_origin_plane_at_origin_anti_dot(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return AntiScalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_flector_anti_dot(self_: Point, other: Flector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w);
}

fn point_multi_vector_anti_dot(self_: Point, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g1.w);
}

fn point_origin_anti_dot(self_: Point, other: Origin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0);
}

fn point_point_anti_dot(self_: Point, other: Point) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.w * other.g0.w);
}

fn rotor_anti_scalar_anti_dot(self_: Rotor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn rotor_line_anti_dot(self_: Rotor, other: Line) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_line_at_origin_anti_dot(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn rotor_magnitude_anti_dot(self_: Rotor, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn rotor_motor_anti_dot(self_: Rotor, other: Motor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn rotor_multi_vector_anti_dot(self_: Rotor, other: MultiVector) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g2.x - self_.g0.y * other.g2.y - self_.g0.z * other.g2.z + self_.g0.w * other.g0.y);
}

fn rotor_rotor_anti_dot(self_: Rotor, other: Rotor) -> AntiScalar {
    return AntiScalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z + self_.g0.w * other.g0.w);
}

fn rotor_translator_anti_dot(self_: Rotor, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn translator_anti_scalar_anti_dot(self_: Translator, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0);
}

fn translator_magnitude_anti_dot(self_: Translator, other: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn translator_motor_anti_dot(self_: Translator, other: Motor) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn translator_multi_vector_anti_dot(self_: Translator, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.y);
}

fn translator_rotor_anti_dot(self_: Translator, other: Rotor) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn translator_translator_anti_dot(self_: Translator, other: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * other.g0.w);
}

fn flector_flector_dot(self_: Flector, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z - self_.g1.w * other.g1.w);
}

fn flector_horizon_dot(self_: Flector, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g1.w * other.g0);
}

fn flector_multi_vector_dot(self_: Flector, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z - self_.g1.w * other.g4.w);
}

fn flector_plane_dot(self_: Flector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g1.w * other.g0.w);
}

fn flector_point_dot(self_: Flector, other: Point) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn flector_point_at_infinity_dot(self_: Flector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn horizon_flector_dot(self_: Horizon, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g1.w);
}

fn horizon_horizon_dot(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0);
}

fn horizon_multi_vector_dot(self_: Horizon, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g4.w);
}

fn horizon_plane_dot(self_: Horizon, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0 * other.g0.w);
}

fn line_line_dot(self_: Line, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z);
}

fn line_line_at_infinity_dot(self_: Line, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_motor_dot(self_: Line, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z);
}

fn line_multi_vector_dot(self_: Line, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g3.x - self_.g1.y * other.g3.y - self_.g1.z * other.g3.z);
}

fn line_translator_dot(self_: Line, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn line_at_infinity_line_dot(self_: LineAtInfinity, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_infinity_line_at_infinity_dot(self_: LineAtInfinity, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn line_at_infinity_motor_dot(self_: LineAtInfinity, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn line_at_infinity_multi_vector_dot(self_: LineAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g3.x - self_.g0.y * other.g3.y - self_.g0.z * other.g3.z);
}

fn line_at_infinity_translator_dot(self_: LineAtInfinity, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn magnitude_magnitude_dot(self_: Magnitude, other: Magnitude) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x);
}

fn magnitude_multi_vector_dot(self_: Magnitude, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x);
}

fn magnitude_scalar_dot(self_: Magnitude, other: Scalar) -> Scalar {
    return Scalar(self_.g0.x * other.g0);
}

fn motor_line_dot(self_: Motor, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z);
}

fn motor_line_at_infinity_dot(self_: Motor, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn motor_motor_dot(self_: Motor, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g1.x - self_.g1.y * other.g1.y - self_.g1.z * other.g1.z);
}

fn motor_multi_vector_dot(self_: Motor, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g3.x - self_.g1.y * other.g3.y - self_.g1.z * other.g3.z);
}

fn motor_translator_dot(self_: Motor, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g1.x * other.g0.x - self_.g1.y * other.g0.y - self_.g1.z * other.g0.z);
}

fn multi_vector_flector_dot(self_: MultiVector, other: Flector) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z - self_.g4.w * other.g1.w);
}

fn multi_vector_horizon_dot(self_: MultiVector, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g4.w * other.g0);
}

fn multi_vector_line_dot(self_: MultiVector, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g1.x - self_.g3.y * other.g1.y - self_.g3.z * other.g1.z);
}

fn multi_vector_line_at_infinity_dot(self_: MultiVector, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g0.x - self_.g3.y * other.g0.y - self_.g3.z * other.g0.z);
}

fn multi_vector_magnitude_dot(self_: MultiVector, other: Magnitude) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x);
}

fn multi_vector_motor_dot(self_: MultiVector, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g1.x - self_.g3.y * other.g1.y - self_.g3.z * other.g1.z);
}

fn multi_vector_multi_vector_dot(self_: MultiVector, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g1.x * other.g1.x + self_.g1.y * other.g1.y + self_.g1.z * other.g1.z - self_.g3.x * other.g3.x - self_.g3.y * other.g3.y - self_.g3.z * other.g3.z - self_.g4.w * other.g4.w);
}

fn multi_vector_plane_dot(self_: MultiVector, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g4.w * other.g0.w);
}

fn multi_vector_point_dot(self_: MultiVector, other: Point) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn multi_vector_point_at_infinity_dot(self_: MultiVector, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g1.x * other.g0.x + self_.g1.y * other.g0.y + self_.g1.z * other.g0.z);
}

fn multi_vector_scalar_dot(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.g0.x * other.g0);
}

fn multi_vector_translator_dot(self_: MultiVector, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g3.x * other.g0.x - self_.g3.y * other.g0.y - self_.g3.z * other.g0.z);
}

fn plane_flector_dot(self_: Plane, other: Flector) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g1.w);
}

fn plane_horizon_dot(self_: Plane, other: Horizon) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0);
}

fn plane_multi_vector_dot(self_: Plane, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g4.w);
}

fn plane_plane_dot(self_: Plane, other: Plane) -> Scalar {
    return Scalar(0.0 - self_.g0.w * other.g0.w);
}

fn point_flector_dot(self_: Point, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_multi_vector_dot(self_: Point, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn point_point_dot(self_: Point, other: Point) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_point_at_infinity_dot(self_: Point, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_flector_dot(self_: PointAtInfinity, other: Flector) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_multi_vector_dot(self_: PointAtInfinity, other: MultiVector) -> Scalar {
    return Scalar(self_.g0.x * other.g1.x + self_.g0.y * other.g1.y + self_.g0.z * other.g1.z);
}

fn point_at_infinity_point_dot(self_: PointAtInfinity, other: Point) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn point_at_infinity_point_at_infinity_dot(self_: PointAtInfinity, other: PointAtInfinity) -> Scalar {
    return Scalar(self_.g0.x * other.g0.x + self_.g0.y * other.g0.y + self_.g0.z * other.g0.z);
}

fn scalar_magnitude_dot(self_: Scalar, other: Magnitude) -> Scalar {
    return Scalar(self_.g0 * other.g0.x);
}

fn scalar_multi_vector_dot(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(self_.g0 * other.g0.x);
}

fn scalar_scalar_dot(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.g0 * other.g0);
}

fn translator_line_dot(self_: Translator, other: Line) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn translator_line_at_infinity_dot(self_: Translator, other: LineAtInfinity) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn translator_motor_dot(self_: Translator, other: Motor) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g1.x - self_.g0.y * other.g1.y - self_.g0.z * other.g1.z);
}

fn translator_multi_vector_dot(self_: Translator, other: MultiVector) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g3.x - self_.g0.y * other.g3.y - self_.g0.z * other.g3.z);
}

fn translator_translator_dot(self_: Translator, other: Translator) -> Scalar {
    return Scalar(0.0 - self_.g0.x * other.g0.x - self_.g0.y * other.g0.y - self_.g0.z * other.g0.z);
}

fn flector_bulk(self_: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, 1.0));
}

fn horizon_bulk(self_: Horizon) -> Horizon {
    return self_;
}

fn line_bulk(self_: Line) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn line_at_infinity_bulk(self_: LineAtInfinity) -> LineAtInfinity {
    return self_;
}

fn magnitude_bulk(self_: Magnitude) -> Scalar {
    return Scalar(self_.g0.x * 1.0);
}

fn motor_bulk(self_: Motor) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g1.x, self_.g1.y, self_.g1.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn multi_vector_bulk(self_: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x, self_.g0.y) * vec2<f32>(1.0, 0.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 0.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(0.0, 0.0, 0.0), vec3<f32>(self_.g3.x, self_.g3.y, self_.g3.z) * vec3<f32>(1.0, 1.0, 1.0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.w) * vec4<f32>(0.0, 0.0, 0.0, 1.0));
}

fn plane_bulk(self_: Plane) -> Horizon {
    return Horizon(self_.g0.w * 1.0);
}

fn point_bulk(self_: Point) -> PointAtInfinity {
    return PointAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn point_at_infinity_bulk(self_: PointAtInfinity) -> PointAtInfinity {
    return self_;
}

fn scalar_bulk(self_: Scalar) -> Scalar {
    return self_;
}

fn translator_bulk(self_: Translator) -> LineAtInfinity {
    return LineAtInfinity(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn anti_scalar_weight(self_: AntiScalar) -> AntiScalar {
    return self_;
}

fn flector_weight(self_: Flector) -> Flector {
    return Flector(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(0.0, 0.0, 0.0, 1.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(1.0, 1.0, 1.0, 0.0));
}

fn line_weight(self_: Line) -> LineAtOrigin {
    return LineAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn line_at_origin_weight(self_: LineAtOrigin) -> LineAtOrigin {
    return self_;
}

fn magnitude_weight(self_: Magnitude) -> AntiScalar {
    return AntiScalar(self_.g0.y * 1.0);
}

fn motor_weight(self_: Motor) -> Rotor {
    return Rotor(vec4<f32>(self_.g0.x, self_.g0.y, self_.g0.z, self_.g0.w) * vec4<f32>(1.0, 1.0, 1.0, 1.0));
}

fn multi_vector_weight(self_: MultiVector) -> MultiVector {
    return MultiVector(vec2<f32>(self_.g0.x, self_.g0.y) * vec2<f32>(0.0, 1.0), vec4<f32>(self_.g1.x, self_.g1.y, self_.g1.z, self_.g1.w) * vec4<f32>(0.0, 0.0, 0.0, 1.0), vec3<f32>(self_.g2.x, self_.g2.y, self_.g2.z) * vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(self_.g3.x, self_.g3.y, self_.g3.z) * vec3<f32>(0.0, 0.0, 0.0), vec4<f32>(self_.g4.x, self_.g4.y, self_.g4.z, self_.g4.w) * vec4<f32>(1.0, 1.0, 1.0, 0.0));
}

fn origin_weight(self_: Origin) -> Origin {
    return self_;
}

fn plane_weight(self_: Plane) -> PlaneAtOrigin {
    return PlaneAtOrigin(vec3<f32>(self_.g0.x, self_.g0.y, self_.g0.z) * vec3<f32>(1.0, 1.0, 1.0));
}

fn plane_at_origin_weight(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return self_;
}

fn point_weight(self_: Point) -> Origin {
    return Origin(self_.g0.w * 1.0);
}

fn rotor_weight(self_: Rotor) -> Rotor {
    return self_;
}

fn translator_weight(self_: Translator) -> AntiScalar {
    return AntiScalar(self_.g0.w * 1.0);
}

fn anti_scalar_anti_reversal(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn flector_anti_reversal(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn horizon_anti_reversal(self_: Horizon) -> Horizon {
    return Horizon(self_.g0);
}

fn line_anti_reversal(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec3<f32>(-1.0));
}

fn line_at_infinity_anti_reversal(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_anti_reversal(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn magnitude_anti_reversal(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_anti_reversal(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0));
}

fn multi_vector_anti_reversal(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 * vec4<f32>(-1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0), self_.g3 * vec3<f32>(-1.0), self_.g4 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn origin_anti_reversal(self_: Origin) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn plane_anti_reversal(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn plane_at_origin_anti_reversal(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn point_anti_reversal(self_: Point) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn point_at_infinity_anti_reversal(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn rotor_anti_reversal(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn scalar_anti_reversal(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn translator_anti_reversal(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn anti_scalar_automorphism(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn flector_automorphism(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn horizon_automorphism(self_: Horizon) -> Horizon {
    return Horizon(self_.g0 * -1.0);
}

fn line_automorphism(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(1.0, -1.0, 1.0), self_.g1);
}

fn line_at_infinity_automorphism(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0);
}

fn line_at_origin_automorphism(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn magnitude_automorphism(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_automorphism(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0), self_.g1);
}

fn multi_vector_automorphism(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 * vec4<f32>(-1.0), self_.g2 * vec3<f32>(1.0, -1.0, 1.0), self_.g3, self_.g4 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn origin_automorphism(self_: Origin) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn plane_automorphism(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn plane_at_origin_automorphism(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn point_automorphism(self_: Point) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn point_at_infinity_automorphism(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn rotor_automorphism(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, 1.0));
}

fn scalar_automorphism(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn translator_automorphism(self_: Translator) -> Translator {
    return Translator(self_.g0);
}

fn anti_scalar_conjugation(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn flector_conjugation(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn horizon_conjugation(self_: Horizon) -> Horizon {
    return Horizon(self_.g0);
}

fn line_conjugation(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec3<f32>(-1.0));
}

fn line_at_infinity_conjugation(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_conjugation(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn magnitude_conjugation(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_conjugation(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0));
}

fn multi_vector_conjugation(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 * vec4<f32>(-1.0), self_.g2 * vec3<f32>(-1.0, 1.0, -1.0), self_.g3 * vec3<f32>(-1.0), self_.g4 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn origin_conjugation(self_: Origin) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn plane_conjugation(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn plane_at_origin_conjugation(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn point_conjugation(self_: Point) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn point_at_infinity_conjugation(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn rotor_conjugation(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn scalar_conjugation(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn translator_conjugation(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn anti_scalar_double_complement(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn flector_double_complement(self_: Flector) -> Flector {
    return Flector(self_.g0 * vec4<f32>(-1.0), self_.g1 * vec4<f32>(-1.0));
}

fn horizon_double_complement(self_: Horizon) -> Horizon {
    return Horizon(self_.g0 * -1.0);
}

fn line_double_complement(self_: Line) -> Line {
    return Line(self_.g0, self_.g1);
}

fn line_at_infinity_double_complement(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0);
}

fn line_at_origin_double_complement(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0);
}

fn magnitude_double_complement(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_double_complement(self_: Motor) -> Motor {
    return Motor(self_.g0, self_.g1);
}

fn multi_vector_double_complement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1 * vec4<f32>(-1.0), self_.g2, self_.g3, self_.g4 * vec4<f32>(-1.0));
}

fn origin_double_complement(self_: Origin) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn plane_double_complement(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0));
}

fn plane_at_origin_double_complement(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0));
}

fn point_double_complement(self_: Point) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn point_at_infinity_double_complement(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn rotor_double_complement(self_: Rotor) -> Rotor {
    return Rotor(self_.g0);
}

fn scalar_double_complement(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn translator_double_complement(self_: Translator) -> Translator {
    return Translator(self_.g0);
}

fn anti_scalar_dual(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0);
}

fn flector_dual(self_: Flector) -> Flector {
    return Flector(self_.g1 * vec4<f32>(-1.0), self_.g0);
}

fn horizon_dual(self_: Horizon) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn line_dual(self_: Line) -> Line {
    return Line(self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0));
}

fn line_at_infinity_dual(self_: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_dual(self_: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn magnitude_dual(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx);
}

fn multi_vector_dual(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx, self_.g4 * vec4<f32>(-1.0), self_.g3 * vec3<f32>(-1.0), self_.g2 * vec3<f32>(-1.0), self_.g1);
}

fn origin_dual(self_: Origin) -> Horizon {
    return Horizon(self_.g0);
}

fn plane_dual(self_: Plane) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn plane_at_origin_dual(self_: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_dual(self_: Point) -> Plane {
    return Plane(self_.g0);
}

fn point_at_infinity_dual(self_: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0);
}

fn scalar_dual(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn anti_scalar_left_complement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0);
}

fn flector_left_complement(self_: Flector) -> Flector {
    return Flector(self_.g1, self_.g0 * vec4<f32>(-1.0));
}

fn horizon_left_complement(self_: Horizon) -> Origin {
    return Origin(self_.g0);
}

fn line_left_complement(self_: Line) -> Line {
    return Line(self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0));
}

fn line_at_infinity_left_complement(self_: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_left_complement(self_: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn magnitude_left_complement(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx);
}

fn multi_vector_left_complement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx, self_.g4, self_.g3 * vec3<f32>(-1.0), self_.g2 * vec3<f32>(-1.0), self_.g1 * vec4<f32>(-1.0));
}

fn origin_left_complement(self_: Origin) -> Horizon {
    return Horizon(self_.g0 * -1.0);
}

fn plane_left_complement(self_: Plane) -> Point {
    return Point(self_.g0);
}

fn plane_at_origin_left_complement(self_: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0);
}

fn point_left_complement(self_: Point) -> Plane {
    return Plane(self_.g0 * vec4<f32>(-1.0));
}

fn point_at_infinity_left_complement(self_: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(-1.0));
}

fn scalar_left_complement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn anti_scalar_reversal(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn flector_reversal(self_: Flector) -> Flector {
    return Flector(self_.g0, self_.g1 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn horizon_reversal(self_: Horizon) -> Horizon {
    return Horizon(self_.g0 * -1.0);
}

fn line_reversal(self_: Line) -> Line {
    return Line(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0), self_.g1 * vec3<f32>(-1.0));
}

fn line_at_infinity_reversal(self_: LineAtInfinity) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_reversal(self_: LineAtOrigin) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0, 1.0, -1.0));
}

fn magnitude_reversal(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0);
}

fn motor_reversal(self_: Motor) -> Motor {
    return Motor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0), self_.g1 * vec3<f32>(-1.0));
}

fn multi_vector_reversal(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0, self_.g1, self_.g2 * vec3<f32>(-1.0, 1.0, -1.0), self_.g3 * vec3<f32>(-1.0), self_.g4 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn origin_reversal(self_: Origin) -> Origin {
    return Origin(self_.g0);
}

fn plane_reversal(self_: Plane) -> Plane {
    return Plane(self_.g0 * vec4<f32>(1.0, -1.0, 1.0, -1.0));
}

fn plane_at_origin_reversal(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0 * vec3<f32>(1.0, -1.0, 1.0));
}

fn point_reversal(self_: Point) -> Point {
    return Point(self_.g0);
}

fn point_at_infinity_reversal(self_: PointAtInfinity) -> PointAtInfinity {
    return PointAtInfinity(self_.g0);
}

fn rotor_reversal(self_: Rotor) -> Rotor {
    return Rotor(self_.g0 * vec4<f32>(-1.0, 1.0, -1.0, 1.0));
}

fn scalar_reversal(self_: Scalar) -> Scalar {
    return Scalar(self_.g0);
}

fn translator_reversal(self_: Translator) -> Translator {
    return Translator(self_.g0 * vec4<f32>(-1.0, -1.0, -1.0, 1.0));
}

fn anti_scalar_right_complement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.g0);
}

fn flector_right_complement(self_: Flector) -> Flector {
    return Flector(self_.g1 * vec4<f32>(-1.0), self_.g0);
}

fn horizon_right_complement(self_: Horizon) -> Origin {
    return Origin(self_.g0 * -1.0);
}

fn line_right_complement(self_: Line) -> Line {
    return Line(self_.g1 * vec3<f32>(-1.0), self_.g0 * vec3<f32>(-1.0));
}

fn line_at_infinity_right_complement(self_: LineAtInfinity) -> LineAtOrigin {
    return LineAtOrigin(self_.g0 * vec3<f32>(-1.0));
}

fn line_at_origin_right_complement(self_: LineAtOrigin) -> LineAtInfinity {
    return LineAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn magnitude_right_complement(self_: Magnitude) -> Magnitude {
    return Magnitude(self_.g0.yx);
}

fn multi_vector_right_complement(self_: MultiVector) -> MultiVector {
    return MultiVector(self_.g0.yx, self_.g4 * vec4<f32>(-1.0), self_.g3 * vec3<f32>(-1.0), self_.g2 * vec3<f32>(-1.0), self_.g1);
}

fn origin_right_complement(self_: Origin) -> Horizon {
    return Horizon(self_.g0);
}

fn plane_right_complement(self_: Plane) -> Point {
    return Point(self_.g0 * vec4<f32>(-1.0));
}

fn plane_at_origin_right_complement(self_: PlaneAtOrigin) -> PointAtInfinity {
    return PointAtInfinity(self_.g0 * vec3<f32>(-1.0));
}

fn point_right_complement(self_: Point) -> Plane {
    return Plane(self_.g0);
}

fn point_at_infinity_right_complement(self_: PointAtInfinity) -> PlaneAtOrigin {
    return PlaneAtOrigin(self_.g0);
}

fn scalar_right_complement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.g0);
}

fn flector_left_bulk_dual(self_: Flector) -> Flector {
    return flector_left_complement(flector_bulk(self_));
}

fn horizon_left_bulk_dual(self_: Horizon) -> Origin {
    return horizon_left_complement(horizon_bulk(self_));
}

fn line_left_bulk_dual(self_: Line) -> LineAtOrigin {
    return line_at_infinity_left_complement(line_bulk(self_));
}

fn line_at_infinity_left_bulk_dual(self_: LineAtInfinity) -> LineAtOrigin {
    return line_at_infinity_left_complement(line_at_infinity_bulk(self_));
}

fn magnitude_left_bulk_dual(self_: Magnitude) -> AntiScalar {
    return scalar_left_complement(magnitude_bulk(self_));
}

fn motor_left_bulk_dual(self_: Motor) -> LineAtOrigin {
    return line_at_infinity_left_complement(motor_bulk(self_));
}

fn multi_vector_left_bulk_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_left_complement(multi_vector_bulk(self_));
}

fn plane_left_bulk_dual(self_: Plane) -> Origin {
    return horizon_left_complement(plane_bulk(self_));
}

fn point_left_bulk_dual(self_: Point) -> PlaneAtOrigin {
    return point_at_infinity_left_complement(point_bulk(self_));
}

fn point_at_infinity_left_bulk_dual(self_: PointAtInfinity) -> PlaneAtOrigin {
    return point_at_infinity_left_complement(point_at_infinity_bulk(self_));
}

fn scalar_left_bulk_dual(self_: Scalar) -> AntiScalar {
    return scalar_left_complement(scalar_bulk(self_));
}

fn translator_left_bulk_dual(self_: Translator) -> LineAtOrigin {
    return line_at_infinity_left_complement(translator_bulk(self_));
}

fn anti_scalar_left_weight_dual(self_: AntiScalar) -> Scalar {
    return anti_scalar_left_complement(anti_scalar_weight(self_));
}

fn flector_left_weight_dual(self_: Flector) -> Flector {
    return flector_left_complement(flector_weight(self_));
}

fn line_left_weight_dual(self_: Line) -> LineAtInfinity {
    return line_at_origin_left_complement(line_weight(self_));
}

fn line_at_origin_left_weight_dual(self_: LineAtOrigin) -> LineAtInfinity {
    return line_at_origin_left_complement(line_at_origin_weight(self_));
}

fn magnitude_left_weight_dual(self_: Magnitude) -> Scalar {
    return anti_scalar_left_complement(magnitude_weight(self_));
}

fn multi_vector_left_weight_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_left_complement(multi_vector_weight(self_));
}

fn origin_left_weight_dual(self_: Origin) -> Horizon {
    return origin_left_complement(origin_weight(self_));
}

fn plane_left_weight_dual(self_: Plane) -> PointAtInfinity {
    return plane_at_origin_left_complement(plane_weight(self_));
}

fn plane_at_origin_left_weight_dual(self_: PlaneAtOrigin) -> PointAtInfinity {
    return plane_at_origin_left_complement(plane_at_origin_weight(self_));
}

fn point_left_weight_dual(self_: Point) -> Horizon {
    return origin_left_complement(point_weight(self_));
}

fn translator_left_weight_dual(self_: Translator) -> Scalar {
    return anti_scalar_left_complement(translator_weight(self_));
}

fn flector_right_bulk_dual(self_: Flector) -> Flector {
    return flector_right_complement(flector_bulk(self_));
}

fn horizon_right_bulk_dual(self_: Horizon) -> Origin {
    return horizon_right_complement(horizon_bulk(self_));
}

fn line_right_bulk_dual(self_: Line) -> LineAtOrigin {
    return line_at_infinity_right_complement(line_bulk(self_));
}

fn line_at_infinity_right_bulk_dual(self_: LineAtInfinity) -> LineAtOrigin {
    return line_at_infinity_right_complement(line_at_infinity_bulk(self_));
}

fn magnitude_right_bulk_dual(self_: Magnitude) -> AntiScalar {
    return scalar_right_complement(magnitude_bulk(self_));
}

fn motor_right_bulk_dual(self_: Motor) -> LineAtOrigin {
    return line_at_infinity_right_complement(motor_bulk(self_));
}

fn multi_vector_right_bulk_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_right_complement(multi_vector_bulk(self_));
}

fn plane_right_bulk_dual(self_: Plane) -> Origin {
    return horizon_right_complement(plane_bulk(self_));
}

fn point_right_bulk_dual(self_: Point) -> PlaneAtOrigin {
    return point_at_infinity_right_complement(point_bulk(self_));
}

fn point_at_infinity_right_bulk_dual(self_: PointAtInfinity) -> PlaneAtOrigin {
    return point_at_infinity_right_complement(point_at_infinity_bulk(self_));
}

fn scalar_right_bulk_dual(self_: Scalar) -> AntiScalar {
    return scalar_right_complement(scalar_bulk(self_));
}

fn translator_right_bulk_dual(self_: Translator) -> LineAtOrigin {
    return line_at_infinity_right_complement(translator_bulk(self_));
}

fn anti_scalar_right_weight_dual(self_: AntiScalar) -> Scalar {
    return anti_scalar_right_complement(anti_scalar_weight(self_));
}

fn flector_right_weight_dual(self_: Flector) -> Flector {
    return flector_right_complement(flector_weight(self_));
}

fn line_right_weight_dual(self_: Line) -> LineAtInfinity {
    return line_at_origin_right_complement(line_weight(self_));
}

fn line_at_origin_right_weight_dual(self_: LineAtOrigin) -> LineAtInfinity {
    return line_at_origin_right_complement(line_at_origin_weight(self_));
}

fn magnitude_right_weight_dual(self_: Magnitude) -> Scalar {
    return anti_scalar_right_complement(magnitude_weight(self_));
}

fn multi_vector_right_weight_dual(self_: MultiVector) -> MultiVector {
    return multi_vector_right_complement(multi_vector_weight(self_));
}

fn origin_right_weight_dual(self_: Origin) -> Horizon {
    return origin_right_complement(origin_weight(self_));
}

fn plane_right_weight_dual(self_: Plane) -> PointAtInfinity {
    return plane_at_origin_right_complement(plane_weight(self_));
}

fn plane_at_origin_right_weight_dual(self_: PlaneAtOrigin) -> PointAtInfinity {
    return plane_at_origin_right_complement(plane_at_origin_weight(self_));
}

fn point_right_weight_dual(self_: Point) -> Horizon {
    return origin_right_complement(point_weight(self_));
}

fn translator_right_weight_dual(self_: Translator) -> Scalar {
    return anti_scalar_right_complement(translator_weight(self_));
}

fn anti_scalar_anti_grade(self_: AntiScalar) -> i32 {
    return 0;
}

fn horizon_anti_grade(self_: Horizon) -> i32 {
    return 1;
}

fn line_anti_grade(self_: Line) -> i32 {
    return 2;
}

fn line_at_infinity_anti_grade(self_: LineAtInfinity) -> i32 {
    return 2;
}

fn line_at_origin_anti_grade(self_: LineAtOrigin) -> i32 {
    return 2;
}

fn origin_anti_grade(self_: Origin) -> i32 {
    return 3;
}

fn plane_anti_grade(self_: Plane) -> i32 {
    return 1;
}

fn plane_at_origin_anti_grade(self_: PlaneAtOrigin) -> i32 {
    return 1;
}

fn point_anti_grade(self_: Point) -> i32 {
    return 3;
}

fn point_at_infinity_anti_grade(self_: PointAtInfinity) -> i32 {
    return 3;
}

fn scalar_anti_grade(self_: Scalar) -> i32 {
    return 4;
}

fn anti_scalar_grade(self_: AntiScalar) -> i32 {
    return 4;
}

fn horizon_grade(self_: Horizon) -> i32 {
    return 3;
}

fn line_grade(self_: Line) -> i32 {
    return 2;
}

fn line_at_infinity_grade(self_: LineAtInfinity) -> i32 {
    return 2;
}

fn line_at_origin_grade(self_: LineAtOrigin) -> i32 {
    return 2;
}

fn origin_grade(self_: Origin) -> i32 {
    return 1;
}

fn plane_grade(self_: Plane) -> i32 {
    return 3;
}

fn plane_at_origin_grade(self_: PlaneAtOrigin) -> i32 {
    return 3;
}

fn point_grade(self_: Point) -> i32 {
    return 1;
}

fn point_at_infinity_grade(self_: PointAtInfinity) -> i32 {
    return 1;
}

fn scalar_grade(self_: Scalar) -> i32 {
    return 0;
}

fn anti_scalar_attitude(self_: AntiScalar) -> Horizon {
    return anti_scalar_horizon_anti_wedge(self_, horizon_one());
}

fn flector_attitude(self_: Flector) -> MultiVector {
    return flector_horizon_anti_wedge(self_, horizon_one());
}

fn line_attitude(self_: Line) -> PointAtInfinity {
    return line_horizon_anti_wedge(self_, horizon_one());
}

fn line_at_origin_attitude(self_: LineAtOrigin) -> PointAtInfinity {
    return line_at_origin_horizon_anti_wedge(self_, horizon_one());
}

fn magnitude_attitude(self_: Magnitude) -> Horizon {
    return magnitude_horizon_anti_wedge(self_, horizon_one());
}

fn motor_attitude(self_: Motor) -> Flector {
    return motor_horizon_anti_wedge(self_, horizon_one());
}

fn multi_vector_attitude(self_: MultiVector) -> MultiVector {
    return multi_vector_horizon_anti_wedge(self_, horizon_one());
}

fn origin_attitude(self_: Origin) -> Scalar {
    return origin_horizon_anti_wedge(self_, horizon_one());
}

fn plane_attitude(self_: Plane) -> LineAtInfinity {
    return plane_horizon_anti_wedge(self_, horizon_one());
}

fn plane_at_origin_attitude(self_: PlaneAtOrigin) -> LineAtInfinity {
    return plane_at_origin_horizon_anti_wedge(self_, horizon_one());
}

fn point_attitude(self_: Point) -> Scalar {
    return point_horizon_anti_wedge(self_, horizon_one());
}

fn rotor_attitude(self_: Rotor) -> Flector {
    return rotor_horizon_anti_wedge(self_, horizon_one());
}

fn translator_attitude(self_: Translator) -> Horizon {
    return translator_horizon_anti_wedge(self_, horizon_one());
}

fn anti_scalar_sqrt(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(sqrt(self_.g0));
}

fn scalar_sqrt(self_: Scalar) -> Scalar {
    return Scalar(sqrt(self_.g0));
}

fn flector_bulk_norm(self_: Flector) -> Scalar {
    return scalar_sqrt(flector_flector_dot(self_, self_));
}

fn horizon_bulk_norm(self_: Horizon) -> Scalar {
    return scalar_sqrt(horizon_horizon_dot(self_, self_));
}

fn line_bulk_norm(self_: Line) -> Scalar {
    return scalar_sqrt(line_line_dot(self_, self_));
}

fn line_at_infinity_bulk_norm(self_: LineAtInfinity) -> Scalar {
    return scalar_sqrt(line_at_infinity_line_at_infinity_dot(self_, self_));
}

fn magnitude_bulk_norm(self_: Magnitude) -> Scalar {
    return scalar_sqrt(magnitude_magnitude_dot(self_, self_));
}

fn motor_bulk_norm(self_: Motor) -> Scalar {
    return scalar_sqrt(motor_motor_dot(self_, self_));
}

fn multi_vector_bulk_norm(self_: MultiVector) -> Scalar {
    return scalar_sqrt(multi_vector_multi_vector_dot(self_, self_));
}

fn plane_bulk_norm(self_: Plane) -> Scalar {
    return scalar_sqrt(plane_plane_dot(self_, self_));
}

fn point_bulk_norm(self_: Point) -> Scalar {
    return scalar_sqrt(point_point_dot(self_, self_));
}

fn point_at_infinity_bulk_norm(self_: PointAtInfinity) -> Scalar {
    return scalar_sqrt(point_at_infinity_point_at_infinity_dot(self_, self_));
}

fn scalar_bulk_norm(self_: Scalar) -> Scalar {
    return scalar_sqrt(scalar_scalar_dot(self_, self_));
}

fn translator_bulk_norm(self_: Translator) -> Scalar {
    return scalar_sqrt(translator_translator_dot(self_, self_));
}

fn flector_bulk_norm_squared(self_: Flector) -> Scalar {
    return flector_flector_dot(self_, self_);
}

fn horizon_bulk_norm_squared(self_: Horizon) -> Scalar {
    return horizon_horizon_dot(self_, self_);
}

fn line_bulk_norm_squared(self_: Line) -> Scalar {
    return line_line_dot(self_, self_);
}

fn line_at_infinity_bulk_norm_squared(self_: LineAtInfinity) -> Scalar {
    return line_at_infinity_line_at_infinity_dot(self_, self_);
}

fn magnitude_bulk_norm_squared(self_: Magnitude) -> Scalar {
    return magnitude_magnitude_dot(self_, self_);
}

fn motor_bulk_norm_squared(self_: Motor) -> Scalar {
    return motor_motor_dot(self_, self_);
}

fn multi_vector_bulk_norm_squared(self_: MultiVector) -> Scalar {
    return multi_vector_multi_vector_dot(self_, self_);
}

fn plane_bulk_norm_squared(self_: Plane) -> Scalar {
    return plane_plane_dot(self_, self_);
}

fn point_bulk_norm_squared(self_: Point) -> Scalar {
    return point_point_dot(self_, self_);
}

fn point_at_infinity_bulk_norm_squared(self_: PointAtInfinity) -> Scalar {
    return point_at_infinity_point_at_infinity_dot(self_, self_);
}

fn scalar_bulk_norm_squared(self_: Scalar) -> Scalar {
    return scalar_scalar_dot(self_, self_);
}

fn translator_bulk_norm_squared(self_: Translator) -> Scalar {
    return translator_translator_dot(self_, self_);
}

fn anti_scalar_weight_norm(self_: AntiScalar) -> AntiScalar {
    return anti_scalar_sqrt(anti_scalar_anti_scalar_anti_dot(self_, self_));
}

fn flector_weight_norm(self_: Flector) -> AntiScalar {
    return anti_scalar_sqrt(flector_flector_anti_dot(self_, self_));
}

fn line_weight_norm(self_: Line) -> AntiScalar {
    return anti_scalar_sqrt(line_line_anti_dot(self_, self_));
}

fn line_at_origin_weight_norm(self_: LineAtOrigin) -> AntiScalar {
    return anti_scalar_sqrt(line_at_origin_line_at_origin_anti_dot(self_, self_));
}

fn magnitude_weight_norm(self_: Magnitude) -> AntiScalar {
    return anti_scalar_sqrt(magnitude_magnitude_anti_dot(self_, self_));
}

fn motor_weight_norm(self_: Motor) -> AntiScalar {
    return anti_scalar_sqrt(motor_motor_anti_dot(self_, self_));
}

fn multi_vector_weight_norm(self_: MultiVector) -> AntiScalar {
    return anti_scalar_sqrt(multi_vector_multi_vector_anti_dot(self_, self_));
}

fn origin_weight_norm(self_: Origin) -> AntiScalar {
    return anti_scalar_sqrt(origin_origin_anti_dot(self_, self_));
}

fn plane_weight_norm(self_: Plane) -> AntiScalar {
    return anti_scalar_sqrt(plane_plane_anti_dot(self_, self_));
}

fn plane_at_origin_weight_norm(self_: PlaneAtOrigin) -> AntiScalar {
    return anti_scalar_sqrt(plane_at_origin_plane_at_origin_anti_dot(self_, self_));
}

fn point_weight_norm(self_: Point) -> AntiScalar {
    return anti_scalar_sqrt(point_point_anti_dot(self_, self_));
}

fn rotor_weight_norm(self_: Rotor) -> AntiScalar {
    return anti_scalar_sqrt(rotor_rotor_anti_dot(self_, self_));
}

fn translator_weight_norm(self_: Translator) -> AntiScalar {
    return anti_scalar_sqrt(translator_translator_anti_dot(self_, self_));
}

fn anti_scalar_weight_norm_squared(self_: AntiScalar) -> AntiScalar {
    return anti_scalar_anti_scalar_anti_dot(self_, self_);
}

fn flector_weight_norm_squared(self_: Flector) -> AntiScalar {
    return flector_flector_anti_dot(self_, self_);
}

fn line_weight_norm_squared(self_: Line) -> AntiScalar {
    return line_line_anti_dot(self_, self_);
}

fn line_at_origin_weight_norm_squared(self_: LineAtOrigin) -> AntiScalar {
    return line_at_origin_line_at_origin_anti_dot(self_, self_);
}

fn magnitude_weight_norm_squared(self_: Magnitude) -> AntiScalar {
    return magnitude_magnitude_anti_dot(self_, self_);
}

fn motor_weight_norm_squared(self_: Motor) -> AntiScalar {
    return motor_motor_anti_dot(self_, self_);
}

fn multi_vector_weight_norm_squared(self_: MultiVector) -> AntiScalar {
    return multi_vector_multi_vector_anti_dot(self_, self_);
}

fn origin_weight_norm_squared(self_: Origin) -> AntiScalar {
    return origin_origin_anti_dot(self_, self_);
}

fn plane_weight_norm_squared(self_: Plane) -> AntiScalar {
    return plane_plane_anti_dot(self_, self_);
}

fn plane_at_origin_weight_norm_squared(self_: PlaneAtOrigin) -> AntiScalar {
    return plane_at_origin_plane_at_origin_anti_dot(self_, self_);
}

fn point_weight_norm_squared(self_: Point) -> AntiScalar {
    return point_point_anti_dot(self_, self_);
}

fn rotor_weight_norm_squared(self_: Rotor) -> AntiScalar {
    return rotor_rotor_anti_dot(self_, self_);
}

fn translator_weight_norm_squared(self_: Translator) -> AntiScalar {
    return translator_translator_anti_dot(self_, self_);
}

fn flector_geometric_norm(self_: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(self_), flector_weight_norm(self_));
}

fn line_geometric_norm(self_: Line) -> Magnitude {
    return scalar_anti_scalar_add(line_bulk_norm(self_), line_weight_norm(self_));
}

fn magnitude_geometric_norm(self_: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(magnitude_bulk_norm(self_), magnitude_weight_norm(self_));
}

fn motor_geometric_norm(self_: Motor) -> Magnitude {
    return scalar_anti_scalar_add(motor_bulk_norm(self_), motor_weight_norm(self_));
}

fn multi_vector_geometric_norm(self_: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(self_), multi_vector_weight_norm(self_));
}

fn plane_geometric_norm(self_: Plane) -> Magnitude {
    return scalar_anti_scalar_add(plane_bulk_norm(self_), plane_weight_norm(self_));
}

fn point_geometric_norm(self_: Point) -> Magnitude {
    return scalar_anti_scalar_add(point_bulk_norm(self_), point_weight_norm(self_));
}

fn translator_geometric_norm(self_: Translator) -> Magnitude {
    return scalar_anti_scalar_add(translator_bulk_norm(self_), translator_weight_norm(self_));
}

fn anti_scalar_unitize(self_: AntiScalar) -> AntiScalar {
    return anti_scalar_scalar_geometric_product(self_, Scalar(1.0 / anti_scalar_weight_norm(self_).g0));
}

fn flector_unitize(self_: Flector) -> Flector {
    return flector_scalar_geometric_product(self_, Scalar(1.0 / flector_weight_norm(self_).g0));
}

fn line_unitize(self_: Line) -> Line {
    return line_scalar_geometric_product(self_, Scalar(1.0 / line_weight_norm(self_).g0));
}

fn line_at_origin_unitize(self_: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_scalar_geometric_product(self_, Scalar(1.0 / line_at_origin_weight_norm(self_).g0));
}

fn magnitude_unitize(self_: Magnitude) -> Magnitude {
    return magnitude_scalar_geometric_product(self_, Scalar(1.0 / magnitude_weight_norm(self_).g0));
}

fn motor_unitize(self_: Motor) -> Motor {
    return motor_scalar_geometric_product(self_, Scalar(1.0 / motor_weight_norm(self_).g0));
}

fn multi_vector_unitize(self_: MultiVector) -> MultiVector {
    return multi_vector_scalar_geometric_product(self_, Scalar(1.0 / multi_vector_weight_norm(self_).g0));
}

fn origin_unitize(self_: Origin) -> Origin {
    return origin_scalar_geometric_product(self_, Scalar(1.0 / origin_weight_norm(self_).g0));
}

fn plane_unitize(self_: Plane) -> Plane {
    return plane_scalar_geometric_product(self_, Scalar(1.0 / plane_weight_norm(self_).g0));
}

fn plane_at_origin_unitize(self_: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_scalar_geometric_product(self_, Scalar(1.0 / plane_at_origin_weight_norm(self_).g0));
}

fn point_unitize(self_: Point) -> Point {
    return point_scalar_geometric_product(self_, Scalar(1.0 / point_weight_norm(self_).g0));
}

fn rotor_unitize(self_: Rotor) -> Rotor {
    return rotor_scalar_geometric_product(self_, Scalar(1.0 / rotor_weight_norm(self_).g0));
}

fn translator_unitize(self_: Translator) -> Translator {
    return translator_scalar_geometric_product(self_, Scalar(1.0 / translator_weight_norm(self_).g0));
}

fn anti_scalar_flector_sandwich(self_: AntiScalar, other: Flector) -> Flector {
    return flector_anti_scalar_geometric_anti_product(anti_scalar_flector_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_horizon_sandwich(self_: AntiScalar, other: Horizon) -> Horizon {
    return horizon_anti_scalar_geometric_anti_product(anti_scalar_horizon_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_line_sandwich(self_: AntiScalar, other: Line) -> Line {
    return line_anti_scalar_geometric_anti_product(anti_scalar_line_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_line_at_infinity_sandwich(self_: AntiScalar, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_geometric_anti_product(anti_scalar_line_at_infinity_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_line_at_origin_sandwich(self_: AntiScalar, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_geometric_anti_product(anti_scalar_line_at_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_motor_sandwich(self_: AntiScalar, other: Motor) -> Motor {
    return motor_anti_scalar_geometric_anti_product(anti_scalar_motor_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_multi_vector_sandwich(self_: AntiScalar, other: MultiVector) -> MultiVector {
    return multi_vector_anti_scalar_geometric_anti_product(anti_scalar_multi_vector_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_origin_sandwich(self_: AntiScalar, other: Origin) -> Origin {
    return origin_anti_scalar_geometric_anti_product(anti_scalar_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_plane_sandwich(self_: AntiScalar, other: Plane) -> Plane {
    return plane_anti_scalar_geometric_anti_product(anti_scalar_plane_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_plane_at_origin_sandwich(self_: AntiScalar, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_geometric_anti_product(anti_scalar_plane_at_origin_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_point_sandwich(self_: AntiScalar, other: Point) -> Point {
    return point_anti_scalar_geometric_anti_product(anti_scalar_point_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_point_at_infinity_sandwich(self_: AntiScalar, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_geometric_anti_product(anti_scalar_point_at_infinity_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_rotor_sandwich(self_: AntiScalar, other: Rotor) -> Rotor {
    return rotor_anti_scalar_geometric_anti_product(anti_scalar_rotor_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn anti_scalar_translator_sandwich(self_: AntiScalar, other: Translator) -> Translator {
    return translator_anti_scalar_geometric_anti_product(anti_scalar_translator_geometric_anti_product(self_, other), anti_scalar_anti_reversal(self_));
}

fn flector_flector_sandwich(self_: Flector, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_flector_geometric_anti_product(flector_flector_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_horizon_sandwich(self_: Flector, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_flector_geometric_anti_product(flector_horizon_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_line_sandwich(self_: Flector, other: Line) -> Line {
    return multi_vector_line_into(flector_flector_geometric_anti_product(flector_line_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_line_at_infinity_sandwich(self_: Flector, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(flector_flector_geometric_anti_product(flector_line_at_infinity_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_line_at_origin_sandwich(self_: Flector, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_flector_geometric_anti_product(flector_line_at_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_motor_sandwich(self_: Flector, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_flector_geometric_anti_product(flector_motor_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_multi_vector_sandwich(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_flector_geometric_anti_product(flector_multi_vector_geometric_anti_product(self_, other), flector_anti_reversal(self_));
}

fn flector_origin_sandwich(self_: Flector, other: Origin) -> Point {
    return multi_vector_point_into(multi_vector_flector_geometric_anti_product(flector_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_plane_sandwich(self_: Flector, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_flector_geometric_anti_product(flector_plane_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_plane_at_origin_sandwich(self_: Flector, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_flector_geometric_anti_product(flector_plane_at_origin_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_point_sandwich(self_: Flector, other: Point) -> Point {
    return multi_vector_point_into(multi_vector_flector_geometric_anti_product(flector_point_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_point_at_infinity_sandwich(self_: Flector, other: PointAtInfinity) -> Point {
    return multi_vector_point_into(multi_vector_flector_geometric_anti_product(flector_point_at_infinity_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_rotor_sandwich(self_: Flector, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_flector_geometric_anti_product(flector_rotor_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn flector_translator_sandwich(self_: Flector, other: Translator) -> Motor {
    return multi_vector_motor_into(flector_flector_geometric_anti_product(flector_translator_geometric_anti_product(self_, other), flector_anti_reversal(self_)));
}

fn horizon_flector_sandwich(self_: Horizon, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_horizon_geometric_anti_product(horizon_flector_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_motor_sandwich(self_: Horizon, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_horizon_geometric_anti_product(horizon_motor_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn horizon_multi_vector_sandwich(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_horizon_geometric_anti_product(horizon_multi_vector_geometric_anti_product(self_, other), horizon_anti_reversal(self_));
}

fn horizon_rotor_sandwich(self_: Horizon, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_horizon_geometric_anti_product(horizon_rotor_geometric_anti_product(self_, other), horizon_anti_reversal(self_)));
}

fn line_flector_sandwich(self_: Line, other: Flector) -> Flector {
    return flector_line_geometric_anti_product(line_flector_geometric_anti_product(self_, other), line_anti_reversal(self_));
}

fn line_horizon_sandwich(self_: Line, other: Horizon) -> Plane {
    return flector_plane_into(point_at_infinity_line_geometric_anti_product(line_horizon_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_line_sandwich(self_: Line, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_line_geometric_anti_product(line_line_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_line_at_infinity_sandwich(self_: Line, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_line_geometric_anti_product(line_line_at_infinity_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_line_at_origin_sandwich(self_: Line, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_line_geometric_anti_product(line_line_at_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_motor_sandwich(self_: Line, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_geometric_anti_product(line_motor_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_multi_vector_sandwich(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_line_geometric_anti_product(line_multi_vector_geometric_anti_product(self_, other), line_anti_reversal(self_));
}

fn line_origin_sandwich(self_: Line, other: Origin) -> Point {
    return flector_point_into(flector_line_geometric_anti_product(line_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_plane_sandwich(self_: Line, other: Plane) -> Plane {
    return flector_plane_into(flector_line_geometric_anti_product(line_plane_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_plane_at_origin_sandwich(self_: Line, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_line_geometric_anti_product(line_plane_at_origin_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_point_sandwich(self_: Line, other: Point) -> Point {
    return flector_point_into(flector_line_geometric_anti_product(line_point_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_point_at_infinity_sandwich(self_: Line, other: PointAtInfinity) -> Point {
    return flector_point_into(flector_line_geometric_anti_product(line_point_at_infinity_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_rotor_sandwich(self_: Line, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_geometric_anti_product(line_rotor_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_translator_sandwich(self_: Line, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_line_geometric_anti_product(line_translator_geometric_anti_product(self_, other), line_anti_reversal(self_)));
}

fn line_at_infinity_flector_sandwich(self_: LineAtInfinity, other: Flector) -> Flector {
    return flector_line_at_infinity_geometric_anti_product(line_at_infinity_flector_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_));
}

fn line_at_infinity_line_sandwich(self_: LineAtInfinity, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_line_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_line_at_origin_sandwich(self_: LineAtInfinity, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_line_at_origin_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_motor_sandwich(self_: LineAtInfinity, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_motor_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_multi_vector_sandwich(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_multi_vector_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_));
}

fn line_at_infinity_plane_sandwich(self_: LineAtInfinity, other: Plane) -> Plane {
    return flector_plane_into(flector_line_at_infinity_geometric_anti_product(line_at_infinity_plane_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_plane_at_origin_sandwich(self_: LineAtInfinity, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_line_at_infinity_geometric_anti_product(line_at_infinity_plane_at_origin_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_infinity_rotor_sandwich(self_: LineAtInfinity, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_infinity_geometric_anti_product(line_at_infinity_rotor_geometric_anti_product(self_, other), line_at_infinity_anti_reversal(self_)));
}

fn line_at_origin_flector_sandwich(self_: LineAtOrigin, other: Flector) -> Flector {
    return flector_line_at_origin_geometric_anti_product(line_at_origin_flector_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_horizon_sandwich(self_: LineAtOrigin, other: Horizon) -> Plane {
    return flector_plane_into(point_at_infinity_line_at_origin_geometric_anti_product(line_at_origin_horizon_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_line_sandwich(self_: LineAtOrigin, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_line_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_line_at_infinity_sandwich(self_: LineAtOrigin, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_line_at_infinity_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_line_at_origin_sandwich(self_: LineAtOrigin, other: LineAtOrigin) -> Rotor {
    return rotor_line_at_origin_geometric_anti_product(line_at_origin_line_at_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_motor_sandwich(self_: LineAtOrigin, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_motor_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_multi_vector_sandwich(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_line_at_origin_geometric_anti_product(line_at_origin_multi_vector_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_origin_sandwich(self_: LineAtOrigin, other: Origin) -> Point {
    return flector_point_into(plane_at_origin_line_at_origin_geometric_anti_product(line_at_origin_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_plane_sandwich(self_: LineAtOrigin, other: Plane) -> Plane {
    return flector_plane_into(flector_line_at_origin_geometric_anti_product(line_at_origin_plane_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_plane_at_origin_sandwich(self_: LineAtOrigin, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_line_at_origin_geometric_anti_product(line_at_origin_plane_at_origin_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_point_sandwich(self_: LineAtOrigin, other: Point) -> Point {
    return flector_point_into(flector_line_at_origin_geometric_anti_product(line_at_origin_point_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_point_at_infinity_sandwich(self_: LineAtOrigin, other: PointAtInfinity) -> Point {
    return flector_point_into(flector_line_at_origin_geometric_anti_product(line_at_origin_point_at_infinity_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn line_at_origin_rotor_sandwich(self_: LineAtOrigin, other: Rotor) -> Rotor {
    return rotor_line_at_origin_geometric_anti_product(line_at_origin_rotor_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_));
}

fn line_at_origin_translator_sandwich(self_: LineAtOrigin, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_line_at_origin_geometric_anti_product(line_at_origin_translator_geometric_anti_product(self_, other), line_at_origin_anti_reversal(self_)));
}

fn magnitude_flector_sandwich(self_: Magnitude, other: Flector) -> Flector {
    return flector_magnitude_geometric_anti_product(magnitude_flector_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_horizon_sandwich(self_: Magnitude, other: Horizon) -> Horizon {
    return horizon_magnitude_geometric_anti_product(magnitude_horizon_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_line_sandwich(self_: Magnitude, other: Line) -> Line {
    return line_magnitude_geometric_anti_product(magnitude_line_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_line_at_infinity_sandwich(self_: Magnitude, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_magnitude_geometric_anti_product(magnitude_line_at_infinity_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_line_at_origin_sandwich(self_: Magnitude, other: LineAtOrigin) -> Line {
    return line_magnitude_geometric_anti_product(magnitude_line_at_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_motor_sandwich(self_: Magnitude, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_magnitude_geometric_anti_product(magnitude_motor_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_multi_vector_sandwich(self_: Magnitude, other: MultiVector) -> MultiVector {
    return multi_vector_magnitude_geometric_anti_product(magnitude_multi_vector_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_origin_sandwich(self_: Magnitude, other: Origin) -> Point {
    return flector_point_into(flector_magnitude_geometric_anti_product(magnitude_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_plane_sandwich(self_: Magnitude, other: Plane) -> Plane {
    return flector_plane_into(flector_magnitude_geometric_anti_product(magnitude_plane_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_plane_at_origin_sandwich(self_: Magnitude, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_magnitude_geometric_anti_product(magnitude_plane_at_origin_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_point_sandwich(self_: Magnitude, other: Point) -> Point {
    return flector_point_into(flector_magnitude_geometric_anti_product(magnitude_point_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_point_at_infinity_sandwich(self_: Magnitude, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_magnitude_geometric_anti_product(magnitude_point_at_infinity_geometric_anti_product(self_, other), magnitude_anti_reversal(self_));
}

fn magnitude_rotor_sandwich(self_: Magnitude, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_magnitude_geometric_anti_product(magnitude_rotor_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn magnitude_translator_sandwich(self_: Magnitude, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_magnitude_geometric_anti_product(magnitude_translator_geometric_anti_product(self_, other), magnitude_anti_reversal(self_)));
}

fn motor_flector_sandwich(self_: Motor, other: Flector) -> Flector {
    return flector_motor_geometric_anti_product(motor_flector_geometric_anti_product(self_, other), motor_anti_reversal(self_));
}

fn motor_horizon_sandwich(self_: Motor, other: Horizon) -> Plane {
    return flector_plane_into(flector_motor_geometric_anti_product(motor_horizon_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_line_sandwich(self_: Motor, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_motor_geometric_anti_product(motor_line_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_line_at_infinity_sandwich(self_: Motor, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_motor_geometric_anti_product(motor_line_at_infinity_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_line_at_origin_sandwich(self_: Motor, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_motor_geometric_anti_product(motor_line_at_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_motor_sandwich(self_: Motor, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_motor_geometric_anti_product(motor_motor_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_multi_vector_sandwich(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_motor_geometric_anti_product(motor_multi_vector_geometric_anti_product(self_, other), motor_anti_reversal(self_));
}

fn motor_origin_sandwich(self_: Motor, other: Origin) -> Point {
    return flector_point_into(flector_motor_geometric_anti_product(motor_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_plane_sandwich(self_: Motor, other: Plane) -> Plane {
    return flector_plane_into(flector_motor_geometric_anti_product(motor_plane_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_plane_at_origin_sandwich(self_: Motor, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_motor_geometric_anti_product(motor_plane_at_origin_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_point_sandwich(self_: Motor, other: Point) -> Point {
    return flector_point_into(flector_motor_geometric_anti_product(motor_point_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_point_at_infinity_sandwich(self_: Motor, other: PointAtInfinity) -> Point {
    return flector_point_into(flector_motor_geometric_anti_product(motor_point_at_infinity_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_rotor_sandwich(self_: Motor, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_motor_geometric_anti_product(motor_rotor_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn motor_translator_sandwich(self_: Motor, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_motor_geometric_anti_product(motor_translator_geometric_anti_product(self_, other), motor_anti_reversal(self_)));
}

fn multi_vector_flector_sandwich(self_: MultiVector, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_flector_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_horizon_sandwich(self_: MultiVector, other: Horizon) -> Plane {
    return multi_vector_plane_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_horizon_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_line_sandwich(self_: MultiVector, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_line_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_line_at_infinity_sandwich(self_: MultiVector, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_line_at_infinity_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_line_at_origin_sandwich(self_: MultiVector, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_line_at_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_motor_sandwich(self_: MultiVector, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_motor_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_multi_vector_sandwich(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_geometric_anti_product(multi_vector_multi_vector_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_));
}

fn multi_vector_origin_sandwich(self_: MultiVector, other: Origin) -> Point {
    return multi_vector_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_plane_sandwich(self_: MultiVector, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_plane_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_plane_at_origin_sandwich(self_: MultiVector, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_plane_at_origin_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_point_sandwich(self_: MultiVector, other: Point) -> Point {
    return multi_vector_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_point_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_point_at_infinity_sandwich(self_: MultiVector, other: PointAtInfinity) -> Point {
    return multi_vector_point_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_point_at_infinity_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_rotor_sandwich(self_: MultiVector, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_rotor_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn multi_vector_translator_sandwich(self_: MultiVector, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_multi_vector_geometric_anti_product(multi_vector_translator_geometric_anti_product(self_, other), multi_vector_anti_reversal(self_)));
}

fn origin_flector_sandwich(self_: Origin, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_origin_geometric_anti_product(origin_flector_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_horizon_sandwich(self_: Origin, other: Horizon) -> Horizon {
    return scalar_origin_geometric_anti_product(origin_horizon_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_line_sandwich(self_: Origin, other: Line) -> Line {
    return multi_vector_line_into(flector_origin_geometric_anti_product(origin_line_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_line_at_infinity_sandwich(self_: Origin, other: LineAtInfinity) -> LineAtInfinity {
    return point_at_infinity_origin_geometric_anti_product(origin_line_at_infinity_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_line_at_origin_sandwich(self_: Origin, other: LineAtOrigin) -> LineAtOrigin {
    return plane_at_origin_origin_geometric_anti_product(origin_line_at_origin_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_motor_sandwich(self_: Origin, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_origin_geometric_anti_product(origin_motor_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_multi_vector_sandwich(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_origin_geometric_anti_product(origin_multi_vector_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_origin_sandwich(self_: Origin, other: Origin) -> Origin {
    return anti_scalar_origin_geometric_anti_product(origin_origin_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_plane_sandwich(self_: Origin, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_origin_geometric_anti_product(origin_plane_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_plane_at_origin_sandwich(self_: Origin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return line_at_origin_origin_geometric_anti_product(origin_plane_at_origin_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_point_sandwich(self_: Origin, other: Point) -> Point {
    return translator_origin_geometric_anti_product(origin_point_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_point_at_infinity_sandwich(self_: Origin, other: PointAtInfinity) -> PointAtInfinity {
    return line_at_infinity_origin_geometric_anti_product(origin_point_at_infinity_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn origin_rotor_sandwich(self_: Origin, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_origin_geometric_anti_product(origin_rotor_geometric_anti_product(self_, other), origin_anti_reversal(self_)));
}

fn origin_translator_sandwich(self_: Origin, other: Translator) -> Translator {
    return point_origin_geometric_anti_product(origin_translator_geometric_anti_product(self_, other), origin_anti_reversal(self_));
}

fn plane_flector_sandwich(self_: Plane, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_plane_geometric_anti_product(plane_flector_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_horizon_sandwich(self_: Plane, other: Horizon) -> Plane {
    return flector_plane_into(line_at_infinity_plane_geometric_anti_product(plane_horizon_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_line_sandwich(self_: Plane, other: Line) -> Line {
    return multi_vector_line_into(flector_plane_geometric_anti_product(plane_line_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_line_at_infinity_sandwich(self_: Plane, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(flector_plane_geometric_anti_product(plane_line_at_infinity_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_line_at_origin_sandwich(self_: Plane, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_plane_geometric_anti_product(plane_line_at_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_motor_sandwich(self_: Plane, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_plane_geometric_anti_product(plane_motor_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_multi_vector_sandwich(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_plane_geometric_anti_product(plane_multi_vector_geometric_anti_product(self_, other), plane_anti_reversal(self_));
}

fn plane_origin_sandwich(self_: Plane, other: Origin) -> Point {
    return multi_vector_point_into(multi_vector_plane_geometric_anti_product(plane_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_plane_sandwich(self_: Plane, other: Plane) -> Plane {
    return flector_plane_into(motor_plane_geometric_anti_product(plane_plane_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_plane_at_origin_sandwich(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(motor_plane_geometric_anti_product(plane_plane_at_origin_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_point_sandwich(self_: Plane, other: Point) -> Point {
    return multi_vector_point_into(multi_vector_plane_geometric_anti_product(plane_point_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_point_at_infinity_sandwich(self_: Plane, other: PointAtInfinity) -> Point {
    return multi_vector_point_into(multi_vector_plane_geometric_anti_product(plane_point_at_infinity_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_rotor_sandwich(self_: Plane, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_plane_geometric_anti_product(plane_rotor_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_translator_sandwich(self_: Plane, other: Translator) -> Motor {
    return multi_vector_motor_into(flector_plane_geometric_anti_product(plane_translator_geometric_anti_product(self_, other), plane_anti_reversal(self_)));
}

fn plane_at_origin_flector_sandwich(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_flector_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_horizon_sandwich(self_: PlaneAtOrigin, other: Horizon) -> Plane {
    return flector_plane_into(line_at_infinity_plane_at_origin_geometric_anti_product(plane_at_origin_horizon_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_line_sandwich(self_: PlaneAtOrigin, other: Line) -> Line {
    return multi_vector_line_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_line_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_line_at_infinity_sandwich(self_: PlaneAtOrigin, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_line_at_infinity_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_line_at_origin_sandwich(self_: PlaneAtOrigin, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_line_at_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_motor_sandwich(self_: PlaneAtOrigin, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_motor_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_multi_vector_sandwich(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_multi_vector_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_));
}

fn plane_at_origin_origin_sandwich(self_: PlaneAtOrigin, other: Origin) -> Point {
    return flector_point_into(line_at_origin_plane_at_origin_geometric_anti_product(plane_at_origin_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_plane_sandwich(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return flector_plane_into(motor_plane_at_origin_geometric_anti_product(plane_at_origin_plane_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_plane_at_origin_sandwich(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(rotor_plane_at_origin_geometric_anti_product(plane_at_origin_plane_at_origin_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_point_sandwich(self_: PlaneAtOrigin, other: Point) -> Point {
    return multi_vector_point_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_point_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_point_at_infinity_sandwich(self_: PlaneAtOrigin, other: PointAtInfinity) -> Point {
    return multi_vector_point_into(multi_vector_plane_at_origin_geometric_anti_product(plane_at_origin_point_at_infinity_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_rotor_sandwich(self_: PlaneAtOrigin, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_rotor_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn plane_at_origin_translator_sandwich(self_: PlaneAtOrigin, other: Translator) -> Motor {
    return multi_vector_motor_into(flector_plane_at_origin_geometric_anti_product(plane_at_origin_translator_geometric_anti_product(self_, other), plane_at_origin_anti_reversal(self_)));
}

fn point_flector_sandwich(self_: Point, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_point_geometric_anti_product(point_flector_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_horizon_sandwich(self_: Point, other: Horizon) -> Horizon {
    return scalar_point_geometric_anti_product(point_horizon_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_line_sandwich(self_: Point, other: Line) -> Line {
    return multi_vector_line_into(flector_point_geometric_anti_product(point_line_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_line_at_infinity_sandwich(self_: Point, other: LineAtInfinity) -> LineAtInfinity {
    return point_at_infinity_point_geometric_anti_product(point_line_at_infinity_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_line_at_origin_sandwich(self_: Point, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_point_geometric_anti_product(point_line_at_origin_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_motor_sandwich(self_: Point, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_point_geometric_anti_product(point_motor_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_multi_vector_sandwich(self_: Point, other: MultiVector) -> MultiVector {
    return multi_vector_point_geometric_anti_product(point_multi_vector_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_origin_sandwich(self_: Point, other: Origin) -> Point {
    return translator_point_geometric_anti_product(point_origin_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_plane_sandwich(self_: Point, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_point_geometric_anti_product(point_plane_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_plane_at_origin_sandwich(self_: Point, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_point_geometric_anti_product(point_plane_at_origin_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_point_sandwich(self_: Point, other: Point) -> Point {
    return translator_point_geometric_anti_product(point_point_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_point_at_infinity_sandwich(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return line_at_infinity_point_geometric_anti_product(point_point_at_infinity_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_rotor_sandwich(self_: Point, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_point_geometric_anti_product(point_rotor_geometric_anti_product(self_, other), point_anti_reversal(self_)));
}

fn point_translator_sandwich(self_: Point, other: Translator) -> Translator {
    return point_point_geometric_anti_product(point_translator_geometric_anti_product(self_, other), point_anti_reversal(self_));
}

fn point_at_infinity_flector_sandwich(self_: PointAtInfinity, other: Flector) -> Flector {
    return multi_vector_flector_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_flector_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_line_sandwich(self_: PointAtInfinity, other: Line) -> Line {
    return multi_vector_line_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_line_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_line_at_origin_sandwich(self_: PointAtInfinity, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_line_at_origin_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_motor_sandwich(self_: PointAtInfinity, other: Motor) -> Motor {
    return multi_vector_motor_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_motor_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_multi_vector_sandwich(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_multi_vector_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_));
}

fn point_at_infinity_plane_sandwich(self_: PointAtInfinity, other: Plane) -> Plane {
    return multi_vector_plane_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_plane_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_plane_at_origin_sandwich(self_: PointAtInfinity, other: PlaneAtOrigin) -> Plane {
    return multi_vector_plane_into(multi_vector_point_at_infinity_geometric_anti_product(point_at_infinity_plane_at_origin_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn point_at_infinity_rotor_sandwich(self_: PointAtInfinity, other: Rotor) -> Motor {
    return multi_vector_motor_into(flector_point_at_infinity_geometric_anti_product(point_at_infinity_rotor_geometric_anti_product(self_, other), point_at_infinity_anti_reversal(self_)));
}

fn rotor_flector_sandwich(self_: Rotor, other: Flector) -> Flector {
    return flector_rotor_geometric_anti_product(rotor_flector_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_horizon_sandwich(self_: Rotor, other: Horizon) -> Plane {
    return flector_plane_into(flector_rotor_geometric_anti_product(rotor_horizon_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_line_sandwich(self_: Rotor, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_rotor_geometric_anti_product(rotor_line_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_line_at_infinity_sandwich(self_: Rotor, other: LineAtInfinity) -> Line {
    return multi_vector_line_into(multi_vector_rotor_geometric_anti_product(rotor_line_at_infinity_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_line_at_origin_sandwich(self_: Rotor, other: LineAtOrigin) -> Rotor {
    return rotor_rotor_geometric_anti_product(rotor_line_at_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_motor_sandwich(self_: Rotor, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_rotor_geometric_anti_product(rotor_motor_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_multi_vector_sandwich(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_rotor_geometric_anti_product(rotor_multi_vector_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_origin_sandwich(self_: Rotor, other: Origin) -> Point {
    return flector_point_into(flector_rotor_geometric_anti_product(rotor_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_plane_sandwich(self_: Rotor, other: Plane) -> Plane {
    return flector_plane_into(flector_rotor_geometric_anti_product(rotor_plane_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_plane_at_origin_sandwich(self_: Rotor, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_rotor_geometric_anti_product(rotor_plane_at_origin_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_point_sandwich(self_: Rotor, other: Point) -> Point {
    return flector_point_into(flector_rotor_geometric_anti_product(rotor_point_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_point_at_infinity_sandwich(self_: Rotor, other: PointAtInfinity) -> Point {
    return flector_point_into(flector_rotor_geometric_anti_product(rotor_point_at_infinity_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn rotor_rotor_sandwich(self_: Rotor, other: Rotor) -> Rotor {
    return rotor_rotor_geometric_anti_product(rotor_rotor_geometric_anti_product(self_, other), rotor_anti_reversal(self_));
}

fn rotor_translator_sandwich(self_: Rotor, other: Translator) -> Motor {
    return multi_vector_motor_into(multi_vector_rotor_geometric_anti_product(rotor_translator_geometric_anti_product(self_, other), rotor_anti_reversal(self_)));
}

fn scalar_flector_sandwich(self_: Scalar, other: Flector) -> Flector {
    return flector_scalar_geometric_anti_product(scalar_flector_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_motor_sandwich(self_: Scalar, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_scalar_geometric_anti_product(scalar_motor_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn scalar_multi_vector_sandwich(self_: Scalar, other: MultiVector) -> MultiVector {
    return multi_vector_scalar_geometric_anti_product(scalar_multi_vector_geometric_anti_product(self_, other), scalar_anti_reversal(self_));
}

fn scalar_rotor_sandwich(self_: Scalar, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_scalar_geometric_anti_product(scalar_rotor_geometric_anti_product(self_, other), scalar_anti_reversal(self_)));
}

fn translator_flector_sandwich(self_: Translator, other: Flector) -> Flector {
    return flector_translator_geometric_anti_product(translator_flector_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_horizon_sandwich(self_: Translator, other: Horizon) -> Horizon {
    return horizon_translator_geometric_anti_product(translator_horizon_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_line_sandwich(self_: Translator, other: Line) -> Line {
    return multi_vector_line_into(multi_vector_translator_geometric_anti_product(translator_line_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_line_at_infinity_sandwich(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_translator_geometric_anti_product(translator_line_at_infinity_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_line_at_origin_sandwich(self_: Translator, other: LineAtOrigin) -> Line {
    return multi_vector_line_into(multi_vector_translator_geometric_anti_product(translator_line_at_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_motor_sandwich(self_: Translator, other: Motor) -> Motor {
    return multi_vector_motor_into(multi_vector_translator_geometric_anti_product(translator_motor_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_multi_vector_sandwich(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_translator_geometric_anti_product(translator_multi_vector_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_origin_sandwich(self_: Translator, other: Origin) -> Point {
    return point_translator_geometric_anti_product(translator_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_plane_sandwich(self_: Translator, other: Plane) -> Plane {
    return flector_plane_into(flector_translator_geometric_anti_product(translator_plane_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_plane_at_origin_sandwich(self_: Translator, other: PlaneAtOrigin) -> Plane {
    return flector_plane_into(flector_translator_geometric_anti_product(translator_plane_at_origin_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_point_sandwich(self_: Translator, other: Point) -> Point {
    return point_translator_geometric_anti_product(translator_point_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_point_at_infinity_sandwich(self_: Translator, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_translator_geometric_anti_product(translator_point_at_infinity_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn translator_rotor_sandwich(self_: Translator, other: Rotor) -> Motor {
    return multi_vector_motor_into(multi_vector_translator_geometric_anti_product(translator_rotor_geometric_anti_product(self_, other), translator_anti_reversal(self_)));
}

fn translator_translator_sandwich(self_: Translator, other: Translator) -> Translator {
    return translator_translator_geometric_anti_product(translator_translator_geometric_anti_product(self_, other), translator_anti_reversal(self_));
}

fn point_flector_invert(self_: Point, other: Flector) -> Flector {
    return point_flector_sandwich(point_unitize(self_), other);
}

fn point_horizon_invert(self_: Point, other: Horizon) -> Horizon {
    return point_horizon_sandwich(point_unitize(self_), other);
}

fn point_line_invert(self_: Point, other: Line) -> Line {
    return point_line_sandwich(point_unitize(self_), other);
}

fn point_line_at_infinity_invert(self_: Point, other: LineAtInfinity) -> LineAtInfinity {
    return point_line_at_infinity_sandwich(point_unitize(self_), other);
}

fn point_line_at_origin_invert(self_: Point, other: LineAtOrigin) -> Line {
    return point_line_at_origin_sandwich(point_unitize(self_), other);
}

fn point_motor_invert(self_: Point, other: Motor) -> Motor {
    return point_motor_sandwich(point_unitize(self_), other);
}

fn point_multi_vector_invert(self_: Point, other: MultiVector) -> MultiVector {
    return point_multi_vector_sandwich(point_unitize(self_), other);
}

fn point_origin_invert(self_: Point, other: Origin) -> Point {
    return point_origin_sandwich(point_unitize(self_), other);
}

fn point_plane_invert(self_: Point, other: Plane) -> Plane {
    return point_plane_sandwich(point_unitize(self_), other);
}

fn point_plane_at_origin_invert(self_: Point, other: PlaneAtOrigin) -> Plane {
    return point_plane_at_origin_sandwich(point_unitize(self_), other);
}

fn point_point_invert(self_: Point, other: Point) -> Point {
    return point_point_sandwich(point_unitize(self_), other);
}

fn point_point_at_infinity_invert(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return point_point_at_infinity_sandwich(point_unitize(self_), other);
}

fn point_rotor_invert(self_: Point, other: Rotor) -> Motor {
    return point_rotor_sandwich(point_unitize(self_), other);
}

fn point_translator_invert(self_: Point, other: Translator) -> Translator {
    return point_translator_sandwich(point_unitize(self_), other);
}

fn plane_flector_reflect(self_: Plane, other: Flector) -> Flector {
    return plane_flector_sandwich(plane_unitize(self_), other);
}

fn plane_horizon_reflect(self_: Plane, other: Horizon) -> Plane {
    return plane_horizon_sandwich(plane_unitize(self_), other);
}

fn plane_line_reflect(self_: Plane, other: Line) -> Line {
    return plane_line_sandwich(plane_unitize(self_), other);
}

fn plane_line_at_infinity_reflect(self_: Plane, other: LineAtInfinity) -> Line {
    return plane_line_at_infinity_sandwich(plane_unitize(self_), other);
}

fn plane_line_at_origin_reflect(self_: Plane, other: LineAtOrigin) -> Line {
    return plane_line_at_origin_sandwich(plane_unitize(self_), other);
}

fn plane_motor_reflect(self_: Plane, other: Motor) -> Motor {
    return plane_motor_sandwich(plane_unitize(self_), other);
}

fn plane_multi_vector_reflect(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_sandwich(plane_unitize(self_), other);
}

fn plane_origin_reflect(self_: Plane, other: Origin) -> Point {
    return plane_origin_sandwich(plane_unitize(self_), other);
}

fn plane_plane_reflect(self_: Plane, other: Plane) -> Plane {
    return plane_plane_sandwich(plane_unitize(self_), other);
}

fn plane_plane_at_origin_reflect(self_: Plane, other: PlaneAtOrigin) -> Plane {
    return plane_plane_at_origin_sandwich(plane_unitize(self_), other);
}

fn plane_point_reflect(self_: Plane, other: Point) -> Point {
    return plane_point_sandwich(plane_unitize(self_), other);
}

fn plane_point_at_infinity_reflect(self_: Plane, other: PointAtInfinity) -> Point {
    return plane_point_at_infinity_sandwich(plane_unitize(self_), other);
}

fn plane_rotor_reflect(self_: Plane, other: Rotor) -> Motor {
    return plane_rotor_sandwich(plane_unitize(self_), other);
}

fn plane_translator_reflect(self_: Plane, other: Translator) -> Motor {
    return plane_translator_sandwich(plane_unitize(self_), other);
}

fn flector_flector_bulk_contraction(self_: Flector, other: Flector) -> MultiVector {
    return flector_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn flector_horizon_bulk_contraction(self_: Flector, other: Horizon) -> Scalar {
    return flector_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn flector_line_bulk_contraction(self_: Flector, other: Line) -> Point {
    return flector_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn flector_line_at_infinity_bulk_contraction(self_: Flector, other: LineAtInfinity) -> Point {
    return flector_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn flector_motor_bulk_contraction(self_: Flector, other: Motor) -> Point {
    return flector_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn flector_multi_vector_bulk_contraction(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn flector_plane_bulk_contraction(self_: Flector, other: Plane) -> Scalar {
    return flector_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn flector_point_bulk_contraction(self_: Flector, other: Point) -> MultiVector {
    return flector_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn flector_point_at_infinity_bulk_contraction(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return flector_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn flector_translator_bulk_contraction(self_: Flector, other: Translator) -> Point {
    return flector_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn horizon_flector_bulk_contraction(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn horizon_horizon_bulk_contraction(self_: Horizon, other: Horizon) -> Scalar {
    return horizon_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn horizon_line_bulk_contraction(self_: Horizon, other: Line) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn horizon_line_at_infinity_bulk_contraction(self_: Horizon, other: LineAtInfinity) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn horizon_motor_bulk_contraction(self_: Horizon, other: Motor) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn horizon_multi_vector_bulk_contraction(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn horizon_plane_bulk_contraction(self_: Horizon, other: Plane) -> Scalar {
    return horizon_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn horizon_point_bulk_contraction(self_: Horizon, other: Point) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn horizon_point_at_infinity_bulk_contraction(self_: Horizon, other: PointAtInfinity) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn horizon_translator_bulk_contraction(self_: Horizon, other: Translator) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn line_flector_bulk_contraction(self_: Line, other: Flector) -> Point {
    return line_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn line_line_bulk_contraction(self_: Line, other: Line) -> Scalar {
    return line_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn line_line_at_infinity_bulk_contraction(self_: Line, other: LineAtInfinity) -> Scalar {
    return line_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_motor_bulk_contraction(self_: Line, other: Motor) -> Scalar {
    return line_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn line_multi_vector_bulk_contraction(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_point_bulk_contraction(self_: Line, other: Point) -> Point {
    return line_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn line_point_at_infinity_bulk_contraction(self_: Line, other: PointAtInfinity) -> Point {
    return line_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn line_translator_bulk_contraction(self_: Line, other: Translator) -> Scalar {
    return line_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_infinity_flector_bulk_contraction(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return line_at_infinity_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_infinity_line_bulk_contraction(self_: LineAtInfinity, other: Line) -> Scalar {
    return line_at_infinity_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn line_at_infinity_line_at_infinity_bulk_contraction(self_: LineAtInfinity, other: LineAtInfinity) -> Scalar {
    return line_at_infinity_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_at_infinity_motor_bulk_contraction(self_: LineAtInfinity, other: Motor) -> Scalar {
    return line_at_infinity_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn line_at_infinity_multi_vector_bulk_contraction(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_infinity_point_bulk_contraction(self_: LineAtInfinity, other: Point) -> PointAtInfinity {
    return line_at_infinity_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn line_at_infinity_point_at_infinity_bulk_contraction(self_: LineAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn line_at_infinity_translator_bulk_contraction(self_: LineAtInfinity, other: Translator) -> Scalar {
    return line_at_infinity_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_origin_flector_bulk_contraction(self_: LineAtOrigin, other: Flector) -> Point {
    return line_at_origin_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_origin_multi_vector_bulk_contraction(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_origin_point_bulk_contraction(self_: LineAtOrigin, other: Point) -> Origin {
    return line_at_origin_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn line_at_origin_point_at_infinity_bulk_contraction(self_: LineAtOrigin, other: PointAtInfinity) -> Origin {
    return line_at_origin_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn motor_flector_bulk_contraction(self_: Motor, other: Flector) -> Flector {
    return motor_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn motor_horizon_bulk_contraction(self_: Motor, other: Horizon) -> Origin {
    return motor_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn motor_line_bulk_contraction(self_: Motor, other: Line) -> MultiVector {
    return motor_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn motor_line_at_infinity_bulk_contraction(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return motor_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn motor_motor_bulk_contraction(self_: Motor, other: Motor) -> MultiVector {
    return motor_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn motor_multi_vector_bulk_contraction(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn motor_plane_bulk_contraction(self_: Motor, other: Plane) -> Origin {
    return motor_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn motor_point_bulk_contraction(self_: Motor, other: Point) -> Flector {
    return motor_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn motor_point_at_infinity_bulk_contraction(self_: Motor, other: PointAtInfinity) -> Flector {
    return motor_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn motor_translator_bulk_contraction(self_: Motor, other: Translator) -> MultiVector {
    return motor_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn multi_vector_flector_bulk_contraction(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn multi_vector_horizon_bulk_contraction(self_: MultiVector, other: Horizon) -> MultiVector {
    return multi_vector_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn multi_vector_line_bulk_contraction(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn multi_vector_line_at_infinity_bulk_contraction(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multi_vector_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn multi_vector_motor_bulk_contraction(self_: MultiVector, other: Motor) -> MultiVector {
    return multi_vector_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn multi_vector_multi_vector_bulk_contraction(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn multi_vector_plane_bulk_contraction(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn multi_vector_point_bulk_contraction(self_: MultiVector, other: Point) -> MultiVector {
    return multi_vector_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn multi_vector_point_at_infinity_bulk_contraction(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multi_vector_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn multi_vector_translator_bulk_contraction(self_: MultiVector, other: Translator) -> MultiVector {
    return multi_vector_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn origin_flector_bulk_contraction(self_: Origin, other: Flector) -> Scalar {
    return origin_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn origin_multi_vector_bulk_contraction(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_flector_bulk_contraction(self_: Plane, other: Flector) -> MultiVector {
    return plane_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_horizon_bulk_contraction(self_: Plane, other: Horizon) -> Scalar {
    return plane_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn plane_line_bulk_contraction(self_: Plane, other: Line) -> Point {
    return plane_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn plane_line_at_infinity_bulk_contraction(self_: Plane, other: LineAtInfinity) -> Point {
    return plane_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn plane_motor_bulk_contraction(self_: Plane, other: Motor) -> Point {
    return plane_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn plane_multi_vector_bulk_contraction(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_plane_bulk_contraction(self_: Plane, other: Plane) -> Scalar {
    return plane_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn plane_point_bulk_contraction(self_: Plane, other: Point) -> Line {
    return plane_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn plane_point_at_infinity_bulk_contraction(self_: Plane, other: PointAtInfinity) -> Line {
    return plane_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn plane_translator_bulk_contraction(self_: Plane, other: Translator) -> Point {
    return plane_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn plane_at_origin_flector_bulk_contraction(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return plane_at_origin_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_at_origin_line_bulk_contraction(self_: PlaneAtOrigin, other: Line) -> Origin {
    return plane_at_origin_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn plane_at_origin_line_at_infinity_bulk_contraction(self_: PlaneAtOrigin, other: LineAtInfinity) -> Origin {
    return plane_at_origin_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn plane_at_origin_motor_bulk_contraction(self_: PlaneAtOrigin, other: Motor) -> Origin {
    return plane_at_origin_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn plane_at_origin_multi_vector_bulk_contraction(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_at_origin_point_bulk_contraction(self_: PlaneAtOrigin, other: Point) -> LineAtOrigin {
    return plane_at_origin_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn plane_at_origin_point_at_infinity_bulk_contraction(self_: PlaneAtOrigin, other: PointAtInfinity) -> LineAtOrigin {
    return plane_at_origin_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn plane_at_origin_translator_bulk_contraction(self_: PlaneAtOrigin, other: Translator) -> Origin {
    return plane_at_origin_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn point_flector_bulk_contraction(self_: Point, other: Flector) -> Scalar {
    return point_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn point_multi_vector_bulk_contraction(self_: Point, other: MultiVector) -> MultiVector {
    return point_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_point_bulk_contraction(self_: Point, other: Point) -> Scalar {
    return point_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn point_point_at_infinity_bulk_contraction(self_: Point, other: PointAtInfinity) -> Scalar {
    return point_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_at_infinity_flector_bulk_contraction(self_: PointAtInfinity, other: Flector) -> Scalar {
    return point_at_infinity_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn point_at_infinity_multi_vector_bulk_contraction(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_infinity_point_bulk_contraction(self_: PointAtInfinity, other: Point) -> Scalar {
    return point_at_infinity_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn point_at_infinity_point_at_infinity_bulk_contraction(self_: PointAtInfinity, other: PointAtInfinity) -> Scalar {
    return point_at_infinity_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn rotor_flector_bulk_contraction(self_: Rotor, other: Flector) -> Flector {
    return rotor_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn rotor_horizon_bulk_contraction(self_: Rotor, other: Horizon) -> Origin {
    return rotor_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn rotor_line_bulk_contraction(self_: Rotor, other: Line) -> LineAtOrigin {
    return rotor_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn rotor_line_at_infinity_bulk_contraction(self_: Rotor, other: LineAtInfinity) -> LineAtOrigin {
    return rotor_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn rotor_motor_bulk_contraction(self_: Rotor, other: Motor) -> LineAtOrigin {
    return rotor_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn rotor_multi_vector_bulk_contraction(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn rotor_plane_bulk_contraction(self_: Rotor, other: Plane) -> Origin {
    return rotor_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn rotor_point_bulk_contraction(self_: Rotor, other: Point) -> Flector {
    return rotor_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn rotor_point_at_infinity_bulk_contraction(self_: Rotor, other: PointAtInfinity) -> Flector {
    return rotor_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn rotor_translator_bulk_contraction(self_: Rotor, other: Translator) -> LineAtOrigin {
    return rotor_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn translator_flector_bulk_contraction(self_: Translator, other: Flector) -> Flector {
    return translator_flector_anti_wedge(self_, flector_right_bulk_dual(other));
}

fn translator_horizon_bulk_contraction(self_: Translator, other: Horizon) -> Origin {
    return translator_origin_anti_wedge(self_, horizon_right_bulk_dual(other));
}

fn translator_line_bulk_contraction(self_: Translator, other: Line) -> MultiVector {
    return translator_line_at_origin_anti_wedge(self_, line_right_bulk_dual(other));
}

fn translator_line_at_infinity_bulk_contraction(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return translator_line_at_origin_anti_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn translator_motor_bulk_contraction(self_: Translator, other: Motor) -> MultiVector {
    return translator_line_at_origin_anti_wedge(self_, motor_right_bulk_dual(other));
}

fn translator_multi_vector_bulk_contraction(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn translator_plane_bulk_contraction(self_: Translator, other: Plane) -> Origin {
    return translator_origin_anti_wedge(self_, plane_right_bulk_dual(other));
}

fn translator_point_bulk_contraction(self_: Translator, other: Point) -> Flector {
    return translator_plane_at_origin_anti_wedge(self_, point_right_bulk_dual(other));
}

fn translator_point_at_infinity_bulk_contraction(self_: Translator, other: PointAtInfinity) -> Flector {
    return translator_plane_at_origin_anti_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn translator_translator_bulk_contraction(self_: Translator, other: Translator) -> MultiVector {
    return translator_line_at_origin_anti_wedge(self_, translator_right_bulk_dual(other));
}

fn flector_flector_weight_contraction(self_: Flector, other: Flector) -> MultiVector {
    return flector_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn flector_line_weight_contraction(self_: Flector, other: Line) -> PointAtInfinity {
    return flector_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn flector_line_at_origin_weight_contraction(self_: Flector, other: LineAtOrigin) -> PointAtInfinity {
    return flector_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn flector_multi_vector_weight_contraction(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn flector_origin_weight_contraction(self_: Flector, other: Origin) -> MultiVector {
    return flector_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn flector_plane_weight_contraction(self_: Flector, other: Plane) -> Scalar {
    return flector_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn flector_plane_at_origin_weight_contraction(self_: Flector, other: PlaneAtOrigin) -> Scalar {
    return flector_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn flector_point_weight_contraction(self_: Flector, other: Point) -> MultiVector {
    return flector_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn horizon_flector_weight_contraction(self_: Horizon, other: Flector) -> MultiVector {
    return horizon_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn horizon_multi_vector_weight_contraction(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_flector_weight_contraction(self_: Line, other: Flector) -> Point {
    return line_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn line_line_weight_contraction(self_: Line, other: Line) -> Scalar {
    return line_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn line_line_at_origin_weight_contraction(self_: Line, other: LineAtOrigin) -> Scalar {
    return line_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_multi_vector_weight_contraction(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_origin_weight_contraction(self_: Line, other: Origin) -> PointAtInfinity {
    return line_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn line_point_weight_contraction(self_: Line, other: Point) -> PointAtInfinity {
    return line_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn line_at_infinity_flector_weight_contraction(self_: LineAtInfinity, other: Flector) -> PointAtInfinity {
    return line_at_infinity_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_infinity_multi_vector_weight_contraction(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_origin_flector_weight_contraction(self_: LineAtOrigin, other: Flector) -> Point {
    return line_at_origin_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_origin_line_weight_contraction(self_: LineAtOrigin, other: Line) -> Scalar {
    return line_at_origin_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn line_at_origin_line_at_origin_weight_contraction(self_: LineAtOrigin, other: LineAtOrigin) -> Scalar {
    return line_at_origin_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_at_origin_multi_vector_weight_contraction(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_origin_origin_weight_contraction(self_: LineAtOrigin, other: Origin) -> PointAtInfinity {
    return line_at_origin_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn line_at_origin_point_weight_contraction(self_: LineAtOrigin, other: Point) -> PointAtInfinity {
    return line_at_origin_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn motor_flector_weight_contraction(self_: Motor, other: Flector) -> Flector {
    return motor_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn motor_line_weight_contraction(self_: Motor, other: Line) -> MultiVector {
    return motor_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn motor_line_at_origin_weight_contraction(self_: Motor, other: LineAtOrigin) -> MultiVector {
    return motor_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn motor_multi_vector_weight_contraction(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn motor_origin_weight_contraction(self_: Motor, other: Origin) -> Flector {
    return motor_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn motor_plane_weight_contraction(self_: Motor, other: Plane) -> PointAtInfinity {
    return motor_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn motor_plane_at_origin_weight_contraction(self_: Motor, other: PlaneAtOrigin) -> PointAtInfinity {
    return motor_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn motor_point_weight_contraction(self_: Motor, other: Point) -> Flector {
    return motor_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn motor_translator_weight_contraction(self_: Motor, other: Translator) -> Scalar {
    return motor_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn multi_vector_flector_weight_contraction(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn multi_vector_line_weight_contraction(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn multi_vector_line_at_origin_weight_contraction(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multi_vector_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn multi_vector_multi_vector_weight_contraction(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn multi_vector_origin_weight_contraction(self_: MultiVector, other: Origin) -> MultiVector {
    return multi_vector_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn multi_vector_plane_weight_contraction(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn multi_vector_plane_at_origin_weight_contraction(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multi_vector_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn multi_vector_point_weight_contraction(self_: MultiVector, other: Point) -> MultiVector {
    return multi_vector_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn multi_vector_translator_weight_contraction(self_: MultiVector, other: Translator) -> Scalar {
    return multi_vector_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn origin_flector_weight_contraction(self_: Origin, other: Flector) -> Scalar {
    return origin_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn origin_multi_vector_weight_contraction(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn origin_origin_weight_contraction(self_: Origin, other: Origin) -> Scalar {
    return origin_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn origin_point_weight_contraction(self_: Origin, other: Point) -> Scalar {
    return origin_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn plane_flector_weight_contraction(self_: Plane, other: Flector) -> MultiVector {
    return plane_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn plane_line_weight_contraction(self_: Plane, other: Line) -> PointAtInfinity {
    return plane_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn plane_line_at_origin_weight_contraction(self_: Plane, other: LineAtOrigin) -> PointAtInfinity {
    return plane_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn plane_multi_vector_weight_contraction(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_origin_weight_contraction(self_: Plane, other: Origin) -> LineAtInfinity {
    return plane_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn plane_plane_weight_contraction(self_: Plane, other: Plane) -> Scalar {
    return plane_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn plane_plane_at_origin_weight_contraction(self_: Plane, other: PlaneAtOrigin) -> Scalar {
    return plane_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_point_weight_contraction(self_: Plane, other: Point) -> LineAtInfinity {
    return plane_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn plane_at_origin_flector_weight_contraction(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return plane_at_origin_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn plane_at_origin_line_weight_contraction(self_: PlaneAtOrigin, other: Line) -> PointAtInfinity {
    return plane_at_origin_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn plane_at_origin_line_at_origin_weight_contraction(self_: PlaneAtOrigin, other: LineAtOrigin) -> PointAtInfinity {
    return plane_at_origin_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn plane_at_origin_multi_vector_weight_contraction(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_at_origin_origin_weight_contraction(self_: PlaneAtOrigin, other: Origin) -> LineAtInfinity {
    return plane_at_origin_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn plane_at_origin_plane_weight_contraction(self_: PlaneAtOrigin, other: Plane) -> Scalar {
    return plane_at_origin_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn plane_at_origin_plane_at_origin_weight_contraction(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Scalar {
    return plane_at_origin_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_at_origin_point_weight_contraction(self_: PlaneAtOrigin, other: Point) -> LineAtInfinity {
    return plane_at_origin_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn point_flector_weight_contraction(self_: Point, other: Flector) -> Scalar {
    return point_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn point_multi_vector_weight_contraction(self_: Point, other: MultiVector) -> MultiVector {
    return point_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_origin_weight_contraction(self_: Point, other: Origin) -> Scalar {
    return point_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn point_point_weight_contraction(self_: Point, other: Point) -> Scalar {
    return point_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn point_at_infinity_flector_weight_contraction(self_: PointAtInfinity, other: Flector) -> Scalar {
    return point_at_infinity_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn point_at_infinity_multi_vector_weight_contraction(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn rotor_flector_weight_contraction(self_: Rotor, other: Flector) -> Flector {
    return rotor_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn rotor_line_weight_contraction(self_: Rotor, other: Line) -> MultiVector {
    return rotor_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn rotor_line_at_origin_weight_contraction(self_: Rotor, other: LineAtOrigin) -> MultiVector {
    return rotor_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn rotor_multi_vector_weight_contraction(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn rotor_origin_weight_contraction(self_: Rotor, other: Origin) -> Flector {
    return rotor_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn rotor_plane_weight_contraction(self_: Rotor, other: Plane) -> PointAtInfinity {
    return rotor_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn rotor_plane_at_origin_weight_contraction(self_: Rotor, other: PlaneAtOrigin) -> PointAtInfinity {
    return rotor_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn rotor_point_weight_contraction(self_: Rotor, other: Point) -> Flector {
    return rotor_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn rotor_translator_weight_contraction(self_: Rotor, other: Translator) -> Scalar {
    return rotor_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn translator_flector_weight_contraction(self_: Translator, other: Flector) -> Flector {
    return translator_flector_anti_wedge(self_, flector_right_weight_dual(other));
}

fn translator_line_weight_contraction(self_: Translator, other: Line) -> LineAtInfinity {
    return translator_line_at_infinity_anti_wedge(self_, line_right_weight_dual(other));
}

fn translator_line_at_origin_weight_contraction(self_: Translator, other: LineAtOrigin) -> LineAtInfinity {
    return translator_line_at_infinity_anti_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn translator_multi_vector_weight_contraction(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_anti_wedge(self_, multi_vector_right_weight_dual(other));
}

fn translator_origin_weight_contraction(self_: Translator, other: Origin) -> Horizon {
    return translator_horizon_anti_wedge(self_, origin_right_weight_dual(other));
}

fn translator_plane_weight_contraction(self_: Translator, other: Plane) -> PointAtInfinity {
    return translator_point_at_infinity_anti_wedge(self_, plane_right_weight_dual(other));
}

fn translator_plane_at_origin_weight_contraction(self_: Translator, other: PlaneAtOrigin) -> PointAtInfinity {
    return translator_point_at_infinity_anti_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn translator_point_weight_contraction(self_: Translator, other: Point) -> Horizon {
    return translator_horizon_anti_wedge(self_, point_right_weight_dual(other));
}

fn translator_translator_weight_contraction(self_: Translator, other: Translator) -> Scalar {
    return translator_scalar_anti_wedge(self_, translator_right_weight_dual(other));
}

fn flector_flector_bulk_expansion(self_: Flector, other: Flector) -> Motor {
    return flector_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn flector_horizon_bulk_expansion(self_: Flector, other: Horizon) -> Rotor {
    return flector_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn flector_line_bulk_expansion(self_: Flector, other: Line) -> PlaneAtOrigin {
    return flector_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn flector_line_at_infinity_bulk_expansion(self_: Flector, other: LineAtInfinity) -> PlaneAtOrigin {
    return flector_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn flector_motor_bulk_expansion(self_: Flector, other: Motor) -> PlaneAtOrigin {
    return flector_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn flector_multi_vector_bulk_expansion(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn flector_plane_bulk_expansion(self_: Flector, other: Plane) -> Rotor {
    return flector_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn flector_point_bulk_expansion(self_: Flector, other: Point) -> AntiScalar {
    return flector_plane_at_origin_wedge(self_, point_right_bulk_dual(other));
}

fn flector_point_at_infinity_bulk_expansion(self_: Flector, other: PointAtInfinity) -> AntiScalar {
    return flector_plane_at_origin_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn flector_translator_bulk_expansion(self_: Flector, other: Translator) -> PlaneAtOrigin {
    return flector_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn horizon_flector_bulk_expansion(self_: Horizon, other: Flector) -> AntiScalar {
    return horizon_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn horizon_horizon_bulk_expansion(self_: Horizon, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn horizon_multi_vector_bulk_expansion(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn horizon_plane_bulk_expansion(self_: Horizon, other: Plane) -> AntiScalar {
    return horizon_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn line_flector_bulk_expansion(self_: Line, other: Flector) -> Plane {
    return line_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn line_horizon_bulk_expansion(self_: Line, other: Horizon) -> PlaneAtOrigin {
    return line_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn line_line_bulk_expansion(self_: Line, other: Line) -> AntiScalar {
    return line_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn line_line_at_infinity_bulk_expansion(self_: Line, other: LineAtInfinity) -> AntiScalar {
    return line_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_motor_bulk_expansion(self_: Line, other: Motor) -> AntiScalar {
    return line_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn line_multi_vector_bulk_expansion(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_plane_bulk_expansion(self_: Line, other: Plane) -> PlaneAtOrigin {
    return line_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn line_translator_bulk_expansion(self_: Line, other: Translator) -> AntiScalar {
    return line_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_infinity_flector_bulk_expansion(self_: LineAtInfinity, other: Flector) -> Plane {
    return line_at_infinity_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_infinity_horizon_bulk_expansion(self_: LineAtInfinity, other: Horizon) -> PlaneAtOrigin {
    return line_at_infinity_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn line_at_infinity_line_bulk_expansion(self_: LineAtInfinity, other: Line) -> AntiScalar {
    return line_at_infinity_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn line_at_infinity_line_at_infinity_bulk_expansion(self_: LineAtInfinity, other: LineAtInfinity) -> AntiScalar {
    return line_at_infinity_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn line_at_infinity_motor_bulk_expansion(self_: LineAtInfinity, other: Motor) -> AntiScalar {
    return line_at_infinity_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn line_at_infinity_multi_vector_bulk_expansion(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn line_at_infinity_plane_bulk_expansion(self_: LineAtInfinity, other: Plane) -> PlaneAtOrigin {
    return line_at_infinity_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn line_at_infinity_translator_bulk_expansion(self_: LineAtInfinity, other: Translator) -> AntiScalar {
    return line_at_infinity_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn line_at_origin_flector_bulk_expansion(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return line_at_origin_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn line_at_origin_multi_vector_bulk_expansion(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn motor_flector_bulk_expansion(self_: Motor, other: Flector) -> Plane {
    return motor_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn motor_horizon_bulk_expansion(self_: Motor, other: Horizon) -> PlaneAtOrigin {
    return motor_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn motor_line_bulk_expansion(self_: Motor, other: Line) -> AntiScalar {
    return motor_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn motor_line_at_infinity_bulk_expansion(self_: Motor, other: LineAtInfinity) -> AntiScalar {
    return motor_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn motor_motor_bulk_expansion(self_: Motor, other: Motor) -> AntiScalar {
    return motor_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn motor_multi_vector_bulk_expansion(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn motor_plane_bulk_expansion(self_: Motor, other: Plane) -> PlaneAtOrigin {
    return motor_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn motor_translator_bulk_expansion(self_: Motor, other: Translator) -> AntiScalar {
    return motor_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn multi_vector_flector_bulk_expansion(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn multi_vector_horizon_bulk_expansion(self_: MultiVector, other: Horizon) -> MultiVector {
    return multi_vector_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn multi_vector_line_bulk_expansion(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn multi_vector_line_at_infinity_bulk_expansion(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return multi_vector_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn multi_vector_motor_bulk_expansion(self_: MultiVector, other: Motor) -> MultiVector {
    return multi_vector_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn multi_vector_multi_vector_bulk_expansion(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn multi_vector_plane_bulk_expansion(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn multi_vector_point_bulk_expansion(self_: MultiVector, other: Point) -> MultiVector {
    return multi_vector_plane_at_origin_wedge(self_, point_right_bulk_dual(other));
}

fn multi_vector_point_at_infinity_bulk_expansion(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return multi_vector_plane_at_origin_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn multi_vector_translator_bulk_expansion(self_: MultiVector, other: Translator) -> MultiVector {
    return multi_vector_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn origin_flector_bulk_expansion(self_: Origin, other: Flector) -> Rotor {
    return origin_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn origin_multi_vector_bulk_expansion(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_flector_bulk_expansion(self_: Plane, other: Flector) -> AntiScalar {
    return plane_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_horizon_bulk_expansion(self_: Plane, other: Horizon) -> AntiScalar {
    return plane_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn plane_multi_vector_bulk_expansion(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn plane_plane_bulk_expansion(self_: Plane, other: Plane) -> AntiScalar {
    return plane_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn plane_at_origin_flector_bulk_expansion(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return plane_at_origin_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn plane_at_origin_multi_vector_bulk_expansion(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_flector_bulk_expansion(self_: Point, other: Flector) -> Motor {
    return point_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn point_horizon_bulk_expansion(self_: Point, other: Horizon) -> LineAtOrigin {
    return point_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn point_line_bulk_expansion(self_: Point, other: Line) -> PlaneAtOrigin {
    return point_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn point_line_at_infinity_bulk_expansion(self_: Point, other: LineAtInfinity) -> PlaneAtOrigin {
    return point_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn point_motor_bulk_expansion(self_: Point, other: Motor) -> PlaneAtOrigin {
    return point_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn point_multi_vector_bulk_expansion(self_: Point, other: MultiVector) -> MultiVector {
    return point_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_plane_bulk_expansion(self_: Point, other: Plane) -> LineAtOrigin {
    return point_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn point_point_bulk_expansion(self_: Point, other: Point) -> AntiScalar {
    return point_plane_at_origin_wedge(self_, point_right_bulk_dual(other));
}

fn point_point_at_infinity_bulk_expansion(self_: Point, other: PointAtInfinity) -> AntiScalar {
    return point_plane_at_origin_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_translator_bulk_expansion(self_: Point, other: Translator) -> PlaneAtOrigin {
    return point_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn point_at_infinity_flector_bulk_expansion(self_: PointAtInfinity, other: Flector) -> Motor {
    return point_at_infinity_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn point_at_infinity_horizon_bulk_expansion(self_: PointAtInfinity, other: Horizon) -> LineAtOrigin {
    return point_at_infinity_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn point_at_infinity_line_bulk_expansion(self_: PointAtInfinity, other: Line) -> PlaneAtOrigin {
    return point_at_infinity_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn point_at_infinity_line_at_infinity_bulk_expansion(self_: PointAtInfinity, other: LineAtInfinity) -> PlaneAtOrigin {
    return point_at_infinity_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn point_at_infinity_motor_bulk_expansion(self_: PointAtInfinity, other: Motor) -> PlaneAtOrigin {
    return point_at_infinity_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn point_at_infinity_multi_vector_bulk_expansion(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn point_at_infinity_plane_bulk_expansion(self_: PointAtInfinity, other: Plane) -> LineAtOrigin {
    return point_at_infinity_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn point_at_infinity_point_bulk_expansion(self_: PointAtInfinity, other: Point) -> AntiScalar {
    return point_at_infinity_plane_at_origin_wedge(self_, point_right_bulk_dual(other));
}

fn point_at_infinity_point_at_infinity_bulk_expansion(self_: PointAtInfinity, other: PointAtInfinity) -> AntiScalar {
    return point_at_infinity_plane_at_origin_wedge(self_, point_at_infinity_right_bulk_dual(other));
}

fn point_at_infinity_translator_bulk_expansion(self_: PointAtInfinity, other: Translator) -> PlaneAtOrigin {
    return point_at_infinity_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn rotor_flector_bulk_expansion(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return rotor_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn rotor_multi_vector_bulk_expansion(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn translator_flector_bulk_expansion(self_: Translator, other: Flector) -> Plane {
    return translator_flector_wedge(self_, flector_right_bulk_dual(other));
}

fn translator_horizon_bulk_expansion(self_: Translator, other: Horizon) -> PlaneAtOrigin {
    return translator_origin_wedge(self_, horizon_right_bulk_dual(other));
}

fn translator_line_bulk_expansion(self_: Translator, other: Line) -> AntiScalar {
    return translator_line_at_origin_wedge(self_, line_right_bulk_dual(other));
}

fn translator_line_at_infinity_bulk_expansion(self_: Translator, other: LineAtInfinity) -> AntiScalar {
    return translator_line_at_origin_wedge(self_, line_at_infinity_right_bulk_dual(other));
}

fn translator_motor_bulk_expansion(self_: Translator, other: Motor) -> AntiScalar {
    return translator_line_at_origin_wedge(self_, motor_right_bulk_dual(other));
}

fn translator_multi_vector_bulk_expansion(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_wedge(self_, multi_vector_right_bulk_dual(other));
}

fn translator_plane_bulk_expansion(self_: Translator, other: Plane) -> PlaneAtOrigin {
    return translator_origin_wedge(self_, plane_right_bulk_dual(other));
}

fn translator_translator_bulk_expansion(self_: Translator, other: Translator) -> AntiScalar {
    return translator_line_at_origin_wedge(self_, translator_right_bulk_dual(other));
}

fn flector_flector_weight_expansion(self_: Flector, other: Flector) -> Motor {
    return flector_flector_wedge(self_, flector_right_weight_dual(other));
}

fn flector_line_weight_expansion(self_: Flector, other: Line) -> Plane {
    return flector_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn flector_line_at_origin_weight_expansion(self_: Flector, other: LineAtOrigin) -> Plane {
    return flector_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn flector_multi_vector_weight_expansion(self_: Flector, other: MultiVector) -> MultiVector {
    return flector_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn flector_origin_weight_expansion(self_: Flector, other: Origin) -> AntiScalar {
    return flector_horizon_wedge(self_, origin_right_weight_dual(other));
}

fn flector_plane_weight_expansion(self_: Flector, other: Plane) -> Motor {
    return flector_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn flector_plane_at_origin_weight_expansion(self_: Flector, other: PlaneAtOrigin) -> Motor {
    return flector_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn flector_point_weight_expansion(self_: Flector, other: Point) -> AntiScalar {
    return flector_horizon_wedge(self_, point_right_weight_dual(other));
}

fn flector_translator_weight_expansion(self_: Flector, other: Translator) -> Flector {
    return flector_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn horizon_flector_weight_expansion(self_: Horizon, other: Flector) -> AntiScalar {
    return horizon_flector_wedge(self_, flector_right_weight_dual(other));
}

fn horizon_multi_vector_weight_expansion(self_: Horizon, other: MultiVector) -> MultiVector {
    return horizon_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn horizon_translator_weight_expansion(self_: Horizon, other: Translator) -> Horizon {
    return horizon_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn line_flector_weight_expansion(self_: Line, other: Flector) -> Plane {
    return line_flector_wedge(self_, flector_right_weight_dual(other));
}

fn line_line_weight_expansion(self_: Line, other: Line) -> AntiScalar {
    return line_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn line_line_at_origin_weight_expansion(self_: Line, other: LineAtOrigin) -> AntiScalar {
    return line_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_multi_vector_weight_expansion(self_: Line, other: MultiVector) -> MultiVector {
    return line_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_plane_weight_expansion(self_: Line, other: Plane) -> Plane {
    return line_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn line_plane_at_origin_weight_expansion(self_: Line, other: PlaneAtOrigin) -> Plane {
    return line_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn line_translator_weight_expansion(self_: Line, other: Translator) -> Line {
    return line_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn line_at_infinity_flector_weight_expansion(self_: LineAtInfinity, other: Flector) -> Plane {
    return line_at_infinity_flector_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_infinity_multi_vector_weight_expansion(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_infinity_plane_weight_expansion(self_: LineAtInfinity, other: Plane) -> Horizon {
    return line_at_infinity_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn line_at_infinity_plane_at_origin_weight_expansion(self_: LineAtInfinity, other: PlaneAtOrigin) -> Horizon {
    return line_at_infinity_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn line_at_infinity_translator_weight_expansion(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn line_at_origin_flector_weight_expansion(self_: LineAtOrigin, other: Flector) -> PlaneAtOrigin {
    return line_at_origin_flector_wedge(self_, flector_right_weight_dual(other));
}

fn line_at_origin_line_weight_expansion(self_: LineAtOrigin, other: Line) -> AntiScalar {
    return line_at_origin_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn line_at_origin_line_at_origin_weight_expansion(self_: LineAtOrigin, other: LineAtOrigin) -> AntiScalar {
    return line_at_origin_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn line_at_origin_multi_vector_weight_expansion(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return line_at_origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn line_at_origin_plane_weight_expansion(self_: LineAtOrigin, other: Plane) -> PlaneAtOrigin {
    return line_at_origin_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn line_at_origin_plane_at_origin_weight_expansion(self_: LineAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return line_at_origin_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn line_at_origin_translator_weight_expansion(self_: LineAtOrigin, other: Translator) -> LineAtOrigin {
    return line_at_origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn motor_flector_weight_expansion(self_: Motor, other: Flector) -> Plane {
    return motor_flector_wedge(self_, flector_right_weight_dual(other));
}

fn motor_line_weight_expansion(self_: Motor, other: Line) -> AntiScalar {
    return motor_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn motor_line_at_origin_weight_expansion(self_: Motor, other: LineAtOrigin) -> AntiScalar {
    return motor_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn motor_multi_vector_weight_expansion(self_: Motor, other: MultiVector) -> MultiVector {
    return motor_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn motor_plane_weight_expansion(self_: Motor, other: Plane) -> Plane {
    return motor_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn motor_plane_at_origin_weight_expansion(self_: Motor, other: PlaneAtOrigin) -> Plane {
    return motor_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn motor_translator_weight_expansion(self_: Motor, other: Translator) -> Motor {
    return motor_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn multi_vector_flector_weight_expansion(self_: MultiVector, other: Flector) -> MultiVector {
    return multi_vector_flector_wedge(self_, flector_right_weight_dual(other));
}

fn multi_vector_line_weight_expansion(self_: MultiVector, other: Line) -> MultiVector {
    return multi_vector_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn multi_vector_line_at_origin_weight_expansion(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return multi_vector_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn multi_vector_multi_vector_weight_expansion(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn multi_vector_origin_weight_expansion(self_: MultiVector, other: Origin) -> MultiVector {
    return multi_vector_horizon_wedge(self_, origin_right_weight_dual(other));
}

fn multi_vector_plane_weight_expansion(self_: MultiVector, other: Plane) -> MultiVector {
    return multi_vector_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn multi_vector_plane_at_origin_weight_expansion(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return multi_vector_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn multi_vector_point_weight_expansion(self_: MultiVector, other: Point) -> MultiVector {
    return multi_vector_horizon_wedge(self_, point_right_weight_dual(other));
}

fn multi_vector_translator_weight_expansion(self_: MultiVector, other: Translator) -> MultiVector {
    return multi_vector_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn origin_flector_weight_expansion(self_: Origin, other: Flector) -> Rotor {
    return origin_flector_wedge(self_, flector_right_weight_dual(other));
}

fn origin_line_weight_expansion(self_: Origin, other: Line) -> PlaneAtOrigin {
    return origin_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn origin_line_at_origin_weight_expansion(self_: Origin, other: LineAtOrigin) -> PlaneAtOrigin {
    return origin_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn origin_multi_vector_weight_expansion(self_: Origin, other: MultiVector) -> MultiVector {
    return origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn origin_origin_weight_expansion(self_: Origin, other: Origin) -> AntiScalar {
    return origin_horizon_wedge(self_, origin_right_weight_dual(other));
}

fn origin_plane_weight_expansion(self_: Origin, other: Plane) -> LineAtOrigin {
    return origin_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn origin_plane_at_origin_weight_expansion(self_: Origin, other: PlaneAtOrigin) -> LineAtOrigin {
    return origin_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn origin_point_weight_expansion(self_: Origin, other: Point) -> AntiScalar {
    return origin_horizon_wedge(self_, point_right_weight_dual(other));
}

fn origin_translator_weight_expansion(self_: Origin, other: Translator) -> Origin {
    return origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn plane_flector_weight_expansion(self_: Plane, other: Flector) -> AntiScalar {
    return plane_flector_wedge(self_, flector_right_weight_dual(other));
}

fn plane_multi_vector_weight_expansion(self_: Plane, other: MultiVector) -> MultiVector {
    return plane_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_plane_weight_expansion(self_: Plane, other: Plane) -> AntiScalar {
    return plane_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn plane_plane_at_origin_weight_expansion(self_: Plane, other: PlaneAtOrigin) -> AntiScalar {
    return plane_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_translator_weight_expansion(self_: Plane, other: Translator) -> Plane {
    return plane_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn plane_at_origin_flector_weight_expansion(self_: PlaneAtOrigin, other: Flector) -> AntiScalar {
    return plane_at_origin_flector_wedge(self_, flector_right_weight_dual(other));
}

fn plane_at_origin_multi_vector_weight_expansion(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return plane_at_origin_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn plane_at_origin_plane_weight_expansion(self_: PlaneAtOrigin, other: Plane) -> AntiScalar {
    return plane_at_origin_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn plane_at_origin_plane_at_origin_weight_expansion(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> AntiScalar {
    return plane_at_origin_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn plane_at_origin_translator_weight_expansion(self_: PlaneAtOrigin, other: Translator) -> PlaneAtOrigin {
    return plane_at_origin_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn point_flector_weight_expansion(self_: Point, other: Flector) -> Motor {
    return point_flector_wedge(self_, flector_right_weight_dual(other));
}

fn point_line_weight_expansion(self_: Point, other: Line) -> Plane {
    return point_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn point_line_at_origin_weight_expansion(self_: Point, other: LineAtOrigin) -> Plane {
    return point_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn point_multi_vector_weight_expansion(self_: Point, other: MultiVector) -> MultiVector {
    return point_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_origin_weight_expansion(self_: Point, other: Origin) -> AntiScalar {
    return point_horizon_wedge(self_, origin_right_weight_dual(other));
}

fn point_plane_weight_expansion(self_: Point, other: Plane) -> Line {
    return point_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn point_plane_at_origin_weight_expansion(self_: Point, other: PlaneAtOrigin) -> Line {
    return point_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn point_point_weight_expansion(self_: Point, other: Point) -> AntiScalar {
    return point_horizon_wedge(self_, point_right_weight_dual(other));
}

fn point_translator_weight_expansion(self_: Point, other: Translator) -> Point {
    return point_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn point_at_infinity_flector_weight_expansion(self_: PointAtInfinity, other: Flector) -> Motor {
    return point_at_infinity_flector_wedge(self_, flector_right_weight_dual(other));
}

fn point_at_infinity_line_weight_expansion(self_: PointAtInfinity, other: Line) -> Horizon {
    return point_at_infinity_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn point_at_infinity_line_at_origin_weight_expansion(self_: PointAtInfinity, other: LineAtOrigin) -> Horizon {
    return point_at_infinity_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn point_at_infinity_multi_vector_weight_expansion(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn point_at_infinity_plane_weight_expansion(self_: PointAtInfinity, other: Plane) -> LineAtInfinity {
    return point_at_infinity_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn point_at_infinity_plane_at_origin_weight_expansion(self_: PointAtInfinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return point_at_infinity_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn point_at_infinity_translator_weight_expansion(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn rotor_flector_weight_expansion(self_: Rotor, other: Flector) -> PlaneAtOrigin {
    return rotor_flector_wedge(self_, flector_right_weight_dual(other));
}

fn rotor_line_weight_expansion(self_: Rotor, other: Line) -> AntiScalar {
    return rotor_line_at_infinity_wedge(self_, line_right_weight_dual(other));
}

fn rotor_line_at_origin_weight_expansion(self_: Rotor, other: LineAtOrigin) -> AntiScalar {
    return rotor_line_at_infinity_wedge(self_, line_at_origin_right_weight_dual(other));
}

fn rotor_multi_vector_weight_expansion(self_: Rotor, other: MultiVector) -> MultiVector {
    return rotor_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn rotor_plane_weight_expansion(self_: Rotor, other: Plane) -> PlaneAtOrigin {
    return rotor_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn rotor_plane_at_origin_weight_expansion(self_: Rotor, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return rotor_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn rotor_translator_weight_expansion(self_: Rotor, other: Translator) -> Rotor {
    return rotor_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn translator_flector_weight_expansion(self_: Translator, other: Flector) -> Plane {
    return translator_flector_wedge(self_, flector_right_weight_dual(other));
}

fn translator_multi_vector_weight_expansion(self_: Translator, other: MultiVector) -> MultiVector {
    return translator_multi_vector_wedge(self_, multi_vector_right_weight_dual(other));
}

fn translator_plane_weight_expansion(self_: Translator, other: Plane) -> Horizon {
    return translator_point_at_infinity_wedge(self_, plane_right_weight_dual(other));
}

fn translator_plane_at_origin_weight_expansion(self_: Translator, other: PlaneAtOrigin) -> Horizon {
    return translator_point_at_infinity_wedge(self_, plane_at_origin_right_weight_dual(other));
}

fn translator_translator_weight_expansion(self_: Translator, other: Translator) -> Translator {
    return translator_scalar_wedge(self_, translator_right_weight_dual(other));
}

fn flector_flector_anti_project_via_horizon_onto(self_: Flector, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, flector_flector_bulk_contraction(self_, other));
}

fn flector_horizon_anti_project_via_horizon_onto(self_: Flector, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, flector_horizon_bulk_contraction(self_, other));
}

fn flector_line_anti_project_via_horizon_onto(self_: Flector, other: Line) -> Plane {
    return line_point_wedge(other, flector_line_bulk_contraction(self_, other));
}

fn flector_line_at_infinity_anti_project_via_horizon_onto(self_: Flector, other: LineAtInfinity) -> Plane {
    return line_at_infinity_point_wedge(other, flector_line_at_infinity_bulk_contraction(self_, other));
}

fn flector_motor_anti_project_via_horizon_onto(self_: Flector, other: Motor) -> Plane {
    return motor_point_wedge(other, flector_motor_bulk_contraction(self_, other));
}

fn flector_multi_vector_anti_project_via_horizon_onto(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, flector_multi_vector_bulk_contraction(self_, other));
}

fn flector_plane_anti_project_via_horizon_onto(self_: Flector, other: Plane) -> Plane {
    return plane_scalar_wedge(other, flector_plane_bulk_contraction(self_, other));
}

fn flector_point_anti_project_via_horizon_onto(self_: Flector, other: Point) -> MultiVector {
    return point_multi_vector_wedge(other, flector_point_bulk_contraction(self_, other));
}

fn flector_point_at_infinity_anti_project_via_horizon_onto(self_: Flector, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, flector_point_at_infinity_bulk_contraction(self_, other));
}

fn flector_translator_anti_project_via_horizon_onto(self_: Flector, other: Translator) -> Plane {
    return translator_point_wedge(other, flector_translator_bulk_contraction(self_, other));
}

fn horizon_flector_anti_project_via_horizon_onto(self_: Horizon, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, horizon_flector_bulk_contraction(self_, other));
}

fn horizon_horizon_anti_project_via_horizon_onto(self_: Horizon, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, horizon_horizon_bulk_contraction(self_, other));
}

fn horizon_line_anti_project_via_horizon_onto(self_: Horizon, other: Line) -> Plane {
    return line_point_at_infinity_wedge(other, horizon_line_bulk_contraction(self_, other));
}

fn horizon_line_at_infinity_anti_project_via_horizon_onto(self_: Horizon, other: LineAtInfinity) -> Horizon {
    return line_at_infinity_point_at_infinity_wedge(other, horizon_line_at_infinity_bulk_contraction(self_, other));
}

fn horizon_motor_anti_project_via_horizon_onto(self_: Horizon, other: Motor) -> Plane {
    return motor_point_at_infinity_wedge(other, horizon_motor_bulk_contraction(self_, other));
}

fn horizon_multi_vector_anti_project_via_horizon_onto(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, horizon_multi_vector_bulk_contraction(self_, other));
}

fn horizon_plane_anti_project_via_horizon_onto(self_: Horizon, other: Plane) -> Plane {
    return plane_scalar_wedge(other, horizon_plane_bulk_contraction(self_, other));
}

fn horizon_point_anti_project_via_horizon_onto(self_: Horizon, other: Point) -> Plane {
    return point_line_at_infinity_wedge(other, horizon_point_bulk_contraction(self_, other));
}

fn horizon_point_at_infinity_anti_project_via_horizon_onto(self_: Horizon, other: PointAtInfinity) -> Horizon {
    return point_at_infinity_line_at_infinity_wedge(other, horizon_point_at_infinity_bulk_contraction(self_, other));
}

fn horizon_translator_anti_project_via_horizon_onto(self_: Horizon, other: Translator) -> Horizon {
    return translator_point_at_infinity_wedge(other, horizon_translator_bulk_contraction(self_, other));
}

fn line_flector_anti_project_via_horizon_onto(self_: Line, other: Flector) -> Motor {
    return flector_point_wedge(other, line_flector_bulk_contraction(self_, other));
}

fn line_line_anti_project_via_horizon_onto(self_: Line, other: Line) -> Line {
    return line_scalar_wedge(other, line_line_bulk_contraction(self_, other));
}

fn line_line_at_infinity_anti_project_via_horizon_onto(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(other, line_line_at_infinity_bulk_contraction(self_, other));
}

fn line_motor_anti_project_via_horizon_onto(self_: Line, other: Motor) -> Motor {
    return motor_scalar_wedge(other, line_motor_bulk_contraction(self_, other));
}

fn line_multi_vector_anti_project_via_horizon_onto(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, line_multi_vector_bulk_contraction(self_, other));
}

fn line_point_anti_project_via_horizon_onto(self_: Line, other: Point) -> Line {
    return point_point_wedge(other, line_point_bulk_contraction(self_, other));
}

fn line_point_at_infinity_anti_project_via_horizon_onto(self_: Line, other: PointAtInfinity) -> Line {
    return point_at_infinity_point_wedge(other, line_point_at_infinity_bulk_contraction(self_, other));
}

fn line_translator_anti_project_via_horizon_onto(self_: Line, other: Translator) -> Translator {
    return translator_scalar_wedge(other, line_translator_bulk_contraction(self_, other));
}

fn line_at_infinity_flector_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Flector) -> Motor {
    return flector_point_at_infinity_wedge(other, line_at_infinity_flector_bulk_contraction(self_, other));
}

fn line_at_infinity_line_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Line) -> Line {
    return line_scalar_wedge(other, line_at_infinity_line_bulk_contraction(self_, other));
}

fn line_at_infinity_line_at_infinity_anti_project_via_horizon_onto(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_scalar_wedge(other, line_at_infinity_line_at_infinity_bulk_contraction(self_, other));
}

fn line_at_infinity_motor_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Motor) -> Motor {
    return motor_scalar_wedge(other, line_at_infinity_motor_bulk_contraction(self_, other));
}

fn line_at_infinity_multi_vector_anti_project_via_horizon_onto(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, line_at_infinity_multi_vector_bulk_contraction(self_, other));
}

fn line_at_infinity_point_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Point) -> Line {
    return point_point_at_infinity_wedge(other, line_at_infinity_point_bulk_contraction(self_, other));
}

fn line_at_infinity_point_at_infinity_anti_project_via_horizon_onto(self_: LineAtInfinity, other: PointAtInfinity) -> LineAtInfinity {
    return point_at_infinity_point_at_infinity_wedge(other, line_at_infinity_point_at_infinity_bulk_contraction(self_, other));
}

fn line_at_infinity_translator_anti_project_via_horizon_onto(self_: LineAtInfinity, other: Translator) -> Translator {
    return translator_scalar_wedge(other, line_at_infinity_translator_bulk_contraction(self_, other));
}

fn line_at_origin_flector_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Flector) -> Motor {
    return flector_point_wedge(other, line_at_origin_flector_bulk_contraction(self_, other));
}

fn line_at_origin_multi_vector_anti_project_via_horizon_onto(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, line_at_origin_multi_vector_bulk_contraction(self_, other));
}

fn line_at_origin_point_anti_project_via_horizon_onto(self_: LineAtOrigin, other: Point) -> LineAtOrigin {
    return point_origin_wedge(other, line_at_origin_point_bulk_contraction(self_, other));
}

fn line_at_origin_point_at_infinity_anti_project_via_horizon_onto(self_: LineAtOrigin, other: PointAtInfinity) -> LineAtOrigin {
    return point_at_infinity_origin_wedge(other, line_at_origin_point_at_infinity_bulk_contraction(self_, other));
}

fn motor_flector_anti_project_via_horizon_onto(self_: Motor, other: Flector) -> Motor {
    return flector_flector_wedge(other, motor_flector_bulk_contraction(self_, other));
}

fn motor_horizon_anti_project_via_horizon_onto(self_: Motor, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(other, motor_horizon_bulk_contraction(self_, other));
}

fn motor_line_anti_project_via_horizon_onto(self_: Motor, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, motor_line_bulk_contraction(self_, other));
}

fn motor_line_at_infinity_anti_project_via_horizon_onto(self_: Motor, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, motor_line_at_infinity_bulk_contraction(self_, other));
}

fn motor_motor_anti_project_via_horizon_onto(self_: Motor, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, motor_motor_bulk_contraction(self_, other));
}

fn motor_multi_vector_anti_project_via_horizon_onto(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, motor_multi_vector_bulk_contraction(self_, other));
}

fn motor_plane_anti_project_via_horizon_onto(self_: Motor, other: Plane) -> AntiScalar {
    return plane_origin_wedge(other, motor_plane_bulk_contraction(self_, other));
}

fn motor_point_anti_project_via_horizon_onto(self_: Motor, other: Point) -> Motor {
    return point_flector_wedge(other, motor_point_bulk_contraction(self_, other));
}

fn motor_point_at_infinity_anti_project_via_horizon_onto(self_: Motor, other: PointAtInfinity) -> Motor {
    return point_at_infinity_flector_wedge(other, motor_point_at_infinity_bulk_contraction(self_, other));
}

fn motor_translator_anti_project_via_horizon_onto(self_: Motor, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, motor_translator_bulk_contraction(self_, other));
}

fn multi_vector_flector_anti_project_via_horizon_onto(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, multi_vector_flector_bulk_contraction(self_, other));
}

fn multi_vector_horizon_anti_project_via_horizon_onto(self_: MultiVector, other: Horizon) -> MultiVector {
    return horizon_multi_vector_wedge(other, multi_vector_horizon_bulk_contraction(self_, other));
}

fn multi_vector_line_anti_project_via_horizon_onto(self_: MultiVector, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, multi_vector_line_bulk_contraction(self_, other));
}

fn multi_vector_line_at_infinity_anti_project_via_horizon_onto(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, multi_vector_line_at_infinity_bulk_contraction(self_, other));
}

fn multi_vector_motor_anti_project_via_horizon_onto(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, multi_vector_motor_bulk_contraction(self_, other));
}

fn multi_vector_multi_vector_anti_project_via_horizon_onto(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, multi_vector_multi_vector_bulk_contraction(self_, other));
}

fn multi_vector_plane_anti_project_via_horizon_onto(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_multi_vector_wedge(other, multi_vector_plane_bulk_contraction(self_, other));
}

fn multi_vector_point_anti_project_via_horizon_onto(self_: MultiVector, other: Point) -> MultiVector {
    return point_multi_vector_wedge(other, multi_vector_point_bulk_contraction(self_, other));
}

fn multi_vector_point_at_infinity_anti_project_via_horizon_onto(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_wedge(other, multi_vector_point_at_infinity_bulk_contraction(self_, other));
}

fn multi_vector_translator_anti_project_via_horizon_onto(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, multi_vector_translator_bulk_contraction(self_, other));
}

fn origin_flector_anti_project_via_horizon_onto(self_: Origin, other: Flector) -> Flector {
    return flector_scalar_wedge(other, origin_flector_bulk_contraction(self_, other));
}

fn origin_multi_vector_anti_project_via_horizon_onto(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, origin_multi_vector_bulk_contraction(self_, other));
}

fn plane_flector_anti_project_via_horizon_onto(self_: Plane, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, plane_flector_bulk_contraction(self_, other));
}

fn plane_horizon_anti_project_via_horizon_onto(self_: Plane, other: Horizon) -> Horizon {
    return horizon_scalar_wedge(other, plane_horizon_bulk_contraction(self_, other));
}

fn plane_line_anti_project_via_horizon_onto(self_: Plane, other: Line) -> Plane {
    return line_point_wedge(other, plane_line_bulk_contraction(self_, other));
}

fn plane_line_at_infinity_anti_project_via_horizon_onto(self_: Plane, other: LineAtInfinity) -> Plane {
    return line_at_infinity_point_wedge(other, plane_line_at_infinity_bulk_contraction(self_, other));
}

fn plane_motor_anti_project_via_horizon_onto(self_: Plane, other: Motor) -> Plane {
    return motor_point_wedge(other, plane_motor_bulk_contraction(self_, other));
}

fn plane_multi_vector_anti_project_via_horizon_onto(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, plane_multi_vector_bulk_contraction(self_, other));
}

fn plane_plane_anti_project_via_horizon_onto(self_: Plane, other: Plane) -> Plane {
    return plane_scalar_wedge(other, plane_plane_bulk_contraction(self_, other));
}

fn plane_point_anti_project_via_horizon_onto(self_: Plane, other: Point) -> Plane {
    return point_line_wedge(other, plane_point_bulk_contraction(self_, other));
}

fn plane_point_at_infinity_anti_project_via_horizon_onto(self_: Plane, other: PointAtInfinity) -> Plane {
    return point_at_infinity_line_wedge(other, plane_point_at_infinity_bulk_contraction(self_, other));
}

fn plane_translator_anti_project_via_horizon_onto(self_: Plane, other: Translator) -> Plane {
    return translator_point_wedge(other, plane_translator_bulk_contraction(self_, other));
}

fn plane_at_origin_flector_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Flector) -> MultiVector {
    return flector_multi_vector_wedge(other, plane_at_origin_flector_bulk_contraction(self_, other));
}

fn plane_at_origin_line_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Line) -> PlaneAtOrigin {
    return line_origin_wedge(other, plane_at_origin_line_bulk_contraction(self_, other));
}

fn plane_at_origin_line_at_infinity_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: LineAtInfinity) -> PlaneAtOrigin {
    return line_at_infinity_origin_wedge(other, plane_at_origin_line_at_infinity_bulk_contraction(self_, other));
}

fn plane_at_origin_motor_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Motor) -> PlaneAtOrigin {
    return motor_origin_wedge(other, plane_at_origin_motor_bulk_contraction(self_, other));
}

fn plane_at_origin_multi_vector_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, plane_at_origin_multi_vector_bulk_contraction(self_, other));
}

fn plane_at_origin_point_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Point) -> PlaneAtOrigin {
    return point_line_at_origin_wedge(other, plane_at_origin_point_bulk_contraction(self_, other));
}

fn plane_at_origin_point_at_infinity_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: PointAtInfinity) -> PlaneAtOrigin {
    return point_at_infinity_line_at_origin_wedge(other, plane_at_origin_point_at_infinity_bulk_contraction(self_, other));
}

fn plane_at_origin_translator_anti_project_via_horizon_onto(self_: PlaneAtOrigin, other: Translator) -> PlaneAtOrigin {
    return translator_origin_wedge(other, plane_at_origin_translator_bulk_contraction(self_, other));
}

fn point_flector_anti_project_via_horizon_onto(self_: Point, other: Flector) -> Flector {
    return flector_scalar_wedge(other, point_flector_bulk_contraction(self_, other));
}

fn point_multi_vector_anti_project_via_horizon_onto(self_: Point, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, point_multi_vector_bulk_contraction(self_, other));
}

fn point_point_anti_project_via_horizon_onto(self_: Point, other: Point) -> Point {
    return point_scalar_wedge(other, point_point_bulk_contraction(self_, other));
}

fn point_point_at_infinity_anti_project_via_horizon_onto(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(other, point_point_at_infinity_bulk_contraction(self_, other));
}

fn point_at_infinity_flector_anti_project_via_horizon_onto(self_: PointAtInfinity, other: Flector) -> Flector {
    return flector_scalar_wedge(other, point_at_infinity_flector_bulk_contraction(self_, other));
}

fn point_at_infinity_multi_vector_anti_project_via_horizon_onto(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, point_at_infinity_multi_vector_bulk_contraction(self_, other));
}

fn point_at_infinity_point_anti_project_via_horizon_onto(self_: PointAtInfinity, other: Point) -> Point {
    return point_scalar_wedge(other, point_at_infinity_point_bulk_contraction(self_, other));
}

fn point_at_infinity_point_at_infinity_anti_project_via_horizon_onto(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_scalar_wedge(other, point_at_infinity_point_at_infinity_bulk_contraction(self_, other));
}

fn rotor_flector_anti_project_via_horizon_onto(self_: Rotor, other: Flector) -> Motor {
    return flector_flector_wedge(other, rotor_flector_bulk_contraction(self_, other));
}

fn rotor_horizon_anti_project_via_horizon_onto(self_: Rotor, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(other, rotor_horizon_bulk_contraction(self_, other));
}

fn rotor_line_anti_project_via_horizon_onto(self_: Rotor, other: Line) -> AntiScalar {
    return line_line_at_origin_wedge(other, rotor_line_bulk_contraction(self_, other));
}

fn rotor_line_at_infinity_anti_project_via_horizon_onto(self_: Rotor, other: LineAtInfinity) -> AntiScalar {
    return line_at_infinity_line_at_origin_wedge(other, rotor_line_at_infinity_bulk_contraction(self_, other));
}

fn rotor_motor_anti_project_via_horizon_onto(self_: Rotor, other: Motor) -> AntiScalar {
    return motor_line_at_origin_wedge(other, rotor_motor_bulk_contraction(self_, other));
}

fn rotor_multi_vector_anti_project_via_horizon_onto(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, rotor_multi_vector_bulk_contraction(self_, other));
}

fn rotor_plane_anti_project_via_horizon_onto(self_: Rotor, other: Plane) -> AntiScalar {
    return plane_origin_wedge(other, rotor_plane_bulk_contraction(self_, other));
}

fn rotor_point_anti_project_via_horizon_onto(self_: Rotor, other: Point) -> Motor {
    return point_flector_wedge(other, rotor_point_bulk_contraction(self_, other));
}

fn rotor_point_at_infinity_anti_project_via_horizon_onto(self_: Rotor, other: PointAtInfinity) -> Motor {
    return point_at_infinity_flector_wedge(other, rotor_point_at_infinity_bulk_contraction(self_, other));
}

fn rotor_translator_anti_project_via_horizon_onto(self_: Rotor, other: Translator) -> AntiScalar {
    return translator_line_at_origin_wedge(other, rotor_translator_bulk_contraction(self_, other));
}

fn translator_flector_anti_project_via_horizon_onto(self_: Translator, other: Flector) -> Motor {
    return flector_flector_wedge(other, translator_flector_bulk_contraction(self_, other));
}

fn translator_horizon_anti_project_via_horizon_onto(self_: Translator, other: Horizon) -> AntiScalar {
    return horizon_origin_wedge(other, translator_horizon_bulk_contraction(self_, other));
}

fn translator_line_anti_project_via_horizon_onto(self_: Translator, other: Line) -> MultiVector {
    return line_multi_vector_wedge(other, translator_line_bulk_contraction(self_, other));
}

fn translator_line_at_infinity_anti_project_via_horizon_onto(self_: Translator, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_wedge(other, translator_line_at_infinity_bulk_contraction(self_, other));
}

fn translator_motor_anti_project_via_horizon_onto(self_: Translator, other: Motor) -> MultiVector {
    return motor_multi_vector_wedge(other, translator_motor_bulk_contraction(self_, other));
}

fn translator_multi_vector_anti_project_via_horizon_onto(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_wedge(other, translator_multi_vector_bulk_contraction(self_, other));
}

fn translator_plane_anti_project_via_horizon_onto(self_: Translator, other: Plane) -> AntiScalar {
    return plane_origin_wedge(other, translator_plane_bulk_contraction(self_, other));
}

fn translator_point_anti_project_via_horizon_onto(self_: Translator, other: Point) -> Motor {
    return point_flector_wedge(other, translator_point_bulk_contraction(self_, other));
}

fn translator_point_at_infinity_anti_project_via_horizon_onto(self_: Translator, other: PointAtInfinity) -> Motor {
    return point_at_infinity_flector_wedge(other, translator_point_at_infinity_bulk_contraction(self_, other));
}

fn translator_translator_anti_project_via_horizon_onto(self_: Translator, other: Translator) -> MultiVector {
    return translator_multi_vector_wedge(other, translator_translator_bulk_contraction(self_, other));
}

fn flector_flector_project_orthogonally_onto(self_: Flector, other: Flector) -> Flector {
    return flector_motor_anti_wedge(other, flector_flector_weight_expansion(self_, other));
}

fn flector_line_project_orthogonally_onto(self_: Flector, other: Line) -> Point {
    return line_plane_anti_wedge(other, flector_line_weight_expansion(self_, other));
}

fn flector_line_at_origin_project_orthogonally_onto(self_: Flector, other: LineAtOrigin) -> Point {
    return line_at_origin_plane_anti_wedge(other, flector_line_at_origin_weight_expansion(self_, other));
}

fn flector_multi_vector_project_orthogonally_onto(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, flector_multi_vector_weight_expansion(self_, other));
}

fn flector_origin_project_orthogonally_onto(self_: Flector, other: Origin) -> Origin {
    return origin_anti_scalar_anti_wedge(other, flector_origin_weight_expansion(self_, other));
}

fn flector_plane_project_orthogonally_onto(self_: Flector, other: Plane) -> Flector {
    return plane_motor_anti_wedge(other, flector_plane_weight_expansion(self_, other));
}

fn flector_plane_at_origin_project_orthogonally_onto(self_: Flector, other: PlaneAtOrigin) -> Flector {
    return plane_at_origin_motor_anti_wedge(other, flector_plane_at_origin_weight_expansion(self_, other));
}

fn flector_point_project_orthogonally_onto(self_: Flector, other: Point) -> Point {
    return point_anti_scalar_anti_wedge(other, flector_point_weight_expansion(self_, other));
}

fn flector_translator_project_orthogonally_onto(self_: Flector, other: Translator) -> Flector {
    return translator_flector_anti_wedge(other, flector_translator_weight_expansion(self_, other));
}

fn horizon_flector_project_orthogonally_onto(self_: Horizon, other: Flector) -> Flector {
    return flector_anti_scalar_anti_wedge(other, horizon_flector_weight_expansion(self_, other));
}

fn horizon_multi_vector_project_orthogonally_onto(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, horizon_multi_vector_weight_expansion(self_, other));
}

fn horizon_translator_project_orthogonally_onto(self_: Horizon, other: Translator) -> Horizon {
    return translator_horizon_anti_wedge(other, horizon_translator_weight_expansion(self_, other));
}

fn line_flector_project_orthogonally_onto(self_: Line, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, line_flector_weight_expansion(self_, other));
}

fn line_line_project_orthogonally_onto(self_: Line, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_line_weight_expansion(self_, other));
}

fn line_line_at_origin_project_orthogonally_onto(self_: Line, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, line_line_at_origin_weight_expansion(self_, other));
}

fn line_multi_vector_project_orthogonally_onto(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_multi_vector_weight_expansion(self_, other));
}

fn line_plane_project_orthogonally_onto(self_: Line, other: Plane) -> Line {
    return plane_plane_anti_wedge(other, line_plane_weight_expansion(self_, other));
}

fn line_plane_at_origin_project_orthogonally_onto(self_: Line, other: PlaneAtOrigin) -> Line {
    return plane_at_origin_plane_anti_wedge(other, line_plane_at_origin_weight_expansion(self_, other));
}

fn line_translator_project_orthogonally_onto(self_: Line, other: Translator) -> MultiVector {
    return translator_line_anti_wedge(other, line_translator_weight_expansion(self_, other));
}

fn line_at_infinity_flector_project_orthogonally_onto(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, line_at_infinity_flector_weight_expansion(self_, other));
}

fn line_at_infinity_multi_vector_project_orthogonally_onto(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_infinity_multi_vector_weight_expansion(self_, other));
}

fn line_at_infinity_plane_project_orthogonally_onto(self_: LineAtInfinity, other: Plane) -> LineAtInfinity {
    return plane_horizon_anti_wedge(other, line_at_infinity_plane_weight_expansion(self_, other));
}

fn line_at_infinity_plane_at_origin_project_orthogonally_onto(self_: LineAtInfinity, other: PlaneAtOrigin) -> LineAtInfinity {
    return plane_at_origin_horizon_anti_wedge(other, line_at_infinity_plane_at_origin_weight_expansion(self_, other));
}

fn line_at_infinity_translator_project_orthogonally_onto(self_: LineAtInfinity, other: Translator) -> LineAtInfinity {
    return translator_line_at_infinity_anti_wedge(other, line_at_infinity_translator_weight_expansion(self_, other));
}

fn line_at_origin_flector_project_orthogonally_onto(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_plane_at_origin_anti_wedge(other, line_at_origin_flector_weight_expansion(self_, other));
}

fn line_at_origin_line_project_orthogonally_onto(self_: LineAtOrigin, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_at_origin_line_weight_expansion(self_, other));
}

fn line_at_origin_line_at_origin_project_orthogonally_onto(self_: LineAtOrigin, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, line_at_origin_line_at_origin_weight_expansion(self_, other));
}

fn line_at_origin_multi_vector_project_orthogonally_onto(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_origin_multi_vector_weight_expansion(self_, other));
}

fn line_at_origin_plane_project_orthogonally_onto(self_: LineAtOrigin, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, line_at_origin_plane_weight_expansion(self_, other));
}

fn line_at_origin_plane_at_origin_project_orthogonally_onto(self_: LineAtOrigin, other: PlaneAtOrigin) -> LineAtOrigin {
    return plane_at_origin_plane_at_origin_anti_wedge(other, line_at_origin_plane_at_origin_weight_expansion(self_, other));
}

fn line_at_origin_translator_project_orthogonally_onto(self_: LineAtOrigin, other: Translator) -> MultiVector {
    return translator_line_at_origin_anti_wedge(other, line_at_origin_translator_weight_expansion(self_, other));
}

fn motor_flector_project_orthogonally_onto(self_: Motor, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, motor_flector_weight_expansion(self_, other));
}

fn motor_line_project_orthogonally_onto(self_: Motor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, motor_line_weight_expansion(self_, other));
}

fn motor_line_at_origin_project_orthogonally_onto(self_: Motor, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, motor_line_at_origin_weight_expansion(self_, other));
}

fn motor_multi_vector_project_orthogonally_onto(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, motor_multi_vector_weight_expansion(self_, other));
}

fn motor_plane_project_orthogonally_onto(self_: Motor, other: Plane) -> Line {
    return plane_plane_anti_wedge(other, motor_plane_weight_expansion(self_, other));
}

fn motor_plane_at_origin_project_orthogonally_onto(self_: Motor, other: PlaneAtOrigin) -> Line {
    return plane_at_origin_plane_anti_wedge(other, motor_plane_at_origin_weight_expansion(self_, other));
}

fn motor_translator_project_orthogonally_onto(self_: Motor, other: Translator) -> MultiVector {
    return translator_motor_anti_wedge(other, motor_translator_weight_expansion(self_, other));
}

fn multi_vector_flector_project_orthogonally_onto(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, multi_vector_flector_weight_expansion(self_, other));
}

fn multi_vector_line_project_orthogonally_onto(self_: MultiVector, other: Line) -> MultiVector {
    return line_multi_vector_anti_wedge(other, multi_vector_line_weight_expansion(self_, other));
}

fn multi_vector_line_at_origin_project_orthogonally_onto(self_: MultiVector, other: LineAtOrigin) -> MultiVector {
    return line_at_origin_multi_vector_anti_wedge(other, multi_vector_line_at_origin_weight_expansion(self_, other));
}

fn multi_vector_multi_vector_project_orthogonally_onto(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, multi_vector_multi_vector_weight_expansion(self_, other));
}

fn multi_vector_origin_project_orthogonally_onto(self_: MultiVector, other: Origin) -> MultiVector {
    return origin_multi_vector_anti_wedge(other, multi_vector_origin_weight_expansion(self_, other));
}

fn multi_vector_plane_project_orthogonally_onto(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_multi_vector_anti_wedge(other, multi_vector_plane_weight_expansion(self_, other));
}

fn multi_vector_plane_at_origin_project_orthogonally_onto(self_: MultiVector, other: PlaneAtOrigin) -> MultiVector {
    return plane_at_origin_multi_vector_anti_wedge(other, multi_vector_plane_at_origin_weight_expansion(self_, other));
}

fn multi_vector_point_project_orthogonally_onto(self_: MultiVector, other: Point) -> MultiVector {
    return point_multi_vector_anti_wedge(other, multi_vector_point_weight_expansion(self_, other));
}

fn multi_vector_translator_project_orthogonally_onto(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_multi_vector_anti_wedge(other, multi_vector_translator_weight_expansion(self_, other));
}

fn origin_flector_project_orthogonally_onto(self_: Origin, other: Flector) -> Flector {
    return flector_rotor_anti_wedge(other, origin_flector_weight_expansion(self_, other));
}

fn origin_line_project_orthogonally_onto(self_: Origin, other: Line) -> Point {
    return line_plane_at_origin_anti_wedge(other, origin_line_weight_expansion(self_, other));
}

fn origin_line_at_origin_project_orthogonally_onto(self_: Origin, other: LineAtOrigin) -> Origin {
    return line_at_origin_plane_at_origin_anti_wedge(other, origin_line_at_origin_weight_expansion(self_, other));
}

fn origin_multi_vector_project_orthogonally_onto(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, origin_multi_vector_weight_expansion(self_, other));
}

fn origin_origin_project_orthogonally_onto(self_: Origin, other: Origin) -> Origin {
    return origin_anti_scalar_anti_wedge(other, origin_origin_weight_expansion(self_, other));
}

fn origin_plane_project_orthogonally_onto(self_: Origin, other: Plane) -> Point {
    return plane_line_at_origin_anti_wedge(other, origin_plane_weight_expansion(self_, other));
}

fn origin_plane_at_origin_project_orthogonally_onto(self_: Origin, other: PlaneAtOrigin) -> Origin {
    return plane_at_origin_line_at_origin_anti_wedge(other, origin_plane_at_origin_weight_expansion(self_, other));
}

fn origin_point_project_orthogonally_onto(self_: Origin, other: Point) -> Point {
    return point_anti_scalar_anti_wedge(other, origin_point_weight_expansion(self_, other));
}

fn origin_translator_project_orthogonally_onto(self_: Origin, other: Translator) -> Origin {
    return translator_origin_anti_wedge(other, origin_translator_weight_expansion(self_, other));
}

fn plane_flector_project_orthogonally_onto(self_: Plane, other: Flector) -> Flector {
    return flector_anti_scalar_anti_wedge(other, plane_flector_weight_expansion(self_, other));
}

fn plane_multi_vector_project_orthogonally_onto(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_multi_vector_weight_expansion(self_, other));
}

fn plane_plane_project_orthogonally_onto(self_: Plane, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, plane_plane_weight_expansion(self_, other));
}

fn plane_plane_at_origin_project_orthogonally_onto(self_: Plane, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_anti_wedge(other, plane_plane_at_origin_weight_expansion(self_, other));
}

fn plane_translator_project_orthogonally_onto(self_: Plane, other: Translator) -> Flector {
    return translator_plane_anti_wedge(other, plane_translator_weight_expansion(self_, other));
}

fn plane_at_origin_flector_project_orthogonally_onto(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return flector_anti_scalar_anti_wedge(other, plane_at_origin_flector_weight_expansion(self_, other));
}

fn plane_at_origin_multi_vector_project_orthogonally_onto(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_at_origin_multi_vector_weight_expansion(self_, other));
}

fn plane_at_origin_plane_project_orthogonally_onto(self_: PlaneAtOrigin, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, plane_at_origin_plane_weight_expansion(self_, other));
}

fn plane_at_origin_plane_at_origin_project_orthogonally_onto(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> PlaneAtOrigin {
    return plane_at_origin_anti_scalar_anti_wedge(other, plane_at_origin_plane_at_origin_weight_expansion(self_, other));
}

fn plane_at_origin_translator_project_orthogonally_onto(self_: PlaneAtOrigin, other: Translator) -> Flector {
    return translator_plane_at_origin_anti_wedge(other, plane_at_origin_translator_weight_expansion(self_, other));
}

fn point_flector_project_orthogonally_onto(self_: Point, other: Flector) -> Flector {
    return flector_motor_anti_wedge(other, point_flector_weight_expansion(self_, other));
}

fn point_line_project_orthogonally_onto(self_: Point, other: Line) -> Point {
    return line_plane_anti_wedge(other, point_line_weight_expansion(self_, other));
}

fn point_line_at_origin_project_orthogonally_onto(self_: Point, other: LineAtOrigin) -> Point {
    return line_at_origin_plane_anti_wedge(other, point_line_at_origin_weight_expansion(self_, other));
}

fn point_multi_vector_project_orthogonally_onto(self_: Point, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_multi_vector_weight_expansion(self_, other));
}

fn point_origin_project_orthogonally_onto(self_: Point, other: Origin) -> Origin {
    return origin_anti_scalar_anti_wedge(other, point_origin_weight_expansion(self_, other));
}

fn point_plane_project_orthogonally_onto(self_: Point, other: Plane) -> Point {
    return plane_line_anti_wedge(other, point_plane_weight_expansion(self_, other));
}

fn point_plane_at_origin_project_orthogonally_onto(self_: Point, other: PlaneAtOrigin) -> Point {
    return plane_at_origin_line_anti_wedge(other, point_plane_at_origin_weight_expansion(self_, other));
}

fn point_point_project_orthogonally_onto(self_: Point, other: Point) -> Point {
    return point_anti_scalar_anti_wedge(other, point_point_weight_expansion(self_, other));
}

fn point_translator_project_orthogonally_onto(self_: Point, other: Translator) -> Point {
    return translator_point_anti_wedge(other, point_translator_weight_expansion(self_, other));
}

fn point_at_infinity_flector_project_orthogonally_onto(self_: PointAtInfinity, other: Flector) -> Flector {
    return flector_motor_anti_wedge(other, point_at_infinity_flector_weight_expansion(self_, other));
}

fn point_at_infinity_line_project_orthogonally_onto(self_: PointAtInfinity, other: Line) -> PointAtInfinity {
    return line_horizon_anti_wedge(other, point_at_infinity_line_weight_expansion(self_, other));
}

fn point_at_infinity_line_at_origin_project_orthogonally_onto(self_: PointAtInfinity, other: LineAtOrigin) -> PointAtInfinity {
    return line_at_origin_horizon_anti_wedge(other, point_at_infinity_line_at_origin_weight_expansion(self_, other));
}

fn point_at_infinity_multi_vector_project_orthogonally_onto(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_at_infinity_multi_vector_weight_expansion(self_, other));
}

fn point_at_infinity_plane_project_orthogonally_onto(self_: PointAtInfinity, other: Plane) -> PointAtInfinity {
    return plane_line_at_infinity_anti_wedge(other, point_at_infinity_plane_weight_expansion(self_, other));
}

fn point_at_infinity_plane_at_origin_project_orthogonally_onto(self_: PointAtInfinity, other: PlaneAtOrigin) -> PointAtInfinity {
    return plane_at_origin_line_at_infinity_anti_wedge(other, point_at_infinity_plane_at_origin_weight_expansion(self_, other));
}

fn point_at_infinity_translator_project_orthogonally_onto(self_: PointAtInfinity, other: Translator) -> PointAtInfinity {
    return translator_point_at_infinity_anti_wedge(other, point_at_infinity_translator_weight_expansion(self_, other));
}

fn rotor_flector_project_orthogonally_onto(self_: Rotor, other: Flector) -> MultiVector {
    return flector_plane_at_origin_anti_wedge(other, rotor_flector_weight_expansion(self_, other));
}

fn rotor_line_project_orthogonally_onto(self_: Rotor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, rotor_line_weight_expansion(self_, other));
}

fn rotor_line_at_origin_project_orthogonally_onto(self_: Rotor, other: LineAtOrigin) -> LineAtOrigin {
    return line_at_origin_anti_scalar_anti_wedge(other, rotor_line_at_origin_weight_expansion(self_, other));
}

fn rotor_multi_vector_project_orthogonally_onto(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, rotor_multi_vector_weight_expansion(self_, other));
}

fn rotor_plane_project_orthogonally_onto(self_: Rotor, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, rotor_plane_weight_expansion(self_, other));
}

fn rotor_plane_at_origin_project_orthogonally_onto(self_: Rotor, other: PlaneAtOrigin) -> LineAtOrigin {
    return plane_at_origin_plane_at_origin_anti_wedge(other, rotor_plane_at_origin_weight_expansion(self_, other));
}

fn rotor_translator_project_orthogonally_onto(self_: Rotor, other: Translator) -> MultiVector {
    return translator_rotor_anti_wedge(other, rotor_translator_weight_expansion(self_, other));
}

fn translator_flector_project_orthogonally_onto(self_: Translator, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, translator_flector_weight_expansion(self_, other));
}

fn translator_multi_vector_project_orthogonally_onto(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, translator_multi_vector_weight_expansion(self_, other));
}

fn translator_plane_project_orthogonally_onto(self_: Translator, other: Plane) -> LineAtInfinity {
    return plane_horizon_anti_wedge(other, translator_plane_weight_expansion(self_, other));
}

fn translator_plane_at_origin_project_orthogonally_onto(self_: Translator, other: PlaneAtOrigin) -> LineAtInfinity {
    return plane_at_origin_horizon_anti_wedge(other, translator_plane_at_origin_weight_expansion(self_, other));
}

fn translator_translator_project_orthogonally_onto(self_: Translator, other: Translator) -> Translator {
    return translator_translator_anti_wedge(other, translator_translator_weight_expansion(self_, other));
}

fn flector_flector_project_via_origin_onto(self_: Flector, other: Flector) -> Flector {
    return flector_motor_anti_wedge(other, flector_flector_bulk_expansion(self_, other));
}

fn flector_horizon_project_via_origin_onto(self_: Flector, other: Horizon) -> Flector {
    return horizon_rotor_anti_wedge(other, flector_horizon_bulk_expansion(self_, other));
}

fn flector_line_project_via_origin_onto(self_: Flector, other: Line) -> Point {
    return line_plane_at_origin_anti_wedge(other, flector_line_bulk_expansion(self_, other));
}

fn flector_line_at_infinity_project_via_origin_onto(self_: Flector, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_at_origin_anti_wedge(other, flector_line_at_infinity_bulk_expansion(self_, other));
}

fn flector_motor_project_via_origin_onto(self_: Flector, other: Motor) -> Flector {
    return motor_plane_at_origin_anti_wedge(other, flector_motor_bulk_expansion(self_, other));
}

fn flector_multi_vector_project_via_origin_onto(self_: Flector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, flector_multi_vector_bulk_expansion(self_, other));
}

fn flector_plane_project_via_origin_onto(self_: Flector, other: Plane) -> Flector {
    return plane_rotor_anti_wedge(other, flector_plane_bulk_expansion(self_, other));
}

fn flector_point_project_via_origin_onto(self_: Flector, other: Point) -> Point {
    return point_anti_scalar_anti_wedge(other, flector_point_bulk_expansion(self_, other));
}

fn flector_point_at_infinity_project_via_origin_onto(self_: Flector, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, flector_point_at_infinity_bulk_expansion(self_, other));
}

fn flector_translator_project_via_origin_onto(self_: Flector, other: Translator) -> Flector {
    return translator_plane_at_origin_anti_wedge(other, flector_translator_bulk_expansion(self_, other));
}

fn horizon_flector_project_via_origin_onto(self_: Horizon, other: Flector) -> Flector {
    return flector_anti_scalar_anti_wedge(other, horizon_flector_bulk_expansion(self_, other));
}

fn horizon_horizon_project_via_origin_onto(self_: Horizon, other: Horizon) -> Horizon {
    return horizon_anti_scalar_anti_wedge(other, horizon_horizon_bulk_expansion(self_, other));
}

fn horizon_multi_vector_project_via_origin_onto(self_: Horizon, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, horizon_multi_vector_bulk_expansion(self_, other));
}

fn horizon_plane_project_via_origin_onto(self_: Horizon, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, horizon_plane_bulk_expansion(self_, other));
}

fn line_flector_project_via_origin_onto(self_: Line, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, line_flector_bulk_expansion(self_, other));
}

fn line_horizon_project_via_origin_onto(self_: Line, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, line_horizon_bulk_expansion(self_, other));
}

fn line_line_project_via_origin_onto(self_: Line, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_line_bulk_expansion(self_, other));
}

fn line_line_at_infinity_project_via_origin_onto(self_: Line, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, line_line_at_infinity_bulk_expansion(self_, other));
}

fn line_motor_project_via_origin_onto(self_: Line, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, line_motor_bulk_expansion(self_, other));
}

fn line_multi_vector_project_via_origin_onto(self_: Line, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_multi_vector_bulk_expansion(self_, other));
}

fn line_plane_project_via_origin_onto(self_: Line, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, line_plane_bulk_expansion(self_, other));
}

fn line_translator_project_via_origin_onto(self_: Line, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, line_translator_bulk_expansion(self_, other));
}

fn line_at_infinity_flector_project_via_origin_onto(self_: LineAtInfinity, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, line_at_infinity_flector_bulk_expansion(self_, other));
}

fn line_at_infinity_horizon_project_via_origin_onto(self_: LineAtInfinity, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, line_at_infinity_horizon_bulk_expansion(self_, other));
}

fn line_at_infinity_line_project_via_origin_onto(self_: LineAtInfinity, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, line_at_infinity_line_bulk_expansion(self_, other));
}

fn line_at_infinity_line_at_infinity_project_via_origin_onto(self_: LineAtInfinity, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, line_at_infinity_line_at_infinity_bulk_expansion(self_, other));
}

fn line_at_infinity_motor_project_via_origin_onto(self_: LineAtInfinity, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, line_at_infinity_motor_bulk_expansion(self_, other));
}

fn line_at_infinity_multi_vector_project_via_origin_onto(self_: LineAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_infinity_multi_vector_bulk_expansion(self_, other));
}

fn line_at_infinity_plane_project_via_origin_onto(self_: LineAtInfinity, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, line_at_infinity_plane_bulk_expansion(self_, other));
}

fn line_at_infinity_translator_project_via_origin_onto(self_: LineAtInfinity, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, line_at_infinity_translator_bulk_expansion(self_, other));
}

fn line_at_origin_flector_project_via_origin_onto(self_: LineAtOrigin, other: Flector) -> MultiVector {
    return flector_plane_at_origin_anti_wedge(other, line_at_origin_flector_bulk_expansion(self_, other));
}

fn line_at_origin_multi_vector_project_via_origin_onto(self_: LineAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, line_at_origin_multi_vector_bulk_expansion(self_, other));
}

fn motor_flector_project_via_origin_onto(self_: Motor, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, motor_flector_bulk_expansion(self_, other));
}

fn motor_horizon_project_via_origin_onto(self_: Motor, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, motor_horizon_bulk_expansion(self_, other));
}

fn motor_line_project_via_origin_onto(self_: Motor, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, motor_line_bulk_expansion(self_, other));
}

fn motor_line_at_infinity_project_via_origin_onto(self_: Motor, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, motor_line_at_infinity_bulk_expansion(self_, other));
}

fn motor_motor_project_via_origin_onto(self_: Motor, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, motor_motor_bulk_expansion(self_, other));
}

fn motor_multi_vector_project_via_origin_onto(self_: Motor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, motor_multi_vector_bulk_expansion(self_, other));
}

fn motor_plane_project_via_origin_onto(self_: Motor, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, motor_plane_bulk_expansion(self_, other));
}

fn motor_translator_project_via_origin_onto(self_: Motor, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, motor_translator_bulk_expansion(self_, other));
}

fn multi_vector_flector_project_via_origin_onto(self_: MultiVector, other: Flector) -> MultiVector {
    return flector_multi_vector_anti_wedge(other, multi_vector_flector_bulk_expansion(self_, other));
}

fn multi_vector_horizon_project_via_origin_onto(self_: MultiVector, other: Horizon) -> MultiVector {
    return horizon_multi_vector_anti_wedge(other, multi_vector_horizon_bulk_expansion(self_, other));
}

fn multi_vector_line_project_via_origin_onto(self_: MultiVector, other: Line) -> MultiVector {
    return line_multi_vector_anti_wedge(other, multi_vector_line_bulk_expansion(self_, other));
}

fn multi_vector_line_at_infinity_project_via_origin_onto(self_: MultiVector, other: LineAtInfinity) -> MultiVector {
    return line_at_infinity_multi_vector_anti_wedge(other, multi_vector_line_at_infinity_bulk_expansion(self_, other));
}

fn multi_vector_motor_project_via_origin_onto(self_: MultiVector, other: Motor) -> MultiVector {
    return motor_multi_vector_anti_wedge(other, multi_vector_motor_bulk_expansion(self_, other));
}

fn multi_vector_multi_vector_project_via_origin_onto(self_: MultiVector, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, multi_vector_multi_vector_bulk_expansion(self_, other));
}

fn multi_vector_plane_project_via_origin_onto(self_: MultiVector, other: Plane) -> MultiVector {
    return plane_multi_vector_anti_wedge(other, multi_vector_plane_bulk_expansion(self_, other));
}

fn multi_vector_point_project_via_origin_onto(self_: MultiVector, other: Point) -> MultiVector {
    return point_multi_vector_anti_wedge(other, multi_vector_point_bulk_expansion(self_, other));
}

fn multi_vector_point_at_infinity_project_via_origin_onto(self_: MultiVector, other: PointAtInfinity) -> MultiVector {
    return point_at_infinity_multi_vector_anti_wedge(other, multi_vector_point_at_infinity_bulk_expansion(self_, other));
}

fn multi_vector_translator_project_via_origin_onto(self_: MultiVector, other: Translator) -> MultiVector {
    return translator_multi_vector_anti_wedge(other, multi_vector_translator_bulk_expansion(self_, other));
}

fn origin_flector_project_via_origin_onto(self_: Origin, other: Flector) -> Flector {
    return flector_rotor_anti_wedge(other, origin_flector_bulk_expansion(self_, other));
}

fn origin_multi_vector_project_via_origin_onto(self_: Origin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, origin_multi_vector_bulk_expansion(self_, other));
}

fn plane_flector_project_via_origin_onto(self_: Plane, other: Flector) -> Flector {
    return flector_anti_scalar_anti_wedge(other, plane_flector_bulk_expansion(self_, other));
}

fn plane_horizon_project_via_origin_onto(self_: Plane, other: Horizon) -> Horizon {
    return horizon_anti_scalar_anti_wedge(other, plane_horizon_bulk_expansion(self_, other));
}

fn plane_multi_vector_project_via_origin_onto(self_: Plane, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_multi_vector_bulk_expansion(self_, other));
}

fn plane_plane_project_via_origin_onto(self_: Plane, other: Plane) -> Plane {
    return plane_anti_scalar_anti_wedge(other, plane_plane_bulk_expansion(self_, other));
}

fn plane_at_origin_flector_project_via_origin_onto(self_: PlaneAtOrigin, other: Flector) -> Flector {
    return flector_anti_scalar_anti_wedge(other, plane_at_origin_flector_bulk_expansion(self_, other));
}

fn plane_at_origin_multi_vector_project_via_origin_onto(self_: PlaneAtOrigin, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, plane_at_origin_multi_vector_bulk_expansion(self_, other));
}

fn point_flector_project_via_origin_onto(self_: Point, other: Flector) -> Flector {
    return flector_motor_anti_wedge(other, point_flector_bulk_expansion(self_, other));
}

fn point_horizon_project_via_origin_onto(self_: Point, other: Horizon) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(other, point_horizon_bulk_expansion(self_, other));
}

fn point_line_project_via_origin_onto(self_: Point, other: Line) -> Point {
    return line_plane_at_origin_anti_wedge(other, point_line_bulk_expansion(self_, other));
}

fn point_line_at_infinity_project_via_origin_onto(self_: Point, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_at_origin_anti_wedge(other, point_line_at_infinity_bulk_expansion(self_, other));
}

fn point_motor_project_via_origin_onto(self_: Point, other: Motor) -> Flector {
    return motor_plane_at_origin_anti_wedge(other, point_motor_bulk_expansion(self_, other));
}

fn point_multi_vector_project_via_origin_onto(self_: Point, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_multi_vector_bulk_expansion(self_, other));
}

fn point_plane_project_via_origin_onto(self_: Point, other: Plane) -> Point {
    return plane_line_at_origin_anti_wedge(other, point_plane_bulk_expansion(self_, other));
}

fn point_point_project_via_origin_onto(self_: Point, other: Point) -> Point {
    return point_anti_scalar_anti_wedge(other, point_point_bulk_expansion(self_, other));
}

fn point_point_at_infinity_project_via_origin_onto(self_: Point, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, point_point_at_infinity_bulk_expansion(self_, other));
}

fn point_translator_project_via_origin_onto(self_: Point, other: Translator) -> Flector {
    return translator_plane_at_origin_anti_wedge(other, point_translator_bulk_expansion(self_, other));
}

fn point_at_infinity_flector_project_via_origin_onto(self_: PointAtInfinity, other: Flector) -> Flector {
    return flector_motor_anti_wedge(other, point_at_infinity_flector_bulk_expansion(self_, other));
}

fn point_at_infinity_horizon_project_via_origin_onto(self_: PointAtInfinity, other: Horizon) -> PointAtInfinity {
    return horizon_line_at_origin_anti_wedge(other, point_at_infinity_horizon_bulk_expansion(self_, other));
}

fn point_at_infinity_line_project_via_origin_onto(self_: PointAtInfinity, other: Line) -> Point {
    return line_plane_at_origin_anti_wedge(other, point_at_infinity_line_bulk_expansion(self_, other));
}

fn point_at_infinity_line_at_infinity_project_via_origin_onto(self_: PointAtInfinity, other: LineAtInfinity) -> PointAtInfinity {
    return line_at_infinity_plane_at_origin_anti_wedge(other, point_at_infinity_line_at_infinity_bulk_expansion(self_, other));
}

fn point_at_infinity_motor_project_via_origin_onto(self_: PointAtInfinity, other: Motor) -> Flector {
    return motor_plane_at_origin_anti_wedge(other, point_at_infinity_motor_bulk_expansion(self_, other));
}

fn point_at_infinity_multi_vector_project_via_origin_onto(self_: PointAtInfinity, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, point_at_infinity_multi_vector_bulk_expansion(self_, other));
}

fn point_at_infinity_plane_project_via_origin_onto(self_: PointAtInfinity, other: Plane) -> Point {
    return plane_line_at_origin_anti_wedge(other, point_at_infinity_plane_bulk_expansion(self_, other));
}

fn point_at_infinity_point_project_via_origin_onto(self_: PointAtInfinity, other: Point) -> Point {
    return point_anti_scalar_anti_wedge(other, point_at_infinity_point_bulk_expansion(self_, other));
}

fn point_at_infinity_point_at_infinity_project_via_origin_onto(self_: PointAtInfinity, other: PointAtInfinity) -> PointAtInfinity {
    return point_at_infinity_anti_scalar_anti_wedge(other, point_at_infinity_point_at_infinity_bulk_expansion(self_, other));
}

fn point_at_infinity_translator_project_via_origin_onto(self_: PointAtInfinity, other: Translator) -> Flector {
    return translator_plane_at_origin_anti_wedge(other, point_at_infinity_translator_bulk_expansion(self_, other));
}

fn rotor_flector_project_via_origin_onto(self_: Rotor, other: Flector) -> MultiVector {
    return flector_plane_at_origin_anti_wedge(other, rotor_flector_bulk_expansion(self_, other));
}

fn rotor_multi_vector_project_via_origin_onto(self_: Rotor, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, rotor_multi_vector_bulk_expansion(self_, other));
}

fn translator_flector_project_via_origin_onto(self_: Translator, other: Flector) -> MultiVector {
    return flector_plane_anti_wedge(other, translator_flector_bulk_expansion(self_, other));
}

fn translator_horizon_project_via_origin_onto(self_: Translator, other: Horizon) -> LineAtInfinity {
    return horizon_plane_at_origin_anti_wedge(other, translator_horizon_bulk_expansion(self_, other));
}

fn translator_line_project_via_origin_onto(self_: Translator, other: Line) -> Line {
    return line_anti_scalar_anti_wedge(other, translator_line_bulk_expansion(self_, other));
}

fn translator_line_at_infinity_project_via_origin_onto(self_: Translator, other: LineAtInfinity) -> LineAtInfinity {
    return line_at_infinity_anti_scalar_anti_wedge(other, translator_line_at_infinity_bulk_expansion(self_, other));
}

fn translator_motor_project_via_origin_onto(self_: Translator, other: Motor) -> Motor {
    return motor_anti_scalar_anti_wedge(other, translator_motor_bulk_expansion(self_, other));
}

fn translator_multi_vector_project_via_origin_onto(self_: Translator, other: MultiVector) -> MultiVector {
    return multi_vector_multi_vector_anti_wedge(other, translator_multi_vector_bulk_expansion(self_, other));
}

fn translator_plane_project_via_origin_onto(self_: Translator, other: Plane) -> Line {
    return plane_plane_at_origin_anti_wedge(other, translator_plane_bulk_expansion(self_, other));
}

fn translator_translator_project_via_origin_onto(self_: Translator, other: Translator) -> Translator {
    return translator_anti_scalar_anti_wedge(other, translator_translator_bulk_expansion(self_, other));
}

fn line_line_cosine_angle(self_: Line, other: Line) -> Scalar {
    return scalar_bulk_norm(line_line_weight_contraction(line_unitize(self_), line_unitize(other)));
}

fn line_line_at_origin_cosine_angle(self_: Line, other: LineAtOrigin) -> Scalar {
    return scalar_bulk_norm(line_line_at_origin_weight_contraction(line_unitize(self_), line_at_origin_unitize(other)));
}

fn line_origin_cosine_angle(self_: Line, other: Origin) -> Scalar {
    return point_at_infinity_bulk_norm(line_origin_weight_contraction(line_unitize(self_), origin_unitize(other)));
}

fn line_point_cosine_angle(self_: Line, other: Point) -> Scalar {
    return point_at_infinity_bulk_norm(line_point_weight_contraction(line_unitize(self_), point_unitize(other)));
}

fn line_at_origin_line_cosine_angle(self_: LineAtOrigin, other: Line) -> Scalar {
    return scalar_bulk_norm(line_at_origin_line_weight_contraction(line_at_origin_unitize(self_), line_unitize(other)));
}

fn line_at_origin_line_at_origin_cosine_angle(self_: LineAtOrigin, other: LineAtOrigin) -> Scalar {
    return scalar_bulk_norm(line_at_origin_line_at_origin_weight_contraction(line_at_origin_unitize(self_), line_at_origin_unitize(other)));
}

fn line_at_origin_origin_cosine_angle(self_: LineAtOrigin, other: Origin) -> Scalar {
    return point_at_infinity_bulk_norm(line_at_origin_origin_weight_contraction(line_at_origin_unitize(self_), origin_unitize(other)));
}

fn line_at_origin_point_cosine_angle(self_: LineAtOrigin, other: Point) -> Scalar {
    return point_at_infinity_bulk_norm(line_at_origin_point_weight_contraction(line_at_origin_unitize(self_), point_unitize(other)));
}

fn origin_origin_cosine_angle(self_: Origin, other: Origin) -> Scalar {
    return scalar_bulk_norm(origin_origin_weight_contraction(origin_unitize(self_), origin_unitize(other)));
}

fn origin_point_cosine_angle(self_: Origin, other: Point) -> Scalar {
    return scalar_bulk_norm(origin_point_weight_contraction(origin_unitize(self_), point_unitize(other)));
}

fn plane_line_cosine_angle(self_: Plane, other: Line) -> Scalar {
    return point_at_infinity_bulk_norm(plane_line_weight_contraction(plane_unitize(self_), line_unitize(other)));
}

fn plane_line_at_origin_cosine_angle(self_: Plane, other: LineAtOrigin) -> Scalar {
    return point_at_infinity_bulk_norm(plane_line_at_origin_weight_contraction(plane_unitize(self_), line_at_origin_unitize(other)));
}

fn plane_origin_cosine_angle(self_: Plane, other: Origin) -> Scalar {
    return line_at_infinity_bulk_norm(plane_origin_weight_contraction(plane_unitize(self_), origin_unitize(other)));
}

fn plane_plane_cosine_angle(self_: Plane, other: Plane) -> Scalar {
    return scalar_bulk_norm(plane_plane_weight_contraction(plane_unitize(self_), plane_unitize(other)));
}

fn plane_plane_at_origin_cosine_angle(self_: Plane, other: PlaneAtOrigin) -> Scalar {
    return scalar_bulk_norm(plane_plane_at_origin_weight_contraction(plane_unitize(self_), plane_at_origin_unitize(other)));
}

fn plane_point_cosine_angle(self_: Plane, other: Point) -> Scalar {
    return line_at_infinity_bulk_norm(plane_point_weight_contraction(plane_unitize(self_), point_unitize(other)));
}

fn plane_at_origin_line_cosine_angle(self_: PlaneAtOrigin, other: Line) -> Scalar {
    return point_at_infinity_bulk_norm(plane_at_origin_line_weight_contraction(plane_at_origin_unitize(self_), line_unitize(other)));
}

fn plane_at_origin_line_at_origin_cosine_angle(self_: PlaneAtOrigin, other: LineAtOrigin) -> Scalar {
    return point_at_infinity_bulk_norm(plane_at_origin_line_at_origin_weight_contraction(plane_at_origin_unitize(self_), line_at_origin_unitize(other)));
}

fn plane_at_origin_origin_cosine_angle(self_: PlaneAtOrigin, other: Origin) -> Scalar {
    return line_at_infinity_bulk_norm(plane_at_origin_origin_weight_contraction(plane_at_origin_unitize(self_), origin_unitize(other)));
}

fn plane_at_origin_plane_cosine_angle(self_: PlaneAtOrigin, other: Plane) -> Scalar {
    return scalar_bulk_norm(plane_at_origin_plane_weight_contraction(plane_at_origin_unitize(self_), plane_unitize(other)));
}

fn plane_at_origin_plane_at_origin_cosine_angle(self_: PlaneAtOrigin, other: PlaneAtOrigin) -> Scalar {
    return scalar_bulk_norm(plane_at_origin_plane_at_origin_weight_contraction(plane_at_origin_unitize(self_), plane_at_origin_unitize(other)));
}

fn plane_at_origin_point_cosine_angle(self_: PlaneAtOrigin, other: Point) -> Scalar {
    return line_at_infinity_bulk_norm(plane_at_origin_point_weight_contraction(plane_at_origin_unitize(self_), point_unitize(other)));
}

fn point_origin_cosine_angle(self_: Point, other: Origin) -> Scalar {
    return scalar_bulk_norm(point_origin_weight_contraction(point_unitize(self_), origin_unitize(other)));
}

fn point_point_cosine_angle(self_: Point, other: Point) -> Scalar {
    return scalar_bulk_norm(point_point_weight_contraction(point_unitize(self_), point_unitize(other)));
}

fn anti_scalar_multi_vector_distance(self_: AntiScalar, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(anti_scalar_multi_vector_wedge(self_, other))), anti_scalar_weight_norm(anti_scalar_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn flector_flector_distance(self_: Flector, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(flector_flector_wedge(self_, other))), multi_vector_weight_norm(flector_multi_vector_wedge(self_, flector_attitude(other))));
}

fn flector_line_distance(self_: Flector, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(flector_line_wedge(self_, other))), motor_weight_norm(flector_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn flector_line_at_origin_distance(self_: Flector, other: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(flector_line_at_origin_wedge(self_, other))), motor_weight_norm(flector_point_at_infinity_wedge(self_, line_at_origin_attitude(other))));
}

fn flector_magnitude_distance(self_: Flector, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(flector_attitude(flector_magnitude_wedge(self_, other))), anti_scalar_weight_norm(flector_horizon_wedge(self_, magnitude_attitude(other))));
}

fn flector_motor_distance(self_: Flector, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(flector_motor_wedge(self_, other))), motor_weight_norm(flector_flector_wedge(self_, motor_attitude(other))));
}

fn flector_multi_vector_distance(self_: Flector, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(flector_multi_vector_wedge(self_, other))), multi_vector_weight_norm(flector_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn flector_origin_distance(self_: Flector, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(flector_origin_wedge(self_, other))), flector_weight_norm(flector_scalar_wedge(self_, origin_attitude(other))));
}

fn flector_plane_distance(self_: Flector, other: Plane) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(flector_plane_wedge(self_, other))), plane_weight_norm(flector_line_at_infinity_wedge(self_, plane_attitude(other))));
}

fn flector_plane_at_origin_distance(self_: Flector, other: PlaneAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(flector_plane_at_origin_wedge(self_, other))), plane_weight_norm(flector_line_at_infinity_wedge(self_, plane_at_origin_attitude(other))));
}

fn flector_point_distance(self_: Flector, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(flector_point_wedge(self_, other))), flector_weight_norm(flector_scalar_wedge(self_, point_attitude(other))));
}

fn flector_rotor_distance(self_: Flector, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(flector_rotor_wedge(self_, other))), motor_weight_norm(flector_flector_wedge(self_, rotor_attitude(other))));
}

fn flector_translator_distance(self_: Flector, other: Translator) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(flector_translator_wedge(self_, other))), anti_scalar_weight_norm(flector_horizon_wedge(self_, translator_attitude(other))));
}

fn horizon_flector_distance(self_: Horizon, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(horizon_flector_wedge(self_, other))), multi_vector_weight_norm(horizon_multi_vector_wedge(self_, flector_attitude(other))));
}

fn horizon_multi_vector_distance(self_: Horizon, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(horizon_multi_vector_wedge(self_, other))), multi_vector_weight_norm(horizon_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_flector_distance(self_: Line, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(line_flector_wedge(self_, other))), multi_vector_weight_norm(line_multi_vector_wedge(self_, flector_attitude(other))));
}

fn line_line_distance(self_: Line, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_line_wedge(self_, other))), plane_weight_norm(line_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn line_line_at_origin_distance(self_: Line, other: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_line_at_origin_wedge(self_, other))), plane_weight_norm(line_point_at_infinity_wedge(self_, line_at_origin_attitude(other))));
}

fn line_motor_distance(self_: Line, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_motor_wedge(self_, other))), plane_weight_norm(line_flector_wedge(self_, motor_attitude(other))));
}

fn line_multi_vector_distance(self_: Line, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(line_multi_vector_wedge(self_, other))), multi_vector_weight_norm(line_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_origin_distance(self_: Line, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(line_origin_wedge(self_, other))), line_weight_norm(line_scalar_wedge(self_, origin_attitude(other))));
}

fn line_point_distance(self_: Line, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(line_point_wedge(self_, other))), line_weight_norm(line_scalar_wedge(self_, point_attitude(other))));
}

fn line_rotor_distance(self_: Line, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_rotor_wedge(self_, other))), plane_weight_norm(line_flector_wedge(self_, rotor_attitude(other))));
}

fn line_at_infinity_flector_distance(self_: LineAtInfinity, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(line_at_infinity_flector_wedge(self_, other))), multi_vector_weight_norm(line_at_infinity_multi_vector_wedge(self_, flector_attitude(other))));
}

fn line_at_infinity_motor_distance(self_: LineAtInfinity, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_at_infinity_motor_wedge(self_, other))), plane_weight_norm(line_at_infinity_flector_wedge(self_, motor_attitude(other))));
}

fn line_at_infinity_multi_vector_distance(self_: LineAtInfinity, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(line_at_infinity_multi_vector_wedge(self_, other))), multi_vector_weight_norm(line_at_infinity_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_at_infinity_rotor_distance(self_: LineAtInfinity, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_at_infinity_rotor_wedge(self_, other))), plane_weight_norm(line_at_infinity_flector_wedge(self_, rotor_attitude(other))));
}

fn line_at_origin_flector_distance(self_: LineAtOrigin, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(line_at_origin_flector_wedge(self_, other))), multi_vector_weight_norm(line_at_origin_multi_vector_wedge(self_, flector_attitude(other))));
}

fn line_at_origin_line_distance(self_: LineAtOrigin, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_at_origin_line_wedge(self_, other))), plane_at_origin_weight_norm(line_at_origin_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn line_at_origin_motor_distance(self_: LineAtOrigin, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(line_at_origin_motor_wedge(self_, other))), plane_at_origin_weight_norm(line_at_origin_flector_wedge(self_, motor_attitude(other))));
}

fn line_at_origin_multi_vector_distance(self_: LineAtOrigin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(line_at_origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(line_at_origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn line_at_origin_point_distance(self_: LineAtOrigin, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(line_at_origin_point_wedge(self_, other))), line_at_origin_weight_norm(line_at_origin_scalar_wedge(self_, point_attitude(other))));
}

fn magnitude_flector_distance(self_: Magnitude, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(flector_attitude(magnitude_flector_wedge(self_, other))), multi_vector_weight_norm(magnitude_multi_vector_wedge(self_, flector_attitude(other))));
}

fn magnitude_motor_distance(self_: Magnitude, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(magnitude_motor_wedge(self_, other))), flector_weight_norm(magnitude_flector_wedge(self_, motor_attitude(other))));
}

fn magnitude_multi_vector_distance(self_: Magnitude, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(magnitude_multi_vector_wedge(self_, other))), multi_vector_weight_norm(magnitude_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn magnitude_origin_distance(self_: Magnitude, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(origin_attitude(magnitude_origin_wedge(self_, other))), magnitude_weight_norm(magnitude_scalar_wedge(self_, origin_attitude(other))));
}

fn magnitude_point_distance(self_: Magnitude, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(point_attitude(magnitude_point_wedge(self_, other))), magnitude_weight_norm(magnitude_scalar_wedge(self_, point_attitude(other))));
}

fn magnitude_rotor_distance(self_: Magnitude, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(magnitude_rotor_wedge(self_, other))), flector_weight_norm(magnitude_flector_wedge(self_, rotor_attitude(other))));
}

fn motor_flector_distance(self_: Motor, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(motor_flector_wedge(self_, other))), multi_vector_weight_norm(motor_multi_vector_wedge(self_, flector_attitude(other))));
}

fn motor_line_distance(self_: Motor, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(motor_line_wedge(self_, other))), plane_weight_norm(motor_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn motor_line_at_origin_distance(self_: Motor, other: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(motor_line_at_origin_wedge(self_, other))), plane_weight_norm(motor_point_at_infinity_wedge(self_, line_at_origin_attitude(other))));
}

fn motor_motor_distance(self_: Motor, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(motor_motor_wedge(self_, other))), plane_weight_norm(motor_flector_wedge(self_, motor_attitude(other))));
}

fn motor_multi_vector_distance(self_: Motor, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(motor_multi_vector_wedge(self_, other))), multi_vector_weight_norm(motor_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn motor_origin_distance(self_: Motor, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(motor_origin_wedge(self_, other))), motor_weight_norm(motor_scalar_wedge(self_, origin_attitude(other))));
}

fn motor_point_distance(self_: Motor, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(motor_point_wedge(self_, other))), motor_weight_norm(motor_scalar_wedge(self_, point_attitude(other))));
}

fn motor_rotor_distance(self_: Motor, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(motor_rotor_wedge(self_, other))), plane_weight_norm(motor_flector_wedge(self_, rotor_attitude(other))));
}

fn multi_vector_anti_scalar_distance(self_: MultiVector, other: AntiScalar) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(multi_vector_anti_scalar_wedge(self_, other))), multi_vector_weight_norm(multi_vector_horizon_wedge(self_, anti_scalar_attitude(other))));
}

fn multi_vector_flector_distance(self_: MultiVector, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_flector_wedge(self_, other))), multi_vector_weight_norm(multi_vector_multi_vector_wedge(self_, flector_attitude(other))));
}

fn multi_vector_line_distance(self_: MultiVector, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_line_wedge(self_, other))), multi_vector_weight_norm(multi_vector_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn multi_vector_line_at_origin_distance(self_: MultiVector, other: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_line_at_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_point_at_infinity_wedge(self_, line_at_origin_attitude(other))));
}

fn multi_vector_magnitude_distance(self_: MultiVector, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_magnitude_wedge(self_, other))), multi_vector_weight_norm(multi_vector_horizon_wedge(self_, magnitude_attitude(other))));
}

fn multi_vector_motor_distance(self_: MultiVector, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_motor_wedge(self_, other))), multi_vector_weight_norm(multi_vector_flector_wedge(self_, motor_attitude(other))));
}

fn multi_vector_multi_vector_distance(self_: MultiVector, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_multi_vector_wedge(self_, other))), multi_vector_weight_norm(multi_vector_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn multi_vector_origin_distance(self_: MultiVector, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_scalar_wedge(self_, origin_attitude(other))));
}

fn multi_vector_plane_distance(self_: MultiVector, other: Plane) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_plane_wedge(self_, other))), multi_vector_weight_norm(multi_vector_line_at_infinity_wedge(self_, plane_attitude(other))));
}

fn multi_vector_plane_at_origin_distance(self_: MultiVector, other: PlaneAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_plane_at_origin_wedge(self_, other))), multi_vector_weight_norm(multi_vector_line_at_infinity_wedge(self_, plane_at_origin_attitude(other))));
}

fn multi_vector_point_distance(self_: MultiVector, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_point_wedge(self_, other))), multi_vector_weight_norm(multi_vector_scalar_wedge(self_, point_attitude(other))));
}

fn multi_vector_rotor_distance(self_: MultiVector, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_rotor_wedge(self_, other))), multi_vector_weight_norm(multi_vector_flector_wedge(self_, rotor_attitude(other))));
}

fn multi_vector_translator_distance(self_: MultiVector, other: Translator) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(multi_vector_translator_wedge(self_, other))), multi_vector_weight_norm(multi_vector_horizon_wedge(self_, translator_attitude(other))));
}

fn origin_flector_distance(self_: Origin, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(origin_flector_wedge(self_, other))), multi_vector_weight_norm(origin_multi_vector_wedge(self_, flector_attitude(other))));
}

fn origin_line_distance(self_: Origin, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(origin_line_wedge(self_, other))), line_at_origin_weight_norm(origin_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn origin_magnitude_distance(self_: Origin, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(origin_attitude(origin_magnitude_wedge(self_, other))), anti_scalar_weight_norm(origin_horizon_wedge(self_, magnitude_attitude(other))));
}

fn origin_motor_distance(self_: Origin, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(origin_motor_wedge(self_, other))), rotor_weight_norm(origin_flector_wedge(self_, motor_attitude(other))));
}

fn origin_multi_vector_distance(self_: Origin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn origin_plane_distance(self_: Origin, other: Plane) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(origin_plane_wedge(self_, other))), plane_at_origin_weight_norm(origin_line_at_infinity_wedge(self_, plane_attitude(other))));
}

fn origin_point_distance(self_: Origin, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(point_at_infinity_bulk_norm(line_at_origin_attitude(origin_point_wedge(self_, other))), origin_weight_norm(origin_scalar_wedge(self_, point_attitude(other))));
}

fn origin_translator_distance(self_: Origin, other: Translator) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(origin_translator_wedge(self_, other))), anti_scalar_weight_norm(origin_horizon_wedge(self_, translator_attitude(other))));
}

fn plane_flector_distance(self_: Plane, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(plane_flector_wedge(self_, other))), multi_vector_weight_norm(plane_multi_vector_wedge(self_, flector_attitude(other))));
}

fn plane_multi_vector_distance(self_: Plane, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(plane_multi_vector_wedge(self_, other))), multi_vector_weight_norm(plane_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn plane_origin_distance(self_: Plane, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(plane_origin_wedge(self_, other))), plane_weight_norm(plane_scalar_wedge(self_, origin_attitude(other))));
}

fn plane_point_distance(self_: Plane, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(plane_point_wedge(self_, other))), plane_weight_norm(plane_scalar_wedge(self_, point_attitude(other))));
}

fn plane_at_origin_flector_distance(self_: PlaneAtOrigin, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(plane_at_origin_flector_wedge(self_, other))), multi_vector_weight_norm(plane_at_origin_multi_vector_wedge(self_, flector_attitude(other))));
}

fn plane_at_origin_multi_vector_distance(self_: PlaneAtOrigin, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(plane_at_origin_multi_vector_wedge(self_, other))), multi_vector_weight_norm(plane_at_origin_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn plane_at_origin_point_distance(self_: PlaneAtOrigin, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(plane_at_origin_point_wedge(self_, other))), plane_at_origin_weight_norm(plane_at_origin_scalar_wedge(self_, point_attitude(other))));
}

fn point_flector_distance(self_: Point, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(point_flector_wedge(self_, other))), multi_vector_weight_norm(point_multi_vector_wedge(self_, flector_attitude(other))));
}

fn point_line_distance(self_: Point, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(point_line_wedge(self_, other))), line_weight_norm(point_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn point_line_at_origin_distance(self_: Point, other: LineAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(point_line_at_origin_wedge(self_, other))), line_weight_norm(point_point_at_infinity_wedge(self_, line_at_origin_attitude(other))));
}

fn point_magnitude_distance(self_: Point, other: Magnitude) -> Magnitude {
    return scalar_anti_scalar_add(scalar_bulk_norm(point_attitude(point_magnitude_wedge(self_, other))), anti_scalar_weight_norm(point_horizon_wedge(self_, magnitude_attitude(other))));
}

fn point_motor_distance(self_: Point, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(point_motor_wedge(self_, other))), motor_weight_norm(point_flector_wedge(self_, motor_attitude(other))));
}

fn point_multi_vector_distance(self_: Point, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(point_multi_vector_wedge(self_, other))), multi_vector_weight_norm(point_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn point_origin_distance(self_: Point, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(point_at_infinity_bulk_norm(line_at_origin_attitude(point_origin_wedge(self_, other))), point_weight_norm(point_scalar_wedge(self_, origin_attitude(other))));
}

fn point_plane_distance(self_: Point, other: Plane) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(point_plane_wedge(self_, other))), plane_weight_norm(point_line_at_infinity_wedge(self_, plane_attitude(other))));
}

fn point_plane_at_origin_distance(self_: Point, other: PlaneAtOrigin) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(point_plane_at_origin_wedge(self_, other))), plane_weight_norm(point_line_at_infinity_wedge(self_, plane_at_origin_attitude(other))));
}

fn point_point_distance(self_: Point, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(point_at_infinity_bulk_norm(line_attitude(point_point_wedge(self_, other))), point_weight_norm(point_scalar_wedge(self_, point_attitude(other))));
}

fn point_rotor_distance(self_: Point, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(point_rotor_wedge(self_, other))), motor_weight_norm(point_flector_wedge(self_, rotor_attitude(other))));
}

fn point_translator_distance(self_: Point, other: Translator) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(point_translator_wedge(self_, other))), anti_scalar_weight_norm(point_horizon_wedge(self_, translator_attitude(other))));
}

fn point_at_infinity_flector_distance(self_: PointAtInfinity, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(point_at_infinity_flector_wedge(self_, other))), multi_vector_weight_norm(point_at_infinity_multi_vector_wedge(self_, flector_attitude(other))));
}

fn point_at_infinity_motor_distance(self_: PointAtInfinity, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(point_at_infinity_motor_wedge(self_, other))), motor_weight_norm(point_at_infinity_flector_wedge(self_, motor_attitude(other))));
}

fn point_at_infinity_multi_vector_distance(self_: PointAtInfinity, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(point_at_infinity_multi_vector_wedge(self_, other))), multi_vector_weight_norm(point_at_infinity_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn point_at_infinity_rotor_distance(self_: PointAtInfinity, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(point_at_infinity_rotor_wedge(self_, other))), motor_weight_norm(point_at_infinity_flector_wedge(self_, rotor_attitude(other))));
}

fn rotor_flector_distance(self_: Rotor, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(rotor_flector_wedge(self_, other))), multi_vector_weight_norm(rotor_multi_vector_wedge(self_, flector_attitude(other))));
}

fn rotor_line_distance(self_: Rotor, other: Line) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(rotor_line_wedge(self_, other))), plane_at_origin_weight_norm(rotor_point_at_infinity_wedge(self_, line_attitude(other))));
}

fn rotor_motor_distance(self_: Rotor, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(rotor_motor_wedge(self_, other))), plane_at_origin_weight_norm(rotor_flector_wedge(self_, motor_attitude(other))));
}

fn rotor_multi_vector_distance(self_: Rotor, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(rotor_multi_vector_wedge(self_, other))), multi_vector_weight_norm(rotor_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn rotor_point_distance(self_: Rotor, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(rotor_point_wedge(self_, other))), rotor_weight_norm(rotor_scalar_wedge(self_, point_attitude(other))));
}

fn scalar_flector_distance(self_: Scalar, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(flector_attitude(scalar_flector_wedge(self_, other))), multi_vector_weight_norm(scalar_multi_vector_wedge(self_, flector_attitude(other))));
}

fn scalar_motor_distance(self_: Scalar, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(motor_attitude(scalar_motor_wedge(self_, other))), flector_weight_norm(scalar_flector_wedge(self_, motor_attitude(other))));
}

fn scalar_multi_vector_distance(self_: Scalar, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(scalar_multi_vector_wedge(self_, other))), multi_vector_weight_norm(scalar_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn scalar_rotor_distance(self_: Scalar, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(flector_bulk_norm(rotor_attitude(scalar_rotor_wedge(self_, other))), flector_weight_norm(scalar_flector_wedge(self_, rotor_attitude(other))));
}

fn translator_flector_distance(self_: Translator, other: Flector) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(translator_flector_wedge(self_, other))), multi_vector_weight_norm(translator_multi_vector_wedge(self_, flector_attitude(other))));
}

fn translator_motor_distance(self_: Translator, other: Motor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(translator_motor_wedge(self_, other))), plane_weight_norm(translator_flector_wedge(self_, motor_attitude(other))));
}

fn translator_multi_vector_distance(self_: Translator, other: MultiVector) -> Magnitude {
    return scalar_anti_scalar_add(multi_vector_bulk_norm(multi_vector_attitude(translator_multi_vector_wedge(self_, other))), multi_vector_weight_norm(translator_multi_vector_wedge(self_, multi_vector_attitude(other))));
}

fn translator_origin_distance(self_: Translator, other: Origin) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_at_origin_attitude(translator_origin_wedge(self_, other))), translator_weight_norm(translator_scalar_wedge(self_, origin_attitude(other))));
}

fn translator_point_distance(self_: Translator, other: Point) -> Magnitude {
    return scalar_anti_scalar_add(line_at_infinity_bulk_norm(plane_attitude(translator_point_wedge(self_, other))), translator_weight_norm(translator_scalar_wedge(self_, point_attitude(other))));
}

fn translator_rotor_distance(self_: Translator, other: Rotor) -> Magnitude {
    return scalar_anti_scalar_add(horizon_bulk_norm(anti_scalar_attitude(translator_rotor_wedge(self_, other))), plane_weight_norm(translator_flector_wedge(self_, rotor_attitude(other))));
}

