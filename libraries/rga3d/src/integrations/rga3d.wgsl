#define_import_path rga3d
//
// AUTO-GENERATED - DO NOT MODIFY
//
// To contribute to this file, see the adjacent codegen package.
// https://github.com/AndrewBrownK/projective_ga/
//
// v1.0.0
// Latest generation test case
// authors = ["Andrew Brown <Andrew.Brown.UNL@gmail.com>"]
// License: MIWT
//

struct AntiScalar {
    e1234_: f32
}
struct AntiScalarGroups {
    // e1234, 0, 0, 0
    group0_: vec4<f32>
}
fn antiScalar_grouped(self_: AntiScalar) -> AntiScalarGroups {
    return AntiScalarGroups(
        vec4<f32>(self_.e1234_, 0.0, 0.0, 0.0)
    );
}
fn antiScalar_degroup(self_: AntiScalarGroups) -> AntiScalar {
    return AntiScalar(
        self_.group0_.x
    );
}


struct DualNum {
    scalar: f32, e1234_: f32
}
struct DualNumGroups {
    // scalar, e1234, 0, 0
    group0_: vec4<f32>
}
fn dualNum_grouped(self_: DualNum) -> DualNumGroups {
    return DualNumGroups(
        vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0)
    );
}
fn dualNum_degroup(self_: DualNumGroups) -> DualNum {
    return DualNum(
        self_.group0_.x, self_.group0_.y
    );
}


struct Flector {
    e1_: f32, e2_: f32, e3_: f32, e4_: f32,
    e423_: f32, e431_: f32, e412_: f32, e321_: f32
}
struct FlectorGroups {
    // e1, e2, e3, e4
    group0_: vec4<f32>,
    // e423, e431, e412, e321
    group1_: vec4<f32>
}
fn flector_grouped(self_: Flector) -> FlectorGroups {
    return FlectorGroups(
        vec4<f32>(self_.e1_, self_.e2_, self_.e3_, self_.e4_),
        vec4<f32>(self_.e423_, self_.e431_, self_.e412_, self_.e321_)
    );
}
fn flector_degroup(self_: FlectorGroups) -> Flector {
    return Flector(
        self_.group0_.x, self_.group0_.y, self_.group0_.z, self_.group0_.w,
        self_.group1_.x, self_.group1_.y, self_.group1_.z, self_.group1_.w
    );
}


struct Horizon {
    e321_: f32
}
struct HorizonGroups {
    // e321, 0, 0, 0
    group0_: vec4<f32>
}
fn horizon_grouped(self_: Horizon) -> HorizonGroups {
    return HorizonGroups(
        vec4<f32>(self_.e321_, 0.0, 0.0, 0.0)
    );
}
fn horizon_degroup(self_: HorizonGroups) -> Horizon {
    return Horizon(
        self_.group0_.x
    );
}


struct Line {
    e41_: f32, e42_: f32, e43_: f32,
    e23_: f32, e31_: f32, e12_: f32
}
struct LineGroups {
    // e41, e42, e43, 0
    group0_: vec4<f32>,
    // e23, e31, e12, 0
    group1_: vec4<f32>
}
fn line_grouped(self_: Line) -> LineGroups {
    return LineGroups(
        vec4<f32>(self_.e41_, self_.e42_, self_.e43_, 0.0),
        vec4<f32>(self_.e23_, self_.e31_, self_.e12_, 0.0)
    );
}
fn line_degroup(self_: LineGroups) -> Line {
    return Line(
        self_.group0_.x, self_.group0_.y, self_.group0_.z,
        self_.group1_.x, self_.group1_.y, self_.group1_.z
    );
}


struct Motor {
    e41_: f32, e42_: f32, e43_: f32, e1234_: f32,
    e23_: f32, e31_: f32, e12_: f32, scalar: f32
}
struct MotorGroups {
    // e41, e42, e43, e1234
    group0_: vec4<f32>,
    // e23, e31, e12, scalar
    group1_: vec4<f32>
}
fn motor_grouped(self_: Motor) -> MotorGroups {
    return MotorGroups(
        vec4<f32>(self_.e41_, self_.e42_, self_.e43_, self_.e1234_),
        vec4<f32>(self_.e23_, self_.e31_, self_.e12_, self_.scalar)
    );
}
fn motor_degroup(self_: MotorGroups) -> Motor {
    return Motor(
        self_.group0_.x, self_.group0_.y, self_.group0_.z, self_.group0_.w,
        self_.group1_.x, self_.group1_.y, self_.group1_.z, self_.group1_.w
    );
}


struct MultiVector {
    scalar: f32, e1234_: f32,
    e1_: f32, e2_: f32, e3_: f32, e4_: f32,
    e41_: f32, e42_: f32, e43_: f32,
    e23_: f32, e31_: f32, e12_: f32,
    e423_: f32, e431_: f32, e412_: f32, e321_: f32
}
struct MultiVectorGroups {
    // scalar, e1234, 0, 0
    group0_: vec4<f32>,
    // e1, e2, e3, e4
    group1_: vec4<f32>,
    // e41, e42, e43, 0
    group2_: vec4<f32>,
    // e23, e31, e12, 0
    group3_: vec4<f32>,
    // e423, e431, e412, e321
    group4_: vec4<f32>
}
fn multiVector_grouped(self_: MultiVector) -> MultiVectorGroups {
    return MultiVectorGroups(
        vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0),
        vec4<f32>(self_.e1_, self_.e2_, self_.e3_, self_.e4_),
        vec4<f32>(self_.e41_, self_.e42_, self_.e43_, 0.0),
        vec4<f32>(self_.e23_, self_.e31_, self_.e12_, 0.0),
        vec4<f32>(self_.e423_, self_.e431_, self_.e412_, self_.e321_)
    );
}
fn multiVector_degroup(self_: MultiVectorGroups) -> MultiVector {
    return MultiVector(
        self_.group0_.x, self_.group0_.y,
        self_.group1_.x, self_.group1_.y, self_.group1_.z, self_.group1_.w,
        self_.group2_.x, self_.group2_.y, self_.group2_.z,
        self_.group3_.x, self_.group3_.y, self_.group3_.z,
        self_.group4_.x, self_.group4_.y, self_.group4_.z, self_.group4_.w
    );
}


struct Origin {
    e4_: f32
}
struct OriginGroups {
    // e4, 0, 0, 0
    group0_: vec4<f32>
}
fn origin_grouped(self_: Origin) -> OriginGroups {
    return OriginGroups(
        vec4<f32>(self_.e4_, 0.0, 0.0, 0.0)
    );
}
fn origin_degroup(self_: OriginGroups) -> Origin {
    return Origin(
        self_.group0_.x
    );
}


struct Plane {
    e423_: f32, e431_: f32, e412_: f32, e321_: f32
}
struct PlaneGroups {
    // e423, e431, e412, e321
    group0_: vec4<f32>
}
fn plane_grouped(self_: Plane) -> PlaneGroups {
    return PlaneGroups(
        vec4<f32>(self_.e423_, self_.e431_, self_.e412_, self_.e321_)
    );
}
fn plane_degroup(self_: PlaneGroups) -> Plane {
    return Plane(
        self_.group0_.x, self_.group0_.y, self_.group0_.z, self_.group0_.w
    );
}


struct Point {
    e1_: f32, e2_: f32, e3_: f32, e4_: f32
}
struct PointGroups {
    // e1, e2, e3, e4
    group0_: vec4<f32>
}
fn point_grouped(self_: Point) -> PointGroups {
    return PointGroups(
        vec4<f32>(self_.e1_, self_.e2_, self_.e3_, self_.e4_)
    );
}
fn point_degroup(self_: PointGroups) -> Point {
    return Point(
        self_.group0_.x, self_.group0_.y, self_.group0_.z, self_.group0_.w
    );
}


struct Scalar {
    scalar: f32
}
struct ScalarGroups {
    // scalar, 0, 0, 0
    group0_: vec4<f32>
}
fn scalar_grouped(self_: Scalar) -> ScalarGroups {
    return ScalarGroups(
        vec4<f32>(self_.scalar, 0.0, 0.0, 0.0)
    );
}
fn scalar_degroup(self_: ScalarGroups) -> Scalar {
    return Scalar(
        self_.group0_.x
    );
}

fn antiScalar_add_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ + self_.e1234_);
}
fn antiScalar_add_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0) + other_groups.group0_
    ));
}
fn antiScalar_add_flector(self_: AntiScalar, other: Flector) -> MultiVector {
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn antiScalar_add_horizon(self_: AntiScalar, other: Horizon) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn antiScalar_add_line(self_: AntiScalar, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    ));
}
fn antiScalar_add_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_), 
        /* e23, e31, e12, scalar */ other_groups.group1_
    ));
}
fn antiScalar_add_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0) + other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn antiScalar_add_origin(self_: AntiScalar, other: Origin) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_add_plane(self_: AntiScalar, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn antiScalar_add_point(self_: AntiScalar, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_add_scalar(self_: AntiScalar, other: Scalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, self_.e1234_, 0.0, 0.0)
    ));
}
fn dualNum_add_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0) + self_groups.group0_
    ));
}
fn dualNum_add_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ other_groups.group0_ + self_groups.group0_
    ));
}
fn dualNum_add_flector(self_: DualNum, other: Flector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn dualNum_add_horizon(self_: DualNum, other: Horizon) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn dualNum_add_line(self_: DualNum, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar)
    ));
}
fn dualNum_add_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_ + other.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar + other.scalar)
    ));
}
fn dualNum_add_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_ + other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn dualNum_add_origin(self_: DualNum, other: Origin) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_add_plane(self_: DualNum, other: Plane) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn dualNum_add_point(self_: DualNum, other: Point) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_add_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0) + self_groups.group0_
    ));
}
fn flector_add_antiScalar(self_: Flector, other: AntiScalar) -> MultiVector {
    let self_groups = flector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_add_dualNum(self_: Flector, other: DualNum) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_add_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ + self_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ + self_groups.group1_
    ));
}
fn flector_add_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn flector_add_line(self_: Flector, other: Line) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_add_motor(self_: Flector, other: Motor) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_add_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group0_ + other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ + other_groups.group4_
    ));
}
fn flector_add_origin(self_: Flector, other: Origin) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_add_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ + other_groups.group0_
    ));
}
fn flector_add_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ + other_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_add_scalar(self_: Flector, other: Scalar) -> MultiVector {
    let self_groups = flector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn horizon_add_antiScalar(self_: Horizon, other: AntiScalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_dualNum(self_: Horizon, other: DualNum) -> MultiVector {
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(other.e321_ + self_.e321_);
}
fn horizon_add_line(self_: Horizon, other: Line) -> MultiVector {
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_motor(self_: Horizon, other: Motor) -> MultiVector {
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_origin(self_: Horizon, other: Origin) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_plane(self_: Horizon, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ other_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_point(self_: Horizon, other: Point) -> Flector {
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_add_scalar(self_: Horizon, other: Scalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn line_add_antiScalar(self_: Line, other: AntiScalar) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, other.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn line_add_dualNum(self_: Line, other: DualNum) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, other.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, other.scalar)
    ));
}
fn line_add_flector(self_: Line, other: Flector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn line_add_horizon(self_: Line, other: Horizon) -> MultiVector {
    let self_groups = line_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn line_add_line(self_: Line, other: Line) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ + self_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_ + self_groups.group1_
    ));
}
fn line_add_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_groups.group0_ + other_groups.group0_).xyz, other.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_groups.group1_ + other_groups.group1_).xyz, other.scalar)
    ));
}
fn line_add_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group0_ + other_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group1_ + other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn line_add_origin(self_: Line, other: Origin) -> MultiVector {
    let self_groups = line_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn line_add_plane(self_: Line, other: Plane) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn line_add_point(self_: Line, other: Point) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn line_add_scalar(self_: Line, other: Scalar) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, other.scalar)
    ));
}
fn motor_add_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_), 
        /* e23, e31, e12, scalar */ self_groups.group1_
    ));
}
fn motor_add_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, other.e1234_ + self_.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, other.scalar + self_.scalar)
    ));
}
fn motor_add_flector(self_: Motor, other: Flector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn motor_add_horizon(self_: Motor, other: Horizon) -> MultiVector {
    let self_groups = motor_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn motor_add_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other_groups.group0_ + self_groups.group0_).xyz, self_.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other_groups.group1_ + self_groups.group1_).xyz, self_.scalar)
    ));
}
fn motor_add_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ + self_groups.group0_, 
        /* e23, e31, e12, scalar */ other_groups.group1_ + self_groups.group1_
    ));
}
fn motor_add_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0) + other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ + self_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group3_ + self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn motor_add_origin(self_: Motor, other: Origin) -> MultiVector {
    let self_groups = motor_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn motor_add_plane(self_: Motor, other: Plane) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn motor_add_point(self_: Motor, other: Point) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn motor_add_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_, 
        /* e23, e31, e12, scalar */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.scalar)
    ));
}
fn multiVector_add_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0) + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_add_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_add_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group0_ + self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ + self_groups.group4_
    ));
}
fn multiVector_add_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn multiVector_add_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group0_ + self_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group1_ + self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_add_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0) + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ + other_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group3_ + other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_add_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ + self_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ + self_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ + self_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_ + self_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_ + self_groups.group4_
    ));
}
fn multiVector_add_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_add_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ + other_groups.group0_
    ));
}
fn multiVector_add_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ + other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_add_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0) + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn origin_add_antiScalar(self_: Origin, other: AntiScalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_add_dualNum(self_: Origin, other: DualNum) -> MultiVector {
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_add_flector(self_: Origin, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn origin_add_horizon(self_: Origin, other: Horizon) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn origin_add_line(self_: Origin, other: Line) -> MultiVector {
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_add_motor(self_: Origin, other: Motor) -> MultiVector {
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_add_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn origin_add_origin(self_: Origin, other: Origin) -> Origin {
    return Origin(other.e4_ + self_.e4_);
}
fn origin_add_plane(self_: Origin, other: Plane) -> Flector {
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn origin_add_point(self_: Origin, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_)
    ));
}
fn origin_add_scalar(self_: Origin, other: Scalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn plane_add_antiScalar(self_: Plane, other: AntiScalar) -> MultiVector {
    let self_groups = plane_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_add_dualNum(self_: Plane, other: DualNum) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_add_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ + self_groups.group0_
    ));
}
fn plane_add_horizon(self_: Plane, other: Horizon) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn plane_add_line(self_: Plane, other: Line) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_add_motor(self_: Plane, other: Motor) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_add_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_ + self_groups.group0_
    ));
}
fn plane_add_origin(self_: Plane, other: Origin) -> Flector {
    let self_groups = plane_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_add_plane(self_: Plane, other: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ other_groups.group0_ + self_groups.group0_
    ));
}
fn plane_add_point(self_: Plane, other: Point) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_add_scalar(self_: Plane, other: Scalar) -> MultiVector {
    let self_groups = plane_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn point_add_antiScalar(self_: Point, other: AntiScalar) -> MultiVector {
    let self_groups = point_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_add_dualNum(self_: Point, other: DualNum) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_add_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ + self_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn point_add_horizon(self_: Point, other: Horizon) -> Flector {
    let self_groups = point_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn point_add_line(self_: Point, other: Line) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_add_motor(self_: Point, other: Motor) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_, 
        /* e23, e31, e12 */ other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_add_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ + self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn point_add_origin(self_: Point, other: Origin) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e4_)
    ));
}
fn point_add_plane(self_: Point, other: Plane) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn point_add_point(self_: Point, other: Point) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ + self_groups.group0_
    ));
}
fn point_add_scalar(self_: Point, other: Scalar) -> MultiVector {
    let self_groups = point_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_add_antiScalar(self_: Scalar, other: AntiScalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, other.e1234_, 0.0, 0.0)
    ));
}
fn scalar_add_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0) + other_groups.group0_
    ));
}
fn scalar_add_flector(self_: Scalar, other: Flector) -> MultiVector {
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    ));
}
fn scalar_add_horizon(self_: Scalar, other: Horizon) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_)
    ));
}
fn scalar_add_line(self_: Scalar, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar)
    ));
}
fn scalar_add_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_, 
        /* e23, e31, e12, scalar */ other_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar)
    ));
}
fn scalar_add_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0) + other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_, 
        /* e23, e31, e12 */ other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_
    ));
}
fn scalar_add_origin(self_: Scalar, other: Origin) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_add_plane(self_: Scalar, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group0_
    ));
}
fn scalar_add_point(self_: Scalar, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_add_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(other.scalar + self_.scalar);
}
fn antiScalar_antiAutoMorphism(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_antiAutoMorphism(self_: DualNum) -> DualNum {
    return self_;
}
fn flector_antiAutoMorphism(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn horizon_antiAutoMorphism(self_: Horizon) -> Horizon {
    return Horizon(self_.e321_ * -1.0);
}
fn line_antiAutoMorphism(self_: Line) -> Line {
    return self_;
}
fn motor_antiAutoMorphism(self_: Motor) -> Motor {
    return self_;
}
fn multiVector_antiAutoMorphism(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn origin_antiAutoMorphism(self_: Origin) -> Origin {
    return Origin(self_.e4_ * -1.0);
}
fn plane_antiAutoMorphism(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_antiAutoMorphism(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_antiAutoMorphism(self_: Scalar) -> Scalar {
    return self_;
}
fn dualNum_antiConstraintViolation(self_: DualNum) -> Scalar {
    return Scalar(self_.scalar * self_.e1234_ * 2.0);
}
fn flector_antiConstraintViolation(self_: Flector) -> Scalar {
    let self_groups = flector_grouped(self_);
    let anti_reverse: Flector = flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
    return Scalar((anti_reverse.e423_ * self_.e1_) + (anti_reverse.e431_ * self_.e2_) + (anti_reverse.e412_ * self_.e3_) + (anti_reverse.e321_ * self_.e4_) - (anti_reverse.e1_ * self_.e423_) - (anti_reverse.e2_ * self_.e431_) - (anti_reverse.e3_ * self_.e412_) - (anti_reverse.e4_ * self_.e321_));
}
fn line_antiConstraintViolation(self_: Line) -> Scalar {
    let self_groups = line_grouped(self_);
    let anti_reverse: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
    return Scalar(-(anti_reverse.e41_ * self_.e23_) - (anti_reverse.e42_ * self_.e31_) - (anti_reverse.e43_ * self_.e12_) - (anti_reverse.e23_ * self_.e41_) - (anti_reverse.e31_ * self_.e42_) - (anti_reverse.e12_ * self_.e43_));
}
fn motor_antiConstraintViolation(self_: Motor) -> Scalar {
    let self_groups = motor_grouped(self_);
    let anti_reverse: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
    return Scalar((anti_reverse.e1234_ * self_.scalar) + (anti_reverse.scalar * self_.e1234_) - (anti_reverse.e41_ * self_.e23_) - (anti_reverse.e42_ * self_.e31_) - (anti_reverse.e43_ * self_.e12_) - (anti_reverse.e23_ * self_.e41_) - (anti_reverse.e31_ * self_.e42_) - (anti_reverse.e12_ * self_.e43_));
}
fn multiVector_antiConstraintViolation(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_
    );
    let anti_reverse: MultiVector = multiVector_degroup(anti_reverse_groups);
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((anti_reverse.e1234_ * self_.scalar) + (anti_reverse.e321_ * self_.e4_) - (anti_reverse.e2_ * self_.e431_) - (anti_reverse.e3_ * self_.e412_) - (anti_reverse.e4_ * self_.e321_) - (anti_reverse.e23_ * self_.e41_) - (anti_reverse.e31_ * self_.e42_) - (anti_reverse.e12_ * self_.e43_), 0.0, 0.0, 0.0) + ((vec4<f32>(anti_reverse.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(anti_reverse.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(anti_reverse.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_) - ((vec4<f32>(anti_reverse.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(anti_reverse.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(anti_reverse.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * anti_reverse_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ (vec4<f32>(anti_reverse.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, anti_reverse.e321_) * vec4<f32>(anti_reverse_groups.group2_.xxyw.xyz, self_.e1234_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(anti_reverse_groups.group2_.zyzw.xyz, anti_reverse.e23_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(anti_reverse_groups.group4_.xyz, anti_reverse.e4_)) + (vec4<f32>(anti_reverse_groups.group1_.wwzw.xy, anti_reverse.e431_, self_.e431_) * vec4<f32>(self_groups.group2_.xyxw.xyz, anti_reverse.e31_)) + (vec4<f32>(anti_reverse_groups.group4_.zxzw.xy, anti_reverse.e4_, self_.e412_) * vec4<f32>(self_groups.group2_.yzzw.xyz, anti_reverse.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_reverse.e1_ * self_.e41_) - (anti_reverse.e2_ * self_.e42_) - (anti_reverse.e3_ * self_.e43_) - (anti_reverse.e42_ * self_.e2_) - (anti_reverse.e43_ * self_.e3_) - (anti_reverse.e423_ * self_.e23_) - (anti_reverse.e431_ * self_.e31_) - (anti_reverse.e412_ * self_.e12_)) - vec4<f32>((anti_reverse_groups.group2_.yzxw * self_groups.group4_.zxyw).xyz, anti_reverse.scalar * self_.e4_) - vec4<f32>((self_groups.group2_.zxyw * anti_reverse_groups.group4_.yzxw).xyz, anti_reverse.e41_ * self_.e1_)
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(geometric_anti_product.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ geometric_anti_product_groups.group4_
    ));
}
fn antiScalar_antiDotProduct_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn antiScalar_antiDotProduct_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.e1234_);
}
fn antiScalar_antiDotProduct_motor(self_: AntiScalar, other: Motor) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.e1234_);
}
fn antiScalar_antiDotProduct_multiVector(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.e1234_);
}
fn dualNum_antiDotProduct_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn dualNum_antiDotProduct_dualNum(self_: DualNum, other: DualNum) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn dualNum_antiDotProduct_motor(self_: DualNum, other: Motor) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.e1234_);
}
fn dualNum_antiDotProduct_multiVector(self_: DualNum, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.e1234_);
}
fn flector_antiDotProduct_flector(self_: Flector, other: Flector) -> AntiScalar {
    return AntiScalar((other.e4_ * self_.e4_) + (other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_));
}
fn flector_antiDotProduct_multiVector(self_: Flector, other: MultiVector) -> AntiScalar {
    return AntiScalar((self_.e4_ * other.e4_) + (self_.e423_ * other.e423_) + (self_.e431_ * other.e431_) + (self_.e412_ * other.e412_));
}
fn flector_antiDotProduct_origin(self_: Flector, other: Origin) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e4_);
}
fn flector_antiDotProduct_plane(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar((self_.e423_ * other.e423_) + (self_.e431_ * other.e431_) + (self_.e412_ * other.e412_));
}
fn flector_antiDotProduct_point(self_: Flector, other: Point) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e4_);
}
fn line_antiDotProduct_line(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar((other.e41_ * self_.e41_) + (other.e42_ * self_.e42_) + (other.e43_ * self_.e43_));
}
fn line_antiDotProduct_motor(self_: Line, other: Motor) -> AntiScalar {
    return AntiScalar((self_.e41_ * other.e41_) + (self_.e42_ * other.e42_) + (self_.e43_ * other.e43_));
}
fn line_antiDotProduct_multiVector(self_: Line, other: MultiVector) -> AntiScalar {
    return AntiScalar((self_.e41_ * other.e41_) + (self_.e42_ * other.e42_) + (self_.e43_ * other.e43_));
}
fn motor_antiDotProduct_antiScalar(self_: Motor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn motor_antiDotProduct_dualNum(self_: Motor, other: DualNum) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn motor_antiDotProduct_line(self_: Motor, other: Line) -> AntiScalar {
    return AntiScalar((other.e41_ * self_.e41_) + (other.e42_ * self_.e42_) + (other.e43_ * self_.e43_));
}
fn motor_antiDotProduct_motor(self_: Motor, other: Motor) -> AntiScalar {
    return AntiScalar((other.e41_ * self_.e41_) + (other.e42_ * self_.e42_) + (other.e43_ * self_.e43_) + (other.e1234_ * self_.e1234_));
}
fn motor_antiDotProduct_multiVector(self_: Motor, other: MultiVector) -> AntiScalar {
    return AntiScalar((self_.e41_ * other.e41_) + (self_.e42_ * other.e42_) + (self_.e43_ * other.e43_) + (self_.e1234_ * other.e1234_));
}
fn multiVector_antiDotProduct_antiScalar(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn multiVector_antiDotProduct_dualNum(self_: MultiVector, other: DualNum) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn multiVector_antiDotProduct_flector(self_: MultiVector, other: Flector) -> AntiScalar {
    return AntiScalar((other.e4_ * self_.e4_) + (other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_));
}
fn multiVector_antiDotProduct_line(self_: MultiVector, other: Line) -> AntiScalar {
    return AntiScalar((other.e41_ * self_.e41_) + (other.e42_ * self_.e42_) + (other.e43_ * self_.e43_));
}
fn multiVector_antiDotProduct_motor(self_: MultiVector, other: Motor) -> AntiScalar {
    return AntiScalar((other.e41_ * self_.e41_) + (other.e42_ * self_.e42_) + (other.e43_ * self_.e43_) + (other.e1234_ * self_.e1234_));
}
fn multiVector_antiDotProduct_multiVector(self_: MultiVector, other: MultiVector) -> AntiScalar {
    return AntiScalar((other.e1234_ * self_.e1234_) + (other.e4_ * self_.e4_) + (other.e41_ * self_.e41_) + (other.e42_ * self_.e42_) + (other.e43_ * self_.e43_) + (other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_));
}
fn multiVector_antiDotProduct_origin(self_: MultiVector, other: Origin) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e4_);
}
fn multiVector_antiDotProduct_plane(self_: MultiVector, other: Plane) -> AntiScalar {
    return AntiScalar((self_.e423_ * other.e423_) + (self_.e431_ * other.e431_) + (self_.e412_ * other.e412_));
}
fn multiVector_antiDotProduct_point(self_: MultiVector, other: Point) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e4_);
}
fn origin_antiDotProduct_flector(self_: Origin, other: Flector) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn origin_antiDotProduct_multiVector(self_: Origin, other: MultiVector) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn origin_antiDotProduct_origin(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn origin_antiDotProduct_point(self_: Origin, other: Point) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e4_);
}
fn plane_antiDotProduct_flector(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar((other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_));
}
fn plane_antiDotProduct_multiVector(self_: Plane, other: MultiVector) -> AntiScalar {
    return AntiScalar((other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_));
}
fn plane_antiDotProduct_plane(self_: Plane, other: Plane) -> AntiScalar {
    return AntiScalar((other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_));
}
fn point_antiDotProduct_flector(self_: Point, other: Flector) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn point_antiDotProduct_multiVector(self_: Point, other: MultiVector) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn point_antiDotProduct_origin(self_: Point, other: Origin) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn point_antiDotProduct_point(self_: Point, other: Point) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_);
}
fn antiScalar_antiFix(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(1.0);
}
fn origin_antiFix(self_: Origin) -> Origin {
    return Origin(1.0);
}
fn plane_antiFix(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(self_.e423_, 2) + pow(self_.e431_, 2) + pow(self_.e412_, 2)) * self_groups.group0_
    ));
}
fn point_antiFix(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow((self_groups.group0_ * vec4<f32>(-1.0)).w, -0.5) * pow(self_.e4_, -0.5) * -1.0) * self_groups.group0_
    ));
}
fn antiScalar_antiGrade() -> i32 {
    return 0;
}
fn horizon_antiGrade() -> i32 {
    return 1;
}
fn line_antiGrade() -> i32 {
    return 2;
}
fn origin_antiGrade() -> i32 {
    return 3;
}
fn plane_antiGrade() -> i32 {
    return 1;
}
fn point_antiGrade() -> i32 {
    return 3;
}
fn scalar_antiGrade() -> i32 {
    return 4;
}
fn antiScalar_antiInverse(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(1.0/(self_.e1234_));
}
fn dualNum_antiInverse(self_: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(self_.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn flector_antiInverse(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    );
    let other: AntiScalar = AntiScalar(pow(self_.e4_, 2) + pow(self_.e423_, 2) + pow(self_.e431_, 2) + pow(self_.e412_, 2));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * anti_reverse_groups.group1_
    ));
}
fn line_antiInverse(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    );
    let other: AntiScalar = AntiScalar(pow(self_.e41_, 2) + pow(self_.e42_, 2) + pow(self_.e43_, 2));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    ));
}
fn motor_antiInverse(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other: AntiScalar = AntiScalar(pow(self_.e41_, 2) + pow(self_.e42_, 2) + pow(self_.e43_, 2) + pow(self_.e1234_, 2));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e1234_) * anti_reverse_groups.group1_
    ));
}
fn multiVector_antiInverse(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_
    );
    let other: AntiScalar = AntiScalar(pow(self_.e1234_, 2) + pow(self_.e4_, 2) + pow(self_.e41_, 2) + pow(self_.e42_, 2) + pow(self_.e43_, 2) + pow(self_.e423_, 2) + pow(self_.e431_, 2) + pow(self_.e412_, 2));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * anti_reverse_groups.group4_
    ));
}
fn origin_antiInverse(self_: Origin) -> Origin {
    return Origin(1.0/(self_.e4_) * -1.0);
}
fn plane_antiInverse(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(self_.e423_, 2) + pow(self_.e431_, 2) + pow(self_.e412_, 2)) * self_groups.group0_
    ));
}
fn point_antiInverse(self_: Point) -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(self_.e4_, -2)) * vec4<f32>(self_.e1_ * -1.0, self_.e2_ * -1.0, self_.e3_ * -1.0, self_.e4_ * -1.0)
    ));
}
fn antiScalar_antiOne() -> AntiScalar {
    return AntiScalar(1.0);
}
fn dualNum_antiOne() -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, 1.0, 0.0, 0.0)
    ));
}
fn motor_antiOne() -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiOne() -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, 1.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_antiProjectOrthogonallyOnto_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(pow(other.scalar, 2) * self_.e1234_);
}
fn antiScalar_antiProjectOrthogonallyOnto_flector(self_: AntiScalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn antiScalar_antiProjectOrthogonallyOnto_horizon(self_: AntiScalar, other: Horizon) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn antiScalar_antiProjectOrthogonallyOnto_line(self_: AntiScalar, other: Line) -> AntiScalar {
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_));
}
fn antiScalar_antiProjectOrthogonallyOnto_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_antiProjectOrthogonallyOnto_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e1234_ * right_anti_dual.e1234_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_).xyz, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn antiScalar_antiProjectOrthogonallyOnto_plane(self_: AntiScalar, other: Plane) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn antiScalar_antiProjectOrthogonallyOnto_point(self_: AntiScalar, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
    return AntiScalar((anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_));
}
fn antiScalar_antiProjectOrthogonallyOnto_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(pow(other.scalar, 2) * self_.e1234_);
}
fn dualNum_antiProjectOrthogonallyOnto_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    let anti_wedge: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar), 0.0, 0.0)
    ));
}
fn dualNum_antiProjectOrthogonallyOnto_flector(self_: DualNum, other: Flector) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn dualNum_antiProjectOrthogonallyOnto_horizon(self_: DualNum, other: Horizon) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn dualNum_antiProjectOrthogonallyOnto_line(self_: DualNum, other: Line) -> AntiScalar {
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_));
}
fn dualNum_antiProjectOrthogonallyOnto_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * right_anti_dual_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, (self_.scalar * right_anti_dual.e1234_) + (self_.e1234_ * right_anti_dual.scalar))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_)).xyz, anti_wedge.scalar * other.scalar)
    ));
}
fn dualNum_antiProjectOrthogonallyOnto_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * right_anti_dual.e1234_) + (self_.e1234_ * right_anti_dual.scalar), self_.e1234_ * right_anti_dual.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn dualNum_antiProjectOrthogonallyOnto_plane(self_: DualNum, other: Plane) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn dualNum_antiProjectOrthogonallyOnto_point(self_: DualNum, other: Point) -> AntiScalar {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    let anti_wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return AntiScalar((anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_));
}
fn dualNum_antiProjectOrthogonallyOnto_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(right_anti_dual.e1234_ * self_.scalar, right_anti_dual.e1234_ * self_.e1234_, 0.0, 0.0)
    ));
}
fn flector_antiProjectOrthogonallyOnto_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn flector_antiProjectOrthogonallyOnto_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_anti_dual_groups.group1_.yzxw * self_groups.group1_.zxyw) - (right_anti_dual_groups.group1_.zxyw * self_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_anti_dual_groups.group1_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_)) - (self_groups.group1_.wwwx * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * anti_wedge.e23_) + (other.e423_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e31_) + (other.e431_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e12_) + (other.e412_ * anti_wedge.scalar), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + vec4<f32>((other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, other.e321_ * anti_wedge.scalar) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn flector_antiProjectOrthogonallyOnto_horizon(self_: Flector, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn flector_antiProjectOrthogonallyOnto_line(self_: Flector, other: Line) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * right_anti_dual.e31_) + (self_.e321_ * right_anti_dual.e41_), (self_.e423_ * right_anti_dual.e12_) + (self_.e321_ * right_anti_dual.e42_), (self_.e431_ * right_anti_dual.e23_) + (self_.e321_ * right_anti_dual.e43_), -(self_.e431_ * right_anti_dual.e42_) - (self_.e412_ * right_anti_dual.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn flector_antiProjectOrthogonallyOnto_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * right_anti_dual.e31_) + (self_.e321_ * right_anti_dual.e41_), (self_.e423_ * right_anti_dual.e12_) + (self_.e321_ * right_anti_dual.e42_), (self_.e431_ * right_anti_dual.e23_) + (self_.e321_ * right_anti_dual.e43_), -(self_.e431_ * right_anti_dual.e42_) - (self_.e412_ * right_anti_dual.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e4_ * other.e23_) + (anti_wedge.e423_ * other.scalar), (anti_wedge.e4_ * other.e31_) + (anti_wedge.e431_ * other.scalar), (anti_wedge.e4_ * other.e12_) + (anti_wedge.e412_ * other.scalar), -(anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_)) + vec4<f32>((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, anti_wedge.e321_ * other.scalar) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn flector_antiProjectOrthogonallyOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * right_anti_dual.e423_) + (self_.e2_ * right_anti_dual.e431_) + (self_.e3_ * right_anti_dual.e412_) + (self_.e4_ * right_anti_dual.e321_) - (self_.e423_ * right_anti_dual.e1_) - (self_.e431_ * right_anti_dual.e2_) - (self_.e412_ * right_anti_dual.e3_) - (self_.e321_ * right_anti_dual.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * right_anti_dual.e31_) + (self_.e321_ * right_anti_dual.e41_), (self_.e423_ * right_anti_dual.e12_) + (self_.e321_ * right_anti_dual.e42_), (self_.e431_ * right_anti_dual.e23_) + (self_.e321_ * right_anti_dual.e43_), -(self_.e431_ * right_anti_dual.e42_) - (self_.e412_ * right_anti_dual.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * right_anti_dual_groups.group4_.yzxw) - (self_groups.group1_.yzxw * right_anti_dual_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn flector_antiProjectOrthogonallyOnto_plane(self_: Flector, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_ * other.e321_) * other_groups.group0_
    ));
}
fn flector_antiProjectOrthogonallyOnto_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((self_groups.group1_.zxyw * right_anti_dual_groups.group0_.yzxw) - (self_groups.group1_.yzxw * right_anti_dual_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_ * right_anti_dual.e423_ * -1.0, self_.e321_ * right_anti_dual.e431_ * -1.0, self_.e321_ * right_anti_dual.e412_ * -1.0, (self_.e2_ * right_anti_dual.e431_) + (self_.e3_ * right_anti_dual.e412_) + (self_.e4_ * right_anti_dual.e321_)) + (right_anti_dual_groups.group0_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn flector_antiProjectOrthogonallyOnto_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn horizon_antiProjectOrthogonallyOnto_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(pow(other.scalar, 2) * self_.e321_);
}
fn horizon_antiProjectOrthogonallyOnto_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e4_) * vec4<f32>(-1.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * anti_wedge.e23_) + (other.e423_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e31_) + (other.e431_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e12_) + (other.e412_ * anti_wedge.scalar), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + vec4<f32>((other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, other.e321_ * anti_wedge.scalar) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn horizon_antiProjectOrthogonallyOnto_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn horizon_antiProjectOrthogonallyOnto_line(self_: Horizon, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0)).xyz, 0.0)
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn horizon_antiProjectOrthogonallyOnto_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * right_anti_dual.e1234_)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(anti_wedge_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e4_ * other.e23_) + (anti_wedge.e423_ * other.scalar), (anti_wedge.e4_ * other.e31_) + (anti_wedge.e431_ * other.scalar), (anti_wedge.e4_ * other.e12_) + (anti_wedge.e412_ * other.scalar), -(anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_)) + vec4<f32>((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, anti_wedge.e321_ * other.scalar) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn horizon_antiProjectOrthogonallyOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * right_anti_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * right_anti_dual.e1234_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn horizon_antiProjectOrthogonallyOnto_plane(self_: Horizon, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_ * other.e321_) * other_groups.group0_
    ));
}
fn horizon_antiProjectOrthogonallyOnto_point(self_: Horizon, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)
    );
    let anti_wedge: Line = line_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn horizon_antiProjectOrthogonallyOnto_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(pow(other.scalar, 2) * self_.e321_);
}
fn line_antiProjectOrthogonallyOnto_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_
    ));
}
fn line_antiProjectOrthogonallyOnto_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * self_.e31_) + (right_anti_dual.e321_ * self_.e41_), (right_anti_dual.e423_ * self_.e12_) + (right_anti_dual.e321_ * self_.e42_), (right_anti_dual.e431_ * self_.e23_) + (right_anti_dual.e321_ * self_.e43_), -(right_anti_dual.e431_ * self_.e42_) - (right_anti_dual.e412_ * self_.e43_)) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_ * anti_wedge.e1_, other.e4_ * anti_wedge.e2_, other.e4_ * anti_wedge.e3_, -(other.e431_ * anti_wedge.e2_) - (other.e412_ * anti_wedge.e3_) - (other.e321_ * anti_wedge.e4_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw) - (other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn line_antiProjectOrthogonallyOnto_line(self_: Line, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    let anti_wedge: Scalar = Scalar(-(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn line_antiProjectOrthogonallyOnto_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e41_ * right_anti_dual.e23_) - (self_.e42_ * right_anti_dual.e31_) - (self_.e43_ * right_anti_dual.e12_) - (self_.e23_ * right_anti_dual.e41_) - (self_.e31_ * right_anti_dual.e42_) - (self_.e12_ * right_anti_dual.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_)).xyz, anti_wedge.scalar * other.scalar)
    ));
}
fn line_antiProjectOrthogonallyOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e41_ * right_anti_dual.e23_) - (self_.e42_ * right_anti_dual.e31_) - (self_.e43_ * right_anti_dual.e12_) - (self_.e23_ * right_anti_dual.e41_) - (self_.e31_ * right_anti_dual.e42_) - (self_.e12_ * right_anti_dual.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_anti_dual.e321_) + (self_.e31_ * right_anti_dual.e412_), (self_.e42_ * right_anti_dual.e321_) + (self_.e12_ * right_anti_dual.e423_), (self_.e43_ * right_anti_dual.e321_) + (self_.e23_ * right_anti_dual.e431_), -(self_.e42_ * right_anti_dual.e431_) - (self_.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn line_antiProjectOrthogonallyOnto_point(self_: Line, other: Point) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_anti_dual.e321_) + (self_.e31_ * right_anti_dual.e412_), (self_.e42_ * right_anti_dual.e321_) + (self_.e12_ * right_anti_dual.e423_), (self_.e43_ * right_anti_dual.e321_) + (self_.e23_ * right_anti_dual.e431_), -(self_.e42_ * right_anti_dual.e431_) - (self_.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group0_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ (anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)
    ));
}
fn line_antiProjectOrthogonallyOnto_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_
    ));
}
fn motor_antiProjectOrthogonallyOnto_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * anti_wedge.e1234_) + (other.e1234_ * anti_wedge.scalar)) * vec4<f32>(anti_wedge_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn motor_antiProjectOrthogonallyOnto_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * self_.e31_) + (right_anti_dual.e321_ * self_.e41_), (right_anti_dual.e423_ * self_.e12_) + (right_anti_dual.e321_ * self_.e42_), (right_anti_dual.e431_ * self_.e23_) + (right_anti_dual.e321_ * self_.e43_), -(right_anti_dual.e431_ * self_.e42_) - (right_anti_dual.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * right_anti_dual_groups.group0_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn motor_antiProjectOrthogonallyOnto_horizon(self_: Motor, other: Horizon) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn motor_antiProjectOrthogonallyOnto_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * anti_wedge.e23_) - (other.e42_ * anti_wedge.e31_) - (other.e43_ * anti_wedge.e12_) - (other.e23_ * anti_wedge.e41_) - (other.e31_ * anti_wedge.e42_) - (other.e12_ * anti_wedge.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.xyz, 0.0) * vec4<f32>(anti_wedge_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn motor_antiProjectOrthogonallyOnto_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)).xyz, right_anti_dual.e1234_ * self_.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * right_anti_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_)).xyz, anti_wedge.scalar * other.scalar)
    ));
}
fn motor_antiProjectOrthogonallyOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1234_ * right_anti_dual.scalar) + (self_.scalar * right_anti_dual.e1234_) - (self_.e41_ * right_anti_dual.e23_) - (self_.e42_ * right_anti_dual.e31_) - (self_.e43_ * right_anti_dual.e12_) - (self_.e23_ * right_anti_dual.e41_) - (self_.e31_ * right_anti_dual.e42_) - (self_.e12_ * right_anti_dual.e43_), self_.e1234_ * right_anti_dual.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1234_ * right_anti_dual.e1_) + (self_.e31_ * right_anti_dual.e412_), (self_.e1234_ * right_anti_dual.e2_) + (self_.e12_ * right_anti_dual.e423_), (self_.e1234_ * right_anti_dual.e3_) + (self_.e23_ * right_anti_dual.e431_), -(self_.e42_ * right_anti_dual.e431_) - (self_.e43_ * right_anti_dual.e412_)) + (self_groups.group0_ * vec4<f32>(right_anti_dual_groups.group4_.wwww.xyz, right_anti_dual.e4_)) - (right_anti_dual_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn motor_antiProjectOrthogonallyOnto_plane(self_: Motor, other: Plane) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn motor_antiProjectOrthogonallyOnto_point(self_: Motor, other: Point) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_anti_dual.e321_) + (self_.e31_ * right_anti_dual.e412_), (self_.e42_ * right_anti_dual.e321_) + (self_.e12_ * right_anti_dual.e423_), (self_.e43_ * right_anti_dual.e321_) + (self_.e23_ * right_anti_dual.e431_), -(self_.e42_ * right_anti_dual.e431_) - (self_.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(anti_wedge.e4_ * other.e1_ * -1.0, anti_wedge.e4_ * other.e2_ * -1.0, anti_wedge.e4_ * other.e3_ * -1.0, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_)) + (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn motor_antiProjectOrthogonallyOnto_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_
    );
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * anti_wedge.scalar, (other.scalar * anti_wedge.e1234_) + (other.e1234_ * anti_wedge.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group4_
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_) - (right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * self_.e31_) + (right_anti_dual.e321_ * self_.e41_), (right_anti_dual.e423_ * self_.e12_) + (right_anti_dual.e321_ * self_.e42_), (right_anti_dual.e431_ * self_.e23_) + (right_anti_dual.e321_ * self_.e43_), -(right_anti_dual.e431_ * self_.e42_) - (right_anti_dual.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * right_anti_dual_groups.group0_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (right_anti_dual_groups.group1_.yzxw * self_groups.group4_.zxyw) - (right_anti_dual_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e1_ * anti_wedge.e423_) + (other.e2_ * anti_wedge.e431_) + (other.e3_ * anti_wedge.e412_) + (other.e4_ * anti_wedge.e321_) - (other.e423_ * anti_wedge.e1_) - (other.e431_ * anti_wedge.e2_) - (other.e412_ * anti_wedge.e3_) - (other.e321_ * anti_wedge.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw) - (other_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * anti_wedge.e42_) + (other.e4_ * anti_wedge.e23_), (other.e1_ * anti_wedge.e43_) + (other.e4_ * anti_wedge.e31_), (other.e2_ * anti_wedge.e41_) + (other.e4_ * anti_wedge.e12_), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    let anti_wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * right_anti_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * right_anti_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * anti_wedge.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * anti_wedge.scalar)
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * self_.e321_) + (right_anti_dual.e31_ * self_.e412_), (right_anti_dual.e42_ * self_.e321_) + (right_anti_dual.e12_ * self_.e423_), (right_anti_dual.e43_ * self_.e321_) + (right_anti_dual.e23_ * self_.e431_), -(right_anti_dual.e42_ * self_.e431_) - (right_anti_dual.e43_ * self_.e412_)) - (self_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e41_ * anti_wedge.e23_) - (other.e42_ * anti_wedge.e31_) - (other.e43_ * anti_wedge.e12_) - (other.e23_ * anti_wedge.e41_) - (other.e31_ * anti_wedge.e42_) - (other.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.e1234_ * self_.scalar) + (right_anti_dual.scalar * self_.e1234_) - (right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_), right_anti_dual.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e1234_ * self_.e1_) + (right_anti_dual.e31_ * self_.e412_), (right_anti_dual.e1234_ * self_.e2_) + (right_anti_dual.e12_ * self_.e423_), (right_anti_dual.e1234_ * self_.e3_) + (right_anti_dual.e23_ * self_.e431_), -(right_anti_dual.e42_ * self_.e431_) - (right_anti_dual.e43_ * self_.e412_)) + (right_anti_dual_groups.group0_ * vec4<f32>(self_groups.group4_.wwww.xyz, self_.e4_)) - (self_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * anti_wedge.scalar, (other.e1234_ * anti_wedge.scalar) + (other.scalar * anti_wedge.e1234_) - (other.e41_ * anti_wedge.e23_) - (other.e42_ * anti_wedge.e31_) - (other.e43_ * anti_wedge.e12_) - (other.e23_ * anti_wedge.e41_) - (other.e31_ * anti_wedge.e42_) - (other.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e23_ * anti_wedge.e4_) + (other.scalar * anti_wedge.e423_), (other.e31_ * anti_wedge.e4_) + (other.scalar * anti_wedge.e431_), (other.e12_ * anti_wedge.e4_) + (other.scalar * anti_wedge.e412_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) + vec4<f32>((other_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, other.scalar * anti_wedge.e321_) - (anti_wedge_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * self_.e1234_) + (right_anti_dual.e1234_ * self_.scalar) + (right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_) - (right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_) - (right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_), right_anti_dual.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * self_.e321_) + (right_anti_dual.e31_ * self_.e412_) + (right_anti_dual.e412_ * self_.e31_) + (right_anti_dual.e321_ * self_.e41_), (right_anti_dual.e42_ * self_.e321_) + (right_anti_dual.e12_ * self_.e423_) + (right_anti_dual.e423_ * self_.e12_) + (right_anti_dual.e321_ * self_.e42_), (right_anti_dual.e43_ * self_.e321_) + (right_anti_dual.e23_ * self_.e431_) + (right_anti_dual.e431_ * self_.e23_) + (right_anti_dual.e321_ * self_.e43_), -(right_anti_dual.e43_ * self_.e412_) - (right_anti_dual.e423_ * self_.e41_) - (right_anti_dual.e431_ * self_.e42_) - (right_anti_dual.e412_ * self_.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * right_anti_dual_groups.group1_) - (self_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((self_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * self_.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * self_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e1234_) * right_anti_dual_groups.group4_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    let anti_wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * right_anti_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * right_anti_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * right_anti_dual.e423_) + (self_.e2_ * right_anti_dual.e431_) + (self_.e3_ * right_anti_dual.e412_) + (self_.e4_ * right_anti_dual.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_anti_dual.e321_) + (self_.e31_ * right_anti_dual.e412_), (self_.e42_ * right_anti_dual.e321_) + (self_.e12_ * right_anti_dual.e423_), (self_.e43_ * right_anti_dual.e321_) + (self_.e23_ * right_anti_dual.e431_), -(self_.e42_ * right_anti_dual.e431_) - (self_.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * right_anti_dual_groups.group0_.yzxw) - (self_groups.group4_.yzxw * right_anti_dual_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ (anti_wedge_groups.group1_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn multiVector_antiProjectOrthogonallyOnto_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group4_
    );
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_wedge_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group4_
    ));
}
fn origin_antiProjectOrthogonallyOnto_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(pow(other.scalar, 2) * self_.e4_);
}
fn origin_antiProjectOrthogonallyOnto_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let anti_wedge: Origin = Origin((other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)).w * self_.e4_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * anti_wedge.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
}
fn origin_antiProjectOrthogonallyOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge: Origin = Origin(other.scalar * self_.e4_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * anti_wedge.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * anti_wedge.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    ));
}
fn origin_antiProjectOrthogonallyOnto_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(pow(other.scalar, 2) * self_.e4_);
}
fn plane_antiProjectOrthogonallyOnto_dualNum(self_: Plane, other: DualNum) -> Plane {
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(right_anti_dual.e1234_ * self_.e423_, right_anti_dual.e1234_ * self_.e431_, right_anti_dual.e1234_ * self_.e412_, right_anti_dual.e1234_ * self_.e321_)
    ));
}
fn plane_antiProjectOrthogonallyOnto_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_anti_dual_groups.group1_.yzxw * self_groups.group0_.zxyw) - (right_anti_dual_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(right_anti_dual.e321_ * self_.e423_, right_anti_dual.e321_ * self_.e431_, right_anti_dual.e321_ * self_.e412_, -(right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_)) - (self_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * anti_wedge.e23_) + (other.e423_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e31_) + (other.e431_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e12_) + (other.e412_ * anti_wedge.scalar), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + vec4<f32>((other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, other.e321_ * anti_wedge.scalar) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn plane_antiProjectOrthogonallyOnto_horizon(self_: Plane, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn plane_antiProjectOrthogonallyOnto_line(self_: Plane, other: Line) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * self_.e321_) + (right_anti_dual.e31_ * self_.e412_), (right_anti_dual.e42_ * self_.e321_) + (right_anti_dual.e12_ * self_.e423_), (right_anti_dual.e43_ * self_.e321_) + (right_anti_dual.e23_ * self_.e431_), -(right_anti_dual.e42_ * self_.e431_) - (right_anti_dual.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn plane_antiProjectOrthogonallyOnto_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * self_.e321_) + (right_anti_dual.e31_ * self_.e412_), (right_anti_dual.e42_ * self_.e321_) + (right_anti_dual.e12_ * self_.e423_), (right_anti_dual.e43_ * self_.e321_) + (right_anti_dual.e23_ * self_.e431_), -(right_anti_dual.e42_ * self_.e431_) - (right_anti_dual.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e4_ * other.e23_) + (anti_wedge.e423_ * other.scalar), (anti_wedge.e4_ * other.e31_) + (anti_wedge.e431_ * other.scalar), (anti_wedge.e4_ * other.e12_) + (anti_wedge.e412_ * other.scalar), -(anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_)) + vec4<f32>((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, anti_wedge.e321_ * other.scalar) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn plane_antiProjectOrthogonallyOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * self_.e321_) + (right_anti_dual.e31_ * self_.e412_), (right_anti_dual.e42_ * self_.e321_) + (right_anti_dual.e12_ * self_.e423_), (right_anti_dual.e43_ * self_.e321_) + (right_anti_dual.e23_ * self_.e431_), -(right_anti_dual.e42_ * self_.e431_) - (right_anti_dual.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e41, e42, e43 */ (right_anti_dual_groups.group4_.yzxw * self_groups.group0_.zxyw) - (right_anti_dual_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn plane_antiProjectOrthogonallyOnto_plane(self_: Plane, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_ * self_.e321_) * other_groups.group0_
    ));
}
fn plane_antiProjectOrthogonallyOnto_point(self_: Plane, other: Point) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (right_anti_dual_groups.group0_.yzxw * self_groups.group0_.zxyw) - (right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)
    );
    let anti_wedge: Line = line_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn plane_antiProjectOrthogonallyOnto_scalar(self_: Plane, other: Scalar) -> Plane {
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(right_anti_dual.e1234_ * self_.e423_, right_anti_dual.e1234_ * self_.e431_, right_anti_dual.e1234_ * self_.e412_, right_anti_dual.e1234_ * self_.e321_)
    ));
}
fn point_antiProjectOrthogonallyOnto_dualNum(self_: Point, other: DualNum) -> Point {
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(right_anti_dual.e1234_ * self_.e1_, right_anti_dual.e1234_ * self_.e2_, right_anti_dual.e1234_ * self_.e3_, right_anti_dual.e1234_ * self_.e4_)
    ));
}
fn point_antiProjectOrthogonallyOnto_flector(self_: Point, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let right_anti_dual: Flector = flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    let anti_wedge: Scalar = Scalar((right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge.scalar) * other_groups.group1_
    ));
}
fn point_antiProjectOrthogonallyOnto_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn point_antiProjectOrthogonallyOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    ));
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn point_antiProjectOrthogonallyOnto_point(self_: Point, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_)) * other_groups.group0_
    ));
}
fn point_antiProjectOrthogonallyOnto_scalar(self_: Point, other: Scalar) -> Point {
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(right_anti_dual.e1234_ * self_.e1_, right_anti_dual.e1234_ * self_.e2_, right_anti_dual.e1234_ * self_.e3_, right_anti_dual.e1234_ * self_.e4_)
    ));
}
fn scalar_antiProjectOrthogonallyOnto_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_antiProjectOrthogonallyOnto_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_wedge: Scalar = Scalar((other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)).w * self_.scalar);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(anti_wedge.scalar) * other_groups.group1_
    ));
}
fn scalar_antiProjectOrthogonallyOnto_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge: Scalar = Scalar(other.scalar * self_.scalar);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge.scalar) * other_groups.group4_
    ));
}
fn scalar_antiProjectOrthogonallyOnto_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn antiScalar_antiProjectViaHorizonOnto_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(pow(other.scalar, 2) * self_.e1234_);
}
fn antiScalar_antiProjectViaHorizonOnto_flector(self_: AntiScalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn antiScalar_antiProjectViaHorizonOnto_horizon(self_: AntiScalar, other: Horizon) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn antiScalar_antiProjectViaHorizonOnto_line(self_: AntiScalar, other: Line) -> AntiScalar {
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_));
}
fn antiScalar_antiProjectViaHorizonOnto_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_antiProjectViaHorizonOnto_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e1234_ * right_dual.e1234_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_).xyz, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn antiScalar_antiProjectViaHorizonOnto_plane(self_: AntiScalar, other: Plane) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn antiScalar_antiProjectViaHorizonOnto_point(self_: AntiScalar, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
    return AntiScalar((anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_));
}
fn antiScalar_antiProjectViaHorizonOnto_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(pow(other.scalar, 2) * self_.e1234_);
}
fn dualNum_antiProjectViaHorizonOnto_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    let anti_wedge: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar), 0.0, 0.0)
    ));
}
fn dualNum_antiProjectViaHorizonOnto_flector(self_: DualNum, other: Flector) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn dualNum_antiProjectViaHorizonOnto_horizon(self_: DualNum, other: Horizon) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn dualNum_antiProjectViaHorizonOnto_line(self_: DualNum, other: Line) -> AntiScalar {
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_));
}
fn dualNum_antiProjectViaHorizonOnto_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * right_dual_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, (self_.scalar * right_dual.e1234_) + (self_.e1234_ * right_dual.scalar))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_)).xyz, anti_wedge.scalar * other.scalar)
    ));
}
fn dualNum_antiProjectViaHorizonOnto_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * right_dual.e1234_) + (self_.e1234_ * right_dual.scalar), self_.e1234_ * right_dual.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn dualNum_antiProjectViaHorizonOnto_plane(self_: DualNum, other: Plane) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn dualNum_antiProjectViaHorizonOnto_point(self_: DualNum, other: Point) -> AntiScalar {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    let anti_wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return AntiScalar((anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_));
}
fn dualNum_antiProjectViaHorizonOnto_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(right_dual.e1234_ * self_.scalar, right_dual.e1234_ * self_.e1234_, 0.0, 0.0)
    ));
}
fn flector_antiProjectViaHorizonOnto_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn flector_antiProjectViaHorizonOnto_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_dual_groups.group1_.yzxw * self_groups.group1_.zxyw) - (right_dual_groups.group1_.zxyw * self_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_dual_groups.group1_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_)) - (self_groups.group1_.wwwx * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * anti_wedge.e23_) + (other.e423_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e31_) + (other.e431_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e12_) + (other.e412_ * anti_wedge.scalar), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + vec4<f32>((other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, other.e321_ * anti_wedge.scalar) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn flector_antiProjectViaHorizonOnto_horizon(self_: Flector, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn flector_antiProjectViaHorizonOnto_line(self_: Flector, other: Line) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * right_dual.e31_) + (self_.e321_ * right_dual.e41_), (self_.e423_ * right_dual.e12_) + (self_.e321_ * right_dual.e42_), (self_.e431_ * right_dual.e23_) + (self_.e321_ * right_dual.e43_), -(self_.e431_ * right_dual.e42_) - (self_.e412_ * right_dual.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn flector_antiProjectViaHorizonOnto_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * right_dual.e31_) + (self_.e321_ * right_dual.e41_), (self_.e423_ * right_dual.e12_) + (self_.e321_ * right_dual.e42_), (self_.e431_ * right_dual.e23_) + (self_.e321_ * right_dual.e43_), -(self_.e431_ * right_dual.e42_) - (self_.e412_ * right_dual.e43_)) + (vec4<f32>(right_dual.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e4_ * other.e23_) + (anti_wedge.e423_ * other.scalar), (anti_wedge.e4_ * other.e31_) + (anti_wedge.e431_ * other.scalar), (anti_wedge.e4_ * other.e12_) + (anti_wedge.e412_ * other.scalar), -(anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_)) + vec4<f32>((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, anti_wedge.e321_ * other.scalar) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn flector_antiProjectViaHorizonOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * right_dual.e423_) + (self_.e2_ * right_dual.e431_) + (self_.e3_ * right_dual.e412_) + (self_.e4_ * right_dual.e321_) - (self_.e423_ * right_dual.e1_) - (self_.e431_ * right_dual.e2_) - (self_.e412_ * right_dual.e3_) - (self_.e321_ * right_dual.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * right_dual.e31_) + (self_.e321_ * right_dual.e41_), (self_.e423_ * right_dual.e12_) + (self_.e321_ * right_dual.e42_), (self_.e431_ * right_dual.e23_) + (self_.e321_ * right_dual.e43_), -(self_.e431_ * right_dual.e42_) - (self_.e412_ * right_dual.e43_)) + (vec4<f32>(right_dual.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * right_dual_groups.group4_.yzxw) - (self_groups.group1_.yzxw * right_dual_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group1_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn flector_antiProjectViaHorizonOnto_plane(self_: Flector, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_ * other.e321_) * other_groups.group0_
    ));
}
fn flector_antiProjectViaHorizonOnto_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((self_groups.group1_.zxyw * right_dual_groups.group0_.yzxw) - (self_groups.group1_.yzxw * right_dual_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_ * right_dual.e423_ * -1.0, self_.e321_ * right_dual.e431_ * -1.0, self_.e321_ * right_dual.e412_ * -1.0, (self_.e2_ * right_dual.e431_) + (self_.e3_ * right_dual.e412_) + (self_.e4_ * right_dual.e321_)) + (right_dual_groups.group0_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn flector_antiProjectViaHorizonOnto_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn horizon_antiProjectViaHorizonOnto_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(pow(other.scalar, 2) * self_.e321_);
}
fn horizon_antiProjectViaHorizonOnto_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e4_) * vec4<f32>(-1.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * anti_wedge.e23_) + (other.e423_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e31_) + (other.e431_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e12_) + (other.e412_ * anti_wedge.scalar), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + vec4<f32>((other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, other.e321_ * anti_wedge.scalar) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn horizon_antiProjectViaHorizonOnto_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn horizon_antiProjectViaHorizonOnto_line(self_: Horizon, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0)).xyz, 0.0)
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn horizon_antiProjectViaHorizonOnto_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * right_dual.e1234_)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(anti_wedge_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e4_ * other.e23_) + (anti_wedge.e423_ * other.scalar), (anti_wedge.e4_ * other.e31_) + (anti_wedge.e431_ * other.scalar), (anti_wedge.e4_ * other.e12_) + (anti_wedge.e412_ * other.scalar), -(anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_)) + vec4<f32>((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, anti_wedge.e321_ * other.scalar) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn horizon_antiProjectViaHorizonOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * right_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * right_dual.e1234_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn horizon_antiProjectViaHorizonOnto_plane(self_: Horizon, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_ * other.e321_) * other_groups.group0_
    ));
}
fn horizon_antiProjectViaHorizonOnto_point(self_: Horizon, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)
    );
    let anti_wedge: Line = line_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn horizon_antiProjectViaHorizonOnto_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(pow(other.scalar, 2) * self_.e321_);
}
fn line_antiProjectViaHorizonOnto_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_
    ));
}
fn line_antiProjectViaHorizonOnto_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * self_.e31_) + (right_dual.e321_ * self_.e41_), (right_dual.e423_ * self_.e12_) + (right_dual.e321_ * self_.e42_), (right_dual.e431_ * self_.e23_) + (right_dual.e321_ * self_.e43_), -(right_dual.e431_ * self_.e42_) - (right_dual.e412_ * self_.e43_)) - (right_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_ * anti_wedge.e1_, other.e4_ * anti_wedge.e2_, other.e4_ * anti_wedge.e3_, -(other.e431_ * anti_wedge.e2_) - (other.e412_ * anti_wedge.e3_) - (other.e321_ * anti_wedge.e4_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw) - (other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn line_antiProjectViaHorizonOnto_line(self_: Line, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    let anti_wedge: Scalar = Scalar(-(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn line_antiProjectViaHorizonOnto_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e41_ * right_dual.e23_) - (self_.e42_ * right_dual.e31_) - (self_.e43_ * right_dual.e12_) - (self_.e23_ * right_dual.e41_) - (self_.e31_ * right_dual.e42_) - (self_.e12_ * right_dual.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_)).xyz, anti_wedge.scalar * other.scalar)
    ));
}
fn line_antiProjectViaHorizonOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e41_ * right_dual.e23_) - (self_.e42_ * right_dual.e31_) - (self_.e43_ * right_dual.e12_) - (self_.e23_ * right_dual.e41_) - (self_.e31_ * right_dual.e42_) - (self_.e12_ * right_dual.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_dual.e321_) + (self_.e31_ * right_dual.e412_), (self_.e42_ * right_dual.e321_) + (self_.e12_ * right_dual.e423_), (self_.e43_ * right_dual.e321_) + (self_.e23_ * right_dual.e431_), -(self_.e42_ * right_dual.e431_) - (self_.e43_ * right_dual.e412_)) - (right_dual_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn line_antiProjectViaHorizonOnto_point(self_: Line, other: Point) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_dual.e321_) + (self_.e31_ * right_dual.e412_), (self_.e42_ * right_dual.e321_) + (self_.e12_ * right_dual.e423_), (self_.e43_ * right_dual.e321_) + (self_.e23_ * right_dual.e431_), -(self_.e42_ * right_dual.e431_) - (self_.e43_ * right_dual.e412_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group0_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ (anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)
    ));
}
fn line_antiProjectViaHorizonOnto_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_
    ));
}
fn motor_antiProjectViaHorizonOnto_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual.e1234_) * self_groups.group1_
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * anti_wedge.e1234_) + (other.e1234_ * anti_wedge.scalar)) * vec4<f32>(anti_wedge_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn motor_antiProjectViaHorizonOnto_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * self_.e31_) + (right_dual.e321_ * self_.e41_), (right_dual.e423_ * self_.e12_) + (right_dual.e321_ * self_.e42_), (right_dual.e431_ * self_.e23_) + (right_dual.e321_ * self_.e43_), -(right_dual.e431_ * self_.e42_) - (right_dual.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * right_dual_groups.group0_) - (right_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_)) - (anti_wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn motor_antiProjectViaHorizonOnto_horizon(self_: Motor, other: Horizon) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn motor_antiProjectViaHorizonOnto_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * anti_wedge.e23_) - (other.e42_ * anti_wedge.e31_) - (other.e43_ * anti_wedge.e12_) - (other.e23_ * anti_wedge.e41_) - (other.e31_ * anti_wedge.e42_) - (other.e12_ * anti_wedge.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.xyz, 0.0) * vec4<f32>(anti_wedge_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn motor_antiProjectViaHorizonOnto_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)).xyz, right_dual.e1234_ * self_.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_dual.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * right_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group0_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_)).xyz, anti_wedge.scalar * other.scalar)
    ));
}
fn motor_antiProjectViaHorizonOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1234_ * right_dual.scalar) + (self_.scalar * right_dual.e1234_) - (self_.e41_ * right_dual.e23_) - (self_.e42_ * right_dual.e31_) - (self_.e43_ * right_dual.e12_) - (self_.e23_ * right_dual.e41_) - (self_.e31_ * right_dual.e42_) - (self_.e12_ * right_dual.e43_), self_.e1234_ * right_dual.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1234_ * right_dual.e1_) + (self_.e31_ * right_dual.e412_), (self_.e1234_ * right_dual.e2_) + (self_.e12_ * right_dual.e423_), (self_.e1234_ * right_dual.e3_) + (self_.e23_ * right_dual.e431_), -(self_.e42_ * right_dual.e431_) - (self_.e43_ * right_dual.e412_)) + (self_groups.group0_ * vec4<f32>(right_dual_groups.group4_.wwww.xyz, right_dual.e4_)) - (right_dual_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn motor_antiProjectViaHorizonOnto_plane(self_: Motor, other: Plane) -> AntiScalar {
    return AntiScalar(pow(other.e321_, 2) * self_.e1234_);
}
fn motor_antiProjectViaHorizonOnto_point(self_: Motor, other: Point) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_dual.e321_) + (self_.e31_ * right_dual.e412_), (self_.e42_ * right_dual.e321_) + (self_.e12_ * right_dual.e423_), (self_.e43_ * right_dual.e321_) + (self_.e23_ * right_dual.e431_), -(self_.e42_ * right_dual.e431_) - (self_.e43_ * right_dual.e412_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(anti_wedge.e4_ * other.e1_ * -1.0, anti_wedge.e4_ * other.e2_ * -1.0, anti_wedge.e4_ * other.e3_ * -1.0, (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_)) + (other_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group0_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn motor_antiProjectViaHorizonOnto_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual.e1234_) * self_groups.group1_
    );
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_
    ));
}
fn multiVector_antiProjectViaHorizonOnto_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * anti_wedge.scalar, (other.scalar * anti_wedge.e1234_) + (other.e1234_ * anti_wedge.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group4_
    ));
}
fn multiVector_antiProjectViaHorizonOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_) - (right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * self_.e31_) + (right_dual.e321_ * self_.e41_), (right_dual.e423_ * self_.e12_) + (right_dual.e321_ * self_.e42_), (right_dual.e431_ * self_.e23_) + (right_dual.e321_ * self_.e43_), -(right_dual.e431_ * self_.e42_) - (right_dual.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * right_dual_groups.group0_) - (right_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (right_dual_groups.group1_.yzxw * self_groups.group4_.zxyw) - (right_dual_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e1_ * anti_wedge.e423_) + (other.e2_ * anti_wedge.e431_) + (other.e3_ * anti_wedge.e412_) + (other.e4_ * anti_wedge.e321_) - (other.e423_ * anti_wedge.e1_) - (other.e431_ * anti_wedge.e2_) - (other.e412_ * anti_wedge.e3_) - (other.e321_ * anti_wedge.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw) - (other_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * anti_wedge.e42_) + (other.e4_ * anti_wedge.e23_), (other.e1_ * anti_wedge.e43_) + (other.e4_ * anti_wedge.e31_), (other.e2_ * anti_wedge.e41_) + (other.e4_ * anti_wedge.e12_), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn multiVector_antiProjectViaHorizonOnto_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    let anti_wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * right_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * right_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * anti_wedge.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * anti_wedge.scalar)
    ));
}
fn multiVector_antiProjectViaHorizonOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * self_.e321_) + (right_dual.e31_ * self_.e412_), (right_dual.e42_ * self_.e321_) + (right_dual.e12_ * self_.e423_), (right_dual.e43_ * self_.e321_) + (right_dual.e23_ * self_.e431_), -(right_dual.e42_ * self_.e431_) - (right_dual.e43_ * self_.e412_)) - (self_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e41_ * anti_wedge.e23_) - (other.e42_ * anti_wedge.e31_) - (other.e43_ * anti_wedge.e12_) - (other.e23_ * anti_wedge.e41_) - (other.e31_ * anti_wedge.e42_) - (other.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_antiProjectViaHorizonOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.e1234_ * self_.scalar) + (right_dual.scalar * self_.e1234_) - (right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_), right_dual.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e1234_ * self_.e1_) + (right_dual.e31_ * self_.e412_), (right_dual.e1234_ * self_.e2_) + (right_dual.e12_ * self_.e423_), (right_dual.e1234_ * self_.e3_) + (right_dual.e23_ * self_.e431_), -(right_dual.e42_ * self_.e431_) - (right_dual.e43_ * self_.e412_)) + (right_dual_groups.group0_ * vec4<f32>(self_groups.group4_.wwww.xyz, self_.e4_)) - (self_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * anti_wedge.scalar, (other.e1234_ * anti_wedge.scalar) + (other.scalar * anti_wedge.e1234_) - (other.e41_ * anti_wedge.e23_) - (other.e42_ * anti_wedge.e31_) - (other.e43_ * anti_wedge.e12_) - (other.e23_ * anti_wedge.e41_) - (other.e31_ * anti_wedge.e42_) - (other.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e23_ * anti_wedge.e4_) + (other.scalar * anti_wedge.e423_), (other.e31_ * anti_wedge.e4_) + (other.scalar * anti_wedge.e431_), (other.e12_ * anti_wedge.e4_) + (other.scalar * anti_wedge.e412_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) + vec4<f32>((other_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, other.scalar * anti_wedge.e321_) - (anti_wedge_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_antiProjectViaHorizonOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * self_.e1234_) + (right_dual.e1234_ * self_.scalar) + (right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_) - (right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_) - (right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_), right_dual.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * self_.e321_) + (right_dual.e31_ * self_.e412_) + (right_dual.e412_ * self_.e31_) + (right_dual.e321_ * self_.e41_), (right_dual.e42_ * self_.e321_) + (right_dual.e12_ * self_.e423_) + (right_dual.e423_ * self_.e12_) + (right_dual.e321_ * self_.e42_), (right_dual.e43_ * self_.e321_) + (right_dual.e23_ * self_.e431_) + (right_dual.e431_ * self_.e23_) + (right_dual.e321_ * self_.e43_), -(right_dual.e43_ * self_.e412_) - (right_dual.e423_ * self_.e41_) - (right_dual.e431_ * self_.e42_) - (right_dual.e412_ * self_.e43_)) + (vec4<f32>(right_dual.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * right_dual_groups.group1_) - (self_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((self_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * self_.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * self_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e1234_) * right_dual_groups.group4_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn multiVector_antiProjectViaHorizonOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    let anti_wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * right_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * right_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_
    ));
}
fn multiVector_antiProjectViaHorizonOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * right_dual.e423_) + (self_.e2_ * right_dual.e431_) + (self_.e3_ * right_dual.e412_) + (self_.e4_ * right_dual.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * right_dual.e321_) + (self_.e31_ * right_dual.e412_), (self_.e42_ * right_dual.e321_) + (self_.e12_ * right_dual.e423_), (self_.e43_ * right_dual.e321_) + (self_.e23_ * right_dual.e431_), -(self_.e42_ * right_dual.e431_) - (self_.e43_ * right_dual.e412_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * right_dual_groups.group0_.yzxw) - (self_groups.group4_.yzxw * right_dual_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ (anti_wedge_groups.group1_.zxyw * other_groups.group0_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn multiVector_antiProjectViaHorizonOnto_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group4_
    );
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_wedge_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * anti_wedge_groups.group4_
    ));
}
fn origin_antiProjectViaHorizonOnto_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(pow(other.scalar, 2) * self_.e4_);
}
fn origin_antiProjectViaHorizonOnto_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let anti_wedge: Origin = Origin((other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)).w * self_.e4_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * anti_wedge.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
}
fn origin_antiProjectViaHorizonOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge: Origin = Origin(other.scalar * self_.e4_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * anti_wedge.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * anti_wedge.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    ));
}
fn origin_antiProjectViaHorizonOnto_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(pow(other.scalar, 2) * self_.e4_);
}
fn plane_antiProjectViaHorizonOnto_dualNum(self_: Plane, other: DualNum) -> Plane {
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(right_dual.e1234_ * self_.e423_, right_dual.e1234_ * self_.e431_, right_dual.e1234_ * self_.e412_, right_dual.e1234_ * self_.e321_)
    ));
}
fn plane_antiProjectViaHorizonOnto_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_dual_groups.group1_.yzxw * self_groups.group0_.zxyw) - (right_dual_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual.e321_ * self_.e423_, right_dual.e321_ * self_.e431_, right_dual.e321_ * self_.e412_, -(right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_)) - (self_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * anti_wedge.e23_) + (other.e423_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e31_) + (other.e431_ * anti_wedge.scalar), (other.e4_ * anti_wedge.e12_) + (other.e412_ * anti_wedge.scalar), -(other.e2_ * anti_wedge.e31_) - (other.e3_ * anti_wedge.e12_)) + vec4<f32>((other_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, other.e321_ * anti_wedge.scalar) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn plane_antiProjectViaHorizonOnto_horizon(self_: Plane, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn plane_antiProjectViaHorizonOnto_line(self_: Plane, other: Line) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * self_.e321_) + (right_dual.e31_ * self_.e412_), (right_dual.e42_ * self_.e321_) + (right_dual.e12_ * self_.e423_), (right_dual.e43_ * self_.e321_) + (right_dual.e23_ * self_.e431_), -(right_dual.e42_ * self_.e431_) - (right_dual.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn plane_antiProjectViaHorizonOnto_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * self_.e321_) + (right_dual.e31_ * self_.e412_), (right_dual.e42_ * self_.e321_) + (right_dual.e12_ * self_.e423_), (right_dual.e43_ * self_.e321_) + (right_dual.e23_ * self_.e431_), -(right_dual.e42_ * self_.e431_) - (right_dual.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e4_ * other.e23_) + (anti_wedge.e423_ * other.scalar), (anti_wedge.e4_ * other.e31_) + (anti_wedge.e431_ * other.scalar), (anti_wedge.e4_ * other.e12_) + (anti_wedge.e412_ * other.scalar), -(anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_)) + vec4<f32>((anti_wedge_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, anti_wedge.e321_ * other.scalar) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn plane_antiProjectViaHorizonOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * self_.e321_) + (right_dual.e31_ * self_.e412_), (right_dual.e42_ * self_.e321_) + (right_dual.e12_ * self_.e423_), (right_dual.e43_ * self_.e321_) + (right_dual.e23_ * self_.e431_), -(right_dual.e42_ * self_.e431_) - (right_dual.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)), 
        /* e41, e42, e43 */ (right_dual_groups.group4_.yzxw * self_groups.group0_.zxyw) - (right_dual_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn plane_antiProjectViaHorizonOnto_plane(self_: Plane, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_ * self_.e321_) * other_groups.group0_
    ));
}
fn plane_antiProjectViaHorizonOnto_point(self_: Plane, other: Point) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    let anti_wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (right_dual_groups.group0_.yzxw * self_groups.group0_.zxyw) - (right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)
    );
    let anti_wedge: Line = line_degroup(anti_wedge_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e31_ * other.e2_) - (anti_wedge.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn plane_antiProjectViaHorizonOnto_scalar(self_: Plane, other: Scalar) -> Plane {
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(right_dual.e1234_ * self_.e423_, right_dual.e1234_ * self_.e431_, right_dual.e1234_ * self_.e412_, right_dual.e1234_ * self_.e321_)
    ));
}
fn point_antiProjectViaHorizonOnto_dualNum(self_: Point, other: DualNum) -> Point {
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(right_dual.e1234_ * self_.e1_, right_dual.e1234_ * self_.e2_, right_dual.e1234_ * self_.e3_, right_dual.e1234_ * self_.e4_)
    ));
}
fn point_antiProjectViaHorizonOnto_flector(self_: Point, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let right_dual: Flector = flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    let anti_wedge: Scalar = Scalar((right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge.scalar) * other_groups.group1_
    ));
}
fn point_antiProjectViaHorizonOnto_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * anti_wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * anti_wedge.e3_) + (other.e23_ * anti_wedge.e4_), (other.e43_ * anti_wedge.e1_) + (other.e31_ * anti_wedge.e4_), (other.e41_ * anti_wedge.e2_) + (other.e12_ * anti_wedge.e4_), -(other.e31_ * anti_wedge.e2_) - (other.e12_ * anti_wedge.e3_)) - (anti_wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn point_antiProjectViaHorizonOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    ));
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(anti_wedge.scalar * other.scalar, (anti_wedge.scalar * other.e1234_) + (anti_wedge.e1234_ * other.scalar) + (anti_wedge.e423_ * other.e1_) + (anti_wedge.e431_ * other.e2_) + (anti_wedge.e412_ * other.e3_) + (anti_wedge.e321_ * other.e4_) - (anti_wedge.e1_ * other.e423_) - (anti_wedge.e2_ * other.e431_) - (anti_wedge.e3_ * other.e412_) - (anti_wedge.e4_ * other.e321_) - (anti_wedge.e41_ * other.e23_) - (anti_wedge.e42_ * other.e31_) - (anti_wedge.e43_ * other.e12_) - (anti_wedge.e23_ * other.e41_) - (anti_wedge.e31_ * other.e42_) - (anti_wedge.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * other_groups.group1_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_) - ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.zxyw * other_groups.group1_.yzxw) - (anti_wedge_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * other.e42_) + (anti_wedge.e4_ * other.e23_) + (anti_wedge.e42_ * other.e3_) + (anti_wedge.e23_ * other.e4_), (anti_wedge.e1_ * other.e43_) + (anti_wedge.e4_ * other.e31_) + (anti_wedge.e43_ * other.e1_) + (anti_wedge.e31_ * other.e4_), (anti_wedge.e2_ * other.e41_) + (anti_wedge.e4_ * other.e12_) + (anti_wedge.e41_ * other.e2_) + (anti_wedge.e12_ * other.e4_), -(anti_wedge.e1_ * other.e23_) - (anti_wedge.e2_ * other.e31_) - (anti_wedge.e3_ * other.e12_) - (anti_wedge.e12_ * other.e3_)) + (vec4<f32>(anti_wedge.scalar) * other_groups.group4_) + (vec4<f32>(other.scalar) * anti_wedge_groups.group4_) - (other_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((other_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * other.e2_)
    ));
}
fn point_antiProjectViaHorizonOnto_point(self_: Point, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_)) * other_groups.group0_
    ));
}
fn point_antiProjectViaHorizonOnto_scalar(self_: Point, other: Scalar) -> Point {
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(right_dual.e1234_ * self_.e1_, right_dual.e1234_ * self_.e2_, right_dual.e1234_ * self_.e3_, right_dual.e1234_ * self_.e4_)
    ));
}
fn scalar_antiProjectViaHorizonOnto_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_antiProjectViaHorizonOnto_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_wedge: Scalar = Scalar((other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)).w * self_.scalar);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(anti_wedge.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(anti_wedge.scalar) * other_groups.group1_
    ));
}
fn scalar_antiProjectViaHorizonOnto_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge: Scalar = Scalar(other.scalar * self_.scalar);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge.scalar) * other_groups.group4_
    ));
}
fn scalar_antiProjectViaHorizonOnto_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn antiScalar_antiRejectOrthogonallyFrom_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn antiScalar_antiRejectOrthogonallyFrom_motor(self_: AntiScalar, other: Motor) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_ * other.scalar) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_antiRejectOrthogonallyFrom_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge: AntiScalar = AntiScalar(self_.e1234_ * other.scalar);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, wedge.e1234_ * right_anti_dual.e1234_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_).xyz, 0.0)
    ));
}
fn antiScalar_antiRejectOrthogonallyFrom_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn dualNum_antiRejectOrthogonallyFrom_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0)
    ));
}
fn dualNum_antiRejectOrthogonallyFrom_flector(self_: DualNum, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_anti_dual_groups.group1_.yzxw * wedge_groups.group1_.zxyw) - (right_anti_dual_groups.group1_.zxyw * wedge_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_anti_dual_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_)) - (wedge_groups.group1_.wwwx * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e1_))
    ));
}
fn dualNum_antiRejectOrthogonallyFrom_horizon(self_: DualNum, other: Horizon) -> Scalar {
    return Scalar(self_.scalar * pow(other.e321_, 2));
}
fn dualNum_antiRejectOrthogonallyFrom_line(self_: DualNum, other: Line) -> Scalar {
    let other_groups = line_grouped(other);
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_));
}
fn dualNum_antiRejectOrthogonallyFrom_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar)) * vec4<f32>(other_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)).xyz, right_anti_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_))
    ));
}
fn dualNum_antiRejectOrthogonallyFrom_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn dualNum_antiRejectOrthogonallyFrom_plane(self_: DualNum, other: Plane) -> Scalar {
    return Scalar(self_.scalar * pow(other.e321_, 2));
}
fn dualNum_antiRejectOrthogonallyFrom_point(self_: DualNum, other: Point) -> Scalar {
    let other_groups = point_grouped(other);
    let wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return Scalar((right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_));
}
fn dualNum_antiRejectOrthogonallyFrom_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.scalar * other.scalar, self_.e1234_ * other.scalar, 0.0, 0.0)
    ));
}
fn flector_antiRejectOrthogonallyFrom_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_
    ));
}
fn flector_antiRejectOrthogonallyFrom_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group0_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn flector_antiRejectOrthogonallyFrom_horizon(self_: Flector, other: Horizon) -> Origin {
    return Origin(self_.e4_ * pow(other.e321_, 2) * -1.0);
}
fn flector_antiRejectOrthogonallyFrom_line(self_: Flector, other: Line) -> Point {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_), -(right_anti_dual.e42_ * wedge.e431_) - (right_anti_dual.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_))
    ));
}
fn flector_antiRejectOrthogonallyFrom_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e4_ * other.e23_) + (self_.e423_ * other.scalar), (self_.e4_ * other.e31_) + (self_.e431_ * other.scalar), (self_.e4_ * other.e12_) + (self_.e412_ * other.scalar), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) + vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, self_.e321_ * other.scalar) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e412_ * right_anti_dual.e31_) + (wedge.e321_ * right_anti_dual.e41_), (wedge.e423_ * right_anti_dual.e12_) + (wedge.e321_ * right_anti_dual.e42_), (wedge.e431_ * right_anti_dual.e23_) + (wedge.e321_ * right_anti_dual.e43_), -(wedge.e431_ * right_anti_dual.e42_) - (wedge.e412_ * right_anti_dual.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_) - (wedge_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_
    ));
}
fn flector_antiRejectOrthogonallyFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_) - (self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * other_groups.group1_.zxyw) - (self_groups.group0_.zxyw * other_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) + (vec4<f32>(other.scalar) * self_groups.group1_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn flector_antiRejectOrthogonallyFrom_plane(self_: Flector, other: Plane) -> Origin {
    return Origin(-(pow(other.e321_, 2) * self_.e4_) - (self_.e1_ * other.e423_ * other.e321_) - (self_.e2_ * other.e431_ * other.e321_) - (self_.e3_ * other.e412_ * other.e321_));
}
fn flector_antiRejectOrthogonallyFrom_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_ * other.e1_, self_.e4_ * other.e2_, self_.e4_ * other.e3_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (self_groups.group0_.zxyw * other_groups.group0_.yzxw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * right_anti_dual.e321_) + (wedge.e31_ * right_anti_dual.e412_), (wedge.e42_ * right_anti_dual.e321_) + (wedge.e12_ * right_anti_dual.e423_), (wedge.e43_ * right_anti_dual.e321_) + (wedge.e23_ * right_anti_dual.e431_), -(wedge.e42_ * right_anti_dual.e431_) - (wedge.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn flector_antiRejectOrthogonallyFrom_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_
    ));
}
fn horizon_antiRejectOrthogonallyFrom_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(pow(other.scalar, 2) * self_.e321_);
}
fn horizon_antiRejectOrthogonallyFrom_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge: AntiScalar = AntiScalar(other.e4_ * self_.e321_ * -1.0);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0)
    ));
}
fn horizon_antiRejectOrthogonallyFrom_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let wedge: Horizon = Horizon(self_.e321_ * other.scalar);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, wedge.e321_ * right_anti_dual.e1234_)
    ));
}
fn horizon_antiRejectOrthogonallyFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * other.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.scalar)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn horizon_antiRejectOrthogonallyFrom_point(self_: Horizon, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_ * other.e4_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_antiRejectOrthogonallyFrom_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.e321_ * pow(other.scalar, 2));
}
fn line_antiRejectOrthogonallyFrom_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group1_
    ));
}
fn line_antiRejectOrthogonallyFrom_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_anti_dual_groups.group1_.yzxw * wedge_groups.group0_.zxyw) - (right_anti_dual_groups.group1_.zxyw * wedge_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(right_anti_dual.e321_ * wedge.e423_, right_anti_dual.e321_ * wedge.e431_, right_anti_dual.e321_ * wedge.e412_, -(right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_)) - (wedge_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e1_))
    ));
}
fn line_antiRejectOrthogonallyFrom_line(self_: Line, other: Line) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_antiRejectOrthogonallyFrom_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group1_.xyz, 0.0) * vec4<f32>(other_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)).xyz, right_anti_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_))
    ));
}
fn line_antiRejectOrthogonallyFrom_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn line_antiRejectOrthogonallyFrom_point(self_: Line, other: Point) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (right_anti_dual_groups.group0_.yzxw * wedge_groups.group0_.zxyw) - (right_anti_dual_groups.group0_.zxyw * wedge_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)
    ));
}
fn line_antiRejectOrthogonallyFrom_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group1_
    ));
}
fn motor_antiRejectOrthogonallyFrom_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar)) * vec4<f32>(self_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_
    ));
}
fn motor_antiRejectOrthogonallyFrom_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e23_) + (other.e423_ * self_.scalar), (other.e4_ * self_.e31_) + (other.e431_ * self_.scalar), (other.e4_ * self_.e12_) + (other.e412_ * self_.scalar), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) + vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, other.e321_ * self_.scalar) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_anti_dual_groups.group1_.yzxw * wedge_groups.group1_.zxyw) - (right_anti_dual_groups.group1_.zxyw * wedge_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_anti_dual_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_)) - (wedge_groups.group1_.wwwx * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e1_))
    ));
}
fn motor_antiRejectOrthogonallyFrom_horizon(self_: Motor, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn motor_antiRejectOrthogonallyFrom_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.xyz, 0.0) * vec4<f32>(self_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_))
    ));
}
fn motor_antiRejectOrthogonallyFrom_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(self_.scalar) * other_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, other.scalar * self_.scalar)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)).xyz, right_anti_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_))
    ));
}
fn motor_antiRejectOrthogonallyFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.e1234_ * other.scalar) + (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * other.e4_) + (self_.scalar * other.e423_), (self_.e31_ * other.e4_) + (self_.scalar * other.e431_), (self_.e12_ * other.e4_) + (self_.scalar * other.e412_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group1_.zxyw).xyz, self_.scalar * other.e321_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn motor_antiRejectOrthogonallyFrom_plane(self_: Motor, other: Plane) -> Scalar {
    return Scalar(self_.scalar * pow(other.e321_, 2));
}
fn motor_antiRejectOrthogonallyFrom_point(self_: Motor, other: Point) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((wedge_groups.group1_.zxyw * right_anti_dual_groups.group0_.yzxw) - (wedge_groups.group1_.yzxw * right_anti_dual_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(wedge.e321_ * right_anti_dual.e423_ * -1.0, wedge.e321_ * right_anti_dual.e431_ * -1.0, wedge.e321_ * right_anti_dual.e412_ * -1.0, (wedge.e2_ * right_anti_dual.e431_) + (wedge.e3_ * right_anti_dual.e412_) + (wedge.e4_ * right_anti_dual.e321_)) + (right_anti_dual_groups.group0_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn motor_antiRejectOrthogonallyFrom_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * wedge_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group1_.yzxw) - (other_groups.group0_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) + (vec4<f32>(self_.scalar) * other_groups.group1_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group0_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (right_anti_dual_groups.group1_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group1_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge_groups.group0_.yyzw.xy, wedge.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.scalar)
    ));
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(wedge.e321_ * right_anti_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, wedge.e1234_ * right_anti_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_), -(right_anti_dual.e42_ * wedge.e431_) - (right_anti_dual.e43_ * wedge.e412_)) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.e1234_ * self_.scalar) + (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e23_ * self_.e4_) + (other.scalar * self_.e423_), (other.e31_ * self_.e4_) + (other.scalar * self_.e431_), (other.e12_ * self_.e4_) + (other.scalar * self_.e412_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) + vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.scalar * self_.e321_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.scalar * wedge.e1234_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e1234_ * wedge.e1_) + (right_anti_dual.e31_ * wedge.e412_), (right_anti_dual.e1234_ * wedge.e2_) + (right_anti_dual.e12_ * wedge.e423_), (right_anti_dual.e1234_ * wedge.e3_) + (right_anti_dual.e23_ * wedge.e431_), -(right_anti_dual.e42_ * wedge.e431_) - (right_anti_dual.e43_ * wedge.e412_)) + (right_anti_dual_groups.group0_ * vec4<f32>(wedge_groups.group4_.wwww.xyz, wedge.e4_)) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar) + (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.scalar) * self_groups.group1_) + (vec4<f32>(self_.scalar) * other_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - (other_groups.group1_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e1_ * self_.e23_) - (other.e2_ * self_.e31_) - (other.e3_ * self_.e12_) - (other.e12_ * self_.e3_)) + (vec4<f32>(other.scalar) * self_groups.group4_) + (vec4<f32>(self_.scalar) * other_groups.group4_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e31_ * self_.e2_)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    let wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(wedge.e321_ * right_anti_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, wedge.e1234_ * right_anti_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((wedge.e1_ * right_anti_dual.e423_) + (wedge.e2_ * right_anti_dual.e431_) + (wedge.e3_ * right_anti_dual.e412_) + (wedge.e4_ * right_anti_dual.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * right_anti_dual.e321_) + (wedge.e31_ * right_anti_dual.e412_), (wedge.e42_ * right_anti_dual.e321_) + (wedge.e12_ * right_anti_dual.e423_), (wedge.e43_ * right_anti_dual.e321_) + (wedge.e23_ * right_anti_dual.e431_), -(wedge.e42_ * right_anti_dual.e431_) - (wedge.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (wedge_groups.group4_.zxyw * right_anti_dual_groups.group0_.yzxw) - (wedge_groups.group4_.yzxw * right_anti_dual_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge_groups.group0_.yyzw.xy, wedge.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_antiRejectOrthogonallyFrom_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    );
    let right_anti_dual: AntiScalar = AntiScalar(other.scalar);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * wedge_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_
    ));
}
fn origin_antiRejectOrthogonallyFrom_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(pow(other.scalar, 2) * self_.e4_);
}
fn origin_antiRejectOrthogonallyFrom_flector(self_: Origin, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group0_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn origin_antiRejectOrthogonallyFrom_horizon(self_: Origin, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn origin_antiRejectOrthogonallyFrom_line(self_: Origin, other: Line) -> Origin {
    let other_groups = line_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Origin(-(right_anti_dual.e41_ * wedge.e423_) - (right_anti_dual.e42_ * wedge.e431_) - (right_anti_dual.e43_ * wedge.e412_));
}
fn origin_antiRejectOrthogonallyFrom_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e412_ * right_anti_dual.e31_) + (wedge.e321_ * right_anti_dual.e41_), (wedge.e423_ * right_anti_dual.e12_) + (wedge.e321_ * right_anti_dual.e42_), (wedge.e431_ * right_anti_dual.e23_) + (wedge.e321_ * right_anti_dual.e43_), -(wedge.e431_ * right_anti_dual.e42_) - (wedge.e412_ * right_anti_dual.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_) - (wedge_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn origin_antiRejectOrthogonallyFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_)).xyz, 0.0)
    ));
}
fn origin_antiRejectOrthogonallyFrom_plane(self_: Origin, other: Plane) -> Origin {
    return Origin(self_.e4_ * pow(other.e321_, 2) * -1.0);
}
fn origin_antiRejectOrthogonallyFrom_point(self_: Origin, other: Point) -> Origin {
    let other_groups = point_grouped(other);
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return Origin(-(wedge.e41_ * right_anti_dual.e423_) - (wedge.e42_ * right_anti_dual.e431_) - (wedge.e43_ * right_anti_dual.e412_));
}
fn origin_antiRejectOrthogonallyFrom_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.e4_ * pow(other.scalar, 2));
}
fn plane_antiRejectOrthogonallyFrom_dualNum(self_: Plane, other: DualNum) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(other.scalar * self_.e423_, other.scalar * self_.e431_, other.scalar * self_.e412_, other.scalar * self_.e321_)
    ));
}
fn plane_antiRejectOrthogonallyFrom_flector(self_: Plane, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge: AntiScalar = AntiScalar(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_));
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0)
    ));
}
fn plane_antiRejectOrthogonallyFrom_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_), -(right_anti_dual.e42_ * wedge.e431_) - (right_anti_dual.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_
    ));
}
fn plane_antiRejectOrthogonallyFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn plane_antiRejectOrthogonallyFrom_point(self_: Plane, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn plane_antiRejectOrthogonallyFrom_scalar(self_: Plane, other: Scalar) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(self_.e423_ * other.scalar, self_.e431_ * other.scalar, self_.e412_ * other.scalar, self_.e321_ * other.scalar)
    ));
}
fn point_antiRejectOrthogonallyFrom_dualNum(self_: Point, other: DualNum) -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(other.scalar * self_.e1_, other.scalar * self_.e2_, other.scalar * self_.e3_, other.scalar * self_.e4_)
    ));
}
fn point_antiRejectOrthogonallyFrom_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_ * self_.e1_ * -1.0, other.e4_ * self_.e2_ * -1.0, other.e4_ * self_.e3_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group0_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn point_antiRejectOrthogonallyFrom_horizon(self_: Point, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn point_antiRejectOrthogonallyFrom_line(self_: Point, other: Line) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_), -(right_anti_dual.e42_ * wedge.e431_) - (right_anti_dual.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_))
    ));
}
fn point_antiRejectOrthogonallyFrom_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e412_ * right_anti_dual.e31_) + (wedge.e321_ * right_anti_dual.e41_), (wedge.e423_ * right_anti_dual.e12_) + (wedge.e321_ * right_anti_dual.e42_), (wedge.e431_ * right_anti_dual.e23_) + (wedge.e321_ * right_anti_dual.e43_), -(wedge.e431_ * right_anti_dual.e42_) - (wedge.e412_ * right_anti_dual.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group0_) - (wedge_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group1_.zxyw.xyz, right_anti_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_
    ));
}
fn point_antiRejectOrthogonallyFrom_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn point_antiRejectOrthogonallyFrom_plane(self_: Point, other: Plane) -> Origin {
    return Origin(-(pow(other.e321_, 2) * self_.e4_) - (other.e423_ * other.e321_ * self_.e1_) - (other.e431_ * other.e321_ * self_.e2_) - (other.e412_ * other.e321_ * self_.e3_));
}
fn point_antiRejectOrthogonallyFrom_point(self_: Point, other: Point) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)
    );
    let wedge: Line = line_degroup(wedge_groups);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * right_anti_dual.e321_) + (wedge.e31_ * right_anti_dual.e412_), (wedge.e42_ * right_anti_dual.e321_) + (wedge.e12_ * right_anti_dual.e423_), (wedge.e43_ * right_anti_dual.e321_) + (wedge.e23_ * right_anti_dual.e431_), -(wedge.e42_ * right_anti_dual.e431_) - (wedge.e43_ * right_anti_dual.e412_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_))
    ));
}
fn point_antiRejectOrthogonallyFrom_scalar(self_: Point, other: Scalar) -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(self_.e1_ * other.scalar, self_.e2_ * other.scalar, self_.e3_ * other.scalar, self_.e4_ * other.scalar)
    ));
}
fn scalar_antiRejectOrthogonallyFrom_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar * self_.scalar, other.e1234_ * self_.scalar, 0.0, 0.0)
    ));
}
fn scalar_antiRejectOrthogonallyFrom_flector(self_: Scalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_anti_dual_groups.group1_.yzxw * wedge_groups.group1_.zxyw) - (right_anti_dual_groups.group1_.zxyw * wedge_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_anti_dual_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_)) - (wedge_groups.group1_.wwwx * vec4<f32>(right_anti_dual_groups.group1_.xyz, right_anti_dual.e1_))
    ));
}
fn scalar_antiRejectOrthogonallyFrom_horizon(self_: Scalar, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_antiRejectOrthogonallyFrom_line(self_: Scalar, other: Line) -> Scalar {
    let other_groups = line_grouped(other);
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_));
}
fn scalar_antiRejectOrthogonallyFrom_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_)).xyz, right_anti_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_))
    ));
}
fn scalar_antiRejectOrthogonallyFrom_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_anti_dual.scalar * wedge.e1234_) + (right_anti_dual.e1234_ * wedge.scalar) + (right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_) - (right_anti_dual.e1_ * wedge.e423_) - (right_anti_dual.e2_ * wedge.e431_) - (right_anti_dual.e3_ * wedge.e412_) - (right_anti_dual.e4_ * wedge.e321_) - (right_anti_dual.e41_ * wedge.e23_) - (right_anti_dual.e42_ * wedge.e31_) - (right_anti_dual.e43_ * wedge.e12_) - (right_anti_dual.e23_ * wedge.e41_) - (right_anti_dual.e31_ * wedge.e42_) - (right_anti_dual.e12_ * wedge.e43_), right_anti_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e41_ * wedge.e321_) + (right_anti_dual.e31_ * wedge.e412_) + (right_anti_dual.e412_ * wedge.e31_) + (right_anti_dual.e321_ * wedge.e41_), (right_anti_dual.e42_ * wedge.e321_) + (right_anti_dual.e12_ * wedge.e423_) + (right_anti_dual.e423_ * wedge.e12_) + (right_anti_dual.e321_ * wedge.e42_), (right_anti_dual.e43_ * wedge.e321_) + (right_anti_dual.e23_ * wedge.e431_) + (right_anti_dual.e431_ * wedge.e23_) + (right_anti_dual.e321_ * wedge.e43_), -(right_anti_dual.e43_ * wedge.e412_) - (right_anti_dual.e423_ * wedge.e41_) - (right_anti_dual.e431_ * wedge.e42_) - (right_anti_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_anti_dual_groups.group3_.zxyw.xyz, right_anti_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_anti_dual_groups.group4_.yzxw).xyz, right_anti_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + (right_anti_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_anti_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_anti_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_anti_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_anti_dual_groups.group4_)
    ));
}
fn scalar_antiRejectOrthogonallyFrom_plane(self_: Scalar, other: Plane) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_antiRejectOrthogonallyFrom_point(self_: Scalar, other: Point) -> Scalar {
    let other_groups = point_grouped(other);
    let wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return Scalar((right_anti_dual.e423_ * wedge.e1_) + (right_anti_dual.e431_ * wedge.e2_) + (right_anti_dual.e412_ * wedge.e3_) + (right_anti_dual.e321_ * wedge.e4_));
}
fn scalar_antiRejectOrthogonallyFrom_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn antiScalar_antiRejectViaHorizonFrom_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn antiScalar_antiRejectViaHorizonFrom_motor(self_: AntiScalar, other: Motor) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_ * other.scalar) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_antiRejectViaHorizonFrom_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge: AntiScalar = AntiScalar(self_.e1234_ * other.scalar);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, wedge.e1234_ * right_dual.e1234_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_).xyz, 0.0)
    ));
}
fn antiScalar_antiRejectViaHorizonFrom_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn dualNum_antiRejectViaHorizonFrom_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0)
    ));
}
fn dualNum_antiRejectViaHorizonFrom_flector(self_: DualNum, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_dual_groups.group1_.yzxw * wedge_groups.group1_.zxyw) - (right_dual_groups.group1_.zxyw * wedge_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_dual_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_)) - (wedge_groups.group1_.wwwx * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e1_))
    ));
}
fn dualNum_antiRejectViaHorizonFrom_horizon(self_: DualNum, other: Horizon) -> Scalar {
    return Scalar(self_.scalar * pow(other.e321_, 2));
}
fn dualNum_antiRejectViaHorizonFrom_line(self_: DualNum, other: Line) -> Scalar {
    let other_groups = line_grouped(other);
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_));
}
fn dualNum_antiRejectViaHorizonFrom_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar)) * vec4<f32>(other_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)).xyz, right_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_))
    ));
}
fn dualNum_antiRejectViaHorizonFrom_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn dualNum_antiRejectViaHorizonFrom_plane(self_: DualNum, other: Plane) -> Scalar {
    return Scalar(self_.scalar * pow(other.e321_, 2));
}
fn dualNum_antiRejectViaHorizonFrom_point(self_: DualNum, other: Point) -> Scalar {
    let other_groups = point_grouped(other);
    let wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return Scalar((right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_));
}
fn dualNum_antiRejectViaHorizonFrom_scalar(self_: DualNum, other: Scalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.scalar * other.scalar, self_.e1234_ * other.scalar, 0.0, 0.0)
    ));
}
fn flector_antiRejectViaHorizonFrom_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_
    ));
}
fn flector_antiRejectViaHorizonFrom_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group0_) - (right_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn flector_antiRejectViaHorizonFrom_horizon(self_: Flector, other: Horizon) -> Origin {
    return Origin(self_.e4_ * pow(other.e321_, 2) * -1.0);
}
fn flector_antiRejectViaHorizonFrom_line(self_: Flector, other: Line) -> Point {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_), -(right_dual.e42_ * wedge.e431_) - (right_dual.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_))
    ));
}
fn flector_antiRejectViaHorizonFrom_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e4_ * other.e23_) + (self_.e423_ * other.scalar), (self_.e4_ * other.e31_) + (self_.e431_ * other.scalar), (self_.e4_ * other.e12_) + (self_.e412_ * other.scalar), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) + vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, self_.e321_ * other.scalar) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e412_ * right_dual.e31_) + (wedge.e321_ * right_dual.e41_), (wedge.e423_ * right_dual.e12_) + (wedge.e321_ * right_dual.e42_), (wedge.e431_ * right_dual.e23_) + (wedge.e321_ * right_dual.e43_), -(wedge.e431_ * right_dual.e42_) - (wedge.e412_ * right_dual.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group0_) - (wedge_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_
    ));
}
fn flector_antiRejectViaHorizonFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_) - (self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * other_groups.group1_.zxyw) - (self_groups.group0_.zxyw * other_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) + (vec4<f32>(other.scalar) * self_groups.group1_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn flector_antiRejectViaHorizonFrom_plane(self_: Flector, other: Plane) -> Origin {
    return Origin(-(pow(other.e321_, 2) * self_.e4_) - (self_.e1_ * other.e423_ * other.e321_) - (self_.e2_ * other.e431_ * other.e321_) - (self_.e3_ * other.e412_ * other.e321_));
}
fn flector_antiRejectViaHorizonFrom_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_ * other.e1_, self_.e4_ * other.e2_, self_.e4_ * other.e3_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (self_groups.group0_.zxyw * other_groups.group0_.yzxw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * right_dual.e321_) + (wedge.e31_ * right_dual.e412_), (wedge.e42_ * right_dual.e321_) + (wedge.e12_ * right_dual.e423_), (wedge.e43_ * right_dual.e321_) + (wedge.e23_ * right_dual.e431_), -(wedge.e42_ * right_dual.e431_) - (wedge.e43_ * right_dual.e412_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn flector_antiRejectViaHorizonFrom_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_
    ));
}
fn horizon_antiRejectViaHorizonFrom_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(pow(other.scalar, 2) * self_.e321_);
}
fn horizon_antiRejectViaHorizonFrom_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge: AntiScalar = AntiScalar(other.e4_ * self_.e321_ * -1.0);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0)
    ));
}
fn horizon_antiRejectViaHorizonFrom_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let wedge: Horizon = Horizon(self_.e321_ * other.scalar);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, wedge.e321_ * right_dual.e1234_)
    ));
}
fn horizon_antiRejectViaHorizonFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * other.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.scalar)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn horizon_antiRejectViaHorizonFrom_point(self_: Horizon, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_ * other.e4_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_antiRejectViaHorizonFrom_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.e321_ * pow(other.scalar, 2));
}
fn line_antiRejectViaHorizonFrom_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group1_
    ));
}
fn line_antiRejectViaHorizonFrom_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_dual_groups.group1_.yzxw * wedge_groups.group0_.zxyw) - (right_dual_groups.group1_.zxyw * wedge_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual.e321_ * wedge.e423_, right_dual.e321_ * wedge.e431_, right_dual.e321_ * wedge.e412_, -(right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_)) - (wedge_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e1_))
    ));
}
fn line_antiRejectViaHorizonFrom_line(self_: Line, other: Line) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_antiRejectViaHorizonFrom_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group1_.xyz, 0.0) * vec4<f32>(other_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)).xyz, right_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_))
    ));
}
fn line_antiRejectViaHorizonFrom_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn line_antiRejectViaHorizonFrom_point(self_: Line, other: Point) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (right_dual_groups.group0_.yzxw * wedge_groups.group0_.zxyw) - (right_dual_groups.group0_.zxyw * wedge_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)
    ));
}
fn line_antiRejectViaHorizonFrom_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group1_
    ));
}
fn motor_antiRejectViaHorizonFrom_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar)) * vec4<f32>(self_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_
    ));
}
fn motor_antiRejectViaHorizonFrom_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e23_) + (other.e423_ * self_.scalar), (other.e4_ * self_.e31_) + (other.e431_ * self_.scalar), (other.e4_ * self_.e12_) + (other.e412_ * self_.scalar), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) + vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, other.e321_ * self_.scalar) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_dual_groups.group1_.yzxw * wedge_groups.group1_.zxyw) - (right_dual_groups.group1_.zxyw * wedge_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_dual_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_)) - (wedge_groups.group1_.wwwx * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e1_))
    ));
}
fn motor_antiRejectViaHorizonFrom_horizon(self_: Motor, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn motor_antiRejectViaHorizonFrom_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.xyz, 0.0) * vec4<f32>(self_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_))
    ));
}
fn motor_antiRejectViaHorizonFrom_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(self_.scalar) * other_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, other.scalar * self_.scalar)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)).xyz, right_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_))
    ));
}
fn motor_antiRejectViaHorizonFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.e1234_ * other.scalar) + (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * other.e4_) + (self_.scalar * other.e423_), (self_.e31_ * other.e4_) + (self_.scalar * other.e431_), (self_.e12_ * other.e4_) + (self_.scalar * other.e412_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group1_.zxyw).xyz, self_.scalar * other.e321_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn motor_antiRejectViaHorizonFrom_plane(self_: Motor, other: Plane) -> Scalar {
    return Scalar(self_.scalar * pow(other.e321_, 2));
}
fn motor_antiRejectViaHorizonFrom_point(self_: Motor, other: Point) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((wedge_groups.group1_.zxyw * right_dual_groups.group0_.yzxw) - (wedge_groups.group1_.yzxw * right_dual_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(wedge.e321_ * right_dual.e423_ * -1.0, wedge.e321_ * right_dual.e431_ * -1.0, wedge.e321_ * right_dual.e412_ * -1.0, (wedge.e2_ * right_dual.e431_) + (wedge.e3_ * right_dual.e412_) + (wedge.e4_ * right_dual.e321_)) + (right_dual_groups.group0_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn motor_antiRejectViaHorizonFrom_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_
    ));
}
fn multiVector_antiRejectViaHorizonFrom_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * wedge_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group4_
    ));
}
fn multiVector_antiRejectViaHorizonFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group1_.yzxw) - (other_groups.group0_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) + (vec4<f32>(self_.scalar) * other_groups.group1_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group0_) - (right_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (right_dual_groups.group1_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group1_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge_groups.group0_.yyzw.xy, wedge.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_antiRejectViaHorizonFrom_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.scalar)
    ));
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(wedge.e321_ * right_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, wedge.e1234_ * right_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiRejectViaHorizonFrom_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_), -(right_dual.e42_ * wedge.e431_) - (right_dual.e43_ * wedge.e412_)) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiRejectViaHorizonFrom_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.e1234_ * self_.scalar) + (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e23_ * self_.e4_) + (other.scalar * self_.e423_), (other.e31_ * self_.e4_) + (other.scalar * self_.e431_), (other.e12_ * self_.e4_) + (other.scalar * self_.e412_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) + vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.scalar * self_.e321_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.e1234_ * wedge.scalar) + (right_dual.scalar * wedge.e1234_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e1234_ * wedge.e1_) + (right_dual.e31_ * wedge.e412_), (right_dual.e1234_ * wedge.e2_) + (right_dual.e12_ * wedge.e423_), (right_dual.e1234_ * wedge.e3_) + (right_dual.e23_ * wedge.e431_), -(right_dual.e42_ * wedge.e431_) - (right_dual.e43_ * wedge.e412_)) + (right_dual_groups.group0_ * vec4<f32>(wedge_groups.group4_.wwww.xyz, wedge.e4_)) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group4_
    ));
}
fn multiVector_antiRejectViaHorizonFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar) + (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.scalar) * self_groups.group1_) + (vec4<f32>(self_.scalar) * other_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - (other_groups.group1_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e1_ * self_.e23_) - (other.e2_ * self_.e31_) - (other.e3_ * self_.e12_) - (other.e12_ * self_.e3_)) + (vec4<f32>(other.scalar) * self_groups.group4_) + (vec4<f32>(self_.scalar) * other_groups.group4_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e31_ * self_.e2_)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn multiVector_antiRejectViaHorizonFrom_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    let wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(wedge.e321_ * right_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, wedge.e1234_ * right_dual.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiRejectViaHorizonFrom_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((wedge.e1_ * right_dual.e423_) + (wedge.e2_ * right_dual.e431_) + (wedge.e3_ * right_dual.e412_) + (wedge.e4_ * right_dual.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * right_dual.e321_) + (wedge.e31_ * right_dual.e412_), (wedge.e42_ * right_dual.e321_) + (wedge.e12_ * right_dual.e423_), (wedge.e43_ * right_dual.e321_) + (wedge.e23_ * right_dual.e431_), -(wedge.e42_ * right_dual.e431_) - (wedge.e43_ * right_dual.e412_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (wedge_groups.group4_.zxyw * right_dual_groups.group0_.yzxw) - (wedge_groups.group4_.yzxw * right_dual_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge_groups.group0_.yyzw.xy, wedge.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_antiRejectViaHorizonFrom_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    );
    let right_dual: AntiScalar = AntiScalar(other.scalar);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * wedge_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group4_
    ));
}
fn origin_antiRejectViaHorizonFrom_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(pow(other.scalar, 2) * self_.e4_);
}
fn origin_antiRejectViaHorizonFrom_flector(self_: Origin, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group0_) - (right_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn origin_antiRejectViaHorizonFrom_horizon(self_: Origin, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn origin_antiRejectViaHorizonFrom_line(self_: Origin, other: Line) -> Origin {
    let other_groups = line_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Origin(-(right_dual.e41_ * wedge.e423_) - (right_dual.e42_ * wedge.e431_) - (right_dual.e43_ * wedge.e412_));
}
fn origin_antiRejectViaHorizonFrom_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e412_ * right_dual.e31_) + (wedge.e321_ * right_dual.e41_), (wedge.e423_ * right_dual.e12_) + (wedge.e321_ * right_dual.e42_), (wedge.e431_ * right_dual.e23_) + (wedge.e321_ * right_dual.e43_), -(wedge.e431_ * right_dual.e42_) - (wedge.e412_ * right_dual.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group0_) - (wedge_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn origin_antiRejectViaHorizonFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_)).xyz, 0.0)
    ));
}
fn origin_antiRejectViaHorizonFrom_plane(self_: Origin, other: Plane) -> Origin {
    return Origin(self_.e4_ * pow(other.e321_, 2) * -1.0);
}
fn origin_antiRejectViaHorizonFrom_point(self_: Origin, other: Point) -> Origin {
    let other_groups = point_grouped(other);
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return Origin(-(wedge.e41_ * right_dual.e423_) - (wedge.e42_ * right_dual.e431_) - (wedge.e43_ * right_dual.e412_));
}
fn origin_antiRejectViaHorizonFrom_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.e4_ * pow(other.scalar, 2));
}
fn plane_antiRejectViaHorizonFrom_dualNum(self_: Plane, other: DualNum) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(other.scalar * self_.e423_, other.scalar * self_.e431_, other.scalar * self_.e412_, other.scalar * self_.e321_)
    ));
}
fn plane_antiRejectViaHorizonFrom_flector(self_: Plane, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge: AntiScalar = AntiScalar(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_));
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0)
    ));
}
fn plane_antiRejectViaHorizonFrom_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_), -(right_dual.e42_ * wedge.e431_) - (right_dual.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group0_
    ));
}
fn plane_antiRejectViaHorizonFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn plane_antiRejectViaHorizonFrom_point(self_: Plane, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn plane_antiRejectViaHorizonFrom_scalar(self_: Plane, other: Scalar) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * vec4<f32>(self_.e423_ * other.scalar, self_.e431_ * other.scalar, self_.e412_ * other.scalar, self_.e321_ * other.scalar)
    ));
}
fn point_antiRejectViaHorizonFrom_dualNum(self_: Point, other: DualNum) -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(other.scalar * self_.e1_, other.scalar * self_.e2_, other.scalar * self_.e3_, other.scalar * self_.e4_)
    ));
}
fn point_antiRejectViaHorizonFrom_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_ * self_.e1_ * -1.0, other.e4_ * self_.e2_ * -1.0, other.e4_ * self_.e3_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group0_) - (right_dual_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn point_antiRejectViaHorizonFrom_horizon(self_: Point, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn point_antiRejectViaHorizonFrom_line(self_: Point, other: Line) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_), -(right_dual.e42_ * wedge.e431_) - (right_dual.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_))
    ));
}
fn point_antiRejectViaHorizonFrom_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e412_ * right_dual.e31_) + (wedge.e321_ * right_dual.e41_), (wedge.e423_ * right_dual.e12_) + (wedge.e321_ * right_dual.e42_), (wedge.e431_ * right_dual.e23_) + (wedge.e321_ * right_dual.e43_), -(wedge.e431_ * right_dual.e42_) - (wedge.e412_ * right_dual.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group0_) - (wedge_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group1_.zxyw.xyz, right_dual.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(right_dual.e1234_) * wedge_groups.group1_
    ));
}
fn point_antiRejectViaHorizonFrom_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn point_antiRejectViaHorizonFrom_plane(self_: Point, other: Plane) -> Origin {
    return Origin(-(pow(other.e321_, 2) * self_.e4_) - (other.e423_ * other.e321_ * self_.e1_) - (other.e431_ * other.e321_ * self_.e2_) - (other.e412_ * other.e321_ * self_.e3_));
}
fn point_antiRejectViaHorizonFrom_point(self_: Point, other: Point) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)
    );
    let wedge: Line = line_degroup(wedge_groups);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * right_dual.e321_) + (wedge.e31_ * right_dual.e412_), (wedge.e42_ * right_dual.e321_) + (wedge.e12_ * right_dual.e423_), (wedge.e43_ * right_dual.e321_) + (wedge.e23_ * right_dual.e431_), -(wedge.e42_ * right_dual.e431_) - (wedge.e43_ * right_dual.e412_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_))
    ));
}
fn point_antiRejectViaHorizonFrom_scalar(self_: Point, other: Scalar) -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * vec4<f32>(self_.e1_ * other.scalar, self_.e2_ * other.scalar, self_.e3_ * other.scalar, self_.e4_ * other.scalar)
    ));
}
fn scalar_antiRejectViaHorizonFrom_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar * self_.scalar, other.e1234_ * self_.scalar, 0.0, 0.0)
    ));
}
fn scalar_antiRejectViaHorizonFrom_flector(self_: Scalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((right_dual_groups.group1_.yzxw * wedge_groups.group1_.zxyw) - (right_dual_groups.group1_.zxyw * wedge_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (right_dual_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_)) - (wedge_groups.group1_.wwwx * vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e1_))
    ));
}
fn scalar_antiRejectViaHorizonFrom_horizon(self_: Scalar, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_antiRejectViaHorizonFrom_line(self_: Scalar, other: Line) -> Scalar {
    let other_groups = line_grouped(other);
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_));
}
fn scalar_antiRejectViaHorizonFrom_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_)).xyz, right_dual.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_))
    ));
}
fn scalar_antiRejectViaHorizonFrom_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((right_dual.scalar * wedge.e1234_) + (right_dual.e1234_ * wedge.scalar) + (right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_) - (right_dual.e1_ * wedge.e423_) - (right_dual.e2_ * wedge.e431_) - (right_dual.e3_ * wedge.e412_) - (right_dual.e4_ * wedge.e321_) - (right_dual.e41_ * wedge.e23_) - (right_dual.e42_ * wedge.e31_) - (right_dual.e43_ * wedge.e12_) - (right_dual.e23_ * wedge.e41_) - (right_dual.e31_ * wedge.e42_) - (right_dual.e12_ * wedge.e43_), right_dual.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e41_ * wedge.e321_) + (right_dual.e31_ * wedge.e412_) + (right_dual.e412_ * wedge.e31_) + (right_dual.e321_ * wedge.e41_), (right_dual.e42_ * wedge.e321_) + (right_dual.e12_ * wedge.e423_) + (right_dual.e423_ * wedge.e12_) + (right_dual.e321_ * wedge.e42_), (right_dual.e43_ * wedge.e321_) + (right_dual.e23_ * wedge.e431_) + (right_dual.e431_ * wedge.e23_) + (right_dual.e321_ * wedge.e43_), -(right_dual.e43_ * wedge.e412_) - (right_dual.e423_ * wedge.e41_) - (right_dual.e431_ * wedge.e42_) - (right_dual.e412_ * wedge.e43_)) + (vec4<f32>(right_dual.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(right_dual_groups.group3_.zxyw.xyz, right_dual.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * right_dual_groups.group4_.yzxw).xyz, right_dual.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + (right_dual_groups.group4_.yzxw * wedge_groups.group4_.zxyw) - (right_dual_groups.group4_.zxyw * wedge_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(right_dual.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) - ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(right_dual.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * right_dual_groups.group4_)
    ));
}
fn scalar_antiRejectViaHorizonFrom_plane(self_: Scalar, other: Plane) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_antiRejectViaHorizonFrom_point(self_: Scalar, other: Point) -> Scalar {
    let other_groups = point_grouped(other);
    let wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return Scalar((right_dual.e423_ * wedge.e1_) + (right_dual.e431_ * wedge.e2_) + (right_dual.e412_ * wedge.e3_) + (right_dual.e321_ * wedge.e4_));
}
fn scalar_antiRejectViaHorizonFrom_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn antiScalar_antiReverse(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_antiReverse(self_: DualNum) -> DualNum {
    return self_;
}
fn flector_antiReverse(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn horizon_antiReverse(self_: Horizon) -> Horizon {
    return self_;
}
fn line_antiReverse(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn motor_antiReverse(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_antiReverse(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn origin_antiReverse(self_: Origin) -> Origin {
    return Origin(self_.e4_ * -1.0);
}
fn plane_antiReverse(self_: Plane) -> Plane {
    return self_;
}
fn point_antiReverse(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_antiReverse(self_: Scalar) -> Scalar {
    return self_;
}
fn antiScalar_antiSquareRoot(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(pow(self_.e1234_, 0.5));
}
fn dualNum_antiSupport(self_: DualNum) -> Horizon {
    return Horizon(self_.scalar);
}
fn flector_antiSupport(self_: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(right_dual_groups.group1_.xyz, right_dual.e4_) * vec4<f32>(-1.0)
    ));
}
fn horizon_antiSupport(self_: Horizon) -> Scalar {
    return Scalar(self_.e321_);
}
fn line_antiSupport(self_: Line) -> Point {
    let self_groups = line_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn motor_antiSupport(self_: Motor) -> Flector {
    let self_groups = motor_grouped(self_);
    let right_complement: Horizon = Horizon(1.0);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(right_complement.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, right_complement.e321_ * right_dual.e1234_)
    ));
}
fn multiVector_antiSupport(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_complement: Horizon = Horizon(1.0);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * -1.0), 
        /* e41, e42, e43 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(right_complement.e321_ * right_dual.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(right_complement.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(right_complement.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, right_complement.e321_ * right_dual.e1234_)
    ));
}
fn plane_antiSupport(self_: Plane) -> Scalar {
    return Scalar(self_.e321_);
}
fn point_antiSupport(self_: Point) -> Line {
    let self_groups = point_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_antiSupport(self_: Scalar) -> Horizon {
    return Horizon(self_.scalar);
}
fn antiScalar_antiWedge_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn antiScalar_antiWedge_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn antiScalar_antiWedge_flector(self_: AntiScalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn antiScalar_antiWedge_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.e1234_ * other.e321_);
}
fn antiScalar_antiWedge_line(self_: AntiScalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn antiScalar_antiWedge_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn antiScalar_antiWedge_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    ));
}
fn antiScalar_antiWedge_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.e1234_ * other.e4_);
}
fn antiScalar_antiWedge_plane(self_: AntiScalar, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn antiScalar_antiWedge_point(self_: AntiScalar, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn antiScalar_antiWedge_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.e1234_ * other.scalar);
}
fn dualNum_antiWedge_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn dualNum_antiWedge_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), other.e1234_ * self_.e1234_, 0.0, 0.0)
    ));
}
fn dualNum_antiWedge_flector(self_: DualNum, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn dualNum_antiWedge_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.e1234_ * other.e321_);
}
fn dualNum_antiWedge_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn dualNum_antiWedge_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar)) * vec4<f32>(other_groups.group1_.xyz, 1.0)
    ));
}
fn dualNum_antiWedge_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    ));
}
fn dualNum_antiWedge_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.e1234_ * other.e4_);
}
fn dualNum_antiWedge_plane(self_: DualNum, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn dualNum_antiWedge_point(self_: DualNum, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn dualNum_antiWedge_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.e1234_ * other.scalar);
}
fn flector_antiWedge_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn flector_antiWedge_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn flector_antiWedge_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.yzxw * self_groups.group1_.zxyw) - (other_groups.group1_.zxyw * self_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (other_groups.group1_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (self_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    ));
}
fn flector_antiWedge_horizon(self_: Flector, other: Horizon) -> Motor {
    let self_groups = flector_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)
    ));
}
fn flector_antiWedge_line(self_: Flector, other: Line) -> Point {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    ));
}
fn flector_antiWedge_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn flector_antiWedge_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_) - (self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * other_groups.group4_.yzxw) - (self_groups.group1_.yzxw * other_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn flector_antiWedge_origin(self_: Flector, other: Origin) -> Scalar {
    return Scalar(self_.e321_ * other.e4_ * -1.0);
}
fn flector_antiWedge_plane(self_: Flector, other: Plane) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((self_groups.group1_.zxyw * other_groups.group0_.yzxw) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_ * other.e423_ * -1.0, self_.e321_ * other.e431_ * -1.0, self_.e321_ * other.e412_ * -1.0, (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (other_groups.group0_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_))
    ));
}
fn flector_antiWedge_point(self_: Flector, other: Point) -> Scalar {
    return Scalar(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_));
}
fn horizon_antiWedge_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(other.e1234_ * self_.e321_);
}
fn horizon_antiWedge_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(other.e1234_ * self_.e321_);
}
fn horizon_antiWedge_flector(self_: Horizon, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0)
    ));
}
fn horizon_antiWedge_line(self_: Horizon, other: Line) -> Point {
    let other_groups = line_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_antiWedge_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    ));
}
fn horizon_antiWedge_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    ));
}
fn horizon_antiWedge_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.e321_ * other.e4_ * -1.0);
}
fn horizon_antiWedge_plane(self_: Horizon, other: Plane) -> Line {
    let other_groups = plane_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn horizon_antiWedge_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.e321_ * other.e4_ * -1.0);
}
fn line_antiWedge_antiScalar(self_: Line, other: AntiScalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_antiWedge_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_antiWedge_flector(self_: Line, other: Flector) -> Point {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    ));
}
fn line_antiWedge_horizon(self_: Line, other: Horizon) -> Point {
    let self_groups = line_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    ));
}
fn line_antiWedge_line(self_: Line, other: Line) -> Scalar {
    return Scalar(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_));
}
fn line_antiWedge_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_))
    ));
}
fn line_antiWedge_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn line_antiWedge_plane(self_: Line, other: Plane) -> Point {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    ));
}
fn motor_antiWedge_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn motor_antiWedge_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar)) * vec4<f32>(self_groups.group1_.xyz, 1.0)
    ));
}
fn motor_antiWedge_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn motor_antiWedge_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    ));
}
fn motor_antiWedge_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_))
    ));
}
fn motor_antiWedge_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * self_.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_))
    ));
}
fn motor_antiWedge_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1234_ * other.scalar) + (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1234_ * other.e1_) + (self_.e31_ * other.e412_), (self_.e1234_ * other.e2_) + (self_.e12_ * other.e423_), (self_.e1234_ * other.e3_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) + (self_groups.group0_ * vec4<f32>(other_groups.group4_.wwww.xyz, other.e4_)) - (other_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    ));
}
fn motor_antiWedge_origin(self_: Motor, other: Origin) -> Origin {
    return Origin(self_.e1234_ * other.e4_);
}
fn motor_antiWedge_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn motor_antiWedge_point(self_: Motor, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn motor_antiWedge_scalar(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.e1234_ * other.scalar);
}
fn multiVector_antiWedge_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    ));
}
fn multiVector_antiWedge_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    ));
}
fn multiVector_antiWedge_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (other_groups.group1_.yzxw * self_groups.group4_.zxyw) - (other_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn multiVector_antiWedge_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    ));
}
fn multiVector_antiWedge_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiWedge_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * self_.scalar) + (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1234_ * self_.e1_) + (other.e31_ * self_.e412_), (other.e1234_ * self_.e2_) + (other.e12_ * self_.e423_), (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) + (other_groups.group0_ * vec4<f32>(self_groups.group4_.wwww.xyz, self_.e4_)) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    ));
}
fn multiVector_antiWedge_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar) + (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e43_ * self_.e412_) - (other.e423_ * self_.e41_) - (other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * other_groups.group1_) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((self_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * self_.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.yzxw * self_groups.group4_.zxyw) - (other_groups.group4_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e1234_) * other_groups.group4_)
    ));
}
fn multiVector_antiWedge_origin(self_: MultiVector, other: Origin) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiWedge_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn multiVector_antiWedge_point(self_: MultiVector, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_antiWedge_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.e1234_ * other.scalar);
}
fn origin_antiWedge_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(other.e1234_ * self_.e4_);
}
fn origin_antiWedge_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(other.e1234_ * self_.e4_);
}
fn origin_antiWedge_flector(self_: Origin, other: Flector) -> Scalar {
    return Scalar(other.e321_ * self_.e4_);
}
fn origin_antiWedge_horizon(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e4_);
}
fn origin_antiWedge_motor(self_: Origin, other: Motor) -> Origin {
    return Origin(other.e1234_ * self_.e4_);
}
fn origin_antiWedge_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_antiWedge_plane(self_: Origin, other: Plane) -> Scalar {
    return Scalar(self_.e4_ * other.e321_);
}
fn plane_antiWedge_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn plane_antiWedge_dualNum(self_: Plane, other: DualNum) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn plane_antiWedge_flector(self_: Plane, other: Flector) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_ * self_.e423_, other.e321_ * self_.e431_, other.e321_ * self_.e412_, -(other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (self_groups.group0_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    ));
}
fn plane_antiWedge_horizon(self_: Plane, other: Horizon) -> Line {
    let self_groups = plane_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_
    ));
}
fn plane_antiWedge_line(self_: Plane, other: Line) -> Point {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    ));
}
fn plane_antiWedge_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn plane_antiWedge_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn plane_antiWedge_origin(self_: Plane, other: Origin) -> Scalar {
    return Scalar(other.e4_ * self_.e321_ * -1.0);
}
fn plane_antiWedge_plane(self_: Plane, other: Plane) -> Line {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (other_groups.group0_.yzxw * self_groups.group0_.zxyw) - (other_groups.group0_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)
    ));
}
fn plane_antiWedge_point(self_: Plane, other: Point) -> Scalar {
    return Scalar(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_));
}
fn point_antiWedge_antiScalar(self_: Point, other: AntiScalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn point_antiWedge_dualNum(self_: Point, other: DualNum) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn point_antiWedge_flector(self_: Point, other: Flector) -> Scalar {
    return Scalar((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_));
}
fn point_antiWedge_horizon(self_: Point, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e4_);
}
fn point_antiWedge_motor(self_: Point, other: Motor) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn point_antiWedge_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_antiWedge_plane(self_: Point, other: Plane) -> Scalar {
    return Scalar((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_));
}
fn scalar_antiWedge_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(other.e1234_ * self_.scalar);
}
fn scalar_antiWedge_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(other.e1234_ * self_.scalar);
}
fn scalar_antiWedge_motor(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(other.e1234_ * self_.scalar);
}
fn scalar_antiWedge_multiVector(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(other.e1234_ * self_.scalar);
}
fn antiScalar_autoMorphism(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_autoMorphism(self_: DualNum) -> DualNum {
    return self_;
}
fn flector_autoMorphism(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn horizon_autoMorphism(self_: Horizon) -> Horizon {
    return Horizon(self_.e321_ * -1.0);
}
fn line_autoMorphism(self_: Line) -> Line {
    return self_;
}
fn motor_autoMorphism(self_: Motor) -> Motor {
    return self_;
}
fn multiVector_autoMorphism(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn origin_autoMorphism(self_: Origin) -> Origin {
    return Origin(self_.e4_ * -1.0);
}
fn plane_autoMorphism(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_autoMorphism(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_autoMorphism(self_: Scalar) -> Scalar {
    return self_;
}
fn dualNum_bulk(self_: DualNum) -> Scalar {
    return Scalar(self_.scalar);
}
fn flector_bulk(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_bulk(self_: Horizon) -> Horizon {
    return self_;
}
fn line_bulk(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ self_groups.group1_
    ));
}
fn motor_bulk(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_
    ));
}
fn multiVector_bulk(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group1_.xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn plane_bulk(self_: Plane) -> Horizon {
    return Horizon(self_.e321_);
}
fn point_bulk(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn scalar_bulk(self_: Scalar) -> Scalar {
    return self_;
}
fn antiScalar_conjugation(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_conjugation(self_: DualNum) -> DualNum {
    return self_;
}
fn flector_conjugation(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn horizon_conjugation(self_: Horizon) -> Horizon {
    return self_;
}
fn line_conjugation(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn motor_conjugation(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_conjugation(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn origin_conjugation(self_: Origin) -> Origin {
    return Origin(self_.e4_ * -1.0);
}
fn plane_conjugation(self_: Plane) -> Plane {
    return self_;
}
fn point_conjugation(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_conjugation(self_: Scalar) -> Scalar {
    return self_;
}
fn dualNum_constraintViolation(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.scalar * self_.e1234_ * 2.0);
}
fn flector_constraintViolation(self_: Flector) -> AntiScalar {
    let self_groups = flector_grouped(self_);
    let reverse: Flector = flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
    return AntiScalar((reverse.e423_ * self_.e1_) + (reverse.e431_ * self_.e2_) + (reverse.e412_ * self_.e3_) + (reverse.e321_ * self_.e4_) - (reverse.e1_ * self_.e423_) - (reverse.e2_ * self_.e431_) - (reverse.e3_ * self_.e412_) - (reverse.e4_ * self_.e321_));
}
fn line_constraintViolation(self_: Line) -> AntiScalar {
    let self_groups = line_grouped(self_);
    let reverse: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
    return AntiScalar(-(reverse.e41_ * self_.e23_) - (reverse.e42_ * self_.e31_) - (reverse.e43_ * self_.e12_) - (reverse.e23_ * self_.e41_) - (reverse.e31_ * self_.e42_) - (reverse.e12_ * self_.e43_));
}
fn motor_constraintViolation(self_: Motor) -> AntiScalar {
    let self_groups = motor_grouped(self_);
    let reverse: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
    return AntiScalar((reverse.e1234_ * self_.scalar) + (reverse.scalar * self_.e1234_) - (reverse.e41_ * self_.e23_) - (reverse.e42_ * self_.e31_) - (reverse.e43_ * self_.e12_) - (reverse.e23_ * self_.e41_) - (reverse.e31_ * self_.e42_) - (reverse.e12_ * self_.e43_));
}
fn multiVector_constraintViolation(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    );
    let reverse: MultiVector = multiVector_degroup(reverse_groups);
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (reverse.e1234_ * self_.scalar) + (reverse.e321_ * self_.e4_) - (reverse.e2_ * self_.e431_) - (reverse.e3_ * self_.e412_) - (reverse.e4_ * self_.e321_) - (reverse.e23_ * self_.e41_) - (reverse.e31_ * self_.e42_) - (reverse.e12_ * self_.e43_), 0.0, 0.0) + ((vec4<f32>(reverse.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(reverse.e1_, reverse.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(reverse.e2_, reverse.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(reverse.e3_, reverse.e412_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(reverse.e23_, reverse.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(reverse.e31_, reverse.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(reverse.e12_, reverse.e43_, 0.0, 0.0)) - (vec4<f32>(reverse.e321_, reverse.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(reverse.scalar) * self_groups.group1_) + (vec4<f32>(reverse.e2_, reverse.e321_, reverse.e321_, reverse.e3_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e43_)) + (vec4<f32>(reverse.e321_, reverse.e3_, reverse.e1_, reverse.e2_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e42_)) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, reverse.e1234_) * vec4<f32>(reverse_groups.group1_.xyz, self_.e321_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, reverse.e1_) * vec4<f32>(reverse_groups.group3_.yzzw.xyz, self_.e41_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, reverse.e4_) * vec4<f32>(reverse_groups.group3_.xyxw.xyz, self_.scalar)) + vec4<f32>(vec4<f32>(0.0).xyz, -(reverse.e42_ * self_.e2_) - (reverse.e43_ * self_.e3_) - (reverse.e23_ * self_.e423_) - (reverse.e31_ * self_.e431_) - (reverse.e12_ * self_.e412_) - (reverse.e423_ * self_.e23_) - (reverse.e431_ * self_.e31_) - (reverse.e412_ * self_.e12_)) - vec4<f32>((reverse_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, reverse.e321_ * self_.e1234_) - vec4<f32>((self_groups.group3_.yzxw * reverse_groups.group1_.zxyw).xyz, reverse.e41_ * self_.e1_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, geometric_product.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ geometric_product_groups.group1_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_dotProduct_dualNum(self_: DualNum, other: DualNum) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn dualNum_dotProduct_motor(self_: DualNum, other: Motor) -> Scalar {
    return Scalar(self_.scalar * other.scalar);
}
fn dualNum_dotProduct_multiVector(self_: DualNum, other: MultiVector) -> Scalar {
    return Scalar(self_.scalar * other.scalar);
}
fn dualNum_dotProduct_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.scalar * other.scalar);
}
fn flector_dotProduct_flector(self_: Flector, other: Flector) -> Scalar {
    return Scalar((other.e1_ * self_.e1_) + (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_) + (other.e321_ * self_.e321_));
}
fn flector_dotProduct_horizon(self_: Flector, other: Horizon) -> Scalar {
    return Scalar(self_.e321_ * other.e321_);
}
fn flector_dotProduct_multiVector(self_: Flector, other: MultiVector) -> Scalar {
    return Scalar((self_.e1_ * other.e1_) + (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_) + (self_.e321_ * other.e321_));
}
fn flector_dotProduct_plane(self_: Flector, other: Plane) -> Scalar {
    return Scalar(self_.e321_ * other.e321_);
}
fn flector_dotProduct_point(self_: Flector, other: Point) -> Scalar {
    return Scalar((self_.e1_ * other.e1_) + (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_));
}
fn horizon_dotProduct_flector(self_: Horizon, other: Flector) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn horizon_dotProduct_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn horizon_dotProduct_multiVector(self_: Horizon, other: MultiVector) -> Scalar {
    return Scalar(self_.e321_ * other.e321_);
}
fn horizon_dotProduct_plane(self_: Horizon, other: Plane) -> Scalar {
    return Scalar(self_.e321_ * other.e321_);
}
fn line_dotProduct_line(self_: Line, other: Line) -> Scalar {
    return Scalar((other.e23_ * self_.e23_) + (other.e31_ * self_.e31_) + (other.e12_ * self_.e12_));
}
fn line_dotProduct_motor(self_: Line, other: Motor) -> Scalar {
    return Scalar((self_.e23_ * other.e23_) + (self_.e31_ * other.e31_) + (self_.e12_ * other.e12_));
}
fn line_dotProduct_multiVector(self_: Line, other: MultiVector) -> Scalar {
    return Scalar((self_.e23_ * other.e23_) + (self_.e31_ * other.e31_) + (self_.e12_ * other.e12_));
}
fn motor_dotProduct_dualNum(self_: Motor, other: DualNum) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn motor_dotProduct_line(self_: Motor, other: Line) -> Scalar {
    return Scalar((other.e23_ * self_.e23_) + (other.e31_ * self_.e31_) + (other.e12_ * self_.e12_));
}
fn motor_dotProduct_motor(self_: Motor, other: Motor) -> Scalar {
    return Scalar((other.e23_ * self_.e23_) + (other.e31_ * self_.e31_) + (other.e12_ * self_.e12_) + (other.scalar * self_.scalar));
}
fn motor_dotProduct_multiVector(self_: Motor, other: MultiVector) -> Scalar {
    return Scalar((self_.e23_ * other.e23_) + (self_.e31_ * other.e31_) + (self_.e12_ * other.e12_) + (self_.scalar * other.scalar));
}
fn motor_dotProduct_scalar(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(self_.scalar * other.scalar);
}
fn multiVector_dotProduct_dualNum(self_: MultiVector, other: DualNum) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn multiVector_dotProduct_flector(self_: MultiVector, other: Flector) -> Scalar {
    return Scalar((other.e1_ * self_.e1_) + (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_) + (other.e321_ * self_.e321_));
}
fn multiVector_dotProduct_horizon(self_: MultiVector, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn multiVector_dotProduct_line(self_: MultiVector, other: Line) -> Scalar {
    return Scalar((other.e23_ * self_.e23_) + (other.e31_ * self_.e31_) + (other.e12_ * self_.e12_));
}
fn multiVector_dotProduct_motor(self_: MultiVector, other: Motor) -> Scalar {
    return Scalar((other.e23_ * self_.e23_) + (other.e31_ * self_.e31_) + (other.e12_ * self_.e12_) + (other.scalar * self_.scalar));
}
fn multiVector_dotProduct_multiVector(self_: MultiVector, other: MultiVector) -> Scalar {
    return Scalar((other.scalar * self_.scalar) + (other.e1_ * self_.e1_) + (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_) + (other.e23_ * self_.e23_) + (other.e31_ * self_.e31_) + (other.e12_ * self_.e12_) + (other.e321_ * self_.e321_));
}
fn multiVector_dotProduct_plane(self_: MultiVector, other: Plane) -> Scalar {
    return Scalar(self_.e321_ * other.e321_);
}
fn multiVector_dotProduct_point(self_: MultiVector, other: Point) -> Scalar {
    return Scalar((self_.e1_ * other.e1_) + (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_));
}
fn multiVector_dotProduct_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(self_.scalar * other.scalar);
}
fn plane_dotProduct_flector(self_: Plane, other: Flector) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn plane_dotProduct_horizon(self_: Plane, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn plane_dotProduct_multiVector(self_: Plane, other: MultiVector) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn plane_dotProduct_plane(self_: Plane, other: Plane) -> Scalar {
    return Scalar(other.e321_ * self_.e321_);
}
fn point_dotProduct_flector(self_: Point, other: Flector) -> Scalar {
    return Scalar((other.e1_ * self_.e1_) + (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_));
}
fn point_dotProduct_multiVector(self_: Point, other: MultiVector) -> Scalar {
    return Scalar((other.e1_ * self_.e1_) + (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_));
}
fn point_dotProduct_point(self_: Point, other: Point) -> Scalar {
    return Scalar((other.e1_ * self_.e1_) + (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_));
}
fn scalar_dotProduct_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn scalar_dotProduct_motor(self_: Scalar, other: Motor) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn scalar_dotProduct_multiVector(self_: Scalar, other: MultiVector) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn scalar_dotProduct_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn antiScalar_doubleComplement(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_doubleComplement(self_: DualNum) -> DualNum {
    return self_;
}
fn flector_doubleComplement(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn horizon_doubleComplement(self_: Horizon) -> Horizon {
    return Horizon(self_.e321_ * -1.0);
}
fn line_doubleComplement(self_: Line) -> Line {
    return self_;
}
fn motor_doubleComplement(self_: Motor) -> Motor {
    return self_;
}
fn multiVector_doubleComplement(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn origin_doubleComplement(self_: Origin) -> Origin {
    return Origin(self_.e4_ * -1.0);
}
fn plane_doubleComplement(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_doubleComplement(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_doubleComplement(self_: Scalar) -> Scalar {
    return self_;
}
fn horizon_fix(self_: Horizon) -> Horizon {
    return Horizon(1.0);
}
fn plane_fix(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow((self_groups.group0_ * vec4<f32>(-1.0)).w, -0.5) * pow(self_.e321_, -0.5) * -1.0) * self_groups.group0_
    ));
}
fn point_fix(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(self_.e1_, 2) + pow(self_.e2_, 2) + pow(self_.e3_, 2)) * self_groups.group0_
    ));
}
fn scalar_fix(self_: Scalar) -> Scalar {
    return Scalar(1.0);
}
fn dualNum_flatBulk(self_: DualNum) -> Scalar {
    return Scalar(self_.scalar);
}
fn flector_flatBulk(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_flatBulk(self_: Horizon) -> Horizon {
    return self_;
}
fn line_flatBulk(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ self_groups.group1_
    ));
}
fn motor_flatBulk(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_
    ));
}
fn multiVector_flatBulk(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group1_.xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn plane_flatBulk(self_: Plane) -> Horizon {
    return Horizon(self_.e321_);
}
fn point_flatBulk(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn scalar_flatBulk(self_: Scalar) -> Scalar {
    return self_;
}
fn antiScalar_flatWeight(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_flatWeight(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_);
}
fn flector_flatWeight(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn line_flatWeight(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_flatWeight(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn multiVector_flatWeight(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group4_.xyz, 0.0)
    ));
}
fn origin_flatWeight(self_: Origin) -> Origin {
    return self_;
}
fn plane_flatWeight(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn point_flatWeight(self_: Point) -> Origin {
    return Origin(self_.e4_);
}
fn antiScalar_flatWeightNormSquared(self_: AntiScalar) -> AntiScalar {
    let flat_weight: AntiScalar = antiScalar_flatWeight(self_);
    return antiScalar_antiDotProduct_antiScalar(flat_weight, flat_weight);
}
fn dualNum_flatWeightNormSquared(self_: DualNum) -> AntiScalar {
    let flat_weight: AntiScalar = dualNum_flatWeight(self_);
    return antiScalar_antiDotProduct_antiScalar(flat_weight, flat_weight);
}
fn flector_flatWeightNormSquared(self_: Flector) -> AntiScalar {
    let self_groups = flector_grouped(self_);
    let flat_weight: Flector = flector_flatWeight(self_);
    return flector_antiDotProduct_flector(flat_weight, flat_weight);
}
fn line_flatWeightNormSquared(self_: Line) -> AntiScalar {
    let self_groups = line_grouped(self_);
    let flat_weight: Line = line_flatWeight(self_);
    return line_antiDotProduct_line(flat_weight, flat_weight);
}
fn motor_flatWeightNormSquared(self_: Motor) -> AntiScalar {
    let self_groups = motor_grouped(self_);
    let flat_weight: Motor = motor_flatWeight(self_);
    return motor_antiDotProduct_motor(flat_weight, flat_weight);
}
fn multiVector_flatWeightNormSquared(self_: MultiVector) -> AntiScalar {
    let self_groups = multiVector_grouped(self_);
    let flat_weight: MultiVector = multiVector_flatWeight(self_);
    return multiVector_antiDotProduct_multiVector(flat_weight, flat_weight);
}
fn origin_flatWeightNormSquared(self_: Origin) -> AntiScalar {
    let flat_weight: Origin = origin_flatWeight(self_);
    return origin_antiDotProduct_origin(flat_weight, flat_weight);
}
fn plane_flatWeightNormSquared(self_: Plane) -> AntiScalar {
    let self_groups = plane_grouped(self_);
    let flat_weight: Plane = plane_flatWeight(self_);
    return plane_antiDotProduct_plane(flat_weight, flat_weight);
}
fn point_flatWeightNormSquared(self_: Point) -> AntiScalar {
    let flat_weight: Origin = point_flatWeight(self_);
    return origin_antiDotProduct_origin(flat_weight, flat_weight);
}
fn antiScalar_geometricAntiProduct_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.e1234_);
}
fn antiScalar_geometricAntiProduct_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn antiScalar_geometricAntiProduct_flector(self_: AntiScalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn antiScalar_geometricAntiProduct_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return Horizon(self_.e1234_ * other.e321_);
}
fn antiScalar_geometricAntiProduct_line(self_: AntiScalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn antiScalar_geometricAntiProduct_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e1234_) * other_groups.group1_
    ));
}
fn antiScalar_geometricAntiProduct_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    ));
}
fn antiScalar_geometricAntiProduct_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.e1234_ * other.e4_);
}
fn antiScalar_geometricAntiProduct_plane(self_: AntiScalar, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn antiScalar_geometricAntiProduct_point(self_: AntiScalar, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn antiScalar_geometricAntiProduct_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return Scalar(self_.e1234_ * other.scalar);
}
fn dualNum_geometricAntiProduct_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn dualNum_geometricAntiProduct_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), other.e1234_ * self_.e1234_, 0.0, 0.0)
    ));
}
fn dualNum_geometricAntiProduct_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, self_.e1234_ * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e4_) + (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group1_.xyz, 1.0)
    ));
}
fn dualNum_geometricAntiProduct_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.e1234_ * other.e321_);
}
fn dualNum_geometricAntiProduct_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)
    ));
}
fn dualNum_geometricAntiProduct_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ (vec4<f32>(self_.scalar) * other_groups.group0_) + (vec4<f32>(self_.e1234_) * other_groups.group1_)
    ));
}
fn dualNum_geometricAntiProduct_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, self_.e1234_ * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e4_) + (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group4_.xyz, 1.0)
    ));
}
fn dualNum_geometricAntiProduct_origin(self_: DualNum, other: Origin) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_)
    ));
}
fn dualNum_geometricAntiProduct_plane(self_: DualNum, other: Plane) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
}
fn dualNum_geometricAntiProduct_point(self_: DualNum, other: Point) -> Flector {
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_)
    ));
}
fn dualNum_geometricAntiProduct_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(self_.e1234_ * other.scalar);
}
fn flector_geometricAntiProduct_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn flector_geometricAntiProduct_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)).xyz, other.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, (other.e1234_ * self_.e321_) - (other.scalar * self_.e4_)) * vec4<f32>(self_groups.group1_.xyz, 1.0)
    ));
}
fn flector_geometricAntiProduct_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(other.e423_ * self_.e4_) - (other.e412_ * self_.e431_), -(other.e423_ * self_.e412_) - (other.e431_ * self_.e4_), -(other.e431_ * self_.e423_) - (other.e412_ * self_.e4_), (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_)) + (other_groups.group1_.yzxx * self_groups.group1_.zxyx) - (vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e1_) * vec4<f32>(other_groups.group0_.xxyw.xyz, other.e423_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e2_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e431_)) + (other_groups.group1_.yzxz * self_groups.group0_.zxyz) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, self_.e321_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e4_)) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, self_.e412_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e3_)) - (other_groups.group0_.yzxx * self_groups.group1_.zxyx) - (other_groups.group0_.wwwy * vec4<f32>(self_groups.group0_.xyz, self_.e431_))
    ));
}
fn flector_geometricAntiProduct_horizon(self_: Flector, other: Horizon) -> Motor {
    let self_groups = flector_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)
    ));
}
fn flector_geometricAntiProduct_line(self_: Flector, other: Line) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * other.e43_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e3_ * other.e41_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e1_ * other.e42_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), 0.0) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, self_.e423_ * other.e41_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(other_groups.group0_.xxyw.xyz, other.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e412_ * other.e12_) - (self_.e2_ * other.e42_) - (self_.e3_ * other.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, self_.e1_ * other.e41_)
    ));
}
fn flector_geometricAntiProduct_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * other.e43_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_) - (self_.e431_ * other.e12_), (self_.e3_ * other.e41_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_) - (self_.e412_ * other.e23_), (self_.e3_ * other.e1234_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_) - (self_.e412_ * other.scalar), 0.0) + (self_groups.group0_.xyxw * other_groups.group0_.wwyw) - (self_groups.group1_.xyxz * vec4<f32>(other_groups.group1_.wwyw.xyz, other.e43_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e423_)) - vec4<f32>((self_groups.group0_.wwww * other_groups.group1_).xyz, self_.e431_ * other.e42_), 
        /* e423, e431, e412, e321 */ (self_groups.group1_.xyxy * vec4<f32>(other_groups.group0_.wwyw.xyz, other.e31_)) + (self_groups.group1_.yzzz * vec4<f32>(other_groups.group0_.zxww.xyz, other.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e321_ * other.e1234_) - (self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e4_ * other.scalar)) + vec4<f32>((self_groups.group0_.wwww * other_groups.group0_).xyz, self_.e423_ * other.e23_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e1_))
    ));
}
fn flector_geometricAntiProduct_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e4_ * other.e321_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * other_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * other.e43_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_) - (self_.e431_ * other.e12_), (self_.e3_ * other.e41_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_) - (self_.e4_ * other.e31_), (self_.e1_ * other.e42_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_) - (self_.e4_ * other.e12_), 0.0) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e412_) * vec4<f32>(other_groups.group3_.xxyw.xyz, other.e43_)) - (self_groups.group1_.xyzx * vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, other.e41_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, self_.e431_ * other.e42_), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * other_groups.group4_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (vec4<f32>(other.e4_, other.e4_, other.e431_, 0.0) * self_groups.group1_.xyxw) - (vec4<f32>(other.e412_, other.e423_, other.e4_, 0.0) * self_groups.group1_.yzzw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (vec4<f32>(other.e3_, other.e1_, other.e321_, 0.0) * self_groups.group1_.yzzw) + (vec4<f32>(other.e321_, other.e321_, other.e2_, 0.0) * self_groups.group1_.xyxw) + (self_groups.group0_.zxyw * other_groups.group4_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (vec4<f32>(other.e4_, other.e4_, other.e431_, 0.0) * self_groups.group0_.xyxw) - (vec4<f32>(other.e412_, other.e423_, other.e4_, 0.0) * self_groups.group0_.yzzw) - (self_groups.group1_.zxyw * other_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(other_groups.group2_.xxyw.xyz, other.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(other_groups.group2_.zyzw.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e412_ * other.e12_) - (self_.e1_ * other.e41_) - (self_.e2_ * other.e42_) - (self_.e3_ * other.e43_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group1_.zxyw).xyz, self_.e4_ * other.scalar)
    ));
}
fn flector_geometricAntiProduct_origin(self_: Flector, other: Origin) -> Motor {
    let self_groups = flector_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    ));
}
fn flector_geometricAntiProduct_plane(self_: Flector, other: Plane) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(self_.e4_ * other.e423_) - (self_.e431_ * other.e412_), -(self_.e4_ * other.e431_) - (self_.e412_ * other.e423_), -(self_.e4_ * other.e412_) - (self_.e423_ * other.e431_), (self_.e431_ * other.e431_) + (self_.e412_ * other.e412_)) + (self_groups.group1_.zxyx * other_groups.group0_.yzxx), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(self_.e2_ * other.e412_) - (self_.e321_ * other.e423_), -(self_.e3_ * other.e423_) - (self_.e321_ * other.e431_), -(self_.e1_ * other.e431_) - (self_.e321_ * other.e412_), (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (self_groups.group0_.zxyx * other_groups.group0_.yzxx) + (other_groups.group0_.wwwy * vec4<f32>(self_groups.group1_.xyz, self_.e2_))
    ));
}
fn flector_geometricAntiProduct_point(self_: Flector, other: Point) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e4_ * other.e1_) + (self_.e431_ * other.e3_), (self_.e4_ * other.e2_) + (self_.e412_ * other.e1_), (self_.e4_ * other.e3_) + (self_.e423_ * other.e2_), -(self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group1_.zxyy * other_groups.group0_.yzxy) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_))
    ));
}
fn flector_geometricAntiProduct_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.scalar * -1.0)
    ));
}
fn horizon_geometricAntiProduct_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(other.e1234_ * self_.e321_);
}
fn horizon_geometricAntiProduct_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(other.e1234_ * self_.e321_);
}
fn horizon_geometricAntiProduct_flector(self_: Horizon, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0)
    ));
}
fn horizon_geometricAntiProduct_line(self_: Horizon, other: Line) -> Point {
    let other_groups = line_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_geometricAntiProduct_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    ));
}
fn horizon_geometricAntiProduct_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    ));
}
fn horizon_geometricAntiProduct_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.e321_ * other.e4_ * -1.0);
}
fn horizon_geometricAntiProduct_plane(self_: Horizon, other: Plane) -> Line {
    let other_groups = plane_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn horizon_geometricAntiProduct_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.e321_ * other.e4_ * -1.0);
}
fn line_geometricAntiProduct_antiScalar(self_: Line, other: AntiScalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_geometricAntiProduct_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)
    ));
}
fn line_geometricAntiProduct_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), other.e412_ * self_.e43_ * -1.0) - (other_groups.group1_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, other.e423_ * self_.e41_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e41_) + (other.e412_ * self_.e42_), (other.e4_ * self_.e42_) + (other.e423_ * self_.e43_), (other.e4_ * self_.e43_) + (other.e431_ * self_.e41_), -(other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group1_.yzxw).xyz, other.e1_ * self_.e41_)
    ));
}
fn line_geometricAntiProduct_horizon(self_: Line, other: Horizon) -> Point {
    let self_groups = line_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    ));
}
fn line_geometricAntiProduct_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e43_ * self_.e42_, other.e41_ * self_.e43_, other.e42_ * self_.e41_, -(other.e42_ * self_.e42_) - (other.e43_ * self_.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, other.e41_ * self_.e41_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e43_ * self_.e31_) + (other.e12_ * self_.e42_), (other.e41_ * self_.e12_) + (other.e23_ * self_.e43_), (other.e42_ * self_.e23_) + (other.e31_ * self_.e41_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.e41_ * self_.e23_) - vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, other.e42_ * self_.e31_)
    ));
}
fn line_geometricAntiProduct_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e41_ * other.e1234_) + (self_.e42_ * other.e43_), (self_.e42_ * other.e1234_) + (self_.e43_ * other.e41_), (self_.e41_ * other.e42_) + (self_.e43_ * other.e1234_), -(self_.e42_ * other.e42_) - (self_.e43_ * other.e43_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e41_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e41_ * other.scalar) + (self_.e42_ * other.e12_) + (self_.e23_ * other.e1234_) + (self_.e31_ * other.e43_), (self_.e42_ * other.scalar) + (self_.e43_ * other.e23_) + (self_.e31_ * other.e1234_) + (self_.e12_ * other.e41_), (self_.e41_ * other.e31_) + (self_.e43_ * other.scalar) + (self_.e23_ * other.e42_) + (self_.e12_ * other.e1234_), -(self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e41_)) - vec4<f32>((self_groups.group1_.zxyw * other_groups.group0_.yzxw).xyz, self_.e42_ * other.e31_)
    ));
}
fn line_geometricAntiProduct_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0, 0.0) - ((vec4<f32>(self_.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e42_ * other.e3_) + (self_.e23_ * other.e4_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_) + (self_.e12_ * other.e423_), (self_.e41_ * other.e2_) + (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_) + (self_.e12_ * other.e4_), self_.e43_ * other.e412_ * -1.0) - (other_groups.group4_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group1_.yzxw).xyz, self_.e41_ * other.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (self_groups.group0_.yzxw * other_groups.group2_.zxyw) - (self_groups.group0_.zxyw * other_groups.group2_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.yzxw * other_groups.group3_.zxyw) + (self_groups.group1_.yzxw * other_groups.group2_.zxyw) - (self_groups.group0_.zxyw * other_groups.group3_.yzxw) - (self_groups.group1_.zxyw * other_groups.group2_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e41_ * other.e4_) + (self_.e42_ * other.e412_), (self_.e42_ * other.e4_) + (self_.e43_ * other.e423_), (self_.e41_ * other.e431_) + (self_.e43_ * other.e4_), -(self_.e42_ * other.e2_) - (self_.e43_ * other.e3_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group4_.yzxw).xyz, self_.e41_ * other.e1_)
    ));
}
fn line_geometricAntiProduct_origin(self_: Line, other: Origin) -> Flector {
    let self_groups = line_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    ));
}
fn line_geometricAntiProduct_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e42_ * other.e412_, self_.e43_ * other.e423_, self_.e41_ * other.e431_, -(self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_geometricAntiProduct_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, -(self_.e41_ * other.e1_) - (self_.e42_ * other.e2_) - (self_.e43_ * other.e3_))
    ));
}
fn line_geometricAntiProduct_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_
    ));
}
fn motor_geometricAntiProduct_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e1234_) * self_groups.group1_
    ));
}
fn motor_geometricAntiProduct_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(other.e1234_) * self_groups.group1_)
    ));
}
fn motor_geometricAntiProduct_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e423_ * self_.scalar) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e2_ * self_.e1234_) + (other.e4_ * self_.e31_) + (other.e423_ * self_.e12_) + (other.e431_ * self_.scalar) + (other.e321_ * self_.e42_), (other.e3_ * self_.e1234_) + (other.e4_ * self_.e12_) + (other.e431_ * self_.e23_) + (other.e412_ * self_.scalar) + (other.e321_ * self_.e43_), other.e412_ * self_.e43_ * -1.0) + (other_groups.group0_.xxyw * self_groups.group0_.wzxw) - (other_groups.group1_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group0_.yzxw.xyz, other.e423_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e412_ * self_.e42_, other.e431_ * self_.e1234_, other.e412_ * self_.e1234_, -(other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) + (vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar)) + (other_groups.group1_.xxyw * self_groups.group0_.wzxw) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group1_.yzxw.xyz, other.e1_))
    ));
}
fn motor_geometricAntiProduct_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    ));
}
fn motor_geometricAntiProduct_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e41_ * self_.e1234_) + (other.e43_ * self_.e42_), (other.e41_ * self_.e43_) + (other.e42_ * self_.e1234_), (other.e42_ * self_.e41_) + (other.e43_ * self_.e1234_), -(other.e42_ * self_.e42_) - (other.e43_ * self_.e43_)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group0_.yzxw.xyz, other.e41_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e41_ * self_.scalar) + (other.e43_ * self_.e31_) + (other.e23_ * self_.e1234_) + (other.e12_ * self_.e42_), (other.e41_ * self_.e12_) + (other.e42_ * self_.scalar) + (other.e23_ * self_.e43_) + (other.e31_ * self_.e1234_), (other.e42_ * self_.e23_) + (other.e43_ * self_.scalar) + (other.e31_ * self_.e41_) + (other.e12_ * self_.e1234_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - (self_groups.group1_.zxyx * vec4<f32>(other_groups.group0_.yzxw.xyz, other.e41_)) - vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, other.e42_ * self_.e31_)
    ));
}
fn motor_geometricAntiProduct_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e43_ * self_.e42_) + (other.e1234_ * self_.e41_), (other.e42_ * self_.e1234_) + (other.e1234_ * self_.e42_), (other.e43_ * self_.e1234_) + (other.e1234_ * self_.e43_), -(other.e42_ * self_.e42_) - (other.e43_ * self_.e43_)) + (other_groups.group0_.xxyw * self_groups.group0_.wzxw) - (other_groups.group0_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e1234_ * self_.e23_) + (other.e23_ * self_.e1234_) + (other.e12_ * self_.e42_) + (other.scalar * self_.e41_), (other.e1234_ * self_.e31_) + (other.e23_ * self_.e43_) + (other.e31_ * self_.e1234_) + (other.scalar * self_.e42_), (other.e1234_ * self_.e12_) + (other.e31_ * self_.e41_) + (other.e12_ * self_.e1234_) + (other.scalar * self_.e43_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) + (other_groups.group0_.xxyw * self_groups.group1_.wzxw) + vec4<f32>((other_groups.group0_.zyzw * self_groups.group1_.ywww).xyz, other.scalar * self_.e1234_) - (other_groups.group0_.yzxx * self_groups.group1_.zxyx) - vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, other.e42_ * self_.e31_)
    ));
}
fn motor_geometricAntiProduct_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_), 0.0, 0.0, 0.0) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e1234_ * other.e1_) + (self_.e23_ * other.e4_) + (self_.e31_ * other.e412_) + (self_.scalar * other.e423_), (self_.e43_ * other.e1_) + (self_.e1234_ * other.e2_) + (self_.e31_ * other.e4_) + (self_.e12_ * other.e423_) + (self_.scalar * other.e431_), (self_.e43_ * other.e321_) + (self_.e1234_ * other.e3_) + (self_.e23_ * other.e431_) + (self_.e12_ * other.e4_) + (self_.scalar * other.e412_), self_.e43_ * other.e412_ * -1.0) + (self_groups.group0_.xyxw * vec4<f32>(other_groups.group4_.wwzw.xy, other.e2_, other.e4_)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group1_.yzxw.xyz, other.e423_)) - (other_groups.group4_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group2_.xxyw * self_groups.group0_.wzxw) + (other_groups.group2_.zyzw * self_groups.group0_.ywww) - (other_groups.group2_.yzxw * self_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (other_groups.group2_.xxyw * self_groups.group1_.wzxw) + (other_groups.group2_.zyzw * self_groups.group1_.ywww) + (other_groups.group3_.xxyw * self_groups.group0_.wzxw) + (other_groups.group3_.zyzw * self_groups.group0_.ywww) - (other_groups.group2_.yzxw * self_groups.group1_.zxyw) - (other_groups.group3_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_ * other.e423_, self_.e1234_ * other.e431_, self_.e1234_ * other.e412_, -(self_.e42_ * other.e2_) - (self_.e43_ * other.e3_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) + (self_groups.group0_.xyxw * vec4<f32>(other_groups.group1_.wwzw.xy, other.e431_, other.e321_)) + (vec4<f32>(other_groups.group4_.zxzw.xy, other.e4_, other.e4_) * vec4<f32>(self_groups.group0_.yzzw.xyz, self_.scalar)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group4_.yzxw.xyz, other.e1_))
    ));
}
fn motor_geometricAntiProduct_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e1234_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar)
    ));
}
fn motor_geometricAntiProduct_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_) + (self_.scalar * other.e423_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_) + (self_.scalar * other.e431_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_) + (self_.scalar * other.e412_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_ * other.e423_, self_.e1234_ * other.e431_, self_.e1234_ * other.e412_, -(self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) + (self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_geometricAntiProduct_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (self_groups.group0_.zxyw * other_groups.group0_.yzxw)).xyz, self_.e1234_ * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, (self_.scalar * other.e4_) - (self_.e41_ * other.e1_) - (self_.e42_ * other.e2_) - (self_.e43_ * other.e3_))
    ));
}
fn motor_geometricAntiProduct_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn multiVector_geometricAntiProduct_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    ));
}
fn multiVector_geometricAntiProduct_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_)).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, (other.e1234_ * self_.e321_) - (other.scalar * self_.e4_)) * vec4<f32>(self_groups.group4_.xyz, 1.0)
    ));
}
fn multiVector_geometricAntiProduct_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * other_groups.group0_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1_ * self_.e1234_) + (other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e1_ * self_.e43_) + (other.e2_ * self_.e1234_) + (other.e4_ * self_.e31_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e2_ * self_.e41_) + (other.e3_ * self_.e1234_) + (other.e4_ * self_.e12_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), other.e412_ * self_.e43_ * -1.0) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, self_.e1234_) * vec4<f32>(other_groups.group1_.xyz, other.e4_)) - (other_groups.group1_.yzxy * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group0_.yzxw).xyz, other.e423_ * self_.e41_), 
        /* e41, e42, e43 */ (other_groups.group1_.yzxw * self_groups.group4_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group1_.xxyw) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group1_.zyzw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group0_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group0_.zyzw) + (other_groups.group1_.yzxw * self_groups.group1_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, 0.0) * other_groups.group1_.zyzw) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, 0.0) * other_groups.group1_.xxyw) - (other_groups.group0_.yzxw * self_groups.group4_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e412_ * self_.e42_, other.e423_ * self_.e43_, other.e4_ * self_.e43_, -(other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(other_groups.group1_.xyz, other.e4_)) + (vec4<f32>(other_groups.group0_.wwzw.xy, other.e431_, other.e321_) * vec4<f32>(self_groups.group2_.xyxw.xyz, self_.e1234_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e1_ * self_.e41_)
    ));
}
fn multiVector_geometricAntiProduct_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    ));
}
fn multiVector_geometricAntiProduct_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0) - ((vec4<f32>(other.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e43_ * self_.e2_) + (other.e31_ * self_.e412_), (other.e41_ * self_.e3_) + (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e42_ * self_.e1_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), 0.0) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.e41_ * self_.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (other_groups.group0_.zxyw * self_groups.group2_.yzxw) - (other_groups.group0_.yzxw * self_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group0_.zxyw * self_groups.group3_.yzxw) + (other_groups.group1_.zxyw * self_groups.group2_.yzxw) - (other_groups.group0_.yzxw * self_groups.group3_.zxyw) - (other_groups.group1_.yzxw * self_groups.group2_.zxyw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(other_groups.group0_.xxyw.xyz, other.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e12_ * self_.e412_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group4_.zxyw).xyz, other.e41_ * self_.e1_)
    ));
}
fn multiVector_geometricAntiProduct_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e43_ * self_.e2_) + (other.e1234_ * self_.e1_) + (other.e31_ * self_.e412_) - (other.scalar * self_.e423_), (other.e42_ * self_.e321_) + (other.e1234_ * self_.e2_) + (other.e12_ * self_.e423_) - (other.scalar * self_.e431_), (other.e43_ * self_.e321_) + (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_) - (other.scalar * self_.e412_), 0.0) + (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, self_.e4_) * other_groups.group0_.xxyw) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e43_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e423_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group2_.xyxw * other_groups.group0_.wwyw) + (self_groups.group2_.yzzw * other_groups.group0_.zxww) - (self_groups.group2_.zxyw * other_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (self_groups.group2_.xyxw * other_groups.group1_.wwyw) + (self_groups.group2_.yzzw * other_groups.group1_.zxww) + (self_groups.group3_.xyxw * other_groups.group0_.wwyw) + (self_groups.group3_.yzzw * other_groups.group0_.zxww) - (self_groups.group2_.zxyw * other_groups.group1_.yzxw) - (self_groups.group3_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e321_) * other_groups.group0_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e23_)) + (self_groups.group4_.xyzy * vec4<f32>(other_groups.group0_.wwww.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e12_ * self_.e412_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.scalar * self_.e4_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group4_.zxyw.xyz, self_.e1_))
    ));
}
fn multiVector_geometricAntiProduct_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * self_.scalar) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * other_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1_ * self_.e1234_) + (other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e41_ * self_.e321_) + (other.e43_ * self_.e2_) + (other.e31_ * self_.e412_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e1_ * self_.e43_) + (other.e2_ * self_.e1234_) + (other.e4_ * self_.e31_) + (other.e41_ * self_.e3_) + (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e2_ * self_.e41_) + (other.e3_ * self_.e1234_) + (other.e4_ * self_.e12_) + (other.e42_ * self_.e1_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), 0.0) + (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, self_.e1234_) * vec4<f32>(other_groups.group4_.xyz, other.e4_)) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e412_) * vec4<f32>(other_groups.group3_.xxyw.xyz, other.e43_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, other.e423_) * vec4<f32>(other_groups.group3_.zyzw.xyz, self_.e41_)) - (other_groups.group4_.yzxz * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e43_)) - (self_groups.group4_.xyzx * vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, other.e41_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group1_.zxyw).xyz, other.e42_ * self_.e431_) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e431_ * self_.e42_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group2_.zxyw * self_groups.group2_.yzxw) + (other_groups.group4_.yzxw * self_groups.group4_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group4_.xxyw) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group4_.zyzw) - (other_groups.group2_.yzxw * self_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group1_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group1_.zyzw) + (other_groups.group2_.zxyw * self_groups.group3_.yzxw) + (other_groups.group3_.zxyw * self_groups.group2_.yzxw) + (other_groups.group4_.yzxw * self_groups.group1_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, 0.0) * other_groups.group4_.zyzw) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, 0.0) * other_groups.group4_.xxyw) - (other_groups.group2_.yzxw * self_groups.group3_.zxyw) - (other_groups.group3_.yzxw * self_groups.group2_.zxyw) - (other_groups.group1_.yzxw * self_groups.group4_.zxyw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, other.e321_) * vec4<f32>(other_groups.group2_.xxyw.xyz, self_.e1234_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(other_groups.group2_.zyzw.xyz, other.e23_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(other_groups.group4_.xyz, other.e4_)) + (vec4<f32>(other_groups.group1_.wwzw.xy, other.e431_, self_.e431_) * vec4<f32>(self_groups.group2_.xyxw.xyz, other.e31_)) + (vec4<f32>(other_groups.group4_.zxzw.xy, other.e4_, self_.e412_) * vec4<f32>(self_groups.group2_.yzzw.xyz, other.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e1_ * self_.e41_) - (other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group4_.zxyw).xyz, other.scalar * self_.e4_) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group4_.yzxw).xyz, other.e41_ * self_.e1_)
    ));
}
fn multiVector_geometricAntiProduct_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e321_, self_.e4_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group3_.xyz, self_.e1234_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group2_.xyz, self_.scalar)
    ));
}
fn multiVector_geometricAntiProduct_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e4_ * other.e321_, 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.scalar * other.e423_) + (self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.scalar * other.e431_) + (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.scalar * other.e412_) + (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (self_groups.group1_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e42_ * other.e412_, self_.e43_ * other.e423_, self_.e41_ * other.e431_, -(self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    ));
}
fn multiVector_geometricAntiProduct_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), self_.e4_ * other.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + (self_groups.group2_.yzxw * other_groups.group0_.zxyw) - (self_groups.group2_.zxyw * other_groups.group0_.yzxw)).xyz, self_.e1234_ * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group4_.yzxw * other_groups.group0_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (self_groups.group4_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, (self_.scalar * other.e4_) - (self_.e41_ * other.e1_) - (self_.e42_ * other.e2_) - (self_.e43_ * other.e3_))
    ));
}
fn multiVector_geometricAntiProduct_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e1234_ * other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.scalar * -1.0)
    ));
}
fn origin_geometricAntiProduct_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(other.e1234_ * self_.e4_);
}
fn origin_geometricAntiProduct_dualNum(self_: Origin, other: DualNum) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_ * -1.0)
    ));
}
fn origin_geometricAntiProduct_flector(self_: Origin, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_)
    ));
}
fn origin_geometricAntiProduct_horizon(self_: Origin, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e4_);
}
fn origin_geometricAntiProduct_line(self_: Origin, other: Line) -> Flector {
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn origin_geometricAntiProduct_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group1_.xyz, other.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    ));
}
fn origin_geometricAntiProduct_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e321_, other.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group3_.xyz, other.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group2_.xyz, other.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    ));
}
fn origin_geometricAntiProduct_origin(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e4_ * -1.0);
}
fn origin_geometricAntiProduct_plane(self_: Origin, other: Plane) -> Motor {
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.e321_)
    ));
}
fn origin_geometricAntiProduct_point(self_: Origin, other: Point) -> Motor {
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn origin_geometricAntiProduct_scalar(self_: Origin, other: Scalar) -> Horizon {
    return Horizon(self_.e4_ * other.scalar * -1.0);
}
fn plane_geometricAntiProduct_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn plane_geometricAntiProduct_dualNum(self_: Plane, other: DualNum) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn plane_geometricAntiProduct_flector(self_: Plane, other: Flector) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(other.e4_ * self_.e423_) - (other.e412_ * self_.e431_), -(other.e4_ * self_.e431_) - (other.e423_ * self_.e412_), -(other.e4_ * self_.e412_) - (other.e431_ * self_.e423_), (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_)) + (other_groups.group1_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e3_ * self_.e431_) + (other.e321_ * self_.e423_), (other.e1_ * self_.e412_) + (other.e321_ * self_.e431_), (other.e2_ * self_.e423_) + (other.e321_ * self_.e412_), -(other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.yzxx * self_groups.group0_.zxyx) - (self_groups.group0_.wwwy * vec4<f32>(other_groups.group1_.xyz, other.e2_))
    ));
}
fn plane_geometricAntiProduct_horizon(self_: Plane, other: Horizon) -> Line {
    let self_groups = plane_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_
    ));
}
fn plane_geometricAntiProduct_line(self_: Plane, other: Line) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e42_ * self_.e412_ * -1.0, other.e43_ * self_.e423_ * -1.0, other.e41_ * self_.e431_ * -1.0, (other.e31_ * self_.e431_) + (other.e12_ * self_.e412_)) + (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn plane_geometricAntiProduct_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), other.e43_ * self_.e412_ * -1.0) - (self_groups.group0_.xyzy * vec4<f32>(other_groups.group1_.wwww.xyz, other.e42_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e42_ * self_.e412_ * -1.0, other.e43_ * self_.e423_ * -1.0, other.e41_ * self_.e431_ * -1.0, (other.e31_ * self_.e431_) + (other.e12_ * self_.e412_)) + (other_groups.group0_.zxyw * self_groups.group0_.yzxw) + (self_groups.group0_.xyzx * vec4<f32>(other_groups.group0_.wwww.xyz, other.e23_))
    ));
}
fn plane_geometricAntiProduct_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), (other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), other.e43_ * self_.e412_ * -1.0) - (self_groups.group0_.xyzx * vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, other.e41_)) - (self_groups.group0_.yzxy * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e42_)), 
        /* e41, e42, e43 */ (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e42_ * self_.e412_ * -1.0, other.e43_ * self_.e423_ * -1.0, other.e41_ * self_.e431_ * -1.0, (other.e31_ * self_.e431_) + (other.e12_ * self_.e412_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) + (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    ));
}
fn plane_geometricAntiProduct_origin(self_: Plane, other: Origin) -> Motor {
    let self_groups = plane_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.e321_ * -1.0)
    ));
}
fn plane_geometricAntiProduct_plane(self_: Plane, other: Plane) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e412_ * self_.e431_ * -1.0, other.e423_ * self_.e412_ * -1.0, other.e431_ * self_.e423_ * -1.0, (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_)) + (other_groups.group0_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, 0.0)
    ));
}
fn plane_geometricAntiProduct_point(self_: Plane, other: Point) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e431_ * other.e3_, self_.e412_ * other.e1_, self_.e423_ * other.e2_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group0_.zxyx * other_groups.group0_.yzxx)
    ));
}
fn plane_geometricAntiProduct_scalar(self_: Plane, other: Scalar) -> Point {
    let self_groups = plane_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn point_geometricAntiProduct_antiScalar(self_: Point, other: AntiScalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    ));
}
fn point_geometricAntiProduct_dualNum(self_: Point, other: DualNum) -> Flector {
    let self_groups = point_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_ * -1.0)
    ));
}
fn point_geometricAntiProduct_flector(self_: Point, other: Flector) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(other.e4_ * self_.e1_) - (other.e412_ * self_.e2_), -(other.e4_ * self_.e2_) - (other.e423_ * self_.e3_), -(other.e4_ * self_.e3_) - (other.e431_ * self_.e1_), (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group1_.yzxy * self_groups.group0_.zxyy) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_))
    ));
}
fn point_geometricAntiProduct_horizon(self_: Point, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e4_);
}
fn point_geometricAntiProduct_line(self_: Point, other: Line) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e1_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_))
    ));
}
fn point_geometricAntiProduct_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group0_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, other.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e1_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.scalar * self_.e4_))
    ));
}
fn point_geometricAntiProduct_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), other.e4_ * self_.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group2_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) - (other_groups.group2_.yzxw * self_groups.group0_.zxyw)).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, -(other.scalar * self_.e4_) - (other.e41_ * self_.e1_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_))
    ));
}
fn point_geometricAntiProduct_origin(self_: Point, other: Origin) -> Motor {
    let self_groups = point_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn point_geometricAntiProduct_plane(self_: Point, other: Plane) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e412_ * self_.e2_ * -1.0, other.e423_ * self_.e3_ * -1.0, other.e431_ * self_.e1_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group0_.yzxx * self_groups.group0_.zxyx)
    ));
}
fn point_geometricAntiProduct_point(self_: Point, other: Point) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, 0.0)
    ));
}
fn point_geometricAntiProduct_scalar(self_: Point, other: Scalar) -> Horizon {
    return Horizon(self_.e4_ * other.scalar * -1.0);
}
fn scalar_geometricAntiProduct_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(other.e1234_ * self_.scalar);
}
fn scalar_geometricAntiProduct_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(other.e1234_ * self_.scalar);
}
fn scalar_geometricAntiProduct_flector(self_: Scalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.scalar)
    ));
}
fn scalar_geometricAntiProduct_line(self_: Scalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_geometricAntiProduct_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn scalar_geometricAntiProduct_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e1234_ * self_.scalar, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.scalar)
    ));
}
fn scalar_geometricAntiProduct_origin(self_: Scalar, other: Origin) -> Horizon {
    return Horizon(other.e4_ * self_.scalar);
}
fn scalar_geometricAntiProduct_plane(self_: Scalar, other: Plane) -> Point {
    let other_groups = plane_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn scalar_geometricAntiProduct_point(self_: Scalar, other: Point) -> Horizon {
    return Horizon(other.e4_ * self_.scalar);
}
fn antiScalar_geometricAntiQuotient_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ / (other.e1234_));
}
fn antiScalar_geometricAntiQuotient_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, -2));
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other_2.e1234_ * other.scalar, other_2.e1234_ * other.e1234_, 0.0, 0.0)
    ));
}
fn antiScalar_geometricAntiQuotient_flector(self_: AntiScalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group1_
    ));
}
fn antiScalar_geometricAntiQuotient_line(self_: AntiScalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_
    ));
}
fn antiScalar_geometricAntiQuotient_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group1_
    ));
}
fn antiScalar_geometricAntiQuotient_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * geometric_anti_product_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group4_
    ));
}
fn antiScalar_geometricAntiQuotient_origin(self_: AntiScalar, other: Origin) -> Origin {
    return Origin(self_.e1234_ / (other.e4_) * -1.0);
}
fn antiScalar_geometricAntiQuotient_plane(self_: AntiScalar, other: Plane) -> Plane {
    let other_2: AntiScalar = AntiScalar(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * vec4<f32>(other_2.e1234_ * other.e423_, other_2.e1234_ * other.e431_, other_2.e1234_ * other.e412_, other_2.e1234_ * other.e321_)
    ));
}
fn antiScalar_geometricAntiQuotient_point(self_: AntiScalar, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let anti_reverse: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, -2));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * vec4<f32>(other_2.e1234_ * anti_reverse.e1_, other_2.e1234_ * anti_reverse.e2_, other_2.e1234_ * anti_reverse.e3_, other_2.e1234_ * anti_reverse.e4_)
    ));
}
fn dualNum_geometricAntiQuotient_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(1.0/(other.e1234_)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn dualNum_geometricAntiQuotient_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>((geometric_anti_product.scalar * self_.e1234_) + (geometric_anti_product.e1234_ * self_.scalar), geometric_anti_product.e1234_ * self_.e1234_, 0.0, 0.0)
    ));
}
fn dualNum_geometricAntiQuotient_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_)).xyz, self_.e1234_ * geometric_anti_product.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * geometric_anti_product.e4_) + (self_.e1234_ * geometric_anti_product.e321_)) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, 1.0)
    ));
}
fn dualNum_geometricAntiQuotient_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_, 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_)
    ));
}
fn dualNum_geometricAntiQuotient_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group0_, 
        /* e23, e31, e12, scalar */ (vec4<f32>(self_.scalar) * geometric_anti_product_groups.group0_) + (vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group1_)
    ));
}
fn dualNum_geometricAntiQuotient_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * geometric_anti_product.e1234_) + (self_.e1234_ * geometric_anti_product.scalar), self_.e1234_ * geometric_anti_product.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_)).xyz, self_.e1234_ * geometric_anti_product.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_, 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group3_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * geometric_anti_product.e4_) + (self_.e1234_ * geometric_anti_product.e321_)) * vec4<f32>(geometric_anti_product_groups.group4_.xyz, 1.0)
    ));
}
fn dualNum_geometricAntiQuotient_origin(self_: DualNum, other: Origin) -> Flector {
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * geometric_anti_product.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * geometric_anti_product.e4_)
    ));
}
fn dualNum_geometricAntiQuotient_plane(self_: DualNum, other: Plane) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(geometric_anti_product_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group0_
    ));
}
fn dualNum_geometricAntiQuotient_point(self_: DualNum, other: Point) -> Flector {
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * geometric_anti_product.e4_)
    ));
}
fn flector_geometricAntiQuotient_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    let self_groups = flector_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(other.e1234_));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_
    ));
}
fn flector_geometricAntiQuotient_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product_groups: DualNumGroups = DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    );
    let geometric_anti_product: DualNum = dualNum_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)).xyz, geometric_anti_product.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product_groups.group0_.yyzw.xy, geometric_anti_product.e1234_, (geometric_anti_product.e1234_ * self_.e321_) - (geometric_anti_product.scalar * self_.e4_)) * vec4<f32>(self_groups.group1_.xyz, 1.0)
    ));
}
fn flector_geometricAntiQuotient_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(geometric_anti_product.e423_ * self_.e4_) - (geometric_anti_product.e412_ * self_.e431_), -(geometric_anti_product.e423_ * self_.e412_) - (geometric_anti_product.e431_ * self_.e4_), -(geometric_anti_product.e431_ * self_.e423_) - (geometric_anti_product.e412_ * self_.e4_), (geometric_anti_product.e431_ * self_.e431_) + (geometric_anti_product.e412_ * self_.e412_)) + (geometric_anti_product_groups.group1_.yzxx * self_groups.group1_.zxyx) - (vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)), 
        /* e23, e31, e12, scalar */ (vec4<f32>(geometric_anti_product.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e1_) * vec4<f32>(geometric_anti_product_groups.group0_.xxyw.xyz, geometric_anti_product.e423_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e2_) * vec4<f32>(geometric_anti_product_groups.group0_.zyzw.xyz, geometric_anti_product.e431_)) + (geometric_anti_product_groups.group1_.yzxz * self_groups.group0_.zxyz) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, self_.e321_) * vec4<f32>(geometric_anti_product_groups.group1_.zyzw.xyz, geometric_anti_product.e4_)) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, self_.e412_) * vec4<f32>(geometric_anti_product_groups.group1_.xxyw.xyz, geometric_anti_product.e3_)) - (geometric_anti_product_groups.group0_.yzxx * self_groups.group1_.zxyx) - (geometric_anti_product_groups.group0_.wwwy * vec4<f32>(self_groups.group0_.xyz, self_.e431_))
    ));
}
fn flector_geometricAntiQuotient_line(self_: Flector, other: Line) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Line = line_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * geometric_anti_product.e43_) + (self_.e412_ * geometric_anti_product.e31_) + (self_.e321_ * geometric_anti_product.e41_), (self_.e3_ * geometric_anti_product.e41_) + (self_.e423_ * geometric_anti_product.e12_) + (self_.e321_ * geometric_anti_product.e42_), (self_.e1_ * geometric_anti_product.e42_) + (self_.e431_ * geometric_anti_product.e23_) + (self_.e321_ * geometric_anti_product.e43_), 0.0) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(geometric_anti_product_groups.group1_.xxyw.xyz, geometric_anti_product.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(geometric_anti_product_groups.group1_.zyzw.xyz, geometric_anti_product.e43_)) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, self_.e423_ * geometric_anti_product.e41_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(geometric_anti_product_groups.group0_.xxyw.xyz, geometric_anti_product.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(geometric_anti_product_groups.group0_.zyzw.xyz, geometric_anti_product.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e412_ * geometric_anti_product.e12_) - (self_.e2_ * geometric_anti_product.e42_) - (self_.e3_ * geometric_anti_product.e43_)) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, self_.e1_ * geometric_anti_product.e41_)
    ));
}
fn flector_geometricAntiQuotient_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * geometric_anti_product.e43_) + (self_.e412_ * geometric_anti_product.e31_) + (self_.e321_ * geometric_anti_product.e41_) - (self_.e431_ * geometric_anti_product.e12_), (self_.e3_ * geometric_anti_product.e41_) + (self_.e423_ * geometric_anti_product.e12_) + (self_.e321_ * geometric_anti_product.e42_) - (self_.e412_ * geometric_anti_product.e23_), (self_.e3_ * geometric_anti_product.e1234_) + (self_.e431_ * geometric_anti_product.e23_) + (self_.e321_ * geometric_anti_product.e43_) - (self_.e412_ * geometric_anti_product.scalar), 0.0) + (self_groups.group0_.xyxw * geometric_anti_product_groups.group0_.wwyw) - (self_groups.group1_.xyxz * vec4<f32>(geometric_anti_product_groups.group1_.wwyw.xyz, geometric_anti_product.e43_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e423_)) - vec4<f32>((self_groups.group0_.wwww * geometric_anti_product_groups.group1_).xyz, self_.e431_ * geometric_anti_product.e42_), 
        /* e423, e431, e412, e321 */ (self_groups.group1_.xyxy * vec4<f32>(geometric_anti_product_groups.group0_.wwyw.xyz, geometric_anti_product.e31_)) + (self_groups.group1_.yzzz * vec4<f32>(geometric_anti_product_groups.group0_.zxww.xyz, geometric_anti_product.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e321_ * geometric_anti_product.e1234_) - (self_.e2_ * geometric_anti_product.e42_) - (self_.e3_ * geometric_anti_product.e43_) - (self_.e4_ * geometric_anti_product.scalar)) + vec4<f32>((self_groups.group0_.wwww * geometric_anti_product_groups.group0_).xyz, self_.e423_ * geometric_anti_product.e23_) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e1_))
    ));
}
fn flector_geometricAntiQuotient_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e4_ * geometric_anti_product.e321_) - (self_.e431_ * geometric_anti_product.e2_) - (self_.e412_ * geometric_anti_product.e3_) - (self_.e321_ * geometric_anti_product.e4_), 0.0, 0.0, 0.0) + ((vec4<f32>(geometric_anti_product.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * geometric_anti_product_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * geometric_anti_product.e43_) + (self_.e412_ * geometric_anti_product.e31_) + (self_.e321_ * geometric_anti_product.e41_) - (self_.e431_ * geometric_anti_product.e12_), (self_.e3_ * geometric_anti_product.e41_) + (self_.e423_ * geometric_anti_product.e12_) + (self_.e321_ * geometric_anti_product.e42_) - (self_.e4_ * geometric_anti_product.e31_), (self_.e1_ * geometric_anti_product.e42_) + (self_.e431_ * geometric_anti_product.e23_) + (self_.e321_ * geometric_anti_product.e43_) - (self_.e4_ * geometric_anti_product.e12_), 0.0) + (vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e412_) * vec4<f32>(geometric_anti_product_groups.group3_.xxyw.xyz, geometric_anti_product.e43_)) - (self_groups.group1_.xyzx * vec4<f32>(geometric_anti_product_groups.group0_.xxzw.xy, geometric_anti_product.scalar, geometric_anti_product.e41_)) - vec4<f32>((geometric_anti_product_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, self_.e431_ * geometric_anti_product.e42_), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * geometric_anti_product_groups.group4_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_) - (vec4<f32>(geometric_anti_product.e4_, geometric_anti_product.e4_, geometric_anti_product.e431_, 0.0) * self_groups.group1_.xyxw) - (vec4<f32>(geometric_anti_product.e412_, geometric_anti_product.e423_, geometric_anti_product.e4_, 0.0) * self_groups.group1_.yzzw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_) + (vec4<f32>(geometric_anti_product.e3_, geometric_anti_product.e1_, geometric_anti_product.e321_, 0.0) * self_groups.group1_.yzzw) + (vec4<f32>(geometric_anti_product.e321_, geometric_anti_product.e321_, geometric_anti_product.e2_, 0.0) * self_groups.group1_.xyxw) + (self_groups.group0_.zxyw * geometric_anti_product_groups.group4_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_) - (vec4<f32>(geometric_anti_product.e4_, geometric_anti_product.e4_, geometric_anti_product.e431_, 0.0) * self_groups.group0_.xyxw) - (vec4<f32>(geometric_anti_product.e412_, geometric_anti_product.e423_, geometric_anti_product.e4_, 0.0) * self_groups.group0_.yzzw) - (self_groups.group1_.zxyw * geometric_anti_product_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(geometric_anti_product_groups.group2_.xxyw.xyz, geometric_anti_product.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(geometric_anti_product_groups.group2_.zyzw.xyz, geometric_anti_product.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e412_ * geometric_anti_product.e12_) - (self_.e1_ * geometric_anti_product.e41_) - (self_.e2_ * geometric_anti_product.e42_) - (self_.e3_ * geometric_anti_product.e43_)) - vec4<f32>((geometric_anti_product_groups.group2_.yzxw * self_groups.group1_.zxyw).xyz, self_.e4_ * geometric_anti_product.scalar)
    ));
}
fn flector_geometricAntiQuotient_origin(self_: Flector, other: Origin) -> Motor {
    let self_groups = flector_grouped(self_);
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    ));
}
fn flector_geometricAntiQuotient_plane(self_: Flector, other: Plane) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(self_.e4_ * geometric_anti_product.e423_) - (self_.e431_ * geometric_anti_product.e412_), -(self_.e4_ * geometric_anti_product.e431_) - (self_.e412_ * geometric_anti_product.e423_), -(self_.e4_ * geometric_anti_product.e412_) - (self_.e423_ * geometric_anti_product.e431_), (self_.e431_ * geometric_anti_product.e431_) + (self_.e412_ * geometric_anti_product.e412_)) + (self_groups.group1_.zxyx * geometric_anti_product_groups.group0_.yzxx), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(self_.e2_ * geometric_anti_product.e412_) - (self_.e321_ * geometric_anti_product.e423_), -(self_.e3_ * geometric_anti_product.e423_) - (self_.e321_ * geometric_anti_product.e431_), -(self_.e1_ * geometric_anti_product.e431_) - (self_.e321_ * geometric_anti_product.e412_), (self_.e3_ * geometric_anti_product.e412_) + (self_.e4_ * geometric_anti_product.e321_)) + (self_groups.group0_.zxyx * geometric_anti_product_groups.group0_.yzxx) + (geometric_anti_product_groups.group0_.wwwy * vec4<f32>(self_groups.group1_.xyz, self_.e2_))
    ));
}
fn flector_geometricAntiQuotient_point(self_: Flector, other: Point) -> Motor {
    let self_groups = flector_grouped(self_);
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e4_ * geometric_anti_product.e1_) + (self_.e431_ * geometric_anti_product.e3_), (self_.e4_ * geometric_anti_product.e2_) + (self_.e412_ * geometric_anti_product.e1_), (self_.e4_ * geometric_anti_product.e3_) + (self_.e423_ * geometric_anti_product.e2_), -(self_.e412_ * geometric_anti_product.e3_) - (self_.e321_ * geometric_anti_product.e4_)) - (self_groups.group1_.zxyy * geometric_anti_product_groups.group0_.yzxy) - (geometric_anti_product_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_))
    ));
}
fn horizon_geometricAntiQuotient_antiScalar(self_: Horizon, other: AntiScalar) -> Horizon {
    return Horizon(self_.e321_ / (other.e1234_));
}
fn horizon_geometricAntiQuotient_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(self_.e321_ / (other.e1234_));
}
fn horizon_geometricAntiQuotient_flector(self_: Horizon, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e4_) * vec4<f32>(-1.0)
    ));
}
fn horizon_geometricAntiQuotient_line(self_: Horizon, other: Line) -> Point {
    let other_groups = line_grouped(other);
    let anti_reverse: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other_2.e1234_ * anti_reverse.e41_, other_2.e1234_ * anti_reverse.e42_, other_2.e1234_ * anti_reverse.e43_, 0.0)).xyz, 0.0)
    ));
}
fn horizon_geometricAntiQuotient_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * geometric_anti_product.e1234_)
    ));
}
fn horizon_geometricAntiQuotient_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * geometric_anti_product.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * geometric_anti_product.e1234_)
    ));
}
fn horizon_geometricAntiQuotient_origin(self_: Horizon, other: Origin) -> Scalar {
    return Scalar(self_.e321_ / (other.e4_));
}
fn horizon_geometricAntiQuotient_plane(self_: Horizon, other: Plane) -> Line {
    let other_2: AntiScalar = AntiScalar(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other_2.e1234_ * other.e423_, other_2.e1234_ * other.e431_, other_2.e1234_ * other.e412_, other_2.e1234_ * other.e321_) * vec4<f32>(-1.0)
    ));
}
fn horizon_geometricAntiQuotient_point(self_: Horizon, other: Point) -> Scalar {
    return Scalar(self_.e321_ / (other.e4_));
}
fn line_geometricAntiQuotient_antiScalar(self_: Line, other: AntiScalar) -> Line {
    let self_groups = line_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(other.e1234_));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_geometricAntiQuotient_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)
    ));
}
fn line_geometricAntiQuotient_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e3_ * self_.e42_) + (geometric_anti_product.e4_ * self_.e23_) + (geometric_anti_product.e412_ * self_.e31_) + (geometric_anti_product.e321_ * self_.e41_), (geometric_anti_product.e1_ * self_.e43_) + (geometric_anti_product.e4_ * self_.e31_) + (geometric_anti_product.e423_ * self_.e12_) + (geometric_anti_product.e321_ * self_.e42_), (geometric_anti_product.e2_ * self_.e41_) + (geometric_anti_product.e4_ * self_.e12_) + (geometric_anti_product.e431_ * self_.e23_) + (geometric_anti_product.e321_ * self_.e43_), geometric_anti_product.e412_ * self_.e43_ * -1.0) - (geometric_anti_product_groups.group1_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group0_.zxyw * geometric_anti_product_groups.group0_.yzxw).xyz, geometric_anti_product.e423_ * self_.e41_), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_anti_product.e4_ * self_.e41_) + (geometric_anti_product.e412_ * self_.e42_), (geometric_anti_product.e4_ * self_.e42_) + (geometric_anti_product.e423_ * self_.e43_), (geometric_anti_product.e4_ * self_.e43_) + (geometric_anti_product.e431_ * self_.e41_), -(geometric_anti_product.e2_ * self_.e42_) - (geometric_anti_product.e3_ * self_.e43_) - (geometric_anti_product.e423_ * self_.e23_) - (geometric_anti_product.e431_ * self_.e31_) - (geometric_anti_product.e412_ * self_.e12_)) - vec4<f32>((self_groups.group0_.zxyw * geometric_anti_product_groups.group1_.yzxw).xyz, geometric_anti_product.e1_ * self_.e41_)
    ));
}
fn line_geometricAntiQuotient_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Line = line_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e43_ * self_.e42_, geometric_anti_product.e41_ * self_.e43_, geometric_anti_product.e42_ * self_.e41_, -(geometric_anti_product.e42_ * self_.e42_) - (geometric_anti_product.e43_ * self_.e43_)) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, geometric_anti_product.e41_ * self_.e41_), 
        /* e23, e31, e12, scalar */ vec4<f32>((geometric_anti_product.e43_ * self_.e31_) + (geometric_anti_product.e12_ * self_.e42_), (geometric_anti_product.e41_ * self_.e12_) + (geometric_anti_product.e23_ * self_.e43_), (geometric_anti_product.e42_ * self_.e23_) + (geometric_anti_product.e31_ * self_.e41_), -(geometric_anti_product.e43_ * self_.e12_) - (geometric_anti_product.e23_ * self_.e41_) - (geometric_anti_product.e31_ * self_.e42_) - (geometric_anti_product.e12_ * self_.e43_)) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, geometric_anti_product.e41_ * self_.e23_) - vec4<f32>((geometric_anti_product_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, geometric_anti_product.e42_ * self_.e31_)
    ));
}
fn line_geometricAntiQuotient_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e41_ * geometric_anti_product.e1234_) + (self_.e42_ * geometric_anti_product.e43_), (self_.e42_ * geometric_anti_product.e1234_) + (self_.e43_ * geometric_anti_product.e41_), (self_.e41_ * geometric_anti_product.e42_) + (self_.e43_ * geometric_anti_product.e1234_), -(self_.e42_ * geometric_anti_product.e42_) - (self_.e43_ * geometric_anti_product.e43_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e41_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e41_ * geometric_anti_product.scalar) + (self_.e42_ * geometric_anti_product.e12_) + (self_.e23_ * geometric_anti_product.e1234_) + (self_.e31_ * geometric_anti_product.e43_), (self_.e42_ * geometric_anti_product.scalar) + (self_.e43_ * geometric_anti_product.e23_) + (self_.e31_ * geometric_anti_product.e1234_) + (self_.e12_ * geometric_anti_product.e41_), (self_.e41_ * geometric_anti_product.e31_) + (self_.e43_ * geometric_anti_product.scalar) + (self_.e23_ * geometric_anti_product.e42_) + (self_.e12_ * geometric_anti_product.e1234_), -(self_.e43_ * geometric_anti_product.e12_) - (self_.e23_ * geometric_anti_product.e41_) - (self_.e31_ * geometric_anti_product.e42_) - (self_.e12_ * geometric_anti_product.e43_)) - (geometric_anti_product_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e41_)) - vec4<f32>((self_groups.group1_.zxyw * geometric_anti_product_groups.group0_.yzxw).xyz, self_.e42_ * geometric_anti_product.e31_)
    ));
}
fn line_geometricAntiQuotient_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e23_ * geometric_anti_product.e41_) - (self_.e31_ * geometric_anti_product.e42_) - (self_.e12_ * geometric_anti_product.e43_), 0.0, 0.0, 0.0) - ((vec4<f32>(self_.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e23_, geometric_anti_product.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e31_, geometric_anti_product.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e12_, geometric_anti_product.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * geometric_anti_product.e321_) + (self_.e42_ * geometric_anti_product.e3_) + (self_.e23_ * geometric_anti_product.e4_) + (self_.e31_ * geometric_anti_product.e412_), (self_.e42_ * geometric_anti_product.e321_) + (self_.e43_ * geometric_anti_product.e1_) + (self_.e31_ * geometric_anti_product.e4_) + (self_.e12_ * geometric_anti_product.e423_), (self_.e41_ * geometric_anti_product.e2_) + (self_.e43_ * geometric_anti_product.e321_) + (self_.e23_ * geometric_anti_product.e431_) + (self_.e12_ * geometric_anti_product.e4_), self_.e43_ * geometric_anti_product.e412_ * -1.0) - (geometric_anti_product_groups.group4_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group0_.zxyw * geometric_anti_product_groups.group1_.yzxw).xyz, self_.e41_ * geometric_anti_product.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (self_groups.group0_.yzxw * geometric_anti_product_groups.group2_.zxyw) - (self_groups.group0_.zxyw * geometric_anti_product_groups.group2_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.yzxw * geometric_anti_product_groups.group3_.zxyw) + (self_groups.group1_.yzxw * geometric_anti_product_groups.group2_.zxyw) - (self_groups.group0_.zxyw * geometric_anti_product_groups.group3_.yzxw) - (self_groups.group1_.zxyw * geometric_anti_product_groups.group2_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e41_ * geometric_anti_product.e4_) + (self_.e42_ * geometric_anti_product.e412_), (self_.e42_ * geometric_anti_product.e4_) + (self_.e43_ * geometric_anti_product.e423_), (self_.e41_ * geometric_anti_product.e431_) + (self_.e43_ * geometric_anti_product.e4_), -(self_.e42_ * geometric_anti_product.e2_) - (self_.e43_ * geometric_anti_product.e3_) - (self_.e23_ * geometric_anti_product.e423_) - (self_.e31_ * geometric_anti_product.e431_) - (self_.e12_ * geometric_anti_product.e412_)) - vec4<f32>((self_groups.group0_.zxyw * geometric_anti_product_groups.group4_.yzxw).xyz, self_.e41_ * geometric_anti_product.e1_)
    ));
}
fn line_geometricAntiQuotient_origin(self_: Line, other: Origin) -> Flector {
    let self_groups = line_grouped(self_);
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    ));
}
fn line_geometricAntiQuotient_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * geometric_anti_product.e321_) + (self_.e31_ * geometric_anti_product.e412_), (self_.e42_ * geometric_anti_product.e321_) + (self_.e12_ * geometric_anti_product.e423_), (self_.e43_ * geometric_anti_product.e321_) + (self_.e23_ * geometric_anti_product.e431_), -(self_.e42_ * geometric_anti_product.e431_) - (self_.e43_ * geometric_anti_product.e412_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e42_ * geometric_anti_product.e412_, self_.e43_ * geometric_anti_product.e423_, self_.e41_ * geometric_anti_product.e431_, -(self_.e31_ * geometric_anti_product.e431_) - (self_.e12_ * geometric_anti_product.e412_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_geometricAntiQuotient_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((self_groups.group0_.yzxw * geometric_anti_product_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((self_groups.group0_.zxyw * geometric_anti_product_groups.group0_.yzxw).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, -(self_.e41_ * geometric_anti_product.e1_) - (self_.e42_ * geometric_anti_product.e2_) - (self_.e43_ * geometric_anti_product.e3_))
    ));
}
fn motor_geometricAntiQuotient_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(other.e1234_));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_
    ));
}
fn motor_geometricAntiQuotient_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ (vec4<f32>(geometric_anti_product.scalar) * self_groups.group0_) + (vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_)
    ));
}
fn motor_geometricAntiQuotient_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e3_ * self_.e42_) + (geometric_anti_product.e4_ * self_.e23_) + (geometric_anti_product.e423_ * self_.scalar) + (geometric_anti_product.e412_ * self_.e31_) + (geometric_anti_product.e321_ * self_.e41_), (geometric_anti_product.e2_ * self_.e1234_) + (geometric_anti_product.e4_ * self_.e31_) + (geometric_anti_product.e423_ * self_.e12_) + (geometric_anti_product.e431_ * self_.scalar) + (geometric_anti_product.e321_ * self_.e42_), (geometric_anti_product.e3_ * self_.e1234_) + (geometric_anti_product.e4_ * self_.e12_) + (geometric_anti_product.e431_ * self_.e23_) + (geometric_anti_product.e412_ * self_.scalar) + (geometric_anti_product.e321_ * self_.e43_), geometric_anti_product.e412_ * self_.e43_ * -1.0) + (geometric_anti_product_groups.group0_.xxyw * self_groups.group0_.wzxw) - (geometric_anti_product_groups.group1_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - (self_groups.group0_.zxyx * vec4<f32>(geometric_anti_product_groups.group0_.yzxw.xyz, geometric_anti_product.e423_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e412_ * self_.e42_, geometric_anti_product.e431_ * self_.e1234_, geometric_anti_product.e412_ * self_.e1234_, -(geometric_anti_product.e2_ * self_.e42_) - (geometric_anti_product.e3_ * self_.e43_) - (geometric_anti_product.e423_ * self_.e23_) - (geometric_anti_product.e431_ * self_.e31_) - (geometric_anti_product.e412_ * self_.e12_)) + (vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar)) + (geometric_anti_product_groups.group1_.xxyw * self_groups.group0_.wzxw) - (self_groups.group0_.zxyx * vec4<f32>(geometric_anti_product_groups.group1_.yzxw.xyz, geometric_anti_product.e1_))
    ));
}
fn motor_geometricAntiQuotient_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Line = line_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((geometric_anti_product.e41_ * self_.e1234_) + (geometric_anti_product.e43_ * self_.e42_), (geometric_anti_product.e41_ * self_.e43_) + (geometric_anti_product.e42_ * self_.e1234_), (geometric_anti_product.e42_ * self_.e41_) + (geometric_anti_product.e43_ * self_.e1234_), -(geometric_anti_product.e42_ * self_.e42_) - (geometric_anti_product.e43_ * self_.e43_)) - (self_groups.group0_.zxyx * vec4<f32>(geometric_anti_product_groups.group0_.yzxw.xyz, geometric_anti_product.e41_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((geometric_anti_product.e41_ * self_.scalar) + (geometric_anti_product.e43_ * self_.e31_) + (geometric_anti_product.e23_ * self_.e1234_) + (geometric_anti_product.e12_ * self_.e42_), (geometric_anti_product.e41_ * self_.e12_) + (geometric_anti_product.e42_ * self_.scalar) + (geometric_anti_product.e23_ * self_.e43_) + (geometric_anti_product.e31_ * self_.e1234_), (geometric_anti_product.e42_ * self_.e23_) + (geometric_anti_product.e43_ * self_.scalar) + (geometric_anti_product.e31_ * self_.e41_) + (geometric_anti_product.e12_ * self_.e1234_), -(geometric_anti_product.e43_ * self_.e12_) - (geometric_anti_product.e23_ * self_.e41_) - (geometric_anti_product.e31_ * self_.e42_) - (geometric_anti_product.e12_ * self_.e43_)) - (self_groups.group1_.zxyx * vec4<f32>(geometric_anti_product_groups.group0_.yzxw.xyz, geometric_anti_product.e41_)) - vec4<f32>((geometric_anti_product_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, geometric_anti_product.e42_ * self_.e31_)
    ));
}
fn motor_geometricAntiQuotient_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((geometric_anti_product.e43_ * self_.e42_) + (geometric_anti_product.e1234_ * self_.e41_), (geometric_anti_product.e42_ * self_.e1234_) + (geometric_anti_product.e1234_ * self_.e42_), (geometric_anti_product.e43_ * self_.e1234_) + (geometric_anti_product.e1234_ * self_.e43_), -(geometric_anti_product.e42_ * self_.e42_) - (geometric_anti_product.e43_ * self_.e43_)) + (geometric_anti_product_groups.group0_.xxyw * self_groups.group0_.wzxw) - (geometric_anti_product_groups.group0_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((geometric_anti_product.e1234_ * self_.e23_) + (geometric_anti_product.e23_ * self_.e1234_) + (geometric_anti_product.e12_ * self_.e42_) + (geometric_anti_product.scalar * self_.e41_), (geometric_anti_product.e1234_ * self_.e31_) + (geometric_anti_product.e23_ * self_.e43_) + (geometric_anti_product.e31_ * self_.e1234_) + (geometric_anti_product.scalar * self_.e42_), (geometric_anti_product.e1234_ * self_.e12_) + (geometric_anti_product.e31_ * self_.e41_) + (geometric_anti_product.e12_ * self_.e1234_) + (geometric_anti_product.scalar * self_.e43_), -(geometric_anti_product.e43_ * self_.e12_) - (geometric_anti_product.e23_ * self_.e41_) - (geometric_anti_product.e31_ * self_.e42_) - (geometric_anti_product.e12_ * self_.e43_)) + (geometric_anti_product_groups.group0_.xxyw * self_groups.group1_.wzxw) + vec4<f32>((geometric_anti_product_groups.group0_.zyzw * self_groups.group1_.ywww).xyz, geometric_anti_product.scalar * self_.e1234_) - (geometric_anti_product_groups.group0_.yzxx * self_groups.group1_.zxyx) - vec4<f32>((geometric_anti_product_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, geometric_anti_product.e42_ * self_.e31_)
    ));
}
fn motor_geometricAntiQuotient_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * geometric_anti_product.e1234_) - (self_.e41_ * geometric_anti_product.e23_) - (self_.e42_ * geometric_anti_product.e31_) - (self_.e43_ * geometric_anti_product.e12_), 0.0, 0.0, 0.0) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * geometric_anti_product_groups.group0_) - ((vec4<f32>(geometric_anti_product.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(geometric_anti_product.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(geometric_anti_product.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e42_ * geometric_anti_product.e3_) + (self_.e1234_ * geometric_anti_product.e1_) + (self_.e23_ * geometric_anti_product.e4_) + (self_.e31_ * geometric_anti_product.e412_) + (self_.scalar * geometric_anti_product.e423_), (self_.e43_ * geometric_anti_product.e1_) + (self_.e1234_ * geometric_anti_product.e2_) + (self_.e31_ * geometric_anti_product.e4_) + (self_.e12_ * geometric_anti_product.e423_) + (self_.scalar * geometric_anti_product.e431_), (self_.e43_ * geometric_anti_product.e321_) + (self_.e1234_ * geometric_anti_product.e3_) + (self_.e23_ * geometric_anti_product.e431_) + (self_.e12_ * geometric_anti_product.e4_) + (self_.scalar * geometric_anti_product.e412_), self_.e43_ * geometric_anti_product.e412_ * -1.0) + (self_groups.group0_.xyxw * vec4<f32>(geometric_anti_product_groups.group4_.wwzw.xy, geometric_anti_product.e2_, geometric_anti_product.e4_)) - (self_groups.group0_.zxyx * vec4<f32>(geometric_anti_product_groups.group1_.yzxw.xyz, geometric_anti_product.e423_)) - (geometric_anti_product_groups.group4_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (geometric_anti_product_groups.group2_.xxyw * self_groups.group0_.wzxw) + (geometric_anti_product_groups.group2_.zyzw * self_groups.group0_.ywww) - (geometric_anti_product_groups.group2_.yzxw * self_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (geometric_anti_product_groups.group2_.xxyw * self_groups.group1_.wzxw) + (geometric_anti_product_groups.group2_.zyzw * self_groups.group1_.ywww) + (geometric_anti_product_groups.group3_.xxyw * self_groups.group0_.wzxw) + (geometric_anti_product_groups.group3_.zyzw * self_groups.group0_.ywww) - (geometric_anti_product_groups.group2_.yzxw * self_groups.group1_.zxyw) - (geometric_anti_product_groups.group3_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_ * geometric_anti_product.e423_, self_.e1234_ * geometric_anti_product.e431_, self_.e1234_ * geometric_anti_product.e412_, -(self_.e42_ * geometric_anti_product.e2_) - (self_.e43_ * geometric_anti_product.e3_) - (self_.e23_ * geometric_anti_product.e423_) - (self_.e31_ * geometric_anti_product.e431_) - (self_.e12_ * geometric_anti_product.e412_)) + (self_groups.group0_.xyxw * vec4<f32>(geometric_anti_product_groups.group1_.wwzw.xy, geometric_anti_product.e431_, geometric_anti_product.e321_)) + (vec4<f32>(geometric_anti_product_groups.group4_.zxzw.xy, geometric_anti_product.e4_, geometric_anti_product.e4_) * vec4<f32>(self_groups.group0_.yzzw.xyz, self_.scalar)) - (self_groups.group0_.zxyx * vec4<f32>(geometric_anti_product_groups.group4_.yzxw.xyz, geometric_anti_product.e1_))
    ));
}
fn motor_geometricAntiQuotient_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e1234_), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar)
    ));
}
fn motor_geometricAntiQuotient_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * geometric_anti_product.e321_) + (self_.e31_ * geometric_anti_product.e412_) + (self_.scalar * geometric_anti_product.e423_), (self_.e42_ * geometric_anti_product.e321_) + (self_.e12_ * geometric_anti_product.e423_) + (self_.scalar * geometric_anti_product.e431_), (self_.e43_ * geometric_anti_product.e321_) + (self_.e23_ * geometric_anti_product.e431_) + (self_.scalar * geometric_anti_product.e412_), -(self_.e42_ * geometric_anti_product.e431_) - (self_.e43_ * geometric_anti_product.e412_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_ * geometric_anti_product.e423_, self_.e1234_ * geometric_anti_product.e431_, self_.e1234_ * geometric_anti_product.e412_, -(self_.e31_ * geometric_anti_product.e431_) - (self_.e12_ * geometric_anti_product.e412_)) + (self_groups.group0_.yzxw * geometric_anti_product_groups.group0_.zxyw) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_geometricAntiQuotient_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.yzxw * geometric_anti_product_groups.group0_.zxyw) - (self_groups.group0_.zxyw * geometric_anti_product_groups.group0_.yzxw)).xyz, self_.e1234_ * geometric_anti_product.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, (self_.scalar * geometric_anti_product.e4_) - (self_.e41_ * geometric_anti_product.e1_) - (self_.e42_ * geometric_anti_product.e2_) - (self_.e43_ * geometric_anti_product.e3_))
    ));
}
fn multiVector_geometricAntiQuotient_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(other.e1234_));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group4_
    ));
}
fn multiVector_geometricAntiQuotient_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product_groups: DualNumGroups = DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    );
    let geometric_anti_product: DualNum = dualNum_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((geometric_anti_product.scalar * self_.e1234_) + (geometric_anti_product.e1234_ * self_.scalar), geometric_anti_product.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_)).xyz, geometric_anti_product.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product_groups.group0_.yyzw.xy, geometric_anti_product.e1234_, (geometric_anti_product.e1234_ * self_.e321_) - (geometric_anti_product.scalar * self_.e4_)) * vec4<f32>(self_groups.group4_.xyz, 1.0)
    ));
}
fn multiVector_geometricAntiQuotient_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((geometric_anti_product.e321_ * self_.e4_) - (geometric_anti_product.e2_ * self_.e431_) - (geometric_anti_product.e3_ * self_.e412_) - (geometric_anti_product.e4_ * self_.e321_), 0.0, 0.0, 0.0) + ((vec4<f32>(geometric_anti_product.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * geometric_anti_product_groups.group0_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e1_ * self_.e1234_) + (geometric_anti_product.e3_ * self_.e42_) + (geometric_anti_product.e4_ * self_.e23_) + (geometric_anti_product.e412_ * self_.e31_) + (geometric_anti_product.e321_ * self_.e41_), (geometric_anti_product.e1_ * self_.e43_) + (geometric_anti_product.e2_ * self_.e1234_) + (geometric_anti_product.e4_ * self_.e31_) + (geometric_anti_product.e423_ * self_.e12_) + (geometric_anti_product.e321_ * self_.e42_), (geometric_anti_product.e2_ * self_.e41_) + (geometric_anti_product.e3_ * self_.e1234_) + (geometric_anti_product.e4_ * self_.e12_) + (geometric_anti_product.e431_ * self_.e23_) + (geometric_anti_product.e321_ * self_.e43_), geometric_anti_product.e412_ * self_.e43_ * -1.0) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, self_.e1234_) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e4_)) - (geometric_anti_product_groups.group1_.yzxy * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group2_.zxyw * geometric_anti_product_groups.group0_.yzxw).xyz, geometric_anti_product.e423_ * self_.e41_), 
        /* e41, e42, e43 */ (geometric_anti_product_groups.group1_.yzxw * self_groups.group4_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * geometric_anti_product_groups.group1_.xxyw) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * geometric_anti_product_groups.group1_.zyzw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * geometric_anti_product_groups.group0_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * geometric_anti_product_groups.group0_.zyzw) + (geometric_anti_product_groups.group1_.yzxw * self_groups.group1_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, 0.0) * geometric_anti_product_groups.group1_.zyzw) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, 0.0) * geometric_anti_product_groups.group1_.xxyw) - (geometric_anti_product_groups.group0_.yzxw * self_groups.group4_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e412_ * self_.e42_, geometric_anti_product.e423_ * self_.e43_, geometric_anti_product.e4_ * self_.e43_, -(geometric_anti_product.e2_ * self_.e42_) - (geometric_anti_product.e3_ * self_.e43_) - (geometric_anti_product.e423_ * self_.e23_) - (geometric_anti_product.e431_ * self_.e31_) - (geometric_anti_product.e412_ * self_.e12_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e4_)) + (vec4<f32>(geometric_anti_product_groups.group0_.wwzw.xy, geometric_anti_product.e431_, geometric_anti_product.e321_) * vec4<f32>(self_groups.group2_.xyxw.xyz, self_.e1234_)) - vec4<f32>((self_groups.group2_.zxyw * geometric_anti_product_groups.group1_.yzxw).xyz, geometric_anti_product.e1_ * self_.e41_)
    ));
}
fn multiVector_geometricAntiQuotient_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Line = line_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(geometric_anti_product.e23_ * self_.e41_) - (geometric_anti_product.e31_ * self_.e42_) - (geometric_anti_product.e12_ * self_.e43_), 0.0, 0.0, 0.0) - ((vec4<f32>(geometric_anti_product.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(geometric_anti_product.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(geometric_anti_product.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e41_ * self_.e321_) + (geometric_anti_product.e43_ * self_.e2_) + (geometric_anti_product.e31_ * self_.e412_), (geometric_anti_product.e41_ * self_.e3_) + (geometric_anti_product.e42_ * self_.e321_) + (geometric_anti_product.e12_ * self_.e423_), (geometric_anti_product.e42_ * self_.e1_) + (geometric_anti_product.e43_ * self_.e321_) + (geometric_anti_product.e23_ * self_.e431_), 0.0) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(geometric_anti_product_groups.group1_.xxyw.xyz, geometric_anti_product.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(geometric_anti_product_groups.group1_.zyzw.xyz, geometric_anti_product.e43_)) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, geometric_anti_product.e41_ * self_.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + (geometric_anti_product_groups.group0_.zxyw * self_groups.group2_.yzxw) - (geometric_anti_product_groups.group0_.yzxw * self_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_) + (geometric_anti_product_groups.group0_.zxyw * self_groups.group3_.yzxw) + (geometric_anti_product_groups.group1_.zxyw * self_groups.group2_.yzxw) - (geometric_anti_product_groups.group0_.yzxw * self_groups.group3_.zxyw) - (geometric_anti_product_groups.group1_.yzxw * self_groups.group2_.zxyw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(geometric_anti_product_groups.group0_.xxyw.xyz, geometric_anti_product.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(geometric_anti_product_groups.group0_.zyzw.xyz, geometric_anti_product.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (geometric_anti_product.e12_ * self_.e412_) - (geometric_anti_product.e42_ * self_.e2_) - (geometric_anti_product.e43_ * self_.e3_)) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group4_.zxyw).xyz, geometric_anti_product.e41_ * self_.e1_)
    ));
}
fn multiVector_geometricAntiQuotient_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((geometric_anti_product.scalar * self_.e1234_) - (geometric_anti_product.e41_ * self_.e23_) - (geometric_anti_product.e42_ * self_.e31_) - (geometric_anti_product.e43_ * self_.e12_), 0.0, 0.0, 0.0) + ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e23_, geometric_anti_product.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e31_, geometric_anti_product.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e12_, geometric_anti_product.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e43_ * self_.e2_) + (geometric_anti_product.e1234_ * self_.e1_) + (geometric_anti_product.e31_ * self_.e412_) - (geometric_anti_product.scalar * self_.e423_), (geometric_anti_product.e42_ * self_.e321_) + (geometric_anti_product.e1234_ * self_.e2_) + (geometric_anti_product.e12_ * self_.e423_) - (geometric_anti_product.scalar * self_.e431_), (geometric_anti_product.e43_ * self_.e321_) + (geometric_anti_product.e1234_ * self_.e3_) + (geometric_anti_product.e23_ * self_.e431_) - (geometric_anti_product.scalar * self_.e412_), 0.0) + (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, self_.e4_) * geometric_anti_product_groups.group0_.xxyw) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(geometric_anti_product_groups.group1_.xxyw.xyz, geometric_anti_product.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(geometric_anti_product_groups.group1_.zyzw.xyz, geometric_anti_product.e43_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e423_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + (self_groups.group2_.xyxw * geometric_anti_product_groups.group0_.wwyw) + (self_groups.group2_.yzzw * geometric_anti_product_groups.group0_.zxww) - (self_groups.group2_.zxyw * geometric_anti_product_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_) + (self_groups.group2_.xyxw * geometric_anti_product_groups.group1_.wwyw) + (self_groups.group2_.yzzw * geometric_anti_product_groups.group1_.zxww) + (self_groups.group3_.xyxw * geometric_anti_product_groups.group0_.wwyw) + (self_groups.group3_.yzzw * geometric_anti_product_groups.group0_.zxww) - (self_groups.group2_.zxyw * geometric_anti_product_groups.group1_.yzxw) - (self_groups.group3_.zxyw * geometric_anti_product_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e321_) * geometric_anti_product_groups.group0_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(geometric_anti_product_groups.group0_.zyzw.xyz, geometric_anti_product.e23_)) + (self_groups.group4_.xyzy * vec4<f32>(geometric_anti_product_groups.group0_.wwww.xyz, geometric_anti_product.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (geometric_anti_product.e12_ * self_.e412_) - (geometric_anti_product.e42_ * self_.e2_) - (geometric_anti_product.e43_ * self_.e3_) - (geometric_anti_product.scalar * self_.e4_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group4_.zxyw.xyz, self_.e1_))
    ));
}
fn multiVector_geometricAntiQuotient_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((geometric_anti_product.e1234_ * self_.scalar) + (geometric_anti_product.e321_ * self_.e4_) - (geometric_anti_product.e2_ * self_.e431_) - (geometric_anti_product.e3_ * self_.e412_) - (geometric_anti_product.e4_ * self_.e321_) - (geometric_anti_product.e23_ * self_.e41_) - (geometric_anti_product.e31_ * self_.e42_) - (geometric_anti_product.e12_ * self_.e43_), 0.0, 0.0, 0.0) + ((vec4<f32>(geometric_anti_product.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * geometric_anti_product_groups.group0_) - ((vec4<f32>(geometric_anti_product.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(geometric_anti_product.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(geometric_anti_product.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * geometric_anti_product_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e1_ * self_.e1234_) + (geometric_anti_product.e3_ * self_.e42_) + (geometric_anti_product.e4_ * self_.e23_) + (geometric_anti_product.e41_ * self_.e321_) + (geometric_anti_product.e43_ * self_.e2_) + (geometric_anti_product.e31_ * self_.e412_) + (geometric_anti_product.e412_ * self_.e31_) + (geometric_anti_product.e321_ * self_.e41_), (geometric_anti_product.e1_ * self_.e43_) + (geometric_anti_product.e2_ * self_.e1234_) + (geometric_anti_product.e4_ * self_.e31_) + (geometric_anti_product.e41_ * self_.e3_) + (geometric_anti_product.e42_ * self_.e321_) + (geometric_anti_product.e12_ * self_.e423_) + (geometric_anti_product.e423_ * self_.e12_) + (geometric_anti_product.e321_ * self_.e42_), (geometric_anti_product.e2_ * self_.e41_) + (geometric_anti_product.e3_ * self_.e1234_) + (geometric_anti_product.e4_ * self_.e12_) + (geometric_anti_product.e42_ * self_.e1_) + (geometric_anti_product.e43_ * self_.e321_) + (geometric_anti_product.e23_ * self_.e431_) + (geometric_anti_product.e431_ * self_.e23_) + (geometric_anti_product.e321_ * self_.e43_), 0.0) + (vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, self_.e1234_) * vec4<f32>(geometric_anti_product_groups.group4_.xyz, geometric_anti_product.e4_)) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e412_) * vec4<f32>(geometric_anti_product_groups.group3_.xxyw.xyz, geometric_anti_product.e43_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, geometric_anti_product.e423_) * vec4<f32>(geometric_anti_product_groups.group3_.zyzw.xyz, self_.e41_)) - (geometric_anti_product_groups.group4_.yzxz * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e43_)) - (self_groups.group4_.xyzx * vec4<f32>(geometric_anti_product_groups.group0_.xxzw.xy, geometric_anti_product.scalar, geometric_anti_product.e41_)) - vec4<f32>((geometric_anti_product_groups.group2_.yzxw * self_groups.group1_.zxyw).xyz, geometric_anti_product.e42_ * self_.e431_) - vec4<f32>((self_groups.group2_.zxyw * geometric_anti_product_groups.group1_.yzxw).xyz, geometric_anti_product.e431_ * self_.e42_), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_) + (geometric_anti_product_groups.group2_.zxyw * self_groups.group2_.yzxw) + (geometric_anti_product_groups.group4_.yzxw * self_groups.group4_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * geometric_anti_product_groups.group4_.xxyw) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * geometric_anti_product_groups.group4_.zyzw) - (geometric_anti_product_groups.group2_.yzxw * self_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(geometric_anti_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group3_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * geometric_anti_product_groups.group1_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * geometric_anti_product_groups.group1_.zyzw) + (geometric_anti_product_groups.group2_.zxyw * self_groups.group3_.yzxw) + (geometric_anti_product_groups.group3_.zxyw * self_groups.group2_.yzxw) + (geometric_anti_product_groups.group4_.yzxw * self_groups.group1_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, 0.0) * geometric_anti_product_groups.group4_.zyzw) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, 0.0) * geometric_anti_product_groups.group4_.xxyw) - (geometric_anti_product_groups.group2_.yzxw * self_groups.group3_.zxyw) - (geometric_anti_product_groups.group3_.yzxw * self_groups.group2_.zxyw) - (geometric_anti_product_groups.group1_.yzxw * self_groups.group4_.zxyw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(geometric_anti_product.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, geometric_anti_product.e321_) * vec4<f32>(geometric_anti_product_groups.group2_.xxyw.xyz, self_.e1234_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(geometric_anti_product_groups.group2_.zyzw.xyz, geometric_anti_product.e23_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(geometric_anti_product_groups.group4_.xyz, geometric_anti_product.e4_)) + (vec4<f32>(geometric_anti_product_groups.group1_.wwzw.xy, geometric_anti_product.e431_, self_.e431_) * vec4<f32>(self_groups.group2_.xyxw.xyz, geometric_anti_product.e31_)) + (vec4<f32>(geometric_anti_product_groups.group4_.zxzw.xy, geometric_anti_product.e4_, self_.e412_) * vec4<f32>(self_groups.group2_.yzzw.xyz, geometric_anti_product.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, -(geometric_anti_product.e1_ * self_.e41_) - (geometric_anti_product.e2_ * self_.e42_) - (geometric_anti_product.e3_ * self_.e43_) - (geometric_anti_product.e42_ * self_.e2_) - (geometric_anti_product.e43_ * self_.e3_) - (geometric_anti_product.e423_ * self_.e23_) - (geometric_anti_product.e431_ * self_.e31_) - (geometric_anti_product.e412_ * self_.e12_)) - vec4<f32>((geometric_anti_product_groups.group2_.yzxw * self_groups.group4_.zxyw).xyz, geometric_anti_product.scalar * self_.e4_) - vec4<f32>((self_groups.group2_.zxyw * geometric_anti_product_groups.group4_.yzxw).xyz, geometric_anti_product.e41_ * self_.e1_)
    ));
}
fn multiVector_geometricAntiQuotient_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e321_, self_.e4_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group3_.xyz, self_.e1234_), 
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(self_groups.group2_.xyz, self_.scalar)
    ));
}
fn multiVector_geometricAntiQuotient_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e4_ * geometric_anti_product.e321_, 0.0, 0.0, 0.0) + ((vec4<f32>(geometric_anti_product.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(geometric_anti_product.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.scalar * geometric_anti_product.e423_) + (self_.e41_ * geometric_anti_product.e321_) + (self_.e31_ * geometric_anti_product.e412_), (self_.scalar * geometric_anti_product.e431_) + (self_.e42_ * geometric_anti_product.e321_) + (self_.e12_ * geometric_anti_product.e423_), (self_.scalar * geometric_anti_product.e412_) + (self_.e43_ * geometric_anti_product.e321_) + (self_.e23_ * geometric_anti_product.e431_), -(self_.e42_ * geometric_anti_product.e431_) - (self_.e43_ * geometric_anti_product.e412_)) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * geometric_anti_product_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) - (self_groups.group4_.yzxw * geometric_anti_product_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (self_groups.group1_.zxyw * geometric_anti_product_groups.group0_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) - (self_groups.group1_.yzxw * geometric_anti_product_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e42_ * geometric_anti_product.e412_, self_.e43_ * geometric_anti_product.e423_, self_.e41_ * geometric_anti_product.e431_, -(self_.e31_ * geometric_anti_product.e431_) - (self_.e12_ * geometric_anti_product.e412_)) + (vec4<f32>(self_.e1234_) * geometric_anti_product_groups.group0_) - (geometric_anti_product_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    ));
}
fn multiVector_geometricAntiQuotient_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e423_ * geometric_anti_product.e1_) - (self_.e431_ * geometric_anti_product.e2_) - (self_.e412_ * geometric_anti_product.e3_) - (self_.e321_ * geometric_anti_product.e4_), self_.e4_ * geometric_anti_product.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + (self_groups.group2_.yzxw * geometric_anti_product_groups.group0_.zxyw) - (self_groups.group2_.zxyw * geometric_anti_product_groups.group0_.yzxw)).xyz, self_.e1234_ * geometric_anti_product.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) + (self_groups.group4_.yzxw * geometric_anti_product_groups.group0_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (self_groups.group4_.zxyw * geometric_anti_product_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, (self_.scalar * geometric_anti_product.e4_) - (self_.e41_ * geometric_anti_product.e1_) - (self_.e42_ * geometric_anti_product.e2_) - (self_.e43_ * geometric_anti_product.e3_))
    ));
}
fn origin_geometricAntiQuotient_antiScalar(self_: Origin, other: AntiScalar) -> Origin {
    return Origin(self_.e4_ / (other.e1234_));
}
fn origin_geometricAntiQuotient_dualNum(self_: Origin, other: DualNum) -> Flector {
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.scalar * self_.e4_ * -1.0)
    ));
}
fn origin_geometricAntiQuotient_flector(self_: Origin, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group0_.xyz, geometric_anti_product.e321_)
    ));
}
fn origin_geometricAntiQuotient_line(self_: Origin, other: Line) -> Flector {
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_).xyz, 0.0)
    ));
}
fn origin_geometricAntiQuotient_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group0_.xyz, geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    ));
}
fn origin_geometricAntiQuotient_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_anti_product.e321_, geometric_anti_product.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group3_.xyz, geometric_anti_product.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group2_.xyz, geometric_anti_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    ));
}
fn origin_geometricAntiQuotient_origin(self_: Origin, other: Origin) -> AntiScalar {
    return AntiScalar(self_.e4_ / (other.e4_));
}
fn origin_geometricAntiQuotient_plane(self_: Origin, other: Plane) -> Motor {
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * geometric_anti_product.e321_)
    ));
}
fn origin_geometricAntiQuotient_point(self_: Origin, other: Point) -> Motor {
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * geometric_anti_product.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_).xyz, 0.0)
    ));
}
fn plane_geometricAntiQuotient_antiScalar(self_: Plane, other: AntiScalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(1.0/(other.e1234_)) * self_groups.group0_
    ));
}
fn plane_geometricAntiQuotient_dualNum(self_: Plane, other: DualNum) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product_groups: DualNumGroups = DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    );
    let geometric_anti_product: DualNum = dualNum_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product_groups.group0_.xxzw.xy, geometric_anti_product.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_
    ));
}
fn plane_geometricAntiQuotient_flector(self_: Plane, other: Flector) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(geometric_anti_product.e4_ * self_.e423_) - (geometric_anti_product.e412_ * self_.e431_), -(geometric_anti_product.e4_ * self_.e431_) - (geometric_anti_product.e423_ * self_.e412_), -(geometric_anti_product.e4_ * self_.e412_) - (geometric_anti_product.e431_ * self_.e423_), (geometric_anti_product.e431_ * self_.e431_) + (geometric_anti_product.e412_ * self_.e412_)) + (geometric_anti_product_groups.group1_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((geometric_anti_product.e3_ * self_.e431_) + (geometric_anti_product.e321_ * self_.e423_), (geometric_anti_product.e1_ * self_.e412_) + (geometric_anti_product.e321_ * self_.e431_), (geometric_anti_product.e2_ * self_.e423_) + (geometric_anti_product.e321_ * self_.e412_), -(geometric_anti_product.e3_ * self_.e412_) - (geometric_anti_product.e4_ * self_.e321_)) - (geometric_anti_product_groups.group0_.yzxx * self_groups.group0_.zxyx) - (self_groups.group0_.wwwy * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e2_))
    ));
}
fn plane_geometricAntiQuotient_line(self_: Plane, other: Line) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Line = line_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e41_ * self_.e321_) + (geometric_anti_product.e31_ * self_.e412_), (geometric_anti_product.e42_ * self_.e321_) + (geometric_anti_product.e12_ * self_.e423_), (geometric_anti_product.e43_ * self_.e321_) + (geometric_anti_product.e23_ * self_.e431_), -(geometric_anti_product.e42_ * self_.e431_) - (geometric_anti_product.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_anti_product_groups.group1_.zxyw.xyz, geometric_anti_product.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e42_ * self_.e412_ * -1.0, geometric_anti_product.e43_ * self_.e423_ * -1.0, geometric_anti_product.e41_ * self_.e431_ * -1.0, (geometric_anti_product.e31_ * self_.e431_) + (geometric_anti_product.e12_ * self_.e412_)) + (self_groups.group0_.yzxx * vec4<f32>(geometric_anti_product_groups.group0_.zxyw.xyz, geometric_anti_product.e23_))
    ));
}
fn plane_geometricAntiQuotient_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e41_ * self_.e321_) + (geometric_anti_product.e31_ * self_.e412_), (geometric_anti_product.e42_ * self_.e321_) + (geometric_anti_product.e12_ * self_.e423_), (geometric_anti_product.e43_ * self_.e321_) + (geometric_anti_product.e23_ * self_.e431_), geometric_anti_product.e43_ * self_.e412_ * -1.0) - (self_groups.group0_.xyzy * vec4<f32>(geometric_anti_product_groups.group1_.wwww.xyz, geometric_anti_product.e42_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_anti_product_groups.group1_.zxyw.xyz, geometric_anti_product.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e42_ * self_.e412_ * -1.0, geometric_anti_product.e43_ * self_.e423_ * -1.0, geometric_anti_product.e41_ * self_.e431_ * -1.0, (geometric_anti_product.e31_ * self_.e431_) + (geometric_anti_product.e12_ * self_.e412_)) + (geometric_anti_product_groups.group0_.zxyw * self_groups.group0_.yzxw) + (self_groups.group0_.xyzx * vec4<f32>(geometric_anti_product_groups.group0_.wwww.xyz, geometric_anti_product.e23_))
    ));
}
fn plane_geometricAntiQuotient_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(geometric_anti_product.e1_ * self_.e423_) - (geometric_anti_product.e2_ * self_.e431_) - (geometric_anti_product.e3_ * self_.e412_) - (geometric_anti_product.e4_ * self_.e321_), (geometric_anti_product.e423_ * self_.e423_) + (geometric_anti_product.e431_ * self_.e431_) + (geometric_anti_product.e412_ * self_.e412_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product.e41_ * self_.e321_) + (geometric_anti_product.e31_ * self_.e412_), (geometric_anti_product.e42_ * self_.e321_) + (geometric_anti_product.e12_ * self_.e423_), (geometric_anti_product.e43_ * self_.e321_) + (geometric_anti_product.e23_ * self_.e431_), geometric_anti_product.e43_ * self_.e412_ * -1.0) - (self_groups.group0_.xyzx * vec4<f32>(geometric_anti_product_groups.group0_.xxzw.xy, geometric_anti_product.scalar, geometric_anti_product.e41_)) - (self_groups.group0_.yzxy * vec4<f32>(geometric_anti_product_groups.group3_.zxyw.xyz, geometric_anti_product.e42_)), 
        /* e41, e42, e43 */ (geometric_anti_product_groups.group4_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (geometric_anti_product_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_anti_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (geometric_anti_product_groups.group1_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_) - (geometric_anti_product_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e42_ * self_.e412_ * -1.0, geometric_anti_product.e43_ * self_.e423_ * -1.0, geometric_anti_product.e41_ * self_.e431_ * -1.0, (geometric_anti_product.e31_ * self_.e431_) + (geometric_anti_product.e12_ * self_.e412_)) + (vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_) + (self_groups.group0_.yzxx * vec4<f32>(geometric_anti_product_groups.group2_.zxyw.xyz, geometric_anti_product.e23_))
    ));
}
fn plane_geometricAntiQuotient_origin(self_: Plane, other: Origin) -> Motor {
    let self_groups = plane_grouped(self_);
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.e4_ * self_.e321_ * -1.0)
    ));
}
fn plane_geometricAntiQuotient_plane(self_: Plane, other: Plane) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e412_ * self_.e431_ * -1.0, geometric_anti_product.e423_ * self_.e412_ * -1.0, geometric_anti_product.e431_ * self_.e423_ * -1.0, (geometric_anti_product.e431_ * self_.e431_) + (geometric_anti_product.e412_ * self_.e412_)) + (geometric_anti_product_groups.group0_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(geometric_anti_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_)).xyz, 0.0)
    ));
}
fn plane_geometricAntiQuotient_point(self_: Plane, other: Point) -> Motor {
    let self_groups = plane_grouped(self_);
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(geometric_anti_product_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e431_ * geometric_anti_product.e3_, self_.e412_ * geometric_anti_product.e1_, self_.e423_ * geometric_anti_product.e2_, -(self_.e431_ * geometric_anti_product.e2_) - (self_.e412_ * geometric_anti_product.e3_) - (self_.e321_ * geometric_anti_product.e4_)) - (self_groups.group0_.zxyx * geometric_anti_product_groups.group0_.yzxx)
    ));
}
fn point_geometricAntiQuotient_antiScalar(self_: Point, other: AntiScalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(1.0/(other.e1234_)) * self_groups.group0_
    ));
}
fn point_geometricAntiQuotient_dualNum(self_: Point, other: DualNum) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_anti_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.e1234_, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.scalar * self_.e4_ * -1.0)
    ));
}
fn point_geometricAntiQuotient_flector(self_: Point, other: Flector) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_anti_product_groups.group1_.xyz, geometric_anti_product.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(geometric_anti_product.e4_ * self_.e1_) - (geometric_anti_product.e412_ * self_.e2_), -(geometric_anti_product.e4_ * self_.e2_) - (geometric_anti_product.e423_ * self_.e3_), -(geometric_anti_product.e4_ * self_.e3_) - (geometric_anti_product.e431_ * self_.e1_), (geometric_anti_product.e412_ * self_.e3_) + (geometric_anti_product.e321_ * self_.e4_)) + (geometric_anti_product_groups.group1_.yzxy * self_groups.group0_.zxyy) + (self_groups.group0_.wwwx * vec4<f32>(geometric_anti_product_groups.group0_.xyz, geometric_anti_product.e423_))
    ));
}
fn point_geometricAntiQuotient_line(self_: Point, other: Line) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    let geometric_anti_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Line = line_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_anti_product_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_).xyz, 0.0) - vec4<f32>((geometric_anti_product_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_).xyz, -(geometric_anti_product.e41_ * self_.e1_) - (geometric_anti_product.e42_ * self_.e2_) - (geometric_anti_product.e43_ * self_.e3_))
    ));
}
fn point_geometricAntiQuotient_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    let geometric_anti_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Motor = motor_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (geometric_anti_product_groups.group0_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_) - (geometric_anti_product_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, geometric_anti_product.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_).xyz, -(geometric_anti_product.e41_ * self_.e1_) - (geometric_anti_product.e42_ * self_.e2_) - (geometric_anti_product.e43_ * self_.e3_) - (geometric_anti_product.scalar * self_.e4_))
    ));
}
fn point_geometricAntiQuotient_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((geometric_anti_product.e423_ * self_.e1_) + (geometric_anti_product.e431_ * self_.e2_) + (geometric_anti_product.e412_ * self_.e3_) + (geometric_anti_product.e321_ * self_.e4_), geometric_anti_product.e4_ * self_.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (geometric_anti_product_groups.group2_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group3_) - (geometric_anti_product_groups.group2_.yzxw * self_groups.group0_.zxyw)).xyz, geometric_anti_product.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_) + (geometric_anti_product_groups.group4_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (geometric_anti_product_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_).xyz, -(geometric_anti_product.scalar * self_.e4_) - (geometric_anti_product.e41_ * self_.e1_) - (geometric_anti_product.e42_ * self_.e2_) - (geometric_anti_product.e43_ * self_.e3_))
    ));
}
fn point_geometricAntiQuotient_origin(self_: Point, other: Origin) -> Motor {
    let self_groups = point_grouped(self_);
    let geometric_anti_product: Origin = Origin(1.0/(other.e4_) * -1.0);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.e4_ * self_.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn point_geometricAntiQuotient_plane(self_: Point, other: Plane) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    let geometric_anti_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2)) * other_groups.group0_
    );
    let geometric_anti_product: Plane = plane_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(geometric_anti_product_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_anti_product.e412_ * self_.e2_ * -1.0, geometric_anti_product.e423_ * self_.e3_ * -1.0, geometric_anti_product.e431_ * self_.e1_ * -1.0, (geometric_anti_product.e431_ * self_.e2_) + (geometric_anti_product.e412_ * self_.e3_) + (geometric_anti_product.e321_ * self_.e4_)) + (geometric_anti_product_groups.group0_.yzxx * self_groups.group0_.zxyx)
    ));
}
fn point_geometricAntiQuotient_point(self_: Point, other: Point) -> Motor {
    let self_groups = point_grouped(self_);
    let geometric_anti_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e4_, -2)) * vec4<f32>(other.e1_ * -1.0, other.e2_ * -1.0, other.e3_ * -1.0, other.e4_ * -1.0)
    );
    let geometric_anti_product: Point = point_degroup(geometric_anti_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.e4_ * self_.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group0_) - ((vec4<f32>(geometric_anti_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, 0.0)
    ));
}
fn scalar_geometricAntiQuotient_antiScalar(self_: Scalar, other: AntiScalar) -> Scalar {
    return Scalar(self_.scalar / (other.e1234_));
}
fn scalar_geometricAntiQuotient_dualNum(self_: Scalar, other: DualNum) -> Scalar {
    return Scalar(self_.scalar / (other.e1234_));
}
fn scalar_geometricAntiQuotient_flector(self_: Scalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e4_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_
    );
    let geometric_anti_product: Flector = flector_degroup(geometric_anti_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.e4_ * self_.scalar)
    ));
}
fn scalar_geometricAntiQuotient_line(self_: Scalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let anti_reverse: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other_2.e1234_ * anti_reverse.e41_, other_2.e1234_ * anti_reverse.e42_, other_2.e1234_ * anti_reverse.e43_, 0.0)
    ));
}
fn scalar_geometricAntiQuotient_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_reverse: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
    let other_2: AntiScalar = AntiScalar(pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e1234_, 2));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * vec4<f32>(other_2.e1234_ * anti_reverse.e41_, other_2.e1234_ * anti_reverse.e42_, other_2.e1234_ * anti_reverse.e43_, other_2.e1234_ * anti_reverse.e1234_)
    ));
}
fn scalar_geometricAntiQuotient_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_
    );
    let other_2: AntiScalar = AntiScalar(pow(other.e1234_, 2) + pow(other.e4_, 2) + pow(other.e41_, 2) + pow(other.e42_, 2) + pow(other.e43_, 2) + pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    let geometric_anti_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * anti_reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.e1234_) * anti_reverse_groups.group4_
    );
    let geometric_anti_product: MultiVector = multiVector_degroup(geometric_anti_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(geometric_anti_product.e1234_ * self_.scalar, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group4_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_anti_product_groups.group2_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_anti_product.e4_ * self_.scalar)
    ));
}
fn scalar_geometricAntiQuotient_origin(self_: Scalar, other: Origin) -> Horizon {
    return Horizon(self_.scalar / (other.e4_) * -1.0);
}
fn scalar_geometricAntiQuotient_plane(self_: Scalar, other: Plane) -> Point {
    let other_2: AntiScalar = AntiScalar(pow(other.e423_, 2) + pow(other.e431_, 2) + pow(other.e412_, 2));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other_2.e1234_ * other.e423_, other_2.e1234_ * other.e431_, other_2.e1234_ * other.e412_, other_2.e1234_ * other.e321_)).xyz, 0.0)
    ));
}
fn scalar_geometricAntiQuotient_point(self_: Scalar, other: Point) -> Horizon {
    return Horizon(self_.scalar / (other.e4_) * -1.0);
}
fn antiScalar_geometricProduct_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.scalar);
}
fn antiScalar_geometricProduct_flector(self_: AntiScalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_geometricProduct_horizon(self_: AntiScalar, other: Horizon) -> Origin {
    return Origin(self_.e1234_ * other.e321_ * -1.0);
}
fn antiScalar_geometricProduct_line(self_: AntiScalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_geometricProduct_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_geometricProduct_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e1234_ * other.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_geometricProduct_plane(self_: AntiScalar, other: Plane) -> Origin {
    return Origin(self_.e1234_ * other.e321_ * -1.0);
}
fn antiScalar_geometricProduct_point(self_: AntiScalar, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_geometricProduct_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.scalar);
}
fn dualNum_geometricProduct_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.scalar);
}
fn dualNum_geometricProduct_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0)
    ));
}
fn dualNum_geometricProduct_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e4_) - (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group0_.xyz, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, self_.scalar * other.e321_)
    ));
}
fn dualNum_geometricProduct_horizon(self_: DualNum, other: Horizon) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e321_)
    ));
}
fn dualNum_geometricProduct_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn dualNum_geometricProduct_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(self_.scalar) * other_groups.group0_) + (vec4<f32>(self_.e1234_) * other_groups.group1_), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn dualNum_geometricProduct_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e4_) - (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group1_.xyz, 1.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, self_.scalar * other.e321_)
    ));
}
fn dualNum_geometricProduct_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.scalar * other.e4_);
}
fn dualNum_geometricProduct_plane(self_: DualNum, other: Plane) -> Flector {
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn dualNum_geometricProduct_point(self_: DualNum, other: Point) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    ));
}
fn dualNum_geometricProduct_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn flector_geometricProduct_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    ));
}
fn flector_geometricProduct_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e4_) + (other.e1234_ * self_.e321_)) * vec4<f32>(self_groups.group0_.xyz, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, other.scalar * self_.e321_)
    ));
}
fn flector_geometricProduct_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)) + (other_groups.group1_.zxyz * self_groups.group0_.yzxz) + (vec4<f32>(self_groups.group0_.wwzw.xy, self_.e431_, self_.e1_) * vec4<f32>(other_groups.group0_.xyxw.xyz, other.e423_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e4_, self_.e2_) * vec4<f32>(other_groups.group0_.yzzw.xyz, other.e431_)) - (other_groups.group0_.zxyx * self_groups.group1_.yzxx) - (other_groups.group0_.wwwy * vec4<f32>(self_groups.group0_.xyz, self_.e431_)) - (vec4<f32>(self_groups.group0_.zxzw.xy, self_.e321_, self_.e321_) * vec4<f32>(other_groups.group1_.yzzw.xyz, other.e4_)) - (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e412_) * vec4<f32>(other_groups.group1_.xyxw.xyz, other.e3_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(other.e2_ * self_.e3_) - (other.e321_ * self_.e1_), -(other.e3_ * self_.e1_) - (other.e321_ * self_.e2_), -(other.e3_ * self_.e321_) - (other.e321_ * self_.e3_), (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx) - (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group0_.xyxw.xyz, other.e321_))
    ));
}
fn flector_geometricProduct_horizon(self_: Flector, other: Horizon) -> Motor {
    let self_groups = flector_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    ));
}
fn flector_geometricProduct_line(self_: Flector, other: Line) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e3_ * other.e31_) + (self_.e321_ * other.e23_), (self_.e1_ * other.e12_) + (self_.e321_ * other.e31_), (self_.e2_ * other.e23_) + (self_.e321_ * other.e12_), -(self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e423_ * other.e23_) - (self_.e431_ * other.e31_) - (self_.e412_ * other.e12_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), self_.e3_ * other.e12_ * -1.0) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group1_.yzxw).xyz, self_.e2_ * other.e31_)
    ));
}
fn flector_geometricProduct_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_ * other.e23_, self_.e321_ * other.e31_, self_.e321_ * other.e12_, -(self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e423_ * other.e23_) - (self_.e431_ * other.e31_) - (self_.e412_ * other.e12_)) + (self_groups.group0_.xxyw * other_groups.group1_.wzxw) + vec4<f32>((self_groups.group0_.zyzw * other_groups.group1_.ywww).xyz, self_.e321_ * other.e1234_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_) + (self_.e423_ * other.scalar) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e2_ * other.e1234_) + (self_.e4_ * other.e31_) + (self_.e423_ * other.e12_) + (self_.e431_ * other.scalar) + (self_.e321_ * other.e42_), (self_.e3_ * other.e1234_) + (self_.e4_ * other.e12_) + (self_.e431_ * other.e23_) + (self_.e412_ * other.scalar) + (self_.e321_ * other.e43_), self_.e3_ * other.e12_ * -1.0) + vec4<f32>((self_groups.group0_.xxyw * other_groups.group0_.wzxw).xyz, self_.e321_ * other.scalar) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_)) - (other_groups.group1_.zxyy * vec4<f32>(self_groups.group1_.yzxw.xyz, self_.e2_))
    ));
}
fn flector_geometricProduct_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e4_ * other.e321_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)) - (vec4<f32>(other.e321_, other.e1_, 0.0, 0.0) * self_groups.group1_.wxzw), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e3_ * other.e31_, self_.e1_ * other.e12_, self_.e321_ * other.e12_, -(self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e423_ * other.e23_) - (self_.e431_ * other.e31_) - (self_.e412_ * other.e12_)) + (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group3_.xyxw.xyz, other.e1234_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (vec4<f32>(other.e2_, other.e321_, other.e321_, 0.0) * self_groups.group1_.zyzw) + (vec4<f32>(other.e321_, other.e3_, other.e1_, 0.0) * self_groups.group1_.xxyw) + (self_groups.group0_.yzxw * other_groups.group4_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (vec4<f32>(other.e4_, other.e412_, other.e423_, 0.0) * self_groups.group0_.xxyw) - (vec4<f32>(other.e431_, other.e4_, other.e4_, 0.0) * self_groups.group0_.zyzw) - (self_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * other_groups.group1_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - (vec4<f32>(other.e2_, other.e321_, other.e321_, 0.0) * self_groups.group0_.zyzw) - (vec4<f32>(other.e321_, other.e3_, other.e1_, 0.0) * self_groups.group0_.xxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e1_ * other.e1234_) + (self_.e3_ * other.e42_) + (self_.e4_ * other.e23_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e1_ * other.e43_) + (self_.e2_ * other.e1234_) + (self_.e4_ * other.e31_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e2_ * other.e41_) + (self_.e3_ * other.e1234_) + (self_.e4_ * other.e12_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), self_.e3_ * other.e12_ * -1.0) + (vec4<f32>(other.scalar) * self_groups.group1_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_)) - vec4<f32>((other_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, self_.e2_ * other.e31_)
    ));
}
fn flector_geometricProduct_origin(self_: Flector, other: Origin) -> Motor {
    let self_groups = flector_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn flector_geometricProduct_plane(self_: Flector, other: Plane) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(self_.e3_ * other.e431_) - (self_.e321_ * other.e423_), -(self_.e1_ * other.e412_) - (self_.e321_ * other.e431_), -(self_.e2_ * other.e423_) - (self_.e321_ * other.e412_), (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (self_groups.group0_.yzxx * other_groups.group0_.zxyx) + (other_groups.group0_.wwwy * vec4<f32>(self_groups.group1_.xyz, self_.e2_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    ));
}
fn flector_geometricProduct_point(self_: Flector, other: Point) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e4_ * other.e1_) + (self_.e412_ * other.e2_), (self_.e4_ * other.e2_) + (self_.e423_ * other.e3_), (self_.e4_ * other.e3_) + (self_.e431_ * other.e1_), -(self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group1_.yzxy * other_groups.group0_.zxyy) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(self_.e3_ * other.e2_) - (self_.e321_ * other.e1_), -(self_.e1_ * other.e3_) - (self_.e321_ * other.e2_), -(self_.e2_ * other.e1_) - (self_.e321_ * other.e3_), (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_)) + (self_groups.group0_.yzxx * other_groups.group0_.zxyx)
    ));
}
fn flector_geometricProduct_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn horizon_geometricProduct_antiScalar(self_: Horizon, other: AntiScalar) -> Origin {
    return Origin(other.e1234_ * self_.e321_);
}
fn horizon_geometricProduct_dualNum(self_: Horizon, other: DualNum) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e321_)
    ));
}
fn horizon_geometricProduct_flector(self_: Horizon, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group0_.xyz, other.e321_) * vec4<f32>(-1.0)
    ));
}
fn horizon_geometricProduct_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(other.e321_ * self_.e321_ * -1.0);
}
fn horizon_geometricProduct_line(self_: Horizon, other: Line) -> Flector {
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_geometricProduct_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e1234_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group0_.xyz, other.scalar)
    ));
}
fn horizon_geometricProduct_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e321_, other.e4_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group3_.xyz, other.e1234_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group2_.xyz, other.scalar)
    ));
}
fn horizon_geometricProduct_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(self_.e321_ * other.e4_ * -1.0);
}
fn horizon_geometricProduct_plane(self_: Horizon, other: Plane) -> Motor {
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e321_ * -1.0)
    ));
}
fn horizon_geometricProduct_point(self_: Horizon, other: Point) -> Motor {
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn horizon_geometricProduct_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.e321_ * other.scalar);
}
fn line_geometricProduct_antiScalar(self_: Line, other: AntiScalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_geometricProduct_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_geometricProduct_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e3_ * self_.e43_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group0_.zxyw).xyz, other.e423_ * self_.e23_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e431_ * self_.e12_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e412_ * self_.e23_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e423_ * self_.e31_), 0.0) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group1_.zxyw).xyz, other.e3_ * self_.e12_)
    ));
}
fn line_geometricProduct_horizon(self_: Line, other: Horizon) -> Flector {
    let self_groups = line_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn line_geometricProduct_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e42_ * self_.e12_) + (other.e31_ * self_.e43_), (other.e43_ * self_.e23_) + (other.e12_ * self_.e41_), (other.e41_ * self_.e31_) + (other.e23_ * self_.e42_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - vec4<f32>((other_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, other.e41_ * self_.e23_) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, other.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e31_ * self_.e12_, other.e12_ * self_.e23_, other.e23_ * self_.e31_, -(other.e31_ * self_.e31_) - (other.e12_ * self_.e12_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group1_.yzxw).xyz, other.e23_ * self_.e23_)
    ));
}
fn line_geometricProduct_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e41_ * other.scalar) + (self_.e43_ * other.e31_) + (self_.e23_ * other.e1234_) + (self_.e12_ * other.e42_), (self_.e41_ * other.e12_) + (self_.e42_ * other.scalar) + (self_.e23_ * other.e43_) + (self_.e31_ * other.e1234_), (self_.e42_ * other.e23_) + (self_.e43_ * other.scalar) + (self_.e31_ * other.e41_) + (self_.e12_ * other.e1234_), -(self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)) - (other_groups.group1_.zxyx * vec4<f32>(self_groups.group0_.yzxw.xyz, self_.e41_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group0_.zxyw).xyz, self_.e42_ * other.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e23_ * other.scalar) + (self_.e12_ * other.e31_), (self_.e23_ * other.e12_) + (self_.e31_ * other.scalar), (self_.e31_ * other.e23_) + (self_.e12_ * other.scalar), -(self_.e31_ * other.e31_) - (self_.e12_ * other.e12_)) - (other_groups.group1_.zxyx * vec4<f32>(self_groups.group1_.yzxw.xyz, self_.e23_))
    ));
}
fn line_geometricProduct_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0) - ((vec4<f32>(other.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e43_ * other.e3_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group1_.zxyw).xyz, self_.e23_ * other.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.zxyw * other_groups.group3_.yzxw) + (self_groups.group1_.zxyw * other_groups.group2_.yzxw) - (self_groups.group0_.yzxw * other_groups.group3_.zxyw) - (self_groups.group1_.yzxw * other_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group1_.zxyw * other_groups.group3_.yzxw) - (self_groups.group1_.yzxw * other_groups.group3_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_) + (self_.e12_ * other.e431_), (self_.e43_ * other.e1_) + (self_.e23_ * other.e412_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e31_ * other.e423_) + (self_.e12_ * other.e4_), 0.0) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group4_.zxyw).xyz, self_.e12_ * other.e3_)
    ));
}
fn line_geometricProduct_origin(self_: Line, other: Origin) -> Plane {
    let self_groups = line_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    ));
}
fn line_geometricProduct_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_groups.group1_.zxyw * other_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn line_geometricProduct_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * other.e3_ * -1.0, self_.e12_ * other.e1_ * -1.0, self_.e23_ * other.e2_ * -1.0, (self_.e42_ * other.e2_) + (self_.e43_ * other.e3_)) + (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_geometricProduct_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn motor_geometricProduct_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group1_, 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_geometricProduct_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(other.e1234_) * self_groups.group1_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn motor_geometricProduct_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ (other_groups.group0_.xyxx * vec4<f32>(self_groups.group1_.wwyw.xyz, self_.e41_)) + (other_groups.group0_.yzzy * vec4<f32>(self_groups.group1_.zxww.xyz, self_.e42_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e4_ * self_.scalar) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_) - (other.e321_ * self_.e1234_)) + vec4<f32>((other_groups.group1_.wwww * self_groups.group1_).xyz, other.e3_ * self_.e43_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e423_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e23_) + (other.e423_ * self_.scalar) + (other.e431_ * self_.e12_) - (other.e321_ * self_.e41_), (other.e4_ * self_.e31_) + (other.e431_ * self_.scalar) + (other.e412_ * self_.e23_) - (other.e321_ * self_.e42_), (other.e4_ * self_.e12_) + (other.e423_ * self_.e31_) + (other.e412_ * self_.scalar) - (other.e321_ * self_.e43_), 0.0) + vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, other.e321_ * self_.scalar) - (other_groups.group0_.xyxx * vec4<f32>(self_groups.group0_.wwyw.xyz, self_.e23_)) - (other_groups.group0_.yzzy * vec4<f32>(self_groups.group0_.zxww.xyz, self_.e31_)) - (self_groups.group1_.yzxz * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e3_))
    ));
}
fn motor_geometricProduct_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn motor_geometricProduct_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e41_ * self_.scalar) + (other.e42_ * self_.e12_) + (other.e23_ * self_.e1234_) + (other.e31_ * self_.e43_), (other.e42_ * self_.scalar) + (other.e43_ * self_.e23_) + (other.e31_ * self_.e1234_) + (other.e12_ * self_.e41_), (other.e41_ * self_.e31_) + (other.e43_ * self_.scalar) + (other.e23_ * self_.e42_) + (other.e12_ * self_.e1234_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e41_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, other.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e23_ * self_.scalar) + (other.e31_ * self_.e12_), (other.e31_ * self_.scalar) + (other.e12_ * self_.e23_), (other.e23_ * self_.e31_) + (other.e12_ * self_.scalar), -(other.e31_ * self_.e31_) - (other.e12_ * self_.e12_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e23_))
    ));
}
fn motor_geometricProduct_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e1234_ * self_.e23_) + (other.e23_ * self_.e1234_) + (other.e31_ * self_.e43_) + (other.scalar * self_.e41_), (other.e1234_ * self_.e31_) + (other.e31_ * self_.e1234_) + (other.e12_ * self_.e41_) + (other.scalar * self_.e42_), (other.e1234_ * self_.e12_) + (other.e23_ * self_.e42_) + (other.e12_ * self_.e1234_) + (other.scalar * self_.e43_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) + (other_groups.group0_.xyxw * self_groups.group1_.wwyw) + vec4<f32>((other_groups.group0_.yzzw * self_groups.group1_.zxww).xyz, other.scalar * self_.e1234_) - (other_groups.group0_.zxyx * self_groups.group1_.yzxx) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, other.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e31_ * self_.e12_) + (other.scalar * self_.e23_), (other.e12_ * self_.e23_) + (other.scalar * self_.e31_), (other.e12_ * self_.scalar) + (other.scalar * self_.e12_), -(other.e31_ * self_.e31_) - (other.e12_ * self_.e12_)) + (other_groups.group1_.xyxw * self_groups.group1_.wwyw) - (other_groups.group1_.zxyx * self_groups.group1_.yzxx)
    ));
}
fn motor_geometricProduct_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_), 0.0, 0.0) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + (other_groups.group1_.xyzz * vec4<f32>(self_groups.group1_.wwww.xyz, self_.e43_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.scalar * other.e4_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group1_.zxyw).xyz, self_.e1234_ * other.e321_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (other_groups.group2_.xyxw * self_groups.group1_.wwyw) + (other_groups.group2_.yzzw * self_groups.group1_.zxww) + (other_groups.group3_.xyxw * self_groups.group0_.wwyw) + (other_groups.group3_.yzzw * self_groups.group0_.zxww) - (other_groups.group2_.zxyw * self_groups.group1_.yzxw) - (other_groups.group3_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (other_groups.group3_.xyxw * self_groups.group1_.wwyw) + (other_groups.group3_.yzzw * self_groups.group1_.zxww) - (other_groups.group3_.zxyw * self_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * other.e4_) + (self_.e12_ * other.e431_) + (self_.scalar * other.e423_) - (self_.e31_ * other.e412_), (self_.e23_ * other.e412_) + (self_.e31_ * other.e4_) + (self_.scalar * other.e431_) - (self_.e12_ * other.e423_), (self_.e31_ * other.e423_) + (self_.e12_ * other.e4_) + (self_.scalar * other.e412_) - (self_.e23_ * other.e431_), 0.0) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group1_.zxyw).xyz, self_.scalar * other.e321_) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - (other_groups.group1_.xyzz * vec4<f32>(self_groups.group0_.wwww.xyz, self_.e12_))
    ));
}
fn motor_geometricProduct_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    ));
}
fn motor_geometricProduct_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e1234_ * other.e321_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group1_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw)).xyz, self_.scalar * other.e321_)
    ));
}
fn motor_geometricProduct_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * other.e3_ * -1.0, self_.e12_ * other.e1_ * -1.0, self_.e23_ * other.e2_ * -1.0, (self_.e43_ * other.e3_) + (self_.scalar * other.e4_)) + (other_groups.group0_.xyzy * vec4<f32>(self_groups.group1_.wwww.xyz, self_.e42_)) + (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), self_.e12_ * other.e3_ * -1.0) - (other_groups.group0_.xyzy * vec4<f32>(self_groups.group0_.wwww.xyz, self_.e31_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_geometricProduct_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn multiVector_geometricProduct_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_ * self_.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    ));
}
fn multiVector_geometricProduct_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e4_) + (other.e1234_ * self_.e321_)) * vec4<f32>(self_groups.group1_.xyz, 1.0), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)).xyz, other.scalar * self_.e321_)
    ));
}
fn multiVector_geometricProduct_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)) - (vec4<f32>(other.e321_, other.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(self_.scalar) * other_groups.group0_) + (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((self_groups.group3_.yzxw * other_groups.group0_.zxyw).xyz, other.e321_ * self_.e1234_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e4_, self_.e431_, 0.0) * other_groups.group0_.xyxw) + (vec4<f32>(self_.e412_, self_.e423_, self_.e4_, 0.0) * other_groups.group0_.yzzw) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group1_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group1_.xyxw) - (other_groups.group0_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group0_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group0_.xyxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e431_ * self_.e12_) - (other.e412_ * self_.e31_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e412_ * self_.e23_) - (other.e423_ * self_.e12_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e423_ * self_.e31_) - (other.e431_ * self_.e23_), 0.0) + (vec4<f32>(self_.scalar) * other_groups.group1_) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e3_) * vec4<f32>(self_groups.group2_.zyzw.xyz, self_.e12_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e2_) * vec4<f32>(self_groups.group2_.xxyw.xyz, self_.e31_)) - (other_groups.group0_.xyzx * vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.e23_))
    ));
}
fn multiVector_geometricProduct_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e321_, self_.e4_, 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group3_.xyz, self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e41, e42, e43 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group2_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_geometricProduct_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e23_ * self_.e321_) + (other.e31_ * self_.e3_), (other.e31_ * self_.e321_) + (other.e12_ * self_.e1_), (other.e23_ * self_.e2_) + (other.e12_ * self_.e321_), -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group0_.yzxw * self_groups.group3_.zxyw) + (other_groups.group1_.yzxw * self_groups.group2_.zxyw) - (other_groups.group0_.zxyw * self_groups.group3_.yzxw) - (other_groups.group1_.zxyw * self_groups.group2_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group1_.yzxw * self_groups.group3_.zxyw) - (other_groups.group1_.zxyw * self_groups.group3_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_) + (other.e12_ * self_.e423_), (other.e41_ * self_.e2_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e12_ * self_.e4_), other.e12_ * self_.e3_ * -1.0) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group4_.yzxw).xyz, other.e31_ * self_.e2_)
    ));
}
fn multiVector_geometricProduct_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_), 0.0, 0.0) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0)) - ((vec4<f32>(other.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar * self_.e1_, other.scalar * self_.e2_, other.scalar * self_.e3_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)) + (other_groups.group1_.yzzw * vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, self_.e4_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group1_.xyxw.xyz, other.e1234_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (self_groups.group2_.xxyw * other_groups.group1_.wzxw) + (self_groups.group2_.zyzw * other_groups.group1_.ywww) + (self_groups.group3_.xxyw * other_groups.group0_.wzxw) + (self_groups.group3_.zyzw * other_groups.group0_.ywww) - (self_groups.group2_.yzxw * other_groups.group1_.zxyw) - (self_groups.group3_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (self_groups.group3_.xxyw * other_groups.group1_.wzxw) + (self_groups.group3_.zyzw * other_groups.group1_.ywww) - (self_groups.group3_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e1234_ * self_.e1_) + (other.e23_ * self_.e4_) + (other.e31_ * self_.e412_) + (other.scalar * self_.e423_), (other.e43_ * self_.e1_) + (other.e1234_ * self_.e2_) + (other.e31_ * self_.e4_) + (other.e12_ * self_.e423_) + (other.scalar * self_.e431_), (other.e43_ * self_.e321_) + (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_) + (other.e12_ * self_.e4_) + (other.scalar * self_.e412_), other.e12_ * self_.e3_ * -1.0) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group0_.xyxw.xyz, other.scalar)) - (other_groups.group1_.zxyy * vec4<f32>(self_groups.group4_.yzxw.xyz, self_.e2_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_geometricProduct_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e1234_ * self_.scalar) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)) - (vec4<f32>(other.e321_, other.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.scalar) * self_groups.group1_) + (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e3_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e43_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e2_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e42_)) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, other.e1234_) * vec4<f32>(other_groups.group1_.xyz, self_.e321_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, other.e1_) * vec4<f32>(other_groups.group3_.yzzw.xyz, self_.e41_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, other.e4_) * vec4<f32>(other_groups.group3_.xyxw.xyz, self_.scalar)) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((other_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, other.e321_ * self_.e1234_) - vec4<f32>((self_groups.group3_.yzxw * other_groups.group1_.zxyw).xyz, other.e41_ * self_.e1_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (vec4<f32>(self_.e4_, self_.e4_, self_.e431_, 0.0) * other_groups.group1_.xyxw) + (vec4<f32>(self_.e412_, self_.e423_, self_.e4_, 0.0) * other_groups.group1_.yzzw) + (other_groups.group2_.yzxw * self_groups.group3_.zxyw) + (other_groups.group3_.yzxw * self_groups.group2_.zxyw) + (other_groups.group4_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group4_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group4_.xyxw) - (other_groups.group2_.zxyw * self_groups.group3_.yzxw) - (other_groups.group3_.zxyw * self_groups.group2_.yzxw) - (other_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (other_groups.group3_.yzxw * self_groups.group3_.zxyw) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group1_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group1_.xyxw) - (other_groups.group3_.zxyw * self_groups.group3_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e41_ * self_.e321_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_) + (other.e31_ * self_.e412_) + (other.e423_ * self_.scalar) + (other.e431_ * self_.e12_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e42_ * self_.e321_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_) + (other.e12_ * self_.e423_) + (other.e431_ * self_.scalar) + (other.e412_ * self_.e23_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e41_ * self_.e2_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e12_ * self_.e4_) + (other.e423_ * self_.e31_) + (other.e412_ * self_.scalar), 0.0) + (vec4<f32>(other.scalar) * self_groups.group4_) + (vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, self_.scalar) * vec4<f32>(self_groups.group1_.xyz, other.e321_)) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group2_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group2_.xxyw.xyz, self_.e23_)) - (self_groups.group1_.yzxy * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e31_)) - (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, other.e23_) * vec4<f32>(other_groups.group1_.xyz, self_.e1_)) - vec4<f32>((other_groups.group3_.zxyw * self_groups.group4_.yzxw).xyz, other.e12_ * self_.e3_) - vec4<f32>((self_groups.group3_.yzxw * other_groups.group4_.zxyw).xyz, other.e3_ * self_.e12_)
    ));
}
fn multiVector_geometricProduct_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * other.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    ));
}
fn multiVector_geometricProduct_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e321_, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, -(self_.e1234_ * other.e321_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group3_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) - (self_groups.group3_.yzxw * other_groups.group0_.zxyw)).xyz, self_.scalar * other.e321_)
    ));
}
fn multiVector_geometricProduct_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e1_) + (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_), -(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * other.e3_ * -1.0, self_.e12_ * other.e1_ * -1.0, self_.e23_ * other.e2_ * -1.0, (self_.e42_ * other.e2_) + (self_.e43_ * other.e3_)) + (vec4<f32>(self_.scalar) * other_groups.group0_) + (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), self_.e12_ * other.e3_ * -1.0) - (other_groups.group0_.xyzx * vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.e23_)) - (other_groups.group0_.yzxy * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e31_))
    ));
}
fn multiVector_geometricProduct_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    ));
}
fn origin_geometricProduct_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(other.scalar * self_.e4_);
}
fn origin_geometricProduct_flector(self_: Origin, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn origin_geometricProduct_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(other.e321_ * self_.e4_);
}
fn origin_geometricProduct_line(self_: Origin, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
}
fn origin_geometricProduct_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
}
fn origin_geometricProduct_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    ));
}
fn origin_geometricProduct_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e321_);
}
fn origin_geometricProduct_point(self_: Origin, other: Point) -> Line {
    let other_groups = point_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn origin_geometricProduct_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.e4_ * other.scalar);
}
fn plane_geometricProduct_antiScalar(self_: Plane, other: AntiScalar) -> Origin {
    return Origin(other.e1234_ * self_.e321_);
}
fn plane_geometricProduct_dualNum(self_: Plane, other: DualNum) -> Flector {
    let self_groups = plane_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn plane_geometricProduct_flector(self_: Plane, other: Flector) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e2_ * self_.e412_) + (other.e321_ * self_.e423_), (other.e3_ * self_.e423_) + (other.e321_ * self_.e431_), (other.e1_ * self_.e431_) + (other.e321_ * self_.e412_), -(other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.zxyx * self_groups.group0_.yzxx) - (self_groups.group0_.wwwy * vec4<f32>(other_groups.group1_.xyz, other.e2_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group0_.xyz, other.e321_) * vec4<f32>(-1.0)
    ));
}
fn plane_geometricProduct_horizon(self_: Plane, other: Horizon) -> Motor {
    let self_groups = plane_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e321_ * -1.0)
    ));
}
fn plane_geometricProduct_line(self_: Plane, other: Line) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0) + vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn plane_geometricProduct_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, (other.e1234_ * self_.e321_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, other.scalar * self_.e321_)
    ));
}
fn plane_geometricProduct_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e321_, -(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, (other.e1234_ * self_.e321_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group1_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group3_.yzxw * self_groups.group0_.zxyw) - (other_groups.group3_.zxyw * self_groups.group0_.yzxw)).xyz, other.scalar * self_.e321_)
    ));
}
fn plane_geometricProduct_origin(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e321_ * -1.0);
}
fn plane_geometricProduct_plane(self_: Plane, other: Plane) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e321_ * -1.0)
    ));
}
fn plane_geometricProduct_point(self_: Plane, other: Point) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e412_ * other.e2_, self_.e423_ * other.e3_, self_.e431_ * other.e1_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group0_.yzxx * other_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    ));
}
fn plane_geometricProduct_scalar(self_: Plane, other: Scalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn point_geometricProduct_antiScalar(self_: Point, other: AntiScalar) -> Plane {
    let self_groups = point_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    ));
}
fn point_geometricProduct_dualNum(self_: Point, other: DualNum) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn point_geometricProduct_flector(self_: Point, other: Flector) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(other.e4_ * self_.e1_) - (other.e431_ * self_.e3_), -(other.e4_ * self_.e2_) - (other.e412_ * self_.e1_), -(other.e4_ * self_.e3_) - (other.e423_ * self_.e2_), (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group1_.zxyy * self_groups.group0_.yzxy) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(other.e2_ * self_.e3_) - (other.e321_ * self_.e1_), -(other.e3_ * self_.e1_) - (other.e321_ * self_.e2_), -(other.e1_ * self_.e2_) - (other.e321_ * self_.e3_), (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx)
    ));
}
fn point_geometricProduct_horizon(self_: Point, other: Horizon) -> Motor {
    let self_groups = point_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e4_), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn point_geometricProduct_line(self_: Point, other: Line) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e31_ * self_.e3_, other.e12_ * self_.e1_, other.e23_ * self_.e2_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn point_geometricProduct_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar * self_.e1_, other.scalar * self_.e2_, other.scalar * self_.e3_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) + (other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e1234_ * self_.e1_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e1234_ * self_.e2_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e1234_ * self_.e3_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn point_geometricProduct_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e321_ * self_.e4_, 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e31_ * self_.e3_, other.e12_ * self_.e1_, other.e23_ * self_.e2_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) + (vec4<f32>(other.scalar) * self_groups.group0_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group4_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group4_.yzxw * self_groups.group0_.zxyw), 
        /* e23, e31, e12 */ (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e1234_ * self_.e1_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e1234_ * self_.e2_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e1234_ * self_.e3_) + (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    ));
}
fn point_geometricProduct_origin(self_: Point, other: Origin) -> Line {
    let self_groups = point_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn point_geometricProduct_plane(self_: Point, other: Plane) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e431_ * self_.e3_ * -1.0, other.e412_ * self_.e1_ * -1.0, other.e423_ * self_.e2_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    ));
}
fn point_geometricProduct_point(self_: Point, other: Point) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e2_ * self_.e3_ * -1.0, other.e3_ * self_.e1_ * -1.0, other.e1_ * self_.e2_ * -1.0, (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx)
    ));
}
fn point_geometricProduct_scalar(self_: Point, other: Scalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn scalar_geometricProduct_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.scalar);
}
fn scalar_geometricProduct_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_geometricProduct_flector(self_: Scalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn scalar_geometricProduct_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(other.e321_ * self_.scalar);
}
fn scalar_geometricProduct_line(self_: Scalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn scalar_geometricProduct_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn scalar_geometricProduct_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    ));
}
fn scalar_geometricProduct_origin(self_: Scalar, other: Origin) -> Origin {
    return Origin(other.e4_ * self_.scalar);
}
fn scalar_geometricProduct_plane(self_: Scalar, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn scalar_geometricProduct_point(self_: Scalar, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn scalar_geometricProduct_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn antiScalar_geometricQuotient_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ / (other.scalar));
}
fn antiScalar_geometricQuotient_flector(self_: AntiScalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * geometric_product.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_geometricQuotient_horizon(self_: AntiScalar, other: Horizon) -> Origin {
    return Origin(self_.e1234_ / (other.e321_));
}
fn antiScalar_geometricQuotient_line(self_: AntiScalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let reverse: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(reverse.e23_ * other_2.scalar, reverse.e31_ * other_2.scalar, reverse.e12_ * other_2.scalar, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_geometricQuotient_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let reverse: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * vec4<f32>(reverse.e23_ * other_2.scalar, reverse.e31_ * other_2.scalar, reverse.e12_ * other_2.scalar, reverse.scalar * other_2.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_geometricQuotient_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e1234_ * geometric_product.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * geometric_product.e321_ * -1.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_geometricQuotient_plane(self_: AntiScalar, other: Plane) -> Origin {
    return Origin(self_.e1234_ / (other.e321_));
}
fn antiScalar_geometricQuotient_point(self_: AntiScalar, other: Point) -> Plane {
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2));
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e1_ * other_2.scalar, other.e2_ * other_2.scalar, other.e3_ * other_2.scalar, other.e4_ * other_2.scalar) * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_geometricQuotient_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ / (other.scalar));
}
fn dualNum_geometricQuotient_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    let geometric_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(geometric_product.scalar * self_.scalar, (geometric_product.scalar * self_.e1234_) + (geometric_product.e1234_ * self_.scalar), 0.0, 0.0)
    ));
}
fn dualNum_geometricQuotient_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * geometric_product.e4_) - (self_.e1234_ * geometric_product.e321_)) * vec4<f32>(geometric_product_groups.group0_.xyz, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) - ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_)).xyz, self_.scalar * geometric_product.e321_)
    ));
}
fn dualNum_geometricQuotient_horizon(self_: DualNum, other: Horizon) -> Flector {
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * geometric_product.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * geometric_product.e321_)
    ));
}
fn dualNum_geometricQuotient_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_
    ));
}
fn dualNum_geometricQuotient_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(self_.scalar) * geometric_product_groups.group0_) + (vec4<f32>(self_.e1234_) * geometric_product_groups.group1_), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * geometric_product_groups.group1_
    ));
}
fn dualNum_geometricQuotient_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * geometric_product.scalar, (self_.scalar * geometric_product.e1234_) + (self_.e1234_ * geometric_product.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * geometric_product.e4_) - (self_.e1234_ * geometric_product.e321_)) * vec4<f32>(geometric_product_groups.group1_.xyz, 1.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group4_) - ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_)).xyz, self_.scalar * geometric_product.e321_)
    ));
}
fn dualNum_geometricQuotient_plane(self_: DualNum, other: Plane) -> Flector {
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * geometric_product.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * geometric_product_groups.group0_
    ));
}
fn dualNum_geometricQuotient_point(self_: DualNum, other: Point) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * geometric_product_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(geometric_product_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    ));
}
fn dualNum_geometricQuotient_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(1.0/(other.scalar)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn flector_geometricQuotient_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_product_groups: DualNumGroups = DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    );
    let geometric_product: DualNum = dualNum_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product_groups.group0_.xxzw.xy, geometric_product.scalar, (geometric_product.scalar * self_.e4_) + (geometric_product.e1234_ * self_.e321_)) * vec4<f32>(self_groups.group0_.xyz, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, geometric_product.scalar * self_.e321_)
    ));
}
fn flector_geometricQuotient_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)) + (geometric_product_groups.group1_.zxyz * self_groups.group0_.yzxz) + (vec4<f32>(self_groups.group0_.wwzw.xy, self_.e431_, self_.e1_) * vec4<f32>(geometric_product_groups.group0_.xyxw.xyz, geometric_product.e423_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e4_, self_.e2_) * vec4<f32>(geometric_product_groups.group0_.yzzw.xyz, geometric_product.e431_)) - (geometric_product_groups.group0_.zxyx * self_groups.group1_.yzxx) - (geometric_product_groups.group0_.wwwy * vec4<f32>(self_groups.group0_.xyz, self_.e431_)) - (vec4<f32>(self_groups.group0_.zxzw.xy, self_.e321_, self_.e321_) * vec4<f32>(geometric_product_groups.group1_.yzzw.xyz, geometric_product.e4_)) - (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e412_) * vec4<f32>(geometric_product_groups.group1_.xyxw.xyz, geometric_product.e3_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(geometric_product.e2_ * self_.e3_) - (geometric_product.e321_ * self_.e1_), -(geometric_product.e3_ * self_.e1_) - (geometric_product.e321_ * self_.e2_), -(geometric_product.e3_ * self_.e321_) - (geometric_product.e321_ * self_.e3_), (geometric_product.e2_ * self_.e2_) + (geometric_product.e3_ * self_.e3_)) + (geometric_product_groups.group0_.zxyx * self_groups.group0_.yzxx) - (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(geometric_product_groups.group0_.xyxw.xyz, geometric_product.e321_))
    ));
}
fn flector_geometricQuotient_horizon(self_: Flector, other: Horizon) -> Motor {
    let self_groups = flector_grouped(self_);
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    ));
}
fn flector_geometricQuotient_line(self_: Flector, other: Line) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    let geometric_product: Line = line_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e3_ * geometric_product.e31_) + (self_.e321_ * geometric_product.e23_), (self_.e1_ * geometric_product.e12_) + (self_.e321_ * geometric_product.e31_), (self_.e2_ * geometric_product.e23_) + (self_.e321_ * geometric_product.e12_), -(self_.e2_ * geometric_product.e42_) - (self_.e3_ * geometric_product.e43_) - (self_.e423_ * geometric_product.e23_) - (self_.e431_ * geometric_product.e31_) - (self_.e412_ * geometric_product.e12_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * geometric_product.e42_) + (self_.e4_ * geometric_product.e23_) + (self_.e412_ * geometric_product.e31_) + (self_.e321_ * geometric_product.e41_), (self_.e1_ * geometric_product.e43_) + (self_.e4_ * geometric_product.e31_) + (self_.e423_ * geometric_product.e12_) + (self_.e321_ * geometric_product.e42_), (self_.e2_ * geometric_product.e41_) + (self_.e4_ * geometric_product.e12_) + (self_.e431_ * geometric_product.e23_) + (self_.e321_ * geometric_product.e43_), self_.e3_ * geometric_product.e12_ * -1.0) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e23_)) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group1_.yzxw).xyz, self_.e2_ * geometric_product.e31_)
    ));
}
fn flector_geometricQuotient_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_ * geometric_product.e23_, self_.e321_ * geometric_product.e31_, self_.e321_ * geometric_product.e12_, -(self_.e2_ * geometric_product.e42_) - (self_.e3_ * geometric_product.e43_) - (self_.e423_ * geometric_product.e23_) - (self_.e431_ * geometric_product.e31_) - (self_.e412_ * geometric_product.e12_)) + (self_groups.group0_.xxyw * geometric_product_groups.group1_.wzxw) + vec4<f32>((self_groups.group0_.zyzw * geometric_product_groups.group1_.ywww).xyz, self_.e321_ * geometric_product.e1234_) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * geometric_product.e42_) + (self_.e4_ * geometric_product.e23_) + (self_.e423_ * geometric_product.scalar) + (self_.e412_ * geometric_product.e31_) + (self_.e321_ * geometric_product.e41_), (self_.e2_ * geometric_product.e1234_) + (self_.e4_ * geometric_product.e31_) + (self_.e423_ * geometric_product.e12_) + (self_.e431_ * geometric_product.scalar) + (self_.e321_ * geometric_product.e42_), (self_.e3_ * geometric_product.e1234_) + (self_.e4_ * geometric_product.e12_) + (self_.e431_ * geometric_product.e23_) + (self_.e412_ * geometric_product.scalar) + (self_.e321_ * geometric_product.e43_), self_.e3_ * geometric_product.e12_ * -1.0) + vec4<f32>((self_groups.group0_.xxyw * geometric_product_groups.group0_.wzxw).xyz, self_.e321_ * geometric_product.scalar) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e23_)) - (geometric_product_groups.group1_.zxyy * vec4<f32>(self_groups.group1_.yzxw.xyz, self_.e2_))
    ));
}
fn flector_geometricQuotient_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e4_ * geometric_product.e321_) - (self_.e431_ * geometric_product.e2_) - (self_.e412_ * geometric_product.e3_) - (self_.e321_ * geometric_product.e4_), 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e1_, geometric_product.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e2_, geometric_product.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e3_, geometric_product.e412_, 0.0, 0.0)) - (vec4<f32>(geometric_product.e321_, geometric_product.e1_, 0.0, 0.0) * self_groups.group1_.wxzw), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e3_ * geometric_product.e31_, self_.e1_ * geometric_product.e12_, self_.e321_ * geometric_product.e12_, -(self_.e2_ * geometric_product.e42_) - (self_.e3_ * geometric_product.e43_) - (self_.e423_ * geometric_product.e23_) - (self_.e431_ * geometric_product.e31_) - (self_.e412_ * geometric_product.e12_)) + (vec4<f32>(geometric_product.scalar) * self_groups.group0_) + (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(geometric_product_groups.group3_.xyxw.xyz, geometric_product.e1234_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group3_.zxyw.xyz, geometric_product.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) + (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, 0.0) * self_groups.group1_.zyzw) + (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, 0.0) * self_groups.group1_.xxyw) + (self_groups.group0_.yzxw * geometric_product_groups.group4_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group4_) - (vec4<f32>(geometric_product.e4_, geometric_product.e412_, geometric_product.e423_, 0.0) * self_groups.group0_.xxyw) - (vec4<f32>(geometric_product.e431_, geometric_product.e4_, geometric_product.e4_, 0.0) * self_groups.group0_.zyzw) - (self_groups.group1_.yzxw * geometric_product_groups.group1_.zxyw), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * geometric_product_groups.group1_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) - (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, 0.0) * self_groups.group0_.zyzw) - (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, 0.0) * self_groups.group0_.xxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e1_ * geometric_product.e1234_) + (self_.e3_ * geometric_product.e42_) + (self_.e4_ * geometric_product.e23_) + (self_.e412_ * geometric_product.e31_) + (self_.e321_ * geometric_product.e41_), (self_.e1_ * geometric_product.e43_) + (self_.e2_ * geometric_product.e1234_) + (self_.e4_ * geometric_product.e31_) + (self_.e423_ * geometric_product.e12_) + (self_.e321_ * geometric_product.e42_), (self_.e2_ * geometric_product.e41_) + (self_.e3_ * geometric_product.e1234_) + (self_.e4_ * geometric_product.e12_) + (self_.e431_ * geometric_product.e23_) + (self_.e321_ * geometric_product.e43_), self_.e3_ * geometric_product.e12_ * -1.0) + (vec4<f32>(geometric_product.scalar) * self_groups.group1_) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group2_.zxyw.xyz, geometric_product.e23_)) - vec4<f32>((geometric_product_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, self_.e2_ * geometric_product.e31_)
    ));
}
fn flector_geometricQuotient_plane(self_: Flector, other: Plane) -> Motor {
    let self_groups = flector_grouped(self_);
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(self_.e3_ * geometric_product.e431_) - (self_.e321_ * geometric_product.e423_), -(self_.e1_ * geometric_product.e412_) - (self_.e321_ * geometric_product.e431_), -(self_.e2_ * geometric_product.e423_) - (self_.e321_ * geometric_product.e412_), (self_.e3_ * geometric_product.e412_) + (self_.e4_ * geometric_product.e321_)) + (self_groups.group0_.yzxx * geometric_product_groups.group0_.zxyx) + (geometric_product_groups.group0_.wwwy * vec4<f32>(self_groups.group1_.xyz, self_.e2_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    ));
}
fn flector_geometricQuotient_point(self_: Flector, other: Point) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e4_ * geometric_product.e1_) + (self_.e412_ * geometric_product.e2_), (self_.e4_ * geometric_product.e2_) + (self_.e423_ * geometric_product.e3_), (self_.e4_ * geometric_product.e3_) + (self_.e431_ * geometric_product.e1_), -(self_.e412_ * geometric_product.e3_) - (self_.e321_ * geometric_product.e4_)) - (self_groups.group1_.yzxy * geometric_product_groups.group0_.zxyy) - (geometric_product_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(self_.e3_ * geometric_product.e2_) - (self_.e321_ * geometric_product.e1_), -(self_.e1_ * geometric_product.e3_) - (self_.e321_ * geometric_product.e2_), -(self_.e2_ * geometric_product.e1_) - (self_.e321_ * geometric_product.e3_), (self_.e2_ * geometric_product.e2_) + (self_.e3_ * geometric_product.e3_)) + (self_groups.group0_.yzxx * geometric_product_groups.group0_.zxyx)
    ));
}
fn flector_geometricQuotient_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    let geometric_product: Scalar = Scalar(1.0/(other.scalar));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_product.scalar) * self_groups.group1_
    ));
}
fn horizon_geometricQuotient_dualNum(self_: Horizon, other: DualNum) -> Flector {
    let other_groups = dualNum_grouped(other);
    let geometric_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.scalar * self_.e321_)
    ));
}
fn horizon_geometricQuotient_flector(self_: Horizon, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group1_.xyz, geometric_product.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group0_.xyz, geometric_product.e321_) * vec4<f32>(-1.0)
    ));
}
fn horizon_geometricQuotient_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return Scalar(self_.e321_ / (other.e321_));
}
fn horizon_geometricQuotient_line(self_: Horizon, other: Line) -> Flector {
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_geometricQuotient_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group1_.xyz, geometric_product.e1234_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group0_.xyz, geometric_product.scalar)
    ));
}
fn horizon_geometricQuotient_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e321_, geometric_product.e4_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group3_.xyz, geometric_product.e1234_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group2_.xyz, geometric_product.scalar)
    ));
}
fn horizon_geometricQuotient_plane(self_: Horizon, other: Plane) -> Motor {
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * geometric_product.e321_ * -1.0)
    ));
}
fn horizon_geometricQuotient_point(self_: Horizon, other: Point) -> Motor {
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * geometric_product.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn horizon_geometricQuotient_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.e321_ / (other.scalar));
}
fn line_geometricQuotient_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_geometricQuotient_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (geometric_product.e3_ * self_.e43_) - (geometric_product.e431_ * self_.e31_) - (geometric_product.e412_ * self_.e12_)) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group0_.zxyw).xyz, geometric_product.e423_ * self_.e23_), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e3_ * self_.e42_) + (geometric_product.e4_ * self_.e23_) + (geometric_product.e431_ * self_.e12_), (geometric_product.e1_ * self_.e43_) + (geometric_product.e4_ * self_.e31_) + (geometric_product.e412_ * self_.e23_), (geometric_product.e2_ * self_.e41_) + (geometric_product.e4_ * self_.e12_) + (geometric_product.e423_ * self_.e31_), 0.0) - (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group1_.zxyw).xyz, geometric_product.e3_ * self_.e12_)
    ));
}
fn line_geometricQuotient_horizon(self_: Line, other: Horizon) -> Flector {
    let self_groups = line_grouped(self_);
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn line_geometricQuotient_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    let geometric_product: Line = line_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((geometric_product.e42_ * self_.e12_) + (geometric_product.e31_ * self_.e43_), (geometric_product.e43_ * self_.e23_) + (geometric_product.e12_ * self_.e41_), (geometric_product.e41_ * self_.e31_) + (geometric_product.e23_ * self_.e42_), -(geometric_product.e43_ * self_.e12_) - (geometric_product.e23_ * self_.e41_) - (geometric_product.e31_ * self_.e42_) - (geometric_product.e12_ * self_.e43_)) - vec4<f32>((geometric_product_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, geometric_product.e41_ * self_.e23_) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, geometric_product.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_product.e31_ * self_.e12_, geometric_product.e12_ * self_.e23_, geometric_product.e23_ * self_.e31_, -(geometric_product.e31_ * self_.e31_) - (geometric_product.e12_ * self_.e12_)) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group1_.yzxw).xyz, geometric_product.e23_ * self_.e23_)
    ));
}
fn line_geometricQuotient_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e41_ * geometric_product.scalar) + (self_.e43_ * geometric_product.e31_) + (self_.e23_ * geometric_product.e1234_) + (self_.e12_ * geometric_product.e42_), (self_.e41_ * geometric_product.e12_) + (self_.e42_ * geometric_product.scalar) + (self_.e23_ * geometric_product.e43_) + (self_.e31_ * geometric_product.e1234_), (self_.e42_ * geometric_product.e23_) + (self_.e43_ * geometric_product.scalar) + (self_.e31_ * geometric_product.e41_) + (self_.e12_ * geometric_product.e1234_), -(self_.e43_ * geometric_product.e12_) - (self_.e23_ * geometric_product.e41_) - (self_.e31_ * geometric_product.e42_) - (self_.e12_ * geometric_product.e43_)) - (geometric_product_groups.group1_.zxyx * vec4<f32>(self_groups.group0_.yzxw.xyz, self_.e41_)) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group0_.zxyw).xyz, self_.e42_ * geometric_product.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e23_ * geometric_product.scalar) + (self_.e12_ * geometric_product.e31_), (self_.e23_ * geometric_product.e12_) + (self_.e31_ * geometric_product.scalar), (self_.e31_ * geometric_product.e23_) + (self_.e12_ * geometric_product.scalar), -(self_.e31_ * geometric_product.e31_) - (self_.e12_ * geometric_product.e12_)) - (geometric_product_groups.group1_.zxyx * vec4<f32>(self_groups.group1_.yzxw.xyz, self_.e23_))
    ));
}
fn line_geometricQuotient_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e23_ * geometric_product.e41_) - (self_.e31_ * geometric_product.e42_) - (self_.e12_ * geometric_product.e43_), 0.0, 0.0) - ((vec4<f32>(geometric_product.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(geometric_product.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(geometric_product.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e43_ * geometric_product.e3_) - (self_.e31_ * geometric_product.e431_) - (self_.e12_ * geometric_product.e412_)) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group1_.zxyw).xyz, self_.e23_ * geometric_product.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.zxyw * geometric_product_groups.group3_.yzxw) + (self_groups.group1_.zxyw * geometric_product_groups.group2_.yzxw) - (self_groups.group0_.yzxw * geometric_product_groups.group3_.zxyw) - (self_groups.group1_.yzxw * geometric_product_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group1_.zxyw * geometric_product_groups.group3_.yzxw) - (self_groups.group1_.yzxw * geometric_product_groups.group3_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * geometric_product.e3_) + (self_.e23_ * geometric_product.e4_) + (self_.e12_ * geometric_product.e431_), (self_.e43_ * geometric_product.e1_) + (self_.e23_ * geometric_product.e412_) + (self_.e31_ * geometric_product.e4_), (self_.e41_ * geometric_product.e2_) + (self_.e31_ * geometric_product.e423_) + (self_.e12_ * geometric_product.e4_), 0.0) - (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group4_.zxyw).xyz, self_.e12_ * geometric_product.e3_)
    ));
}
fn line_geometricQuotient_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e23_ * geometric_product.e423_) - (self_.e31_ * geometric_product.e431_) - (self_.e12_ * geometric_product.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_groups.group1_.zxyw * geometric_product_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn line_geometricQuotient_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * geometric_product.e3_ * -1.0, self_.e12_ * geometric_product.e1_ * -1.0, self_.e23_ * geometric_product.e2_ * -1.0, (self_.e42_ * geometric_product.e2_) + (self_.e43_ * geometric_product.e3_)) + (geometric_product_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * geometric_product.e3_) + (self_.e23_ * geometric_product.e4_), (self_.e43_ * geometric_product.e1_) + (self_.e31_ * geometric_product.e4_), (self_.e41_ * geometric_product.e2_) + (self_.e12_ * geometric_product.e4_), -(self_.e31_ * geometric_product.e2_) - (self_.e12_ * geometric_product.e3_)) - (geometric_product_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_geometricQuotient_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    let geometric_product: Scalar = Scalar(1.0/(other.scalar));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn motor_geometricQuotient_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(geometric_product.scalar) * self_groups.group0_) + (vec4<f32>(geometric_product.e1234_) * self_groups.group1_), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_product.scalar) * self_groups.group1_
    ));
}
fn motor_geometricQuotient_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ (geometric_product_groups.group0_.xyxx * vec4<f32>(self_groups.group1_.wwyw.xyz, self_.e41_)) + (geometric_product_groups.group0_.yzzy * vec4<f32>(self_groups.group1_.zxww.xyz, self_.e42_)) + vec4<f32>(vec4<f32>(0.0).xyz, (geometric_product.e4_ * self_.scalar) - (geometric_product.e431_ * self_.e31_) - (geometric_product.e412_ * self_.e12_) - (geometric_product.e321_ * self_.e1234_)) + vec4<f32>((geometric_product_groups.group1_.wwww * self_groups.group1_).xyz, geometric_product.e3_ * self_.e43_) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e423_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e4_ * self_.e23_) + (geometric_product.e423_ * self_.scalar) + (geometric_product.e431_ * self_.e12_) - (geometric_product.e321_ * self_.e41_), (geometric_product.e4_ * self_.e31_) + (geometric_product.e431_ * self_.scalar) + (geometric_product.e412_ * self_.e23_) - (geometric_product.e321_ * self_.e42_), (geometric_product.e4_ * self_.e12_) + (geometric_product.e423_ * self_.e31_) + (geometric_product.e412_ * self_.scalar) - (geometric_product.e321_ * self_.e43_), 0.0) + vec4<f32>((geometric_product_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, geometric_product.e321_ * self_.scalar) - (geometric_product_groups.group0_.xyxx * vec4<f32>(self_groups.group0_.wwyw.xyz, self_.e23_)) - (geometric_product_groups.group0_.yzzy * vec4<f32>(self_groups.group0_.zxww.xyz, self_.e31_)) - (self_groups.group1_.yzxz * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e3_))
    ));
}
fn motor_geometricQuotient_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn motor_geometricQuotient_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    let geometric_product: Line = line_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((geometric_product.e41_ * self_.scalar) + (geometric_product.e42_ * self_.e12_) + (geometric_product.e23_ * self_.e1234_) + (geometric_product.e31_ * self_.e43_), (geometric_product.e42_ * self_.scalar) + (geometric_product.e43_ * self_.e23_) + (geometric_product.e31_ * self_.e1234_) + (geometric_product.e12_ * self_.e41_), (geometric_product.e41_ * self_.e31_) + (geometric_product.e43_ * self_.scalar) + (geometric_product.e23_ * self_.e42_) + (geometric_product.e12_ * self_.e1234_), -(geometric_product.e43_ * self_.e12_) - (geometric_product.e23_ * self_.e41_) - (geometric_product.e31_ * self_.e42_) - (geometric_product.e12_ * self_.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e41_)) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, geometric_product.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((geometric_product.e23_ * self_.scalar) + (geometric_product.e31_ * self_.e12_), (geometric_product.e31_ * self_.scalar) + (geometric_product.e12_ * self_.e23_), (geometric_product.e23_ * self_.e31_) + (geometric_product.e12_ * self_.scalar), -(geometric_product.e31_ * self_.e31_) - (geometric_product.e12_ * self_.e12_)) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e23_))
    ));
}
fn motor_geometricQuotient_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((geometric_product.e1234_ * self_.e23_) + (geometric_product.e23_ * self_.e1234_) + (geometric_product.e31_ * self_.e43_) + (geometric_product.scalar * self_.e41_), (geometric_product.e1234_ * self_.e31_) + (geometric_product.e31_ * self_.e1234_) + (geometric_product.e12_ * self_.e41_) + (geometric_product.scalar * self_.e42_), (geometric_product.e1234_ * self_.e12_) + (geometric_product.e23_ * self_.e42_) + (geometric_product.e12_ * self_.e1234_) + (geometric_product.scalar * self_.e43_), -(geometric_product.e43_ * self_.e12_) - (geometric_product.e23_ * self_.e41_) - (geometric_product.e31_ * self_.e42_) - (geometric_product.e12_ * self_.e43_)) + (geometric_product_groups.group0_.xyxw * self_groups.group1_.wwyw) + vec4<f32>((geometric_product_groups.group0_.yzzw * self_groups.group1_.zxww).xyz, geometric_product.scalar * self_.e1234_) - (geometric_product_groups.group0_.zxyx * self_groups.group1_.yzxx) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, geometric_product.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((geometric_product.e31_ * self_.e12_) + (geometric_product.scalar * self_.e23_), (geometric_product.e12_ * self_.e23_) + (geometric_product.scalar * self_.e31_), (geometric_product.e12_ * self_.scalar) + (geometric_product.scalar * self_.e12_), -(geometric_product.e31_ * self_.e31_) - (geometric_product.e12_ * self_.e12_)) + (geometric_product_groups.group1_.xyxw * self_groups.group1_.wwyw) - (geometric_product_groups.group1_.zxyx * self_groups.group1_.yzxx)
    ));
}
fn motor_geometricQuotient_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.scalar * geometric_product.e1234_) - (self_.e41_ * geometric_product.e23_) - (self_.e42_ * geometric_product.e31_) - (self_.e43_ * geometric_product.e12_), 0.0, 0.0) + ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e23_, geometric_product.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e31_, geometric_product.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e12_, geometric_product.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + (geometric_product_groups.group1_.xyzz * vec4<f32>(self_groups.group1_.wwww.xyz, self_.e43_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.scalar * geometric_product.e4_) - (self_.e23_ * geometric_product.e423_) - (self_.e31_ * geometric_product.e431_) - (self_.e12_ * geometric_product.e412_)) - vec4<f32>((self_groups.group1_.yzxw * geometric_product_groups.group1_.zxyw).xyz, self_.e1234_ * geometric_product.e321_), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (geometric_product_groups.group2_.xyxw * self_groups.group1_.wwyw) + (geometric_product_groups.group2_.yzzw * self_groups.group1_.zxww) + (geometric_product_groups.group3_.xyxw * self_groups.group0_.wwyw) + (geometric_product_groups.group3_.yzzw * self_groups.group0_.zxww) - (geometric_product_groups.group2_.zxyw * self_groups.group1_.yzxw) - (geometric_product_groups.group3_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (geometric_product_groups.group3_.xyxw * self_groups.group1_.wwyw) + (geometric_product_groups.group3_.yzzw * self_groups.group1_.zxww) - (geometric_product_groups.group3_.zxyw * self_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * geometric_product.e4_) + (self_.e12_ * geometric_product.e431_) + (self_.scalar * geometric_product.e423_) - (self_.e31_ * geometric_product.e412_), (self_.e23_ * geometric_product.e412_) + (self_.e31_ * geometric_product.e4_) + (self_.scalar * geometric_product.e431_) - (self_.e12_ * geometric_product.e423_), (self_.e31_ * geometric_product.e423_) + (self_.e12_ * geometric_product.e4_) + (self_.scalar * geometric_product.e412_) - (self_.e23_ * geometric_product.e431_), 0.0) + vec4<f32>((self_groups.group0_.yzxw * geometric_product_groups.group1_.zxyw).xyz, self_.scalar * geometric_product.e321_) - (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - (geometric_product_groups.group1_.xyzz * vec4<f32>(self_groups.group0_.wwww.xyz, self_.e12_))
    ));
}
fn motor_geometricQuotient_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e1234_ * geometric_product.e321_) - (self_.e23_ * geometric_product.e423_) - (self_.e31_ * geometric_product.e431_) - (self_.e12_ * geometric_product.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + (self_groups.group1_.zxyw * geometric_product_groups.group0_.yzxw) - ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (self_groups.group1_.yzxw * geometric_product_groups.group0_.zxyw)).xyz, self_.scalar * geometric_product.e321_)
    ));
}
fn motor_geometricQuotient_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * geometric_product.e3_ * -1.0, self_.e12_ * geometric_product.e1_ * -1.0, self_.e23_ * geometric_product.e2_ * -1.0, (self_.e43_ * geometric_product.e3_) + (self_.scalar * geometric_product.e4_)) + (geometric_product_groups.group0_.xyzy * vec4<f32>(self_groups.group1_.wwww.xyz, self_.e42_)) + (geometric_product_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * geometric_product.e3_) + (self_.e23_ * geometric_product.e4_), (self_.e43_ * geometric_product.e1_) + (self_.e31_ * geometric_product.e4_), (self_.e41_ * geometric_product.e2_) + (self_.e12_ * geometric_product.e4_), self_.e12_ * geometric_product.e3_ * -1.0) - (geometric_product_groups.group0_.xyzy * vec4<f32>(self_groups.group0_.wwww.xyz, self_.e31_)) - (geometric_product_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_geometricQuotient_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let geometric_product: Scalar = Scalar(1.0/(other.scalar));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_product.scalar) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_product.scalar) * self_groups.group1_
    ));
}
fn multiVector_geometricQuotient_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_product_groups: DualNumGroups = DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    );
    let geometric_product: DualNum = dualNum_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(geometric_product.scalar * self_.scalar, (geometric_product.scalar * self_.e1234_) + (geometric_product.e1234_ * self_.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product_groups.group0_.xxzw.xy, geometric_product.scalar, (geometric_product.scalar * self_.e4_) + (geometric_product.e1234_ * self_.e321_)) * vec4<f32>(self_groups.group1_.xyz, 1.0), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_), 
        /* e23, e31, e12 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)).xyz, geometric_product.scalar * self_.e321_)
    ));
}
fn multiVector_geometricQuotient_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (geometric_product.e321_ * self_.e4_) - (geometric_product.e2_ * self_.e431_) - (geometric_product.e3_ * self_.e412_) - (geometric_product.e4_ * self_.e321_), 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e1_, geometric_product.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e2_, geometric_product.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e3_, geometric_product.e412_, 0.0, 0.0)) - (vec4<f32>(geometric_product.e321_, geometric_product.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(self_.scalar) * geometric_product_groups.group0_) + (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e42_)) + (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (geometric_product.e3_ * self_.e43_) - (geometric_product.e423_ * self_.e23_) - (geometric_product.e431_ * self_.e31_) - (geometric_product.e412_ * self_.e12_)) - vec4<f32>((self_groups.group3_.yzxw * geometric_product_groups.group0_.zxyw).xyz, geometric_product.e321_ * self_.e1234_), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e4_, self_.e431_, 0.0) * geometric_product_groups.group0_.xyxw) + (vec4<f32>(self_.e412_, self_.e423_, self_.e4_, 0.0) * geometric_product_groups.group0_.yzzw) + (geometric_product_groups.group1_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(geometric_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * geometric_product_groups.group1_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * geometric_product_groups.group1_.xyxw) - (geometric_product_groups.group0_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ (geometric_product_groups.group0_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * geometric_product_groups.group0_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * geometric_product_groups.group0_.xyxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e3_ * self_.e42_) + (geometric_product.e4_ * self_.e23_) + (geometric_product.e431_ * self_.e12_) - (geometric_product.e412_ * self_.e31_), (geometric_product.e1_ * self_.e43_) + (geometric_product.e4_ * self_.e31_) + (geometric_product.e412_ * self_.e23_) - (geometric_product.e423_ * self_.e12_), (geometric_product.e2_ * self_.e41_) + (geometric_product.e4_ * self_.e12_) + (geometric_product.e423_ * self_.e31_) - (geometric_product.e431_ * self_.e23_), 0.0) + (vec4<f32>(self_.scalar) * geometric_product_groups.group1_) - (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e3_) * vec4<f32>(self_groups.group2_.zyzw.xyz, self_.e12_)) - (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e2_) * vec4<f32>(self_groups.group2_.xxyw.xyz, self_.e31_)) - (geometric_product_groups.group0_.xyzx * vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.e23_))
    ));
}
fn multiVector_geometricQuotient_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e321_, self_.e4_, 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group3_.xyz, self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e41, e42, e43 */ (vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_product.e321_) * vec4<f32>(self_groups.group2_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_geometricQuotient_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    let geometric_product: Line = line_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(geometric_product.e23_ * self_.e41_) - (geometric_product.e31_ * self_.e42_) - (geometric_product.e12_ * self_.e43_), 0.0, 0.0) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e23_, geometric_product.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e31_, geometric_product.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e12_, geometric_product.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((geometric_product.e23_ * self_.e321_) + (geometric_product.e31_ * self_.e3_), (geometric_product.e31_ * self_.e321_) + (geometric_product.e12_ * self_.e1_), (geometric_product.e23_ * self_.e2_) + (geometric_product.e12_ * self_.e321_), -(geometric_product.e42_ * self_.e2_) - (geometric_product.e43_ * self_.e3_) - (geometric_product.e23_ * self_.e423_) - (geometric_product.e31_ * self_.e431_) - (geometric_product.e12_ * self_.e412_)) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) + (geometric_product_groups.group0_.yzxw * self_groups.group3_.zxyw) + (geometric_product_groups.group1_.yzxw * self_groups.group2_.zxyw) - (geometric_product_groups.group0_.zxyw * self_groups.group3_.yzxw) - (geometric_product_groups.group1_.zxyw * self_groups.group2_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) + (geometric_product_groups.group1_.yzxw * self_groups.group3_.zxyw) - (geometric_product_groups.group1_.zxyw * self_groups.group3_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e41_ * self_.e321_) + (geometric_product.e42_ * self_.e3_) + (geometric_product.e23_ * self_.e4_) + (geometric_product.e31_ * self_.e412_), (geometric_product.e42_ * self_.e321_) + (geometric_product.e43_ * self_.e1_) + (geometric_product.e31_ * self_.e4_) + (geometric_product.e12_ * self_.e423_), (geometric_product.e41_ * self_.e2_) + (geometric_product.e43_ * self_.e321_) + (geometric_product.e23_ * self_.e431_) + (geometric_product.e12_ * self_.e4_), geometric_product.e12_ * self_.e3_ * -1.0) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e23_)) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group4_.yzxw).xyz, geometric_product.e31_ * self_.e2_)
    ));
}
fn multiVector_geometricQuotient_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (geometric_product.scalar * self_.e1234_) - (geometric_product.e41_ * self_.e23_) - (geometric_product.e42_ * self_.e31_) - (geometric_product.e43_ * self_.e12_), 0.0, 0.0) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.scalar, geometric_product.e1234_, 0.0, 0.0)) - ((vec4<f32>(geometric_product.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(geometric_product.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(geometric_product.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.scalar * self_.e1_, geometric_product.scalar * self_.e2_, geometric_product.scalar * self_.e3_, -(geometric_product.e42_ * self_.e2_) - (geometric_product.e43_ * self_.e3_) - (geometric_product.e23_ * self_.e423_) - (geometric_product.e31_ * self_.e431_) - (geometric_product.e12_ * self_.e412_)) + (geometric_product_groups.group1_.yzzw * vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, self_.e4_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(geometric_product_groups.group1_.xyxw.xyz, geometric_product.e1234_)) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) + (self_groups.group2_.xxyw * geometric_product_groups.group1_.wzxw) + (self_groups.group2_.zyzw * geometric_product_groups.group1_.ywww) + (self_groups.group3_.xxyw * geometric_product_groups.group0_.wzxw) + (self_groups.group3_.zyzw * geometric_product_groups.group0_.ywww) - (self_groups.group2_.yzxw * geometric_product_groups.group1_.zxyw) - (self_groups.group3_.yzxw * geometric_product_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) + (self_groups.group3_.xxyw * geometric_product_groups.group1_.wzxw) + (self_groups.group3_.zyzw * geometric_product_groups.group1_.ywww) - (self_groups.group3_.yzxw * geometric_product_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e42_ * self_.e3_) + (geometric_product.e1234_ * self_.e1_) + (geometric_product.e23_ * self_.e4_) + (geometric_product.e31_ * self_.e412_) + (geometric_product.scalar * self_.e423_), (geometric_product.e43_ * self_.e1_) + (geometric_product.e1234_ * self_.e2_) + (geometric_product.e31_ * self_.e4_) + (geometric_product.e12_ * self_.e423_) + (geometric_product.scalar * self_.e431_), (geometric_product.e43_ * self_.e321_) + (geometric_product.e1234_ * self_.e3_) + (geometric_product.e23_ * self_.e431_) + (geometric_product.e12_ * self_.e4_) + (geometric_product.scalar * self_.e412_), geometric_product.e12_ * self_.e3_ * -1.0) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(geometric_product_groups.group0_.xyxw.xyz, geometric_product.scalar)) - (geometric_product_groups.group1_.zxyy * vec4<f32>(self_groups.group4_.yzxw.xyz, self_.e2_)) - (self_groups.group1_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e23_))
    ));
}
fn multiVector_geometricQuotient_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (geometric_product.e1234_ * self_.scalar) + (geometric_product.e321_ * self_.e4_) - (geometric_product.e2_ * self_.e431_) - (geometric_product.e3_ * self_.e412_) - (geometric_product.e4_ * self_.e321_) - (geometric_product.e23_ * self_.e41_) - (geometric_product.e31_ * self_.e42_) - (geometric_product.e12_ * self_.e43_), 0.0, 0.0) + ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e1_, geometric_product.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e2_, geometric_product.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e3_, geometric_product.e412_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e23_, geometric_product.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e31_, geometric_product.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e12_, geometric_product.e43_, 0.0, 0.0)) - (vec4<f32>(geometric_product.e321_, geometric_product.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(geometric_product.scalar) * self_groups.group1_) + (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e3_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e43_)) + (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e2_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e42_)) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, geometric_product.e1234_) * vec4<f32>(geometric_product_groups.group1_.xyz, self_.e321_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, geometric_product.e1_) * vec4<f32>(geometric_product_groups.group3_.yzzw.xyz, self_.e41_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, geometric_product.e4_) * vec4<f32>(geometric_product_groups.group3_.xyxw.xyz, self_.scalar)) + vec4<f32>(vec4<f32>(0.0).xyz, -(geometric_product.e42_ * self_.e2_) - (geometric_product.e43_ * self_.e3_) - (geometric_product.e23_ * self_.e423_) - (geometric_product.e31_ * self_.e431_) - (geometric_product.e12_ * self_.e412_) - (geometric_product.e423_ * self_.e23_) - (geometric_product.e431_ * self_.e31_) - (geometric_product.e412_ * self_.e12_)) - vec4<f32>((geometric_product_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, geometric_product.e321_ * self_.e1234_) - vec4<f32>((self_groups.group3_.yzxw * geometric_product_groups.group1_.zxyw).xyz, geometric_product.e41_ * self_.e1_), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(geometric_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_) + (vec4<f32>(self_.e4_, self_.e4_, self_.e431_, 0.0) * geometric_product_groups.group1_.xyxw) + (vec4<f32>(self_.e412_, self_.e423_, self_.e4_, 0.0) * geometric_product_groups.group1_.yzzw) + (geometric_product_groups.group2_.yzxw * self_groups.group3_.zxyw) + (geometric_product_groups.group3_.yzxw * self_groups.group2_.zxyw) + (geometric_product_groups.group4_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(geometric_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * geometric_product_groups.group4_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * geometric_product_groups.group4_.xyxw) - (geometric_product_groups.group2_.zxyw * self_groups.group3_.yzxw) - (geometric_product_groups.group3_.zxyw * self_groups.group2_.yzxw) - (geometric_product_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_) + (geometric_product_groups.group3_.yzxw * self_groups.group3_.zxyw) + (geometric_product_groups.group1_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * geometric_product_groups.group1_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * geometric_product_groups.group1_.xyxw) - (geometric_product_groups.group3_.zxyw * self_groups.group3_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e3_ * self_.e42_) + (geometric_product.e4_ * self_.e23_) + (geometric_product.e41_ * self_.e321_) + (geometric_product.e42_ * self_.e3_) + (geometric_product.e23_ * self_.e4_) + (geometric_product.e31_ * self_.e412_) + (geometric_product.e423_ * self_.scalar) + (geometric_product.e431_ * self_.e12_), (geometric_product.e1_ * self_.e43_) + (geometric_product.e4_ * self_.e31_) + (geometric_product.e42_ * self_.e321_) + (geometric_product.e43_ * self_.e1_) + (geometric_product.e31_ * self_.e4_) + (geometric_product.e12_ * self_.e423_) + (geometric_product.e431_ * self_.scalar) + (geometric_product.e412_ * self_.e23_), (geometric_product.e2_ * self_.e41_) + (geometric_product.e4_ * self_.e12_) + (geometric_product.e41_ * self_.e2_) + (geometric_product.e43_ * self_.e321_) + (geometric_product.e23_ * self_.e431_) + (geometric_product.e12_ * self_.e4_) + (geometric_product.e423_ * self_.e31_) + (geometric_product.e412_ * self_.scalar), 0.0) + (vec4<f32>(geometric_product.scalar) * self_groups.group4_) + (vec4<f32>(geometric_product_groups.group0_.yyzw.xy, geometric_product.e1234_, self_.scalar) * vec4<f32>(self_groups.group1_.xyz, geometric_product.e321_)) - (vec4<f32>(geometric_product.e2_, geometric_product.e321_, geometric_product.e321_, geometric_product.e2_) * vec4<f32>(self_groups.group2_.zyzw.xyz, self_.e31_)) - (vec4<f32>(geometric_product.e321_, geometric_product.e3_, geometric_product.e1_, geometric_product.e1_) * vec4<f32>(self_groups.group2_.xxyw.xyz, self_.e23_)) - (self_groups.group1_.yzxy * vec4<f32>(geometric_product_groups.group2_.zxyw.xyz, geometric_product.e31_)) - (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, geometric_product.e23_) * vec4<f32>(geometric_product_groups.group1_.xyz, self_.e1_)) - vec4<f32>((geometric_product_groups.group3_.zxyw * self_groups.group4_.yzxw).xyz, geometric_product.e12_ * self_.e3_) - vec4<f32>((self_groups.group3_.yzxw * geometric_product_groups.group4_.zxyw).xyz, geometric_product.e3_ * self_.e12_)
    ));
}
fn multiVector_geometricQuotient_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * geometric_product.e321_, (self_.e1_ * geometric_product.e423_) + (self_.e2_ * geometric_product.e431_) + (self_.e3_ * geometric_product.e412_) + (self_.e4_ * geometric_product.e321_), 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, -(self_.e1234_ * geometric_product.e321_) - (self_.e23_ * geometric_product.e423_) - (self_.e31_ * geometric_product.e431_) - (self_.e12_ * geometric_product.e412_)), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (self_groups.group1_.yzxw * geometric_product_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) - (self_groups.group1_.zxyw * geometric_product_groups.group0_.yzxw), 
        /* e23, e31, e12 */ (vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + (self_groups.group3_.zxyw * geometric_product_groups.group0_.yzxw) - ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) - (self_groups.group3_.yzxw * geometric_product_groups.group0_.zxyw)).xyz, self_.scalar * geometric_product.e321_)
    ));
}
fn multiVector_geometricQuotient_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * geometric_product.e1_) + (self_.e2_ * geometric_product.e2_) + (self_.e3_ * geometric_product.e3_), -(self_.e423_ * geometric_product.e1_) - (self_.e431_ * geometric_product.e2_) - (self_.e412_ * geometric_product.e3_) - (self_.e321_ * geometric_product.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * geometric_product.e3_ * -1.0, self_.e12_ * geometric_product.e1_ * -1.0, self_.e23_ * geometric_product.e2_ * -1.0, (self_.e42_ * geometric_product.e2_) + (self_.e43_ * geometric_product.e3_)) + (vec4<f32>(self_.scalar) * geometric_product_groups.group0_) + (geometric_product_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + (self_groups.group4_.zxyw * geometric_product_groups.group0_.yzxw) - ((vec4<f32>(geometric_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (self_groups.group4_.yzxw * geometric_product_groups.group0_.zxyw), 
        /* e23, e31, e12 */ (self_groups.group1_.yzxw * geometric_product_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) - (self_groups.group1_.zxyw * geometric_product_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * geometric_product.e3_) + (self_.e23_ * geometric_product.e4_), (self_.e43_ * geometric_product.e1_) + (self_.e31_ * geometric_product.e4_), (self_.e41_ * geometric_product.e2_) + (self_.e12_ * geometric_product.e4_), self_.e12_ * geometric_product.e3_ * -1.0) - (geometric_product_groups.group0_.xyzx * vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.e23_)) - (geometric_product_groups.group0_.yzxy * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e31_))
    ));
}
fn multiVector_geometricQuotient_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_product: Scalar = Scalar(1.0/(other.scalar));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_product.scalar) * self_groups.group4_
    ));
}
fn origin_geometricQuotient_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(self_.e4_ / (other.scalar));
}
fn origin_geometricQuotient_flector(self_: Origin, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(geometric_product_groups.group0_.xyz, geometric_product.e321_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn origin_geometricQuotient_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.e4_ / (other.e321_) * -1.0);
}
fn origin_geometricQuotient_line(self_: Origin, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    let reverse: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(reverse.e23_ * other_2.scalar, reverse.e31_ * other_2.scalar, reverse.e12_ * other_2.scalar, 0.0)).xyz, 0.0)
    ));
}
fn origin_geometricQuotient_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.scalar * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_).xyz, 0.0)
    ));
}
fn origin_geometricQuotient_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, geometric_product.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.scalar * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_).xyz, 0.0)
    ));
}
fn origin_geometricQuotient_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e4_ / (other.e321_) * -1.0);
}
fn origin_geometricQuotient_point(self_: Origin, other: Point) -> Line {
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e1_ * other_2.scalar, other.e2_ * other_2.scalar, other.e3_ * other_2.scalar, other.e4_ * other_2.scalar), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn origin_geometricQuotient_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.e4_ / (other.scalar));
}
fn plane_geometricQuotient_dualNum(self_: Plane, other: DualNum) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_product: DualNum = dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_product.scalar) * self_groups.group0_
    ));
}
fn plane_geometricQuotient_flector(self_: Plane, other: Flector) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((geometric_product.e2_ * self_.e412_) + (geometric_product.e321_ * self_.e423_), (geometric_product.e3_ * self_.e423_) + (geometric_product.e321_ * self_.e431_), (geometric_product.e1_ * self_.e431_) + (geometric_product.e321_ * self_.e412_), -(geometric_product.e3_ * self_.e412_) - (geometric_product.e4_ * self_.e321_)) - (geometric_product_groups.group0_.zxyx * self_groups.group0_.yzxx) - (self_groups.group0_.wwwy * vec4<f32>(geometric_product_groups.group1_.xyz, geometric_product.e2_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(geometric_product_groups.group0_.xyz, geometric_product.e321_) * vec4<f32>(-1.0)
    ));
}
fn plane_geometricQuotient_horizon(self_: Plane, other: Horizon) -> Motor {
    let self_groups = plane_grouped(self_);
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.e321_ * self_.e321_ * -1.0)
    ));
}
fn plane_geometricQuotient_line(self_: Plane, other: Line) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    let geometric_product: Line = line_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_).xyz, -(geometric_product.e23_ * self_.e423_) - (geometric_product.e31_ * self_.e431_) - (geometric_product.e12_ * self_.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_).xyz, 0.0) + vec4<f32>((geometric_product_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn plane_geometricQuotient_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_).xyz, (geometric_product.e1234_ * self_.e321_) - (geometric_product.e23_ * self_.e423_) - (geometric_product.e31_ * self_.e431_) - (geometric_product.e12_ * self_.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) + (geometric_product_groups.group1_.yzxw * self_groups.group0_.zxyw) - (geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, geometric_product.scalar * self_.e321_)
    ));
}
fn plane_geometricQuotient_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(geometric_product.e321_ * self_.e321_, -(geometric_product.e1_ * self_.e423_) - (geometric_product.e2_ * self_.e431_) - (geometric_product.e3_ * self_.e412_) - (geometric_product.e4_ * self_.e321_), 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_).xyz, (geometric_product.e1234_ * self_.e321_) - (geometric_product.e23_ * self_.e423_) - (geometric_product.e31_ * self_.e431_) - (geometric_product.e12_ * self_.e412_)), 
        /* e41, e42, e43 */ ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (geometric_product_groups.group1_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group4_) - (geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(geometric_product.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group2_) + (geometric_product_groups.group3_.yzxw * self_groups.group0_.zxyw) - (geometric_product_groups.group3_.zxyw * self_groups.group0_.yzxw)).xyz, geometric_product.scalar * self_.e321_)
    ));
}
fn plane_geometricQuotient_plane(self_: Plane, other: Plane) -> Motor {
    let self_groups = plane_grouped(self_);
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.e321_ * self_.e321_ * -1.0)
    ));
}
fn plane_geometricQuotient_point(self_: Plane, other: Point) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e412_ * geometric_product.e2_, self_.e423_ * geometric_product.e3_, self_.e431_ * geometric_product.e1_, -(self_.e431_ * geometric_product.e2_) - (self_.e412_ * geometric_product.e3_) - (self_.e321_ * geometric_product.e4_)) - (self_groups.group0_.yzxx * geometric_product_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(geometric_product_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    ));
}
fn plane_geometricQuotient_scalar(self_: Plane, other: Scalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(1.0/(other.scalar)) * self_groups.group0_
    ));
}
fn point_geometricQuotient_dualNum(self_: Point, other: DualNum) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    let geometric_product_groups: DualNumGroups = DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(other.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    );
    let geometric_product: DualNum = dualNum_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_product_groups.group0_.yyzw.xy, geometric_product.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn point_geometricQuotient_flector(self_: Point, other: Flector) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Flector = flector_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(geometric_product.e4_ * self_.e1_) - (geometric_product.e431_ * self_.e3_), -(geometric_product.e4_ * self_.e2_) - (geometric_product.e412_ * self_.e1_), -(geometric_product.e4_ * self_.e3_) - (geometric_product.e423_ * self_.e2_), (geometric_product.e412_ * self_.e3_) + (geometric_product.e321_ * self_.e4_)) + (geometric_product_groups.group1_.zxyy * self_groups.group0_.yzxy) + (self_groups.group0_.wwwx * vec4<f32>(geometric_product_groups.group0_.xyz, geometric_product.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(geometric_product.e2_ * self_.e3_) - (geometric_product.e321_ * self_.e1_), -(geometric_product.e3_ * self_.e1_) - (geometric_product.e321_ * self_.e2_), -(geometric_product.e1_ * self_.e2_) - (geometric_product.e321_ * self_.e3_), (geometric_product.e2_ * self_.e2_) + (geometric_product.e3_ * self_.e3_)) + (geometric_product_groups.group0_.zxyx * self_groups.group0_.yzxx)
    ));
}
fn point_geometricQuotient_horizon(self_: Point, other: Horizon) -> Motor {
    let self_groups = point_grouped(self_);
    let geometric_product: Horizon = Horizon(1.0/(other.e321_) * -1.0);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, geometric_product.e321_ * self_.e4_), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn point_geometricQuotient_line(self_: Point, other: Line) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    let geometric_product: Line = line_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.e31_ * self_.e3_, geometric_product.e12_ * self_.e1_, geometric_product.e23_ * self_.e2_, -(geometric_product.e42_ * self_.e2_) - (geometric_product.e43_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e42_ * self_.e3_) + (geometric_product.e23_ * self_.e4_), (geometric_product.e43_ * self_.e1_) + (geometric_product.e31_ * self_.e4_), (geometric_product.e41_ * self_.e2_) + (geometric_product.e12_ * self_.e4_), -(geometric_product.e31_ * self_.e2_) - (geometric_product.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e23_))
    ));
}
fn point_geometricQuotient_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    let geometric_product: Motor = motor_degroup(geometric_product_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.scalar * self_.e1_, geometric_product.scalar * self_.e2_, geometric_product.scalar * self_.e3_, -(geometric_product.e42_ * self_.e2_) - (geometric_product.e43_ * self_.e3_)) + (geometric_product_groups.group1_.yzxw * self_groups.group0_.zxyw) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group1_.zxyw.xyz, geometric_product.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e42_ * self_.e3_) + (geometric_product.e1234_ * self_.e1_) + (geometric_product.e23_ * self_.e4_), (geometric_product.e43_ * self_.e1_) + (geometric_product.e1234_ * self_.e2_) + (geometric_product.e31_ * self_.e4_), (geometric_product.e41_ * self_.e2_) + (geometric_product.e1234_ * self_.e3_) + (geometric_product.e12_ * self_.e4_), -(geometric_product.e31_ * self_.e2_) - (geometric_product.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group0_.zxyw.xyz, geometric_product.e23_))
    ));
}
fn point_geometricQuotient_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    let geometric_product: MultiVector = multiVector_degroup(geometric_product_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, geometric_product.e321_ * self_.e4_, 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e1_, geometric_product.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e2_, geometric_product.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(geometric_product.e3_, geometric_product.e412_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_product.e31_ * self_.e3_, geometric_product.e12_ * self_.e1_, geometric_product.e23_ * self_.e2_, -(geometric_product.e42_ * self_.e2_) - (geometric_product.e43_ * self_.e3_)) + (vec4<f32>(geometric_product.scalar) * self_groups.group0_) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group3_.zxyw.xyz, geometric_product.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_) + (geometric_product_groups.group4_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(geometric_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (geometric_product_groups.group4_.yzxw * self_groups.group0_.zxyw), 
        /* e23, e31, e12 */ (geometric_product_groups.group1_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(geometric_product.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (geometric_product_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((geometric_product.e1234_ * self_.e1_) + (geometric_product.e42_ * self_.e3_) + (geometric_product.e23_ * self_.e4_), (geometric_product.e1234_ * self_.e2_) + (geometric_product.e43_ * self_.e1_) + (geometric_product.e31_ * self_.e4_), (geometric_product.e1234_ * self_.e3_) + (geometric_product.e41_ * self_.e2_) + (geometric_product.e12_ * self_.e4_), -(geometric_product.e31_ * self_.e2_) - (geometric_product.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(geometric_product_groups.group2_.zxyw.xyz, geometric_product.e23_))
    ));
}
fn point_geometricQuotient_plane(self_: Point, other: Plane) -> Motor {
    let self_groups = point_grouped(self_);
    let geometric_product_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(other.e321_, -2)) * vec4<f32>(other.e423_ * -1.0, other.e431_ * -1.0, other.e412_ * -1.0, other.e321_ * -1.0)
    );
    let geometric_product: Plane = plane_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_product.e431_ * self_.e3_ * -1.0, geometric_product.e412_ * self_.e1_ * -1.0, geometric_product.e423_ * self_.e2_ * -1.0, (geometric_product.e431_ * self_.e2_) + (geometric_product.e412_ * self_.e3_) + (geometric_product.e321_ * self_.e4_)) + (geometric_product_groups.group0_.zxyx * self_groups.group0_.yzxx), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(geometric_product_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    ));
}
fn point_geometricQuotient_point(self_: Point, other: Point) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    let geometric_product_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2)) * other_groups.group0_
    );
    let geometric_product: Point = point_degroup(geometric_product_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_) - ((vec4<f32>(geometric_product.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_product.e2_ * self_.e3_ * -1.0, geometric_product.e3_ * self_.e1_ * -1.0, geometric_product.e1_ * self_.e2_ * -1.0, (geometric_product.e2_ * self_.e2_) + (geometric_product.e3_ * self_.e3_)) + (geometric_product_groups.group0_.zxyx * self_groups.group0_.yzxx)
    ));
}
fn point_geometricQuotient_scalar(self_: Point, other: Scalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(1.0/(other.scalar)) * self_groups.group0_
    ));
}
fn scalar_geometricQuotient_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_2: Scalar = Scalar(pow(other.scalar, -2));
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar * other_2.scalar, other.e1234_ * other_2.scalar, 0.0, 0.0)
    ));
}
fn scalar_geometricQuotient_flector(self_: Scalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * geometric_product_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * geometric_product_groups.group1_
    ));
}
fn scalar_geometricQuotient_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(self_.scalar / (other.e321_) * -1.0);
}
fn scalar_geometricQuotient_line(self_: Scalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2));
    let geometric_product_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    );
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group1_
    ));
}
fn scalar_geometricQuotient_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other_2: Scalar = Scalar(pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.scalar, 2));
    let geometric_product_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_2.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other_2.scalar) * reverse_groups.group1_
    );
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * geometric_product_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * geometric_product_groups.group1_
    ));
}
fn scalar_geometricQuotient_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    );
    let other_2: Scalar = Scalar(pow(other.scalar, 2) + pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2) + pow(other.e23_, 2) + pow(other.e31_, 2) + pow(other.e12_, 2) + pow(other.e321_, 2));
    let geometric_product_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other_2.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other_2.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_2.scalar) * reverse_groups.group4_
    );
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * geometric_product_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * geometric_product_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * geometric_product_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * geometric_product_groups.group4_
    ));
}
fn scalar_geometricQuotient_plane(self_: Scalar, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    let reverse: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
    let other_2: Scalar = Scalar(pow(other.e321_, -2));
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * vec4<f32>(reverse.e423_ * other_2.scalar, reverse.e431_ * other_2.scalar, reverse.e412_ * other_2.scalar, reverse.e321_ * other_2.scalar)
    ));
}
fn scalar_geometricQuotient_point(self_: Scalar, other: Point) -> Point {
    let other_2: Scalar = Scalar(pow(other.e1_, 2) + pow(other.e2_, 2) + pow(other.e3_, 2));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * vec4<f32>(other.e1_ * other_2.scalar, other.e2_ * other_2.scalar, other.e3_ * other_2.scalar, other.e4_ * other_2.scalar)
    ));
}
fn scalar_geometricQuotient_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.scalar / (other.scalar));
}
fn antiScalar_grade() -> i32 {
    return 4;
}
fn horizon_grade() -> i32 {
    return 3;
}
fn line_grade() -> i32 {
    return 2;
}
fn origin_grade() -> i32 {
    return 1;
}
fn plane_grade() -> i32 {
    return 3;
}
fn point_grade() -> i32 {
    return 1;
}
fn scalar_grade() -> i32 {
    return 0;
}
fn antiScalar_into_dualNum(self_: AntiScalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0)
    ));
}
fn antiScalar_into_motor(self_: AntiScalar) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_into_multiVector(self_: AntiScalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_into_motor(self_: DualNum) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar)
    ));
}
fn dualNum_into_multiVector(self_: DualNum) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn flector_into_multiVector(self_: Flector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn horizon_into_flector(self_: Horizon) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_into_multiVector(self_: Horizon) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_into_plane(self_: Horizon) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn line_into_motor(self_: Line) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn line_into_multiVector(self_: Line) -> MultiVector {
    let self_groups = line_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn motor_into_multiVector(self_: Motor) -> MultiVector {
    let self_groups = motor_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_into_flector(self_: Origin) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_into_multiVector(self_: Origin) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_into_point(self_: Origin) -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_)
    ));
}
fn plane_into_flector(self_: Plane) -> Flector {
    let self_groups = plane_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_into_multiVector(self_: Plane) -> MultiVector {
    let self_groups = plane_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn point_into_flector(self_: Point) -> Flector {
    let self_groups = point_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_into_multiVector(self_: Point) -> MultiVector {
    let self_groups = point_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_into_dualNum(self_: Scalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0)
    ));
}
fn scalar_into_motor(self_: Scalar) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar)
    ));
}
fn scalar_into_multiVector(self_: Scalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_inverse(self_: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(pow(self_.scalar, -2)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn flector_inverse(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let reverse_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    );
    let other: Scalar = Scalar(pow(self_.e1_, 2) + pow(self_.e2_, 2) + pow(self_.e3_, 2) + pow(self_.e321_, 2));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * reverse_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * reverse_groups.group1_
    ));
}
fn horizon_inverse(self_: Horizon) -> Horizon {
    return Horizon(1.0/(self_.e321_) * -1.0);
}
fn line_inverse(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    let reverse_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    );
    let other: Scalar = Scalar(pow(self_.e23_, 2) + pow(self_.e31_, 2) + pow(self_.e12_, 2));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group1_
    ));
}
fn motor_inverse(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let reverse_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    );
    let other: Scalar = Scalar(pow(self_.e23_, 2) + pow(self_.e31_, 2) + pow(self_.e12_, 2) + pow(self_.scalar, 2));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * reverse_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * reverse_groups.group1_
    ));
}
fn multiVector_inverse(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let reverse_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    );
    let other: Scalar = Scalar(pow(self_.scalar, 2) + pow(self_.e1_, 2) + pow(self_.e2_, 2) + pow(self_.e3_, 2) + pow(self_.e23_, 2) + pow(self_.e31_, 2) + pow(self_.e12_, 2) + pow(self_.e321_, 2));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * reverse_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * reverse_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * reverse_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * reverse_groups.group4_
    ));
}
fn plane_inverse(self_: Plane) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(pow(self_.e321_, -2)) * vec4<f32>(self_.e423_ * -1.0, self_.e431_ * -1.0, self_.e412_ * -1.0, self_.e321_ * -1.0)
    ));
}
fn point_inverse(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(pow(self_.e1_, 2) + pow(self_.e2_, 2) + pow(self_.e3_, 2)) * self_groups.group0_
    ));
}
fn scalar_inverse(self_: Scalar) -> Scalar {
    return Scalar(1.0/(self_.scalar));
}
fn antiScalar_leftComplement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.e1234_);
}
fn dualNum_leftComplement(self_: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ self_groups.group0_.yxzw
    ));
}
fn flector_leftComplement(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn horizon_leftComplement(self_: Horizon) -> Origin {
    return Origin(self_.e321_);
}
fn line_leftComplement(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn motor_leftComplement(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_leftComplement(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_.yxzw, 
        /* e1, e2, e3, e4 */ self_groups.group4_, 
        /* e41, e42, e43 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn origin_leftComplement(self_: Origin) -> Horizon {
    return Horizon(self_.e4_ * -1.0);
}
fn plane_leftComplement(self_: Plane) -> Point {
    let self_groups = plane_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_
    ));
}
fn point_leftComplement(self_: Point) -> Plane {
    let self_groups = point_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_leftComplement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.scalar);
}
fn antiScalar_mul_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return antiScalar_geometricProduct_dualNum(self_, other);
}
fn antiScalar_mul_flector(self_: AntiScalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return antiScalar_geometricProduct_flector(self_, other);
}
fn antiScalar_mul_horizon(self_: AntiScalar, other: Horizon) -> Origin {
    return antiScalar_geometricProduct_horizon(self_, other);
}
fn antiScalar_mul_line(self_: AntiScalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return antiScalar_geometricProduct_line(self_, other);
}
fn antiScalar_mul_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return antiScalar_geometricProduct_motor(self_, other);
}
fn antiScalar_mul_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return antiScalar_geometricProduct_multiVector(self_, other);
}
fn antiScalar_mul_plane(self_: AntiScalar, other: Plane) -> Origin {
    return antiScalar_geometricProduct_plane(self_, other);
}
fn antiScalar_mul_point(self_: AntiScalar, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return antiScalar_geometricProduct_point(self_, other);
}
fn antiScalar_mul_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return antiScalar_geometricProduct_scalar(self_, other);
}
fn dualNum_mul_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return dualNum_geometricProduct_antiScalar(self_, other);
}
fn dualNum_mul_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_geometricProduct_dualNum(self_, other);
}
fn dualNum_mul_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return dualNum_geometricProduct_flector(self_, other);
}
fn dualNum_mul_horizon(self_: DualNum, other: Horizon) -> Flector {
    return dualNum_geometricProduct_horizon(self_, other);
}
fn dualNum_mul_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return dualNum_geometricProduct_line(self_, other);
}
fn dualNum_mul_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return dualNum_geometricProduct_motor(self_, other);
}
fn dualNum_mul_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return dualNum_geometricProduct_multiVector(self_, other);
}
fn dualNum_mul_origin(self_: DualNum, other: Origin) -> Origin {
    return dualNum_geometricProduct_origin(self_, other);
}
fn dualNum_mul_plane(self_: DualNum, other: Plane) -> Flector {
    let other_groups = plane_grouped(other);
    return dualNum_geometricProduct_plane(self_, other);
}
fn dualNum_mul_point(self_: DualNum, other: Point) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    return dualNum_geometricProduct_point(self_, other);
}
fn dualNum_mul_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_geometricProduct_scalar(self_, other);
}
fn flector_mul_antiScalar(self_: Flector, other: AntiScalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_geometricProduct_antiScalar(self_, other);
}
fn flector_mul_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricProduct_dualNum(self_, other);
}
fn flector_mul_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricProduct_flector(self_, other);
}
fn flector_mul_horizon(self_: Flector, other: Horizon) -> Motor {
    let self_groups = flector_grouped(self_);
    return flector_geometricProduct_horizon(self_, other);
}
fn flector_mul_line(self_: Flector, other: Line) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricProduct_line(self_, other);
}
fn flector_mul_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricProduct_motor(self_, other);
}
fn flector_mul_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return flector_geometricProduct_multiVector(self_, other);
}
fn flector_mul_origin(self_: Flector, other: Origin) -> Motor {
    let self_groups = flector_grouped(self_);
    return flector_geometricProduct_origin(self_, other);
}
fn flector_mul_plane(self_: Flector, other: Plane) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricProduct_plane(self_, other);
}
fn flector_mul_point(self_: Flector, other: Point) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricProduct_point(self_, other);
}
fn flector_mul_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_geometricProduct_scalar(self_, other);
}
fn horizon_mul_antiScalar(self_: Horizon, other: AntiScalar) -> Origin {
    return horizon_geometricProduct_antiScalar(self_, other);
}
fn horizon_mul_dualNum(self_: Horizon, other: DualNum) -> Flector {
    return horizon_geometricProduct_dualNum(self_, other);
}
fn horizon_mul_flector(self_: Horizon, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return horizon_geometricProduct_flector(self_, other);
}
fn horizon_mul_horizon(self_: Horizon, other: Horizon) -> Scalar {
    return horizon_geometricProduct_horizon(self_, other);
}
fn horizon_mul_line(self_: Horizon, other: Line) -> Flector {
    let other_groups = line_grouped(other);
    return horizon_geometricProduct_line(self_, other);
}
fn horizon_mul_motor(self_: Horizon, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return horizon_geometricProduct_motor(self_, other);
}
fn horizon_mul_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return horizon_geometricProduct_multiVector(self_, other);
}
fn horizon_mul_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return horizon_geometricProduct_origin(self_, other);
}
fn horizon_mul_plane(self_: Horizon, other: Plane) -> Motor {
    let other_groups = plane_grouped(other);
    return horizon_geometricProduct_plane(self_, other);
}
fn horizon_mul_point(self_: Horizon, other: Point) -> Motor {
    let other_groups = point_grouped(other);
    return horizon_geometricProduct_point(self_, other);
}
fn horizon_mul_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return horizon_geometricProduct_scalar(self_, other);
}
fn line_mul_antiScalar(self_: Line, other: AntiScalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_geometricProduct_antiScalar(self_, other);
}
fn line_mul_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    return line_geometricProduct_dualNum(self_, other);
}
fn line_mul_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return line_geometricProduct_flector(self_, other);
}
fn line_mul_horizon(self_: Line, other: Horizon) -> Flector {
    let self_groups = line_grouped(self_);
    return line_geometricProduct_horizon(self_, other);
}
fn line_mul_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricProduct_line(self_, other);
}
fn line_mul_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return line_geometricProduct_motor(self_, other);
}
fn line_mul_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return line_geometricProduct_multiVector(self_, other);
}
fn line_mul_origin(self_: Line, other: Origin) -> Plane {
    let self_groups = line_grouped(self_);
    return line_geometricProduct_origin(self_, other);
}
fn line_mul_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return line_geometricProduct_plane(self_, other);
}
fn line_mul_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return line_geometricProduct_point(self_, other);
}
fn line_mul_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_geometricProduct_scalar(self_, other);
}
fn motor_mul_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_geometricProduct_antiScalar(self_, other);
}
fn motor_mul_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_geometricProduct_dualNum(self_, other);
}
fn motor_mul_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricProduct_flector(self_, other);
}
fn motor_mul_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    return motor_geometricProduct_horizon(self_, other);
}
fn motor_mul_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_geometricProduct_line(self_, other);
}
fn motor_mul_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricProduct_motor(self_, other);
}
fn motor_mul_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return motor_geometricProduct_multiVector(self_, other);
}
fn motor_mul_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    return motor_geometricProduct_origin(self_, other);
}
fn motor_mul_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricProduct_plane(self_, other);
}
fn motor_mul_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricProduct_point(self_, other);
}
fn motor_mul_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_geometricProduct_scalar(self_, other);
}
fn multiVector_mul_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_geometricProduct_antiScalar(self_, other);
}
fn multiVector_mul_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_geometricProduct_dualNum(self_, other);
}
fn multiVector_mul_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_geometricProduct_flector(self_, other);
}
fn multiVector_mul_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_geometricProduct_horizon(self_, other);
}
fn multiVector_mul_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_geometricProduct_line(self_, other);
}
fn multiVector_mul_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_geometricProduct_motor(self_, other);
}
fn multiVector_mul_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_multiVector(self_, other);
}
fn multiVector_mul_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_geometricProduct_origin(self_, other);
}
fn multiVector_mul_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_geometricProduct_plane(self_, other);
}
fn multiVector_mul_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_geometricProduct_point(self_, other);
}
fn multiVector_mul_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_geometricProduct_scalar(self_, other);
}
fn origin_mul_dualNum(self_: Origin, other: DualNum) -> Origin {
    return origin_geometricProduct_dualNum(self_, other);
}
fn origin_mul_flector(self_: Origin, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return origin_geometricProduct_flector(self_, other);
}
fn origin_mul_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return origin_geometricProduct_horizon(self_, other);
}
fn origin_mul_line(self_: Origin, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    return origin_geometricProduct_line(self_, other);
}
fn origin_mul_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return origin_geometricProduct_motor(self_, other);
}
fn origin_mul_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return origin_geometricProduct_multiVector(self_, other);
}
fn origin_mul_plane(self_: Origin, other: Plane) -> AntiScalar {
    return origin_geometricProduct_plane(self_, other);
}
fn origin_mul_point(self_: Origin, other: Point) -> Line {
    let other_groups = point_grouped(other);
    return origin_geometricProduct_point(self_, other);
}
fn origin_mul_scalar(self_: Origin, other: Scalar) -> Origin {
    return origin_geometricProduct_scalar(self_, other);
}
fn plane_mul_antiScalar(self_: Plane, other: AntiScalar) -> Origin {
    return plane_geometricProduct_antiScalar(self_, other);
}
fn plane_mul_dualNum(self_: Plane, other: DualNum) -> Flector {
    let self_groups = plane_grouped(self_);
    return plane_geometricProduct_dualNum(self_, other);
}
fn plane_mul_flector(self_: Plane, other: Flector) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return plane_geometricProduct_flector(self_, other);
}
fn plane_mul_horizon(self_: Plane, other: Horizon) -> Motor {
    let self_groups = plane_grouped(self_);
    return plane_geometricProduct_horizon(self_, other);
}
fn plane_mul_line(self_: Plane, other: Line) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return plane_geometricProduct_line(self_, other);
}
fn plane_mul_motor(self_: Plane, other: Motor) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return plane_geometricProduct_motor(self_, other);
}
fn plane_mul_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return plane_geometricProduct_multiVector(self_, other);
}
fn plane_mul_origin(self_: Plane, other: Origin) -> AntiScalar {
    return plane_geometricProduct_origin(self_, other);
}
fn plane_mul_plane(self_: Plane, other: Plane) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return plane_geometricProduct_plane(self_, other);
}
fn plane_mul_point(self_: Plane, other: Point) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return plane_geometricProduct_point(self_, other);
}
fn plane_mul_scalar(self_: Plane, other: Scalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_geometricProduct_scalar(self_, other);
}
fn point_mul_antiScalar(self_: Point, other: AntiScalar) -> Plane {
    let self_groups = point_grouped(self_);
    return point_geometricProduct_antiScalar(self_, other);
}
fn point_mul_dualNum(self_: Point, other: DualNum) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return point_geometricProduct_dualNum(self_, other);
}
fn point_mul_flector(self_: Point, other: Flector) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return point_geometricProduct_flector(self_, other);
}
fn point_mul_horizon(self_: Point, other: Horizon) -> Motor {
    let self_groups = point_grouped(self_);
    return point_geometricProduct_horizon(self_, other);
}
fn point_mul_line(self_: Point, other: Line) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return point_geometricProduct_line(self_, other);
}
fn point_mul_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return point_geometricProduct_motor(self_, other);
}
fn point_mul_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return point_geometricProduct_multiVector(self_, other);
}
fn point_mul_origin(self_: Point, other: Origin) -> Line {
    let self_groups = point_grouped(self_);
    return point_geometricProduct_origin(self_, other);
}
fn point_mul_plane(self_: Point, other: Plane) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return point_geometricProduct_plane(self_, other);
}
fn point_mul_point(self_: Point, other: Point) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return point_geometricProduct_point(self_, other);
}
fn point_mul_scalar(self_: Point, other: Scalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_geometricProduct_scalar(self_, other);
}
fn scalar_mul_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return scalar_geometricProduct_antiScalar(self_, other);
}
fn scalar_mul_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return scalar_geometricProduct_dualNum(self_, other);
}
fn scalar_mul_flector(self_: Scalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return scalar_geometricProduct_flector(self_, other);
}
fn scalar_mul_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return scalar_geometricProduct_horizon(self_, other);
}
fn scalar_mul_line(self_: Scalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return scalar_geometricProduct_line(self_, other);
}
fn scalar_mul_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return scalar_geometricProduct_motor(self_, other);
}
fn scalar_mul_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return scalar_geometricProduct_multiVector(self_, other);
}
fn scalar_mul_origin(self_: Scalar, other: Origin) -> Origin {
    return scalar_geometricProduct_origin(self_, other);
}
fn scalar_mul_plane(self_: Scalar, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return scalar_geometricProduct_plane(self_, other);
}
fn scalar_mul_point(self_: Scalar, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return scalar_geometricProduct_point(self_, other);
}
fn scalar_mul_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return scalar_geometricProduct_scalar(self_, other);
}
fn antiScalar_neg(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * -1.0);
}
fn dualNum_neg(self_: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn flector_neg(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn horizon_neg(self_: Horizon) -> Horizon {
    return Horizon(self_.e321_ * -1.0);
}
fn line_neg(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn motor_neg(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn multiVector_neg(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn origin_neg(self_: Origin) -> Origin {
    return Origin(self_.e4_ * -1.0);
}
fn plane_neg(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_neg(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_neg(self_: Scalar) -> Scalar {
    return Scalar(self_.scalar * -1.0);
}
fn dualNum_one() -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, 0.0, 0.0, 0.0)
    ));
}
fn motor_one() -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, 1.0)
    ));
}
fn multiVector_one() -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_one() -> Scalar {
    return Scalar(1.0);
}
fn dualNum_projectOrthogonallyOnto_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn dualNum_projectOrthogonallyOnto_flector(self_: DualNum, other: Flector) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group1_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group1_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (wedge_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_)) - (other_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn dualNum_projectOrthogonallyOnto_horizon(self_: DualNum, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn dualNum_projectOrthogonallyOnto_line(self_: DualNum, other: Line) -> Scalar {
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_));
}
fn dualNum_projectOrthogonallyOnto_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * right_anti_dual.e1234_) + (self_.e1234_ * right_anti_dual.scalar)) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn dualNum_projectOrthogonallyOnto_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.scalar * right_anti_dual.e1234_) + (self_.e1234_ * right_anti_dual.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn dualNum_projectOrthogonallyOnto_plane(self_: DualNum, other: Plane) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn dualNum_projectOrthogonallyOnto_point(self_: DualNum, other: Point) -> Scalar {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return Scalar((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_));
}
fn dualNum_projectOrthogonallyOnto_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn flector_projectOrthogonallyOnto_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (self_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group0_.xyz, right_anti_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_)) - (right_anti_dual_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw) - (right_anti_dual_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn flector_projectOrthogonallyOnto_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * wedge.e1234_)
    ));
}
fn flector_projectOrthogonallyOnto_line(self_: Flector, other: Line) -> Point {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    ));
}
fn flector_projectOrthogonallyOnto_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((self_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((self_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn flector_projectOrthogonallyOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * right_anti_dual.e423_) + (self_.e2_ * right_anti_dual.e431_) + (self_.e3_ * right_anti_dual.e412_) + (self_.e4_ * right_anti_dual.e321_) - (self_.e423_ * right_anti_dual.e1_) - (self_.e431_ * right_anti_dual.e2_) - (self_.e412_ * right_anti_dual.e3_) - (self_.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * right_anti_dual_groups.group1_.zxyw) - (self_groups.group0_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn flector_projectOrthogonallyOnto_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group0_
    ));
}
fn flector_projectOrthogonallyOnto_point(self_: Flector, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1_ * right_anti_dual.e423_) + (self_.e2_ * right_anti_dual.e431_) + (self_.e3_ * right_anti_dual.e412_) + (self_.e4_ * right_anti_dual.e321_)) * other_groups.group0_
    ));
}
fn horizon_projectOrthogonallyOnto_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge: AntiScalar = AntiScalar(vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0).w * self_.e321_ * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn horizon_projectOrthogonallyOnto_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn horizon_projectOrthogonallyOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge: AntiScalar = AntiScalar(vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0).w * self_.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group4_
    ));
}
fn horizon_projectOrthogonallyOnto_plane(self_: Horizon, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_ * other.e321_) * other_groups.group0_
    ));
}
fn line_projectOrthogonallyOnto_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e3_ * self_.e42_) + (right_anti_dual.e4_ * self_.e23_), (right_anti_dual.e1_ * self_.e43_) + (right_anti_dual.e4_ * self_.e31_), (right_anti_dual.e2_ * self_.e41_) + (right_anti_dual.e4_ * self_.e12_), -(right_anti_dual.e2_ * self_.e31_) - (right_anti_dual.e3_ * self_.e12_)) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group0_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_ * wedge.e423_ * -1.0, other.e321_ * wedge.e431_ * -1.0, other.e321_ * wedge.e412_ * -1.0, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_)) + (wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    ));
}
fn line_projectOrthogonallyOnto_horizon(self_: Line, other: Horizon) -> Line {
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(self_.e23_ * right_anti_dual.e4_, self_.e31_ * right_anti_dual.e4_, self_.e12_ * right_anti_dual.e4_, 0.0) * vec4<f32>(-1.0)
    ));
}
fn line_projectOrthogonallyOnto_line(self_: Line, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn line_projectOrthogonallyOnto_motor(self_: Line, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let right_anti_dual: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(self_.e41_ * right_anti_dual.e23_) - (self_.e42_ * right_anti_dual.e31_) - (self_.e43_ * right_anti_dual.e12_) - (self_.e23_ * right_anti_dual.e41_) - (self_.e31_ * right_anti_dual.e42_) - (self_.e12_ * right_anti_dual.e43_));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn line_projectOrthogonallyOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e41_ * right_anti_dual.e23_) - (self_.e42_ * right_anti_dual.e31_) - (self_.e43_ * right_anti_dual.e12_) - (self_.e23_ * right_anti_dual.e41_) - (self_.e31_ * right_anti_dual.e42_) - (self_.e12_ * right_anti_dual.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * right_anti_dual.e3_) + (self_.e23_ * right_anti_dual.e4_), (self_.e43_ * right_anti_dual.e1_) + (self_.e31_ * right_anti_dual.e4_), (self_.e41_ * right_anti_dual.e2_) + (self_.e12_ * right_anti_dual.e4_), -(self_.e31_ * right_anti_dual.e2_) - (self_.e12_ * right_anti_dual.e3_)) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn line_projectOrthogonallyOnto_plane(self_: Line, other: Plane) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (other_groups.group0_.zxyw * wedge_groups.group0_.yzxw) - (other_groups.group0_.yzxw * wedge_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_)
    ));
}
fn motor_projectOrthogonallyOnto_dualNum(self_: Motor, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn motor_projectOrthogonallyOnto_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e4_ * self_.e23_) + (right_anti_dual.e423_ * self_.scalar), (right_anti_dual.e4_ * self_.e31_) + (right_anti_dual.e431_ * self_.scalar), (right_anti_dual.e4_ * self_.e12_) + (right_anti_dual.e412_ * self_.scalar), -(right_anti_dual.e2_ * self_.e31_) - (right_anti_dual.e3_ * self_.e12_)) + vec4<f32>((right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, right_anti_dual.e321_ * self_.scalar) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group1_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group1_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (wedge_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_)) - (other_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn motor_projectOrthogonallyOnto_horizon(self_: Motor, other: Horizon) -> Motor {
    let self_groups = motor_grouped(self_);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_anti_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(wedge_groups.group1_.xyz, wedge.e4_) * vec4<f32>(-1.0)
    ));
}
fn motor_projectOrthogonallyOnto_line(self_: Motor, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_).xyz, -(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn motor_projectOrthogonallyOnto_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(right_anti_dual.scalar) * self_groups.group0_) + (vec4<f32>(self_.scalar) * right_anti_dual_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn motor_projectOrthogonallyOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1234_ * right_anti_dual.scalar) + (self_.scalar * right_anti_dual.e1234_) - (self_.e41_ * right_anti_dual.e23_) - (self_.e42_ * right_anti_dual.e31_) - (self_.e43_ * right_anti_dual.e12_) - (self_.e23_ * right_anti_dual.e41_) - (self_.e31_ * right_anti_dual.e42_) - (self_.e12_ * right_anti_dual.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * right_anti_dual.e4_) + (self_.scalar * right_anti_dual.e423_), (self_.e31_ * right_anti_dual.e4_) + (self_.scalar * right_anti_dual.e431_), (self_.e12_ * right_anti_dual.e4_) + (self_.scalar * right_anti_dual.e412_), -(self_.e31_ * right_anti_dual.e2_) - (self_.e12_ * right_anti_dual.e3_)) + vec4<f32>((self_groups.group0_.yzxw * right_anti_dual_groups.group1_.zxyw).xyz, self_.scalar * right_anti_dual.e321_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn motor_projectOrthogonallyOnto_plane(self_: Motor, other: Plane) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_anti_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((wedge_groups.group1_.yzxw * other_groups.group0_.zxyw) - (wedge_groups.group1_.zxyw * other_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(wedge.e321_ * other.e423_, wedge.e321_ * other.e431_, wedge.e321_ * other.e412_, -(wedge.e2_ * other.e431_) - (wedge.e3_ * other.e412_) - (wedge.e4_ * other.e321_)) - (other_groups.group0_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn motor_projectOrthogonallyOnto_point(self_: Motor, other: Point) -> Scalar {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return Scalar((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_));
}
fn motor_projectOrthogonallyOnto_scalar(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn multiVector_projectOrthogonallyOnto_dualNum(self_: MultiVector, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn multiVector_projectOrthogonallyOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_) - (right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (right_anti_dual_groups.group0_.zxyw * self_groups.group1_.yzxw) - (right_anti_dual_groups.group0_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e3_ * self_.e42_) + (right_anti_dual.e4_ * self_.e23_), (right_anti_dual.e1_ * self_.e43_) + (right_anti_dual.e4_ * self_.e31_), (right_anti_dual.e2_ * self_.e41_) + (right_anti_dual.e4_ * self_.e12_), -(right_anti_dual.e2_ * self_.e31_) - (right_anti_dual.e3_ * self_.e12_)) + (vec4<f32>(self_.scalar) * right_anti_dual_groups.group1_) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (other_groups.group1_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn multiVector_projectOrthogonallyOnto_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * right_anti_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_anti_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * wedge.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * wedge.e1234_)
    ));
}
fn multiVector_projectOrthogonallyOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_projectOrthogonallyOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_anti_dual.e1234_ * self_.scalar) + (right_anti_dual.scalar * self_.e1234_) - (right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * wedge.scalar) + (other.scalar * wedge.e1234_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1234_ * wedge.e1_) + (other.e31_ * wedge.e412_), (other.e1234_ * wedge.e2_) + (other.e12_ * wedge.e423_), (other.e1234_ * wedge.e3_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) + (other_groups.group0_ * vec4<f32>(wedge_groups.group4_.wwww.xyz, wedge.e4_)) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_projectOrthogonallyOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_anti_dual.scalar * self_.e1234_) + (right_anti_dual.e1234_ * self_.scalar) + (right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_) - (right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_) - (right_anti_dual.e41_ * self_.e23_) - (right_anti_dual.e42_ * self_.e31_) - (right_anti_dual.e43_ * self_.e12_) - (right_anti_dual.e23_ * self_.e41_) - (right_anti_dual.e31_ * self_.e42_) - (right_anti_dual.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(right_anti_dual.scalar) * self_groups.group1_) + (vec4<f32>(self_.scalar) * right_anti_dual_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + (right_anti_dual_groups.group1_.zxyw * self_groups.group1_.yzxw) - (right_anti_dual_groups.group1_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e3_ * self_.e42_) + (right_anti_dual.e4_ * self_.e23_) + (right_anti_dual.e42_ * self_.e3_) + (right_anti_dual.e23_ * self_.e4_), (right_anti_dual.e1_ * self_.e43_) + (right_anti_dual.e4_ * self_.e31_) + (right_anti_dual.e43_ * self_.e1_) + (right_anti_dual.e31_ * self_.e4_), (right_anti_dual.e2_ * self_.e41_) + (right_anti_dual.e4_ * self_.e12_) + (right_anti_dual.e41_ * self_.e2_) + (right_anti_dual.e12_ * self_.e4_), -(right_anti_dual.e1_ * self_.e23_) - (right_anti_dual.e2_ * self_.e31_) - (right_anti_dual.e3_ * self_.e12_) - (right_anti_dual.e12_ * self_.e3_)) + (vec4<f32>(right_anti_dual.scalar) * self_groups.group4_) + (vec4<f32>(self_.scalar) * right_anti_dual_groups.group4_) - (self_groups.group1_.yzxx * vec4<f32>(right_anti_dual_groups.group2_.zxyw.xyz, right_anti_dual.e23_)) - vec4<f32>((self_groups.group2_.zxyw * right_anti_dual_groups.group1_.yzxw).xyz, right_anti_dual.e31_ * self_.e2_)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn multiVector_projectOrthogonallyOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * right_anti_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_anti_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(wedge.e1_ * other.e423_) - (wedge.e2_ * other.e431_) - (wedge.e3_ * other.e412_) - (wedge.e4_ * other.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (wedge_groups.group4_.yzxw * other_groups.group0_.zxyw) - (wedge_groups.group4_.zxyw * other_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group0_
    ));
}
fn multiVector_projectOrthogonallyOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    let wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * right_anti_dual.e423_) + (self_.e2_ * right_anti_dual.e431_) + (self_.e3_ * right_anti_dual.e412_) + (self_.e4_ * right_anti_dual.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_projectOrthogonallyOnto_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn origin_projectOrthogonallyOnto_flector(self_: Origin, other: Flector) -> Point {
    let other_groups = flector_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge: Line = line_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_))
    ));
}
fn origin_projectOrthogonallyOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge: Line = line_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(wedge.e41_ * other.e23_) - (wedge.e42_ * other.e31_) - (wedge.e43_ * other.e12_) - (wedge.e23_ * other.e41_) - (wedge.e31_ * other.e42_) - (wedge.e12_ * other.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group4_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn plane_projectOrthogonallyOnto_flector(self_: Plane, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let right_anti_dual: Flector = flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn plane_projectOrthogonallyOnto_horizon(self_: Plane, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn plane_projectOrthogonallyOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_anti_dual: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(right_anti_dual.e1_ * self_.e423_) - (right_anti_dual.e2_ * self_.e431_) - (right_anti_dual.e3_ * self_.e412_) - (right_anti_dual.e4_ * self_.e321_));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group4_
    ));
}
fn plane_projectOrthogonallyOnto_plane(self_: Plane, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_ * self_.e321_) * other_groups.group0_
    ));
}
fn point_projectOrthogonallyOnto_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_anti_dual.e4_ * self_.e1_ * -1.0, right_anti_dual.e4_ * self_.e2_ * -1.0, right_anti_dual.e4_ * self_.e3_ * -1.0, (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_)) + (self_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group0_.xyz, right_anti_dual.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw) - (right_anti_dual_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn point_projectOrthogonallyOnto_horizon(self_: Point, other: Horizon) -> Point {
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(right_anti_dual.e4_ * self_.e1_ * -1.0, right_anti_dual.e4_ * self_.e2_ * -1.0, right_anti_dual.e4_ * self_.e3_ * -1.0, 0.0)).xyz, 0.0)
    ));
}
fn point_projectOrthogonallyOnto_line(self_: Point, other: Line) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    ));
}
fn point_projectOrthogonallyOnto_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn point_projectOrthogonallyOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (right_anti_dual_groups.group1_.zxyw * self_groups.group0_.yzxw) - (right_anti_dual_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn point_projectOrthogonallyOnto_plane(self_: Point, other: Plane) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge: Line = line_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_))
    ));
}
fn point_projectOrthogonallyOnto_point(self_: Point, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_anti_dual.e423_ * self_.e1_) + (right_anti_dual.e431_ * self_.e2_) + (right_anti_dual.e412_ * self_.e3_) + (right_anti_dual.e321_ * self_.e4_)) * other_groups.group0_
    ));
}
fn scalar_projectOrthogonallyOnto_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_projectOrthogonallyOnto_flector(self_: Scalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group1_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group1_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (wedge_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_)) - (other_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn scalar_projectOrthogonallyOnto_horizon(self_: Scalar, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_projectOrthogonallyOnto_line(self_: Scalar, other: Line) -> Scalar {
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_));
}
fn scalar_projectOrthogonallyOnto_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn scalar_projectOrthogonallyOnto_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, right_anti_dual.e1234_ * self_.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn scalar_projectOrthogonallyOnto_plane(self_: Scalar, other: Plane) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_projectOrthogonallyOnto_point(self_: Scalar, other: Point) -> Scalar {
    let other_groups = point_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
    return Scalar((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_));
}
fn scalar_projectOrthogonallyOnto_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn dualNum_projectViaOriginOnto_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn dualNum_projectViaOriginOnto_flector(self_: DualNum, other: Flector) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group1_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group1_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group1_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (wedge_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_)) - (other_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn dualNum_projectViaOriginOnto_horizon(self_: DualNum, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn dualNum_projectViaOriginOnto_line(self_: DualNum, other: Line) -> Scalar {
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_));
}
fn dualNum_projectViaOriginOnto_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * right_dual.e1234_) + (self_.e1234_ * right_dual.scalar)) * vec4<f32>(right_dual_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn dualNum_projectViaOriginOnto_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.scalar * right_dual.e1234_) + (self_.e1234_ * right_dual.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn dualNum_projectViaOriginOnto_plane(self_: DualNum, other: Plane) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn dualNum_projectViaOriginOnto_point(self_: DualNum, other: Point) -> Scalar {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return Scalar((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_));
}
fn dualNum_projectViaOriginOnto_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn flector_projectViaOriginOnto_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (self_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group0_.xyz, right_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_)) - (right_dual_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw) - (right_dual_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn flector_projectViaOriginOnto_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * wedge.e1234_)
    ));
}
fn flector_projectViaOriginOnto_line(self_: Flector, other: Line) -> Point {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    ));
}
fn flector_projectViaOriginOnto_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((self_groups.group0_.zxyw * right_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((self_groups.group0_.yzxw * right_dual_groups.group0_.zxyw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn flector_projectViaOriginOnto_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * right_dual.e423_) + (self_.e2_ * right_dual.e431_) + (self_.e3_ * right_dual.e412_) + (self_.e4_ * right_dual.e321_) - (self_.e423_ * right_dual.e1_) - (self_.e431_ * right_dual.e2_) - (self_.e412_ * right_dual.e3_) - (self_.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * right_dual_groups.group1_.zxyw) - (self_groups.group0_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group2_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn flector_projectViaOriginOnto_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group0_
    ));
}
fn flector_projectViaOriginOnto_point(self_: Flector, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1_ * right_dual.e423_) + (self_.e2_ * right_dual.e431_) + (self_.e3_ * right_dual.e412_) + (self_.e4_ * right_dual.e321_)) * other_groups.group0_
    ));
}
fn horizon_projectViaOriginOnto_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let wedge: AntiScalar = AntiScalar(vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0).w * self_.e321_ * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn horizon_projectViaOriginOnto_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn horizon_projectViaOriginOnto_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge: AntiScalar = AntiScalar(vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0).w * self_.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group4_
    ));
}
fn horizon_projectViaOriginOnto_plane(self_: Horizon, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_ * other.e321_) * other_groups.group0_
    ));
}
fn line_projectViaOriginOnto_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e3_ * self_.e42_) + (right_dual.e4_ * self_.e23_), (right_dual.e1_ * self_.e43_) + (right_dual.e4_ * self_.e31_), (right_dual.e2_ * self_.e41_) + (right_dual.e4_ * self_.e12_), -(right_dual.e2_ * self_.e31_) - (right_dual.e3_ * self_.e12_)) - (right_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group0_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_ * wedge.e423_ * -1.0, other.e321_ * wedge.e431_ * -1.0, other.e321_ * wedge.e412_ * -1.0, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_)) + (wedge_groups.group0_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    ));
}
fn line_projectViaOriginOnto_horizon(self_: Line, other: Horizon) -> Line {
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(self_.e23_ * right_dual.e4_, self_.e31_ * right_dual.e4_, self_.e12_ * right_dual.e4_, 0.0) * vec4<f32>(-1.0)
    ));
}
fn line_projectViaOriginOnto_line(self_: Line, other: Line) -> Line {
    let other_groups = line_grouped(other);
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn line_projectViaOriginOnto_motor(self_: Line, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let right_dual: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(self_.e41_ * right_dual.e23_) - (self_.e42_ * right_dual.e31_) - (self_.e43_ * right_dual.e12_) - (self_.e23_ * right_dual.e41_) - (self_.e31_ * right_dual.e42_) - (self_.e12_ * right_dual.e43_));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn line_projectViaOriginOnto_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e41_ * right_dual.e23_) - (self_.e42_ * right_dual.e31_) - (self_.e43_ * right_dual.e12_) - (self_.e23_ * right_dual.e41_) - (self_.e31_ * right_dual.e42_) - (self_.e12_ * right_dual.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * right_dual.e3_) + (self_.e23_ * right_dual.e4_), (self_.e43_ * right_dual.e1_) + (self_.e31_ * right_dual.e4_), (self_.e41_ * right_dual.e2_) + (self_.e12_ * right_dual.e4_), -(self_.e31_ * right_dual.e2_) - (self_.e12_ * right_dual.e3_)) - (right_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn line_projectViaOriginOnto_plane(self_: Line, other: Plane) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (other_groups.group0_.zxyw * wedge_groups.group0_.yzxw) - (other_groups.group0_.yzxw * wedge_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_)
    ));
}
fn motor_projectViaOriginOnto_dualNum(self_: Motor, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn motor_projectViaOriginOnto_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e4_ * self_.e23_) + (right_dual.e423_ * self_.scalar), (right_dual.e4_ * self_.e31_) + (right_dual.e431_ * self_.scalar), (right_dual.e4_ * self_.e12_) + (right_dual.e412_ * self_.scalar), -(right_dual.e2_ * self_.e31_) - (right_dual.e3_ * self_.e12_)) + vec4<f32>((right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, right_dual.e321_ * self_.scalar) - (right_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group1_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group1_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (wedge_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_)) - (other_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn motor_projectViaOriginOnto_horizon(self_: Motor, other: Horizon) -> Motor {
    let self_groups = motor_grouped(self_);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(wedge_groups.group1_.xyz, wedge.e4_) * vec4<f32>(-1.0)
    ));
}
fn motor_projectViaOriginOnto_line(self_: Motor, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_).xyz, -(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn motor_projectViaOriginOnto_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(right_dual.scalar) * self_groups.group0_) + (vec4<f32>(self_.scalar) * right_dual_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn motor_projectViaOriginOnto_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1234_ * right_dual.scalar) + (self_.scalar * right_dual.e1234_) - (self_.e41_ * right_dual.e23_) - (self_.e42_ * right_dual.e31_) - (self_.e43_ * right_dual.e12_) - (self_.e23_ * right_dual.e41_) - (self_.e31_ * right_dual.e42_) - (self_.e12_ * right_dual.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * right_dual.e4_) + (self_.scalar * right_dual.e423_), (self_.e31_ * right_dual.e4_) + (self_.scalar * right_dual.e431_), (self_.e12_ * right_dual.e4_) + (self_.scalar * right_dual.e412_), -(self_.e31_ * right_dual.e2_) - (self_.e12_ * right_dual.e3_)) + vec4<f32>((self_groups.group0_.yzxw * right_dual_groups.group1_.zxyw).xyz, self_.scalar * right_dual.e321_) - (right_dual_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn motor_projectViaOriginOnto_plane(self_: Motor, other: Plane) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((wedge_groups.group1_.yzxw * other_groups.group0_.zxyw) - (wedge_groups.group1_.zxyw * other_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(wedge.e321_ * other.e423_, wedge.e321_ * other.e431_, wedge.e321_ * other.e412_, -(wedge.e2_ * other.e431_) - (wedge.e3_ * other.e412_) - (wedge.e4_ * other.e321_)) - (other_groups.group0_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn motor_projectViaOriginOnto_point(self_: Motor, other: Point) -> Scalar {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return Scalar((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_));
}
fn motor_projectViaOriginOnto_scalar(self_: Motor, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn multiVector_projectViaOriginOnto_dualNum(self_: MultiVector, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn multiVector_projectViaOriginOnto_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_) - (right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (right_dual_groups.group0_.zxyw * self_groups.group1_.yzxw) - (right_dual_groups.group0_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e3_ * self_.e42_) + (right_dual.e4_ * self_.e23_), (right_dual.e1_ * self_.e43_) + (right_dual.e4_ * self_.e31_), (right_dual.e2_ * self_.e41_) + (right_dual.e4_ * self_.e12_), -(right_dual.e2_ * self_.e31_) - (right_dual.e3_ * self_.e12_)) + (vec4<f32>(self_.scalar) * right_dual_groups.group1_) - (right_dual_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (other_groups.group1_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn multiVector_projectViaOriginOnto_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * right_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * wedge.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * wedge.e1234_)
    ));
}
fn multiVector_projectViaOriginOnto_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_projectViaOriginOnto_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_dual.e1234_ * self_.scalar) + (right_dual.scalar * self_.e1234_) - (right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * wedge.scalar) + (other.scalar * wedge.e1234_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1234_ * wedge.e1_) + (other.e31_ * wedge.e412_), (other.e1234_ * wedge.e2_) + (other.e12_ * wedge.e423_), (other.e1234_ * wedge.e3_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) + (other_groups.group0_ * vec4<f32>(wedge_groups.group4_.wwww.xyz, wedge.e4_)) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group4_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_projectViaOriginOnto_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_dual.scalar * self_.e1234_) + (right_dual.e1234_ * self_.scalar) + (right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_) - (right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_) - (right_dual.e41_ * self_.e23_) - (right_dual.e42_ * self_.e31_) - (right_dual.e43_ * self_.e12_) - (right_dual.e23_ * self_.e41_) - (right_dual.e31_ * self_.e42_) - (right_dual.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(right_dual.scalar) * self_groups.group1_) + (vec4<f32>(self_.scalar) * right_dual_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + (right_dual_groups.group1_.zxyw * self_groups.group1_.yzxw) - (right_dual_groups.group1_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e3_ * self_.e42_) + (right_dual.e4_ * self_.e23_) + (right_dual.e42_ * self_.e3_) + (right_dual.e23_ * self_.e4_), (right_dual.e1_ * self_.e43_) + (right_dual.e4_ * self_.e31_) + (right_dual.e43_ * self_.e1_) + (right_dual.e31_ * self_.e4_), (right_dual.e2_ * self_.e41_) + (right_dual.e4_ * self_.e12_) + (right_dual.e41_ * self_.e2_) + (right_dual.e12_ * self_.e4_), -(right_dual.e1_ * self_.e23_) - (right_dual.e2_ * self_.e31_) - (right_dual.e3_ * self_.e12_) - (right_dual.e12_ * self_.e3_)) + (vec4<f32>(right_dual.scalar) * self_groups.group4_) + (vec4<f32>(self_.scalar) * right_dual_groups.group4_) - (self_groups.group1_.yzxx * vec4<f32>(right_dual_groups.group2_.zxyw.xyz, right_dual.e23_)) - vec4<f32>((self_groups.group2_.zxyw * right_dual_groups.group1_.yzxw).xyz, right_dual.e31_ * self_.e2_)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn multiVector_projectViaOriginOnto_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * right_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * right_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(wedge.e1_ * other.e423_) - (wedge.e2_ * other.e431_) - (wedge.e3_ * other.e412_) - (wedge.e4_ * other.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(wedge_groups.group3_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (wedge_groups.group4_.yzxw * other_groups.group0_.zxyw) - (wedge_groups.group4_.zxyw * other_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group0_
    ));
}
fn multiVector_projectViaOriginOnto_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    let wedge: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * right_dual.e423_) + (self_.e2_ * right_dual.e431_) + (self_.e3_ * right_dual.e412_) + (self_.e4_ * right_dual.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn multiVector_projectViaOriginOnto_scalar(self_: MultiVector, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn origin_projectViaOriginOnto_flector(self_: Origin, other: Flector) -> Point {
    let other_groups = flector_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge: Line = line_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_))
    ));
}
fn origin_projectViaOriginOnto_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge: Line = line_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(wedge.e41_ * other.e23_) - (wedge.e42_ * other.e31_) - (wedge.e43_ * other.e12_) - (wedge.e23_ * other.e41_) - (wedge.e31_ * other.e42_) - (wedge.e12_ * other.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group4_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn plane_projectViaOriginOnto_flector(self_: Plane, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let right_dual: Flector = flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn plane_projectViaOriginOnto_horizon(self_: Plane, other: Horizon) -> Horizon {
    return Horizon(pow(other.e321_, 2) * self_.e321_);
}
fn plane_projectViaOriginOnto_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_dual: MultiVector = multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    ));
    let wedge: AntiScalar = AntiScalar(-(right_dual.e1_ * self_.e423_) - (right_dual.e2_ * self_.e431_) - (right_dual.e3_ * self_.e412_) - (right_dual.e4_ * self_.e321_));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(wedge.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group4_
    ));
}
fn plane_projectViaOriginOnto_plane(self_: Plane, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_ * self_.e321_) * other_groups.group0_
    ));
}
fn point_projectViaOriginOnto_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_dual.e4_ * self_.e1_ * -1.0, right_dual.e4_ * self_.e2_ * -1.0, right_dual.e4_ * self_.e3_ * -1.0, (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_)) + (self_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group0_.xyz, right_dual.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw) - (right_dual_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(wedge.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(wedge.e1234_) * other_groups.group1_
    ));
}
fn point_projectViaOriginOnto_horizon(self_: Point, other: Horizon) -> Point {
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(right_dual.e4_ * self_.e1_ * -1.0, right_dual.e4_ * self_.e2_ * -1.0, right_dual.e4_ * self_.e3_ * -1.0, 0.0)).xyz, 0.0)
    ));
}
fn point_projectViaOriginOnto_line(self_: Point, other: Line) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    ));
}
fn point_projectViaOriginOnto_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: Plane = plane_degroup(wedge_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_), -(other.e42_ * wedge.e431_) - (other.e43_ * wedge.e412_)) - (wedge_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(wedge_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn point_projectViaOriginOnto_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (right_dual_groups.group1_.zxyw * self_groups.group0_.yzxw) - (right_dual_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_).xyz, 0.0) + vec4<f32>((right_dual_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group2_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn point_projectViaOriginOnto_plane(self_: Point, other: Plane) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    let wedge_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let wedge: Line = line_degroup(wedge_groups);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((wedge.e41_ * other.e321_) + (wedge.e31_ * other.e412_), (wedge.e42_ * other.e321_) + (wedge.e12_ * other.e423_), (wedge.e43_ * other.e321_) + (wedge.e23_ * other.e431_), -(wedge.e42_ * other.e431_) - (wedge.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(wedge_groups.group1_.zxyw.xyz, wedge.e41_))
    ));
}
fn point_projectViaOriginOnto_point(self_: Point, other: Point) -> Point {
    let other_groups = point_grouped(other);
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((right_dual.e423_ * self_.e1_) + (right_dual.e431_ * self_.e2_) + (right_dual.e412_ * self_.e3_) + (right_dual.e321_ * self_.e4_)) * other_groups.group0_
    ));
}
fn scalar_projectViaOriginOnto_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar * self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_projectViaOriginOnto_flector(self_: Scalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0)
    );
    let wedge: Flector = flector_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.zxyw * wedge_groups.group1_.yzxw) - (other_groups.group1_.yzxw * wedge_groups.group1_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (wedge_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_)) - (other_groups.group1_.wwwx * vec4<f32>(wedge_groups.group1_.xyz, wedge.e1_))
    ));
}
fn scalar_projectViaOriginOnto_horizon(self_: Scalar, other: Horizon) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_projectViaOriginOnto_line(self_: Scalar, other: Line) -> Scalar {
    let wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return Scalar(-(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_));
}
fn scalar_projectViaOriginOnto_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let wedge: Motor = motor_degroup(wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group0_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * wedge.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_))
    ));
}
fn scalar_projectViaOriginOnto_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    let wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, right_dual.e1234_ * self_.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_).xyz, 0.0)
    );
    let wedge: MultiVector = multiVector_degroup(wedge_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * wedge.e1234_) + (other.e1234_ * wedge.scalar) + (other.e1_ * wedge.e423_) + (other.e2_ * wedge.e431_) + (other.e3_ * wedge.e412_) + (other.e4_ * wedge.e321_) - (other.e41_ * wedge.e23_) - (other.e42_ * wedge.e31_) - (other.e43_ * wedge.e12_) - (other.e23_ * wedge.e41_) - (other.e31_ * wedge.e42_) - (other.e12_ * wedge.e43_) - (other.e423_ * wedge.e1_) - (other.e431_ * wedge.e2_) - (other.e412_ * wedge.e3_) - (other.e321_ * wedge.e4_), other.e1234_ * wedge.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * wedge.e321_) + (other.e31_ * wedge.e412_) + (other.e412_ * wedge.e31_) + (other.e321_ * wedge.e41_), (other.e42_ * wedge.e321_) + (other.e12_ * wedge.e423_) + (other.e423_ * wedge.e12_) + (other.e321_ * wedge.e42_), (other.e43_ * wedge.e321_) + (other.e23_ * wedge.e431_) + (other.e431_ * wedge.e23_) + (other.e321_ * wedge.e43_), -(other.e43_ * wedge.e412_) - (other.e423_ * wedge.e41_) - (other.e431_ * wedge.e42_) - (other.e412_ * wedge.e43_)) + (vec4<f32>(other.e1234_) * wedge_groups.group1_) + (vec4<f32>(wedge.e1234_) * other_groups.group1_) - (wedge_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((wedge_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * wedge.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group2_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.zxyw * wedge_groups.group4_.yzxw) - (other_groups.group4_.yzxw * wedge_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group3_) + ((vec4<f32>(wedge.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(wedge.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * wedge_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * wedge_groups.group4_) + (vec4<f32>(wedge.e1234_) * other_groups.group4_)
    ));
}
fn scalar_projectViaOriginOnto_plane(self_: Scalar, other: Plane) -> Scalar {
    return Scalar(pow(other.e321_, 2) * self_.scalar);
}
fn scalar_projectViaOriginOnto_point(self_: Scalar, other: Point) -> Scalar {
    let other_groups = point_grouped(other);
    let wedge: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
    return Scalar((wedge.e423_ * other.e1_) + (wedge.e431_ * other.e2_) + (wedge.e412_ * other.e3_) + (wedge.e321_ * other.e4_));
}
fn scalar_projectViaOriginOnto_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(pow(other.scalar, 2) * self_.scalar);
}
fn antiScalar_rejectOrthogonallyFrom_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn antiScalar_rejectOrthogonallyFrom_flector(self_: AntiScalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group0_.xyz, right_anti_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_)) - (right_anti_dual_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw) - (anti_wedge_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn antiScalar_rejectOrthogonallyFrom_horizon(self_: AntiScalar, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn antiScalar_rejectOrthogonallyFrom_line(self_: AntiScalar, other: Line) -> AntiScalar {
    let other_groups = line_grouped(other);
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_));
}
fn antiScalar_rejectOrthogonallyFrom_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_rejectOrthogonallyFrom_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn antiScalar_rejectOrthogonallyFrom_plane(self_: AntiScalar, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn antiScalar_rejectOrthogonallyFrom_point(self_: AntiScalar, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return AntiScalar((right_anti_dual.e423_ * anti_wedge.e1_) + (right_anti_dual.e431_ * anti_wedge.e2_) + (right_anti_dual.e412_ * anti_wedge.e3_) + (right_anti_dual.e321_ * anti_wedge.e4_));
}
fn antiScalar_rejectOrthogonallyFrom_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn dualNum_rejectOrthogonallyFrom_dualNum(self_: DualNum, other: DualNum) -> AntiScalar {
    return AntiScalar((pow(other.scalar, 2) * self_.e1234_) + (other.scalar * other.e1234_ * self_.scalar));
}
fn dualNum_rejectOrthogonallyFrom_flector(self_: DualNum, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group0_.xyz, right_anti_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_)) - (right_anti_dual_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw) - (anti_wedge_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn dualNum_rejectOrthogonallyFrom_horizon(self_: DualNum, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn dualNum_rejectOrthogonallyFrom_line(self_: DualNum, other: Line) -> AntiScalar {
    let other_groups = line_grouped(other);
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_anti_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_));
}
fn dualNum_rejectOrthogonallyFrom_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar)) * vec4<f32>(other_groups.group1_.xyz, 1.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn dualNum_rejectOrthogonallyFrom_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn dualNum_rejectOrthogonallyFrom_plane(self_: DualNum, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn dualNum_rejectOrthogonallyFrom_point(self_: DualNum, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return AntiScalar((right_anti_dual.e423_ * anti_wedge.e1_) + (right_anti_dual.e431_ * anti_wedge.e2_) + (right_anti_dual.e412_ * anti_wedge.e3_) + (right_anti_dual.e321_ * anti_wedge.e4_));
}
fn dualNum_rejectOrthogonallyFrom_scalar(self_: DualNum, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn flector_rejectOrthogonallyFrom_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.yzxw * self_groups.group1_.zxyw) - (other_groups.group1_.zxyw * self_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (other_groups.group1_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (self_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e4_ * anti_wedge.e23_) + (right_anti_dual.e423_ * anti_wedge.scalar), (right_anti_dual.e4_ * anti_wedge.e31_) + (right_anti_dual.e431_ * anti_wedge.scalar), (right_anti_dual.e4_ * anti_wedge.e12_) + (right_anti_dual.e412_ * anti_wedge.scalar), -(right_anti_dual.e2_ * anti_wedge.e31_) - (right_anti_dual.e3_ * anti_wedge.e12_)) + vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, right_anti_dual.e321_ * anti_wedge.scalar) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn flector_rejectOrthogonallyFrom_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_anti_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0)
    ));
}
fn flector_rejectOrthogonallyFrom_line(self_: Flector, other: Line) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn flector_rejectOrthogonallyFrom_motor(self_: Flector, other: Motor) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn flector_rejectOrthogonallyFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_) - (self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * other_groups.group4_.yzxw) - (self_groups.group1_.yzxw * other_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn flector_rejectOrthogonallyFrom_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((self_groups.group1_.zxyw * other_groups.group0_.yzxw) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_ * other.e423_ * -1.0, self_.e321_ * other.e431_ * -1.0, self_.e321_ * other.e412_ * -1.0, (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (other_groups.group0_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_anti_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0)
    ));
}
fn flector_rejectOrthogonallyFrom_point(self_: Flector, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_rejectOrthogonallyFrom_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e4_ * anti_wedge.e23_) + (right_anti_dual.e423_ * anti_wedge.scalar), (right_anti_dual.e4_ * anti_wedge.e31_) + (right_anti_dual.e431_ * anti_wedge.scalar), (right_anti_dual.e4_ * anti_wedge.e12_) + (right_anti_dual.e412_ * anti_wedge.scalar), -(right_anti_dual.e2_ * anti_wedge.e31_) - (right_anti_dual.e3_ * anti_wedge.e12_)) + vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, right_anti_dual.e321_ * anti_wedge.scalar) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn horizon_rejectOrthogonallyFrom_line(self_: Horizon, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn horizon_rejectOrthogonallyFrom_motor(self_: Horizon, other: Motor) -> Plane {
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn horizon_rejectOrthogonallyFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn horizon_rejectOrthogonallyFrom_plane(self_: Horizon, other: Plane) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(self_.e321_ * other.e423_ * -1.0, self_.e321_ * other.e431_ * -1.0, self_.e321_ * other.e412_ * -1.0, 0.0)).xyz, 0.0)
    ));
}
fn horizon_rejectOrthogonallyFrom_point(self_: Horizon, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_ * other.e4_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn line_rejectOrthogonallyFrom_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_anti_dual.e4_ * anti_wedge.e1_ * -1.0, right_anti_dual.e4_ * anti_wedge.e2_ * -1.0, right_anti_dual.e4_ * anti_wedge.e3_ * -1.0, (right_anti_dual.e431_ * anti_wedge.e2_) + (right_anti_dual.e412_ * anti_wedge.e3_) + (right_anti_dual.e321_ * anti_wedge.e4_)) + (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group0_.xyz, right_anti_dual.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw) - (right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn line_rejectOrthogonallyFrom_horizon(self_: Line, other: Horizon) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e321_ * self_.e41_, other.e321_ * self_.e42_, other.e321_ * self_.e43_, 0.0) * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_rejectOrthogonallyFrom_line(self_: Line, other: Line) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_rejectOrthogonallyFrom_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn line_rejectOrthogonallyFrom_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn line_rejectOrthogonallyFrom_plane(self_: Line, other: Plane) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_) - (self_.e12_ * other.e431_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_) - (self_.e23_ * other.e412_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_) - (self_.e31_ * other.e423_), -(self_.e41_ * other.e423_) - (self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_rejectOrthogonallyFrom_dualNum(self_: Motor, other: DualNum) -> AntiScalar {
    return AntiScalar((pow(other.scalar, 2) * self_.e1234_) + (other.scalar * other.e1234_ * self_.scalar));
}
fn motor_rejectOrthogonallyFrom_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_anti_dual_groups.group0_.xyz, right_anti_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_)) - (right_anti_dual_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw) - (anti_wedge_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn motor_rejectOrthogonallyFrom_horizon(self_: Motor, other: Horizon) -> Motor {
    let self_groups = motor_grouped(self_);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectOrthogonallyFrom_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_))
    ));
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_).xyz, -(right_anti_dual.e41_ * anti_wedge.e23_) - (right_anti_dual.e42_ * anti_wedge.e31_) - (right_anti_dual.e43_ * anti_wedge.e12_) - (right_anti_dual.e23_ * anti_wedge.e41_) - (right_anti_dual.e31_ * anti_wedge.e42_) - (right_anti_dual.e12_ * anti_wedge.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectOrthogonallyFrom_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * self_.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectOrthogonallyFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1234_ * other.scalar) + (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1234_ * other.e1_) + (self_.e31_ * other.e412_), (self_.e1234_ * other.e2_) + (self_.e12_ * other.e423_), (self_.e1234_ * other.e3_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) + (self_groups.group0_ * vec4<f32>(other_groups.group4_.wwww.xyz, other.e4_)) - (other_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn motor_rejectOrthogonallyFrom_plane(self_: Motor, other: Plane) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectOrthogonallyFrom_point(self_: Motor, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
    let right_anti_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return AntiScalar((right_anti_dual.e423_ * anti_wedge.e1_) + (right_anti_dual.e431_ * anti_wedge.e2_) + (right_anti_dual.e412_ * anti_wedge.e3_) + (right_anti_dual.e321_ * anti_wedge.e4_));
}
fn motor_rejectOrthogonallyFrom_scalar(self_: Motor, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn multiVector_rejectOrthogonallyFrom_dualNum(self_: MultiVector, other: DualNum) -> AntiScalar {
    return AntiScalar((pow(other.scalar, 2) * self_.e1234_) + (other.scalar * other.e1234_ * self_.scalar));
}
fn multiVector_rejectOrthogonallyFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (other_groups.group1_.yzxw * self_groups.group4_.zxyw) - (other_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_anti_dual.e423_ * anti_wedge.e1_) + (right_anti_dual.e431_ * anti_wedge.e2_) + (right_anti_dual.e412_ * anti_wedge.e3_) + (right_anti_dual.e321_ * anti_wedge.e4_) - (right_anti_dual.e1_ * anti_wedge.e423_) - (right_anti_dual.e2_ * anti_wedge.e431_) - (right_anti_dual.e3_ * anti_wedge.e412_) - (right_anti_dual.e4_ * anti_wedge.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ (right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw) - (right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e3_ * anti_wedge.e42_) + (right_anti_dual.e4_ * anti_wedge.e23_), (right_anti_dual.e1_ * anti_wedge.e43_) + (right_anti_dual.e4_ * anti_wedge.e31_), (right_anti_dual.e2_ * anti_wedge.e41_) + (right_anti_dual.e4_ * anti_wedge.e12_), -(right_anti_dual.e2_ * anti_wedge.e31_) - (right_anti_dual.e3_ * anti_wedge.e12_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn multiVector_rejectOrthogonallyFrom_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, anti_wedge.e321_ * right_anti_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_anti_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0)
    ));
}
fn multiVector_rejectOrthogonallyFrom_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_anti_dual: Line = line_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(right_anti_dual.e41_ * anti_wedge.e23_) - (right_anti_dual.e42_ * anti_wedge.e31_) - (right_anti_dual.e43_ * anti_wedge.e12_) - (right_anti_dual.e23_ * anti_wedge.e41_) - (right_anti_dual.e31_ * anti_wedge.e42_) - (right_anti_dual.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn multiVector_rejectOrthogonallyFrom_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * self_.scalar) + (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1234_ * self_.e1_) + (other.e31_ * self_.e412_), (other.e1234_ * self_.e2_) + (other.e12_ * self_.e423_), (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) + (other_groups.group0_ * vec4<f32>(self_groups.group4_.wwww.xyz, self_.e4_)) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_anti_dual.e1234_ * anti_wedge.scalar) + (right_anti_dual.scalar * anti_wedge.e1234_) - (right_anti_dual.e41_ * anti_wedge.e23_) - (right_anti_dual.e42_ * anti_wedge.e31_) - (right_anti_dual.e43_ * anti_wedge.e12_) - (right_anti_dual.e23_ * anti_wedge.e41_) - (right_anti_dual.e31_ * anti_wedge.e42_) - (right_anti_dual.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group0_), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn multiVector_rejectOrthogonallyFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar) + (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e43_ * self_.e412_) - (other.e423_ * self_.e41_) - (other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * other_groups.group1_) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((self_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * self_.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.yzxw * self_groups.group4_.zxyw) - (other_groups.group4_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e1234_) * other_groups.group4_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn multiVector_rejectOrthogonallyFrom_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, anti_wedge.e321_ * right_anti_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_anti_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0)
    ));
}
fn multiVector_rejectOrthogonallyFrom_point(self_: MultiVector, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Plane = plane_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge_groups.group0_.xxzw.xy, anti_wedge.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_anti_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_rejectOrthogonallyFrom_scalar(self_: MultiVector, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn origin_rejectOrthogonallyFrom_flector(self_: Origin, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_wedge: Scalar = Scalar(other.e321_ * self_.e4_);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0)
    ));
}
fn origin_rejectOrthogonallyFrom_horizon(self_: Origin, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn origin_rejectOrthogonallyFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group2_.yzxw * right_anti_dual_groups.group1_.zxyw).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group2_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group2_.zxyw * right_anti_dual_groups.group1_.yzxw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn origin_rejectOrthogonallyFrom_plane(self_: Origin, other: Plane) -> Origin {
    return Origin(self_.e4_ * pow(other.e321_, 2) * -1.0);
}
fn plane_rejectOrthogonallyFrom_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_ * self_.e423_, other.e321_ * self_.e431_, other.e321_ * self_.e412_, -(other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (self_groups.group0_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_anti_dual: Flector = flector_degroup(right_anti_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_anti_dual.e4_ * anti_wedge.e23_) + (right_anti_dual.e423_ * anti_wedge.scalar), (right_anti_dual.e4_ * anti_wedge.e31_) + (right_anti_dual.e431_ * anti_wedge.scalar), (right_anti_dual.e4_ * anti_wedge.e12_) + (right_anti_dual.e412_ * anti_wedge.scalar), -(right_anti_dual.e2_ * anti_wedge.e31_) - (right_anti_dual.e3_ * anti_wedge.e12_)) + vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, right_anti_dual.e321_ * anti_wedge.scalar) - (right_anti_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn plane_rejectOrthogonallyFrom_horizon(self_: Plane, other: Horizon) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e321_ * self_.e423_, other.e321_ * self_.e431_, other.e321_ * self_.e412_, 0.0)).xyz, 0.0)
    ));
}
fn plane_rejectOrthogonallyFrom_line(self_: Plane, other: Line) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_anti_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn plane_rejectOrthogonallyFrom_motor(self_: Plane, other: Motor) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_anti_dual: Motor = motor_degroup(right_anti_dual_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group0_.zxyw * right_anti_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group0_.yzxw * right_anti_dual_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn plane_rejectOrthogonallyFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_anti_dual.e42_) + (anti_wedge.e4_ * right_anti_dual.e23_) + (anti_wedge.e42_ * right_anti_dual.e3_) + (anti_wedge.e23_ * right_anti_dual.e4_), (anti_wedge.e1_ * right_anti_dual.e43_) + (anti_wedge.e4_ * right_anti_dual.e31_) + (anti_wedge.e43_ * right_anti_dual.e1_) + (anti_wedge.e31_ * right_anti_dual.e4_), (anti_wedge.e2_ * right_anti_dual.e41_) + (anti_wedge.e4_ * right_anti_dual.e12_) + (anti_wedge.e41_ * right_anti_dual.e2_) + (anti_wedge.e12_ * right_anti_dual.e4_), -(anti_wedge.e1_ * right_anti_dual.e23_) - (anti_wedge.e2_ * right_anti_dual.e31_) - (anti_wedge.e3_ * right_anti_dual.e12_) - (anti_wedge.e12_ * right_anti_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group4_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group4_) - (right_anti_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_anti_dual.e2_)
    ));
}
fn plane_rejectOrthogonallyFrom_plane(self_: Plane, other: Plane) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>((other.e321_ * self_.e423_) - (other.e423_ * self_.e321_), (other.e321_ * self_.e431_) - (other.e431_ * self_.e321_), (other.e321_ * self_.e412_) - (other.e412_ * self_.e321_), 0.0)).xyz, 0.0)
    ));
}
fn plane_rejectOrthogonallyFrom_point(self_: Plane, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn point_rejectOrthogonallyFrom_flector(self_: Point, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_wedge: Scalar = Scalar((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_));
    let right_anti_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0)
    ));
}
fn point_rejectOrthogonallyFrom_horizon(self_: Point, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn point_rejectOrthogonallyFrom_motor(self_: Point, other: Motor) -> Plane {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn point_rejectOrthogonallyFrom_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_anti_dual.e1234_) + (anti_wedge.e1234_ * right_anti_dual.scalar) + (anti_wedge.e1_ * right_anti_dual.e423_) + (anti_wedge.e2_ * right_anti_dual.e431_) + (anti_wedge.e3_ * right_anti_dual.e412_) + (anti_wedge.e4_ * right_anti_dual.e321_) - (anti_wedge.e41_ * right_anti_dual.e23_) - (anti_wedge.e42_ * right_anti_dual.e31_) - (anti_wedge.e43_ * right_anti_dual.e12_) - (anti_wedge.e23_ * right_anti_dual.e41_) - (anti_wedge.e31_ * right_anti_dual.e42_) - (anti_wedge.e12_ * right_anti_dual.e43_) - (anti_wedge.e423_ * right_anti_dual.e1_) - (anti_wedge.e431_ * right_anti_dual.e2_) - (anti_wedge.e412_ * right_anti_dual.e3_) - (anti_wedge.e321_ * right_anti_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_) + (vec4<f32>(right_anti_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group1_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_) + ((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_anti_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_anti_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group3_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_anti_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group2_.yzxw * right_anti_dual_groups.group1_.zxyw).xyz, 0.0) + vec4<f32>((right_anti_dual_groups.group2_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group2_.zxyw * right_anti_dual_groups.group1_.yzxw).xyz, 0.0) - vec4<f32>((right_anti_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn point_rejectOrthogonallyFrom_plane(self_: Point, other: Plane) -> Origin {
    return Origin(-(pow(other.e321_, 2) * self_.e4_) - (other.e423_ * other.e321_ * self_.e1_) - (other.e431_ * other.e321_ * self_.e2_) - (other.e412_ * other.e321_ * self_.e3_));
}
fn scalar_rejectOrthogonallyFrom_dualNum(self_: Scalar, other: DualNum) -> AntiScalar {
    return AntiScalar(other.scalar * other.e1234_ * self_.scalar);
}
fn scalar_rejectOrthogonallyFrom_motor(self_: Scalar, other: Motor) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_ * self_.scalar) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn scalar_rejectOrthogonallyFrom_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge: Scalar = Scalar(other.e1234_ * self_.scalar);
    let right_anti_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_anti_dual: MultiVector = multiVector_degroup(right_anti_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, right_anti_dual.e1234_ * anti_wedge.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_anti_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_anti_dual_groups.group4_).xyz, 0.0)
    ));
}
fn antiScalar_rejectViaOriginFrom_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn antiScalar_rejectViaOriginFrom_flector(self_: AntiScalar, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group0_.xyz, right_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_)) - (right_dual_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.yzxw * right_dual_groups.group0_.zxyw) - (anti_wedge_groups.group0_.zxyw * right_dual_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn antiScalar_rejectViaOriginFrom_horizon(self_: AntiScalar, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn antiScalar_rejectViaOriginFrom_line(self_: AntiScalar, other: Line) -> AntiScalar {
    let other_groups = line_grouped(other);
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_));
}
fn antiScalar_rejectViaOriginFrom_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn antiScalar_rejectViaOriginFrom_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn antiScalar_rejectViaOriginFrom_plane(self_: AntiScalar, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn antiScalar_rejectViaOriginFrom_point(self_: AntiScalar, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return AntiScalar((right_dual.e423_ * anti_wedge.e1_) + (right_dual.e431_ * anti_wedge.e2_) + (right_dual.e412_ * anti_wedge.e3_) + (right_dual.e321_ * anti_wedge.e4_));
}
fn antiScalar_rejectViaOriginFrom_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn dualNum_rejectViaOriginFrom_dualNum(self_: DualNum, other: DualNum) -> AntiScalar {
    return AntiScalar((pow(other.scalar, 2) * self_.e1234_) + (other.scalar * other.e1234_ * self_.scalar));
}
fn dualNum_rejectViaOriginFrom_flector(self_: DualNum, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group0_.xyz, right_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_)) - (right_dual_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.yzxw * right_dual_groups.group0_.zxyw) - (anti_wedge_groups.group0_.zxyw * right_dual_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn dualNum_rejectViaOriginFrom_horizon(self_: DualNum, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn dualNum_rejectViaOriginFrom_line(self_: DualNum, other: Line) -> AntiScalar {
    let other_groups = line_grouped(other);
    let anti_wedge: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
    let right_dual: Line = line_degroup(LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
    return AntiScalar(-(anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_));
}
fn dualNum_rejectViaOriginFrom_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar)) * vec4<f32>(other_groups.group1_.xyz, 1.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn dualNum_rejectViaOriginFrom_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn dualNum_rejectViaOriginFrom_plane(self_: DualNum, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.e321_, 2));
}
fn dualNum_rejectViaOriginFrom_point(self_: DualNum, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return AntiScalar((right_dual.e423_ * anti_wedge.e1_) + (right_dual.e431_ * anti_wedge.e2_) + (right_dual.e412_ * anti_wedge.e3_) + (right_dual.e321_ * anti_wedge.e4_));
}
fn dualNum_rejectViaOriginFrom_scalar(self_: DualNum, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn flector_rejectViaOriginFrom_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.yzxw * self_groups.group1_.zxyw) - (other_groups.group1_.zxyw * self_groups.group1_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ (other_groups.group1_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (self_groups.group1_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e4_ * anti_wedge.e23_) + (right_dual.e423_ * anti_wedge.scalar), (right_dual.e4_ * anti_wedge.e31_) + (right_dual.e431_ * anti_wedge.scalar), (right_dual.e4_ * anti_wedge.e12_) + (right_dual.e412_ * anti_wedge.scalar), -(right_dual.e2_ * anti_wedge.e31_) - (right_dual.e3_ * anti_wedge.e12_)) + vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, right_dual.e321_ * anti_wedge.scalar) - (right_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn flector_rejectViaOriginFrom_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0)
    ));
}
fn flector_rejectViaOriginFrom_line(self_: Flector, other: Line) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn flector_rejectViaOriginFrom_motor(self_: Flector, other: Motor) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group0_.zxyw * right_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group0_.yzxw * right_dual_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn flector_rejectViaOriginFrom_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_) - (self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), -(self_.e431_ * other.e42_) - (self_.e412_ * other.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * other_groups.group4_.yzxw) - (self_groups.group1_.yzxw * other_groups.group4_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn flector_rejectViaOriginFrom_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((self_groups.group1_.zxyw * other_groups.group0_.yzxw) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_ * other.e423_ * -1.0, self_.e321_ * other.e431_ * -1.0, self_.e321_ * other.e412_ * -1.0, (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (other_groups.group0_.wwwx * vec4<f32>(self_groups.group1_.xyz, self_.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_dual.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0)
    ));
}
fn flector_rejectViaOriginFrom_point(self_: Flector, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn horizon_rejectViaOriginFrom_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0)
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e4_ * anti_wedge.e23_) + (right_dual.e423_ * anti_wedge.scalar), (right_dual.e4_ * anti_wedge.e31_) + (right_dual.e431_ * anti_wedge.scalar), (right_dual.e4_ * anti_wedge.e12_) + (right_dual.e412_ * anti_wedge.scalar), -(right_dual.e2_ * anti_wedge.e31_) - (right_dual.e3_ * anti_wedge.e12_)) + vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, right_dual.e321_ * anti_wedge.scalar) - (right_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn horizon_rejectViaOriginFrom_line(self_: Horizon, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn horizon_rejectViaOriginFrom_motor(self_: Horizon, other: Motor) -> Plane {
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group0_.zxyw * right_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group0_.yzxw * right_dual_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn horizon_rejectViaOriginFrom_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn horizon_rejectViaOriginFrom_plane(self_: Horizon, other: Plane) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(self_.e321_ * other.e423_ * -1.0, self_.e321_ * other.e431_ * -1.0, self_.e321_ * other.e412_ * -1.0, 0.0)).xyz, 0.0)
    ));
}
fn horizon_rejectViaOriginFrom_point(self_: Horizon, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_ * other.e4_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn line_rejectViaOriginFrom_flector(self_: Line, other: Flector) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(right_dual.e4_ * anti_wedge.e1_ * -1.0, right_dual.e4_ * anti_wedge.e2_ * -1.0, right_dual.e4_ * anti_wedge.e3_ * -1.0, (right_dual.e431_ * anti_wedge.e2_) + (right_dual.e412_ * anti_wedge.e3_) + (right_dual.e321_ * anti_wedge.e4_)) + (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group0_.xyz, right_dual.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw) - (right_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn line_rejectViaOriginFrom_horizon(self_: Line, other: Horizon) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e321_ * self_.e41_, other.e321_ * self_.e42_, other.e321_ * self_.e43_, 0.0) * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_rejectViaOriginFrom_line(self_: Line, other: Line) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn line_rejectViaOriginFrom_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn line_rejectViaOriginFrom_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn line_rejectViaOriginFrom_plane(self_: Line, other: Plane) -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_) - (self_.e12_ * other.e431_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_) - (self_.e23_ * other.e412_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_) - (self_.e31_ * other.e423_), -(self_.e41_ * other.e423_) - (self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_rejectViaOriginFrom_dualNum(self_: Motor, other: DualNum) -> AntiScalar {
    return AntiScalar((pow(other.scalar, 2) * self_.e1234_) + (other.scalar * other.e1234_ * self_.scalar));
}
fn motor_rejectViaOriginFrom_flector(self_: Motor, other: Flector) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (anti_wedge_groups.group0_.wwwx * vec4<f32>(right_dual_groups.group0_.xyz, right_dual.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_)) - (right_dual_groups.group0_.wwwx * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((anti_wedge_groups.group0_.yzxw * right_dual_groups.group0_.zxyw) - (anti_wedge_groups.group0_.zxyw * right_dual_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn motor_rejectViaOriginFrom_horizon(self_: Motor, other: Horizon) -> Motor {
    let self_groups = motor_grouped(self_);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectViaOriginFrom_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge: Motor = motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_))
    ));
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_).xyz, -(right_dual.e41_ * anti_wedge.e23_) - (right_dual.e42_ * anti_wedge.e31_) - (right_dual.e43_ * anti_wedge.e12_) - (right_dual.e23_ * anti_wedge.e41_) - (right_dual.e31_ * anti_wedge.e42_) - (right_dual.e12_ * anti_wedge.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectViaOriginFrom_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, other.e1234_ * self_.e1234_), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * other_groups.group1_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectViaOriginFrom_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1234_ * other.scalar) + (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e1234_ * other.e1_) + (self_.e31_ * other.e412_), (self_.e1234_ * other.e2_) + (self_.e12_ * other.e423_), (self_.e1234_ * other.e3_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) + (self_groups.group0_ * vec4<f32>(other_groups.group4_.wwww.xyz, other.e4_)) - (other_groups.group4_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn motor_rejectViaOriginFrom_plane(self_: Motor, other: Plane) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_ * -1.0) * vec4<f32>(anti_wedge_groups.group0_.xyz, anti_wedge.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn motor_rejectViaOriginFrom_point(self_: Motor, other: Point) -> AntiScalar {
    let other_groups = point_grouped(other);
    let anti_wedge: Point = point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    ));
    let right_dual: Plane = plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    ));
    return AntiScalar((right_dual.e423_ * anti_wedge.e1_) + (right_dual.e431_ * anti_wedge.e2_) + (right_dual.e412_ * anti_wedge.e3_) + (right_dual.e321_ * anti_wedge.e4_));
}
fn motor_rejectViaOriginFrom_scalar(self_: Motor, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn multiVector_rejectViaOriginFrom_dualNum(self_: MultiVector, other: DualNum) -> AntiScalar {
    return AntiScalar((pow(other.scalar, 2) * self_.e1234_) + (other.scalar * other.e1234_ * self_.scalar));
}
fn multiVector_rejectViaOriginFrom_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (other_groups.group1_.yzxw * self_groups.group4_.zxyw) - (other_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_dual.e423_ * anti_wedge.e1_) + (right_dual.e431_ * anti_wedge.e2_) + (right_dual.e412_ * anti_wedge.e3_) + (right_dual.e321_ * anti_wedge.e4_) - (right_dual.e1_ * anti_wedge.e423_) - (right_dual.e2_ * anti_wedge.e431_) - (right_dual.e3_ * anti_wedge.e412_) - (right_dual.e4_ * anti_wedge.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ (right_dual_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw) - (right_dual_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e3_ * anti_wedge.e42_) + (right_dual.e4_ * anti_wedge.e23_), (right_dual.e1_ * anti_wedge.e43_) + (right_dual.e4_ * anti_wedge.e31_), (right_dual.e2_ * anti_wedge.e41_) + (right_dual.e4_ * anti_wedge.e12_), -(right_dual.e2_ * anti_wedge.e31_) - (right_dual.e3_ * anti_wedge.e12_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) - (right_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn multiVector_rejectViaOriginFrom_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, anti_wedge.e321_ * right_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0)
    ));
}
fn multiVector_rejectViaOriginFrom_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    let right_dual: Line = line_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(right_dual.e41_ * anti_wedge.e23_) - (right_dual.e42_ * anti_wedge.e31_) - (right_dual.e43_ * anti_wedge.e12_) - (right_dual.e23_ * anti_wedge.e41_) - (right_dual.e31_ * anti_wedge.e42_) - (right_dual.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn multiVector_rejectViaOriginFrom_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * self_.scalar) + (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1234_ * self_.e1_) + (other.e31_ * self_.e412_), (other.e1234_ * self_.e2_) + (other.e12_ * self_.e423_), (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) + (other_groups.group0_ * vec4<f32>(self_groups.group4_.wwww.xyz, self_.e4_)) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (right_dual.e1234_ * anti_wedge.scalar) + (right_dual.scalar * anti_wedge.e1234_) - (right_dual.e41_ * anti_wedge.e23_) - (right_dual.e42_ * anti_wedge.e31_) - (right_dual.e43_ * anti_wedge.e12_) - (right_dual.e23_ * anti_wedge.e41_) - (right_dual.e31_ * anti_wedge.e42_) - (right_dual.e12_ * anti_wedge.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) + ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group0_), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn multiVector_rejectViaOriginFrom_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar) + (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), -(other.e43_ * self_.e412_) - (other.e423_ * self_.e41_) - (other.e431_ * self_.e42_) - (other.e412_ * self_.e43_)) + (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e1234_) * other_groups.group1_) - (self_groups.group4_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)) - vec4<f32>((self_groups.group3_.zxyw * other_groups.group4_.yzxw).xyz, other.e42_ * self_.e431_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group4_.yzxw * self_groups.group4_.zxyw) - (other_groups.group4_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e1234_) * other_groups.group4_)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn multiVector_rejectViaOriginFrom_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual: Origin = Origin(other.e321_ * -1.0);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, anti_wedge.e321_ * right_dual.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, anti_wedge.scalar * right_dual.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0)
    ));
}
fn multiVector_rejectViaOriginFrom_point(self_: MultiVector, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: PlaneGroups = PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Plane = plane_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(anti_wedge_groups.group0_.xxzw.xy, anti_wedge.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(right_dual_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn multiVector_rejectViaOriginFrom_scalar(self_: MultiVector, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * pow(other.scalar, 2));
}
fn origin_rejectViaOriginFrom_flector(self_: Origin, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_wedge: Scalar = Scalar(other.e321_ * self_.e4_);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0)
    ));
}
fn origin_rejectViaOriginFrom_horizon(self_: Origin, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn origin_rejectViaOriginFrom_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group2_.yzxw * right_dual_groups.group1_.zxyw).xyz, 0.0) + vec4<f32>((right_dual_groups.group2_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group2_.zxyw * right_dual_groups.group1_.yzxw).xyz, 0.0) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn origin_rejectViaOriginFrom_plane(self_: Origin, other: Plane) -> Origin {
    return Origin(self_.e4_ * pow(other.e321_, 2) * -1.0);
}
fn plane_rejectViaOriginFrom_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    let anti_wedge_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_ * self_.e423_, other.e321_ * self_.e431_, other.e321_ * self_.e412_, -(other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (self_groups.group0_.wwwx * vec4<f32>(other_groups.group1_.xyz, other.e1_))
    );
    let anti_wedge: Motor = motor_degroup(anti_wedge_groups);
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    let right_dual: Flector = flector_degroup(right_dual_groups);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((right_dual.e4_ * anti_wedge.e23_) + (right_dual.e423_ * anti_wedge.scalar), (right_dual.e4_ * anti_wedge.e31_) + (right_dual.e431_ * anti_wedge.scalar), (right_dual.e4_ * anti_wedge.e12_) + (right_dual.e412_ * anti_wedge.scalar), -(right_dual.e2_ * anti_wedge.e31_) - (right_dual.e3_ * anti_wedge.e12_)) + vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, right_dual.e321_ * anti_wedge.scalar) - (right_dual_groups.group0_.yzxx * vec4<f32>(anti_wedge_groups.group0_.zxyw.xyz, anti_wedge.e23_))
    ));
}
fn plane_rejectViaOriginFrom_horizon(self_: Plane, other: Horizon) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>(other.e321_ * self_.e423_, other.e321_ * self_.e431_, other.e321_ * self_.e412_, 0.0)).xyz, 0.0)
    ));
}
fn plane_rejectViaOriginFrom_line(self_: Plane, other: Line) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_))
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_dual_groups: LineGroups = LineGroups(
        /* e41, e42, e43 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn plane_rejectViaOriginFrom_motor(self_: Plane, other: Motor) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    );
    let anti_wedge: Flector = flector_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    let right_dual: Motor = motor_degroup(right_dual_groups);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group0_.zxyw * right_dual_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group0_.yzxw * right_dual_groups.group0_.zxyw).xyz, 0.0)
    ));
}
fn plane_rejectViaOriginFrom_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((anti_wedge.e3_ * right_dual.e42_) + (anti_wedge.e4_ * right_dual.e23_) + (anti_wedge.e42_ * right_dual.e3_) + (anti_wedge.e23_ * right_dual.e4_), (anti_wedge.e1_ * right_dual.e43_) + (anti_wedge.e4_ * right_dual.e31_) + (anti_wedge.e43_ * right_dual.e1_) + (anti_wedge.e31_ * right_dual.e4_), (anti_wedge.e2_ * right_dual.e41_) + (anti_wedge.e4_ * right_dual.e12_) + (anti_wedge.e41_ * right_dual.e2_) + (anti_wedge.e12_ * right_dual.e4_), -(anti_wedge.e1_ * right_dual.e23_) - (anti_wedge.e2_ * right_dual.e31_) - (anti_wedge.e3_ * right_dual.e12_) - (anti_wedge.e12_ * right_dual.e3_)) + (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group4_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group4_) - (right_dual_groups.group1_.yzxx * vec4<f32>(anti_wedge_groups.group2_.zxyw.xyz, anti_wedge.e23_)) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, anti_wedge.e31_ * right_dual.e2_)
    ));
}
fn plane_rejectViaOriginFrom_plane(self_: Plane, other: Plane) -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_ * -1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * vec4<f32>((other.e321_ * self_.e423_) - (other.e423_ * self_.e321_), (other.e321_ * self_.e431_) - (other.e431_ * self_.e321_), (other.e321_ * self_.e412_) - (other.e412_ * self_.e321_), 0.0)).xyz, 0.0)
    ));
}
fn plane_rejectViaOriginFrom_point(self_: Plane, other: Point) -> Plane {
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    ));
}
fn point_rejectViaOriginFrom_flector(self_: Point, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    let anti_wedge: Scalar = Scalar((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_));
    let right_dual_groups: FlectorGroups = FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, 0.0)
    );
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0)
    ));
}
fn point_rejectViaOriginFrom_horizon(self_: Point, other: Horizon) -> Origin {
    return Origin(pow(other.e321_, 2) * self_.e4_ * -1.0);
}
fn point_rejectViaOriginFrom_motor(self_: Point, other: Motor) -> Plane {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    let anti_wedge_groups: PointGroups = PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    );
    let anti_wedge: Point = point_degroup(anti_wedge_groups);
    let right_dual_groups: MotorGroups = MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    );
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_).xyz, 0.0) + vec4<f32>((right_dual_groups.group0_.yzxw * anti_wedge_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((right_dual_groups.group0_.zxyw * anti_wedge_groups.group0_.yzxw).xyz, 0.0)
    ));
}
fn point_rejectViaOriginFrom_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    let anti_wedge_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    );
    let anti_wedge: MultiVector = multiVector_degroup(anti_wedge_groups);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (anti_wedge.scalar * right_dual.e1234_) + (anti_wedge.e1234_ * right_dual.scalar) + (anti_wedge.e1_ * right_dual.e423_) + (anti_wedge.e2_ * right_dual.e431_) + (anti_wedge.e3_ * right_dual.e412_) + (anti_wedge.e4_ * right_dual.e321_) - (anti_wedge.e41_ * right_dual.e23_) - (anti_wedge.e42_ * right_dual.e31_) - (anti_wedge.e43_ * right_dual.e12_) - (anti_wedge.e23_ * right_dual.e41_) - (anti_wedge.e31_ * right_dual.e42_) - (anti_wedge.e12_ * right_dual.e43_) - (anti_wedge.e423_ * right_dual.e1_) - (anti_wedge.e431_ * right_dual.e2_) - (anti_wedge.e412_ * right_dual.e3_) - (anti_wedge.e321_ * right_dual.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_) + (vec4<f32>(right_dual.scalar) * anti_wedge_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_) + ((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group1_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group2_) - ((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_) + ((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_) + (anti_wedge_groups.group1_.yzxw * right_dual_groups.group1_.zxyw) - (anti_wedge_groups.group1_.zxyw * right_dual_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(anti_wedge.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group3_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group4_).xyz, 0.0) + vec4<f32>(((vec4<f32>(right_dual.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * anti_wedge_groups.group3_).xyz, 0.0) + vec4<f32>((anti_wedge_groups.group2_.yzxw * right_dual_groups.group1_.zxyw).xyz, 0.0) + vec4<f32>((right_dual_groups.group2_.yzxw * anti_wedge_groups.group1_.zxyw).xyz, 0.0) - vec4<f32>((anti_wedge_groups.group2_.zxyw * right_dual_groups.group1_.yzxw).xyz, 0.0) - vec4<f32>((right_dual_groups.group2_.zxyw * anti_wedge_groups.group1_.yzxw).xyz, 0.0)
    ));
}
fn point_rejectViaOriginFrom_plane(self_: Point, other: Plane) -> Origin {
    return Origin(-(pow(other.e321_, 2) * self_.e4_) - (other.e423_ * other.e321_ * self_.e1_) - (other.e431_ * other.e321_ * self_.e2_) - (other.e412_ * other.e321_ * self_.e3_));
}
fn scalar_rejectViaOriginFrom_dualNum(self_: Scalar, other: DualNum) -> AntiScalar {
    return AntiScalar(other.scalar * other.e1234_ * self_.scalar);
}
fn scalar_rejectViaOriginFrom_motor(self_: Scalar, other: Motor) -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_ * self_.scalar) * vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, other.scalar), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn scalar_rejectViaOriginFrom_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    let anti_wedge: Scalar = Scalar(other.e1234_ * self_.scalar);
    let right_dual_groups: MultiVectorGroups = MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0), 
        /* e41, e42, e43 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, 0.0)
    );
    let right_dual: MultiVector = multiVector_degroup(right_dual_groups);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, right_dual.e1234_ * anti_wedge.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(anti_wedge.scalar) * right_dual_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(anti_wedge.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * right_dual_groups.group4_).xyz, 0.0)
    ));
}
fn antiScalar_reverse(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_reverse(self_: DualNum) -> DualNum {
    return self_;
}
fn flector_reverse(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn horizon_reverse(self_: Horizon) -> Horizon {
    return Horizon(self_.e321_ * -1.0);
}
fn line_reverse(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn motor_reverse(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_reverse(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn origin_reverse(self_: Origin) -> Origin {
    return self_;
}
fn plane_reverse(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_reverse(self_: Point) -> Point {
    return self_;
}
fn scalar_reverse(self_: Scalar) -> Scalar {
    return self_;
}
fn dualNum_rightAntiDual(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.scalar);
}
fn flector_rightAntiDual(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn horizon_rightAntiDual(self_: Horizon) -> Origin {
    return Origin(self_.e321_ * -1.0);
}
fn line_rightAntiDual(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_rightAntiDual(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn multiVector_rightAntiDual(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * -1.0), 
        /* e41, e42, e43 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn plane_rightAntiDual(self_: Plane) -> Origin {
    return Origin(self_.e321_ * -1.0);
}
fn point_rightAntiDual(self_: Point) -> Plane {
    let self_groups = point_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn scalar_rightAntiDual(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.scalar);
}
fn antiScalar_rightComplement(self_: AntiScalar) -> Scalar {
    return Scalar(self_.e1234_);
}
fn dualNum_rightComplement(self_: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ self_groups.group0_.yxzw
    ));
}
fn flector_rightComplement(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn horizon_rightComplement(self_: Horizon) -> Origin {
    return Origin(self_.e321_ * -1.0);
}
fn line_rightComplement(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn motor_rightComplement(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ self_groups.group0_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn multiVector_rightComplement(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_.yxzw, 
        /* e1, e2, e3, e4 */ self_groups.group4_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ self_groups.group2_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn origin_rightComplement(self_: Origin) -> Horizon {
    return Horizon(self_.e4_);
}
fn plane_rightComplement(self_: Plane) -> Point {
    let self_groups = plane_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_rightComplement(self_: Point) -> Plane {
    let self_groups = point_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn scalar_rightComplement(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.scalar);
}
fn dualNum_rightDual(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.scalar);
}
fn flector_rightDual(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn horizon_rightDual(self_: Horizon) -> Origin {
    return Origin(self_.e321_ * -1.0);
}
fn line_rightDual(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_rightDual(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group1_ * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn multiVector_rightDual(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.scalar, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * -1.0), 
        /* e41, e42, e43 */ self_groups.group3_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn plane_rightDual(self_: Plane) -> Origin {
    return Origin(self_.e321_ * -1.0);
}
fn point_rightDual(self_: Point) -> Plane {
    let self_groups = point_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn scalar_rightDual(self_: Scalar) -> AntiScalar {
    return AntiScalar(self_.scalar);
}
fn antiScalar_sandwich_flector(self_: AntiScalar, other: Flector) -> Flector {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricProduct_antiScalar(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), antiScalar_reverse(self_));
}
fn antiScalar_sandwich_line(self_: AntiScalar, other: Line) -> Line {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricProduct_antiScalar(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    )), antiScalar_reverse(self_));
}
fn antiScalar_sandwich_motor(self_: AntiScalar, other: Motor) -> Motor {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricProduct_antiScalar(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    )), antiScalar_reverse(self_));
}
fn antiScalar_sandwich_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_antiScalar(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e1234_ * other.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), antiScalar_reverse(self_));
}
fn antiScalar_sandwich_point(self_: AntiScalar, other: Point) -> Origin {
    let other_groups = point_grouped(other);
    return plane_geometricProduct_antiScalar(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), antiScalar_reverse(self_));
}
fn dualNum_sandwich_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return antiScalar_geometricProduct_dualNum(AntiScalar(other.e1234_ * self_.scalar), dualNum_reverse(self_));
}
fn dualNum_sandwich_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_geometricProduct_dualNum(dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0)
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e4_) - (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group0_.xyz, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, self_.scalar * other.e321_)
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_horizon(self_: DualNum, other: Horizon) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = horizon_grouped(other);
    return flector_geometricProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e321_)
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_line(self_: DualNum, other: Line) -> Line {
    let self_groups = dualNum_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricProduct_dualNum(line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricProduct_dualNum(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(self_.scalar) * other_groups.group0_) + (vec4<f32>(self_.e1234_) * other_groups.group1_), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_dualNum(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e4_) - (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group1_.xyz, 1.0), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, self_.scalar * other.e321_)
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_origin(self_: DualNum, other: Origin) -> Origin {
    return origin_geometricProduct_dualNum(Origin(self_.scalar * other.e4_), dualNum_reverse(self_));
}
fn dualNum_sandwich_plane(self_: DualNum, other: Plane) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e321_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_point(self_: DualNum, other: Point) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    )), dualNum_reverse(self_));
}
fn dualNum_sandwich_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_geometricProduct_dualNum(dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    )), dualNum_reverse(self_));
}
fn flector_sandwich_antiScalar(self_: Flector, other: AntiScalar) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return flector_geometricProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    )), flector_reverse(self_));
}
fn flector_sandwich_dualNum(self_: Flector, other: DualNum) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e4_) + (other.e1234_ * self_.e321_)) * vec4<f32>(self_groups.group0_.xyz, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, other.scalar * self_.e321_)
    )), flector_reverse(self_));
}
fn flector_sandwich_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)) + (other_groups.group1_.zxyz * self_groups.group0_.yzxz) + (vec4<f32>(self_groups.group0_.wwzw.xy, self_.e431_, self_.e1_) * vec4<f32>(other_groups.group0_.xyxw.xyz, other.e423_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e4_, self_.e2_) * vec4<f32>(other_groups.group0_.yzzw.xyz, other.e431_)) - (other_groups.group0_.zxyx * self_groups.group1_.yzxx) - (other_groups.group0_.wwwy * vec4<f32>(self_groups.group0_.xyz, self_.e431_)) - (vec4<f32>(self_groups.group0_.zxzw.xy, self_.e321_, self_.e321_) * vec4<f32>(other_groups.group1_.yzzw.xyz, other.e4_)) - (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e412_) * vec4<f32>(other_groups.group1_.xyxw.xyz, other.e3_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(other.e2_ * self_.e3_) - (other.e321_ * self_.e1_), -(other.e3_ * self_.e1_) - (other.e321_ * self_.e2_), -(other.e3_ * self_.e321_) - (other.e321_ * self_.e3_), (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx) - (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group0_.xyxw.xyz, other.e321_))
    )), flector_reverse(self_));
}
fn flector_sandwich_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = horizon_grouped(other);
    return motor_geometricProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    )), flector_reverse(self_));
}
fn flector_sandwich_line(self_: Flector, other: Line) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e3_ * other.e31_) + (self_.e321_ * other.e23_), (self_.e1_ * other.e12_) + (self_.e321_ * other.e31_), (self_.e2_ * other.e23_) + (self_.e321_ * other.e12_), -(self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e423_ * other.e23_) - (self_.e431_ * other.e31_) - (self_.e412_ * other.e12_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), self_.e3_ * other.e12_ * -1.0) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group1_.yzxw).xyz, self_.e2_ * other.e31_)
    )), flector_reverse(self_));
}
fn flector_sandwich_motor(self_: Flector, other: Motor) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_ * other.e23_, self_.e321_ * other.e31_, self_.e321_ * other.e12_, -(self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e423_ * other.e23_) - (self_.e431_ * other.e31_) - (self_.e412_ * other.e12_)) + (self_groups.group0_.xxyw * other_groups.group1_.wzxw) + vec4<f32>((self_groups.group0_.zyzw * other_groups.group1_.ywww).xyz, self_.e321_ * other.e1234_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_) + (self_.e423_ * other.scalar) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e2_ * other.e1234_) + (self_.e4_ * other.e31_) + (self_.e423_ * other.e12_) + (self_.e431_ * other.scalar) + (self_.e321_ * other.e42_), (self_.e3_ * other.e1234_) + (self_.e4_ * other.e12_) + (self_.e431_ * other.e23_) + (self_.e412_ * other.scalar) + (self_.e321_ * other.e43_), self_.e3_ * other.e12_ * -1.0) + vec4<f32>((self_groups.group0_.xxyw * other_groups.group0_.wzxw).xyz, self_.e321_ * other.scalar) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_)) - (other_groups.group1_.zxyy * vec4<f32>(self_groups.group1_.yzxw.xyz, self_.e2_))
    )), flector_reverse(self_));
}
fn flector_sandwich_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_flector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e4_ * other.e321_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)) - (vec4<f32>(other.e321_, other.e1_, 0.0, 0.0) * self_groups.group1_.wxzw), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e3_ * other.e31_, self_.e1_ * other.e12_, self_.e321_ * other.e12_, -(self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e423_ * other.e23_) - (self_.e431_ * other.e31_) - (self_.e412_ * other.e12_)) + (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(self_groups.group1_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group3_.xyxw.xyz, other.e1234_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (vec4<f32>(other.e2_, other.e321_, other.e321_, 0.0) * self_groups.group1_.zyzw) + (vec4<f32>(other.e321_, other.e3_, other.e1_, 0.0) * self_groups.group1_.xxyw) + (self_groups.group0_.yzxw * other_groups.group4_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (vec4<f32>(other.e4_, other.e412_, other.e423_, 0.0) * self_groups.group0_.xxyw) - (vec4<f32>(other.e431_, other.e4_, other.e4_, 0.0) * self_groups.group0_.zyzw) - (self_groups.group1_.yzxw * other_groups.group1_.zxyw), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * other_groups.group1_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - (vec4<f32>(other.e2_, other.e321_, other.e321_, 0.0) * self_groups.group0_.zyzw) - (vec4<f32>(other.e321_, other.e3_, other.e1_, 0.0) * self_groups.group0_.xxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e1_ * other.e1234_) + (self_.e3_ * other.e42_) + (self_.e4_ * other.e23_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e1_ * other.e43_) + (self_.e2_ * other.e1234_) + (self_.e4_ * other.e31_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e2_ * other.e41_) + (self_.e3_ * other.e1234_) + (self_.e4_ * other.e12_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), self_.e3_ * other.e12_ * -1.0) + (vec4<f32>(other.scalar) * self_groups.group1_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_)) - vec4<f32>((other_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, self_.e2_ * other.e31_)
    )), flector_reverse(self_));
}
fn flector_sandwich_origin(self_: Flector, other: Origin) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = origin_grouped(other);
    return motor_geometricProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    )), flector_reverse(self_));
}
fn flector_sandwich_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(self_.e3_ * other.e431_) - (self_.e321_ * other.e423_), -(self_.e1_ * other.e412_) - (self_.e321_ * other.e431_), -(self_.e2_ * other.e423_) - (self_.e321_ * other.e412_), (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (self_groups.group0_.yzxx * other_groups.group0_.zxyx) + (other_groups.group0_.wwwy * vec4<f32>(self_groups.group1_.xyz, self_.e2_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    )), flector_reverse(self_));
}
fn flector_sandwich_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e4_ * other.e1_) + (self_.e412_ * other.e2_), (self_.e4_ * other.e2_) + (self_.e423_ * other.e3_), (self_.e4_ * other.e3_) + (self_.e431_ * other.e1_), -(self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group1_.yzxy * other_groups.group0_.zxyy) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(self_.e3_ * other.e2_) - (self_.e321_ * other.e1_), -(self_.e1_ * other.e3_) - (self_.e321_ * other.e2_), -(self_.e2_ * other.e1_) - (self_.e321_ * other.e3_), (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_)) + (self_groups.group0_.yzxx * other_groups.group0_.zxyx)
    )), flector_reverse(self_));
}
fn flector_sandwich_scalar(self_: Flector, other: Scalar) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = scalar_grouped(other);
    return flector_geometricProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    )), flector_reverse(self_));
}
fn horizon_sandwich_antiScalar(self_: Horizon, other: AntiScalar) -> AntiScalar {
    return origin_geometricProduct_horizon(Origin(other.e1234_ * self_.e321_), horizon_reverse(self_));
}
fn horizon_sandwich_dualNum(self_: Horizon, other: DualNum) -> Motor {
    let self_groups = horizon_grouped(self_);
    return flector_geometricProduct_horizon(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e321_)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_flector(self_: Horizon, other: Flector) -> Flector {
    let self_groups = horizon_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricProduct_horizon(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group0_.xyz, other.e321_) * vec4<f32>(-1.0)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return scalar_geometricProduct_horizon(Scalar(other.e321_ * self_.e321_ * -1.0), horizon_reverse(self_));
}
fn horizon_sandwich_line(self_: Horizon, other: Line) -> Motor {
    let self_groups = horizon_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricProduct_horizon(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_motor(self_: Horizon, other: Motor) -> Motor {
    let self_groups = horizon_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricProduct_horizon(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e1234_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group0_.xyz, other.scalar)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let self_groups = horizon_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_horizon(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e321_, other.e4_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group3_.xyz, other.e1234_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group2_.xyz, other.scalar)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_origin(self_: Horizon, other: Origin) -> Origin {
    return antiScalar_geometricProduct_horizon(AntiScalar(self_.e321_ * other.e4_ * -1.0), horizon_reverse(self_));
}
fn horizon_sandwich_plane(self_: Horizon, other: Plane) -> Flector {
    let self_groups = horizon_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricProduct_horizon(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e321_ * -1.0)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_point(self_: Horizon, other: Point) -> Flector {
    let self_groups = horizon_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricProduct_horizon(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), horizon_reverse(self_));
}
fn horizon_sandwich_scalar(self_: Horizon, other: Scalar) -> Scalar {
    return horizon_geometricProduct_horizon(Horizon(self_.e321_ * other.scalar), horizon_reverse(self_));
}
fn line_sandwich_antiScalar(self_: Line, other: AntiScalar) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return line_geometricProduct_line(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    )), line_reverse(self_));
}
fn line_sandwich_dualNum(self_: Line, other: DualNum) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return line_geometricProduct_line(line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    )), line_reverse(self_));
}
fn line_sandwich_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e3_ * self_.e43_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group0_.zxyw).xyz, other.e423_ * self_.e23_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e431_ * self_.e12_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e412_ * self_.e23_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e423_ * self_.e31_), 0.0) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group1_.zxyw).xyz, other.e3_ * self_.e12_)
    )), line_reverse(self_));
}
fn line_sandwich_horizon(self_: Line, other: Horizon) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = horizon_grouped(other);
    return flector_geometricProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), line_reverse(self_));
}
fn line_sandwich_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_geometricProduct_line(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e42_ * self_.e12_) + (other.e31_ * self_.e43_), (other.e43_ * self_.e23_) + (other.e12_ * self_.e41_), (other.e41_ * self_.e31_) + (other.e23_ * self_.e42_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - vec4<f32>((other_groups.group0_.zxyw * self_groups.group1_.yzxw).xyz, other.e41_ * self_.e23_) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, other.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e31_ * self_.e12_, other.e12_ * self_.e23_, other.e23_ * self_.e31_, -(other.e31_ * self_.e31_) - (other.e12_ * self_.e12_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group1_.yzxw).xyz, other.e23_ * self_.e23_)
    )), line_reverse(self_));
}
fn line_sandwich_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricProduct_line(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e41_ * other.scalar) + (self_.e43_ * other.e31_) + (self_.e23_ * other.e1234_) + (self_.e12_ * other.e42_), (self_.e41_ * other.e12_) + (self_.e42_ * other.scalar) + (self_.e23_ * other.e43_) + (self_.e31_ * other.e1234_), (self_.e42_ * other.e23_) + (self_.e43_ * other.scalar) + (self_.e31_ * other.e41_) + (self_.e12_ * other.e1234_), -(self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)) - (other_groups.group1_.zxyx * vec4<f32>(self_groups.group0_.yzxw.xyz, self_.e41_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group0_.zxyw).xyz, self_.e42_ * other.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e23_ * other.scalar) + (self_.e12_ * other.e31_), (self_.e23_ * other.e12_) + (self_.e31_ * other.scalar), (self_.e31_ * other.e23_) + (self_.e12_ * other.scalar), -(self_.e31_ * other.e31_) - (self_.e12_ * other.e12_)) - (other_groups.group1_.zxyx * vec4<f32>(self_groups.group1_.yzxw.xyz, self_.e23_))
    )), line_reverse(self_));
}
fn line_sandwich_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_line(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0) - ((vec4<f32>(other.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e43_ * other.e3_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group1_.zxyw).xyz, self_.e23_ * other.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.zxyw * other_groups.group3_.yzxw) + (self_groups.group1_.zxyw * other_groups.group2_.yzxw) - (self_groups.group0_.yzxw * other_groups.group3_.zxyw) - (self_groups.group1_.yzxw * other_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group1_.zxyw * other_groups.group3_.yzxw) - (self_groups.group1_.yzxw * other_groups.group3_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_) + (self_.e12_ * other.e431_), (self_.e43_ * other.e1_) + (self_.e23_ * other.e412_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e31_ * other.e423_) + (self_.e12_ * other.e4_), 0.0) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group4_.zxyw).xyz, self_.e12_ * other.e3_)
    )), line_reverse(self_));
}
fn line_sandwich_origin(self_: Line, other: Origin) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = origin_grouped(other);
    return plane_geometricProduct_line(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    )), line_reverse(self_));
}
fn line_sandwich_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_groups.group1_.zxyw * other_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group0_.zxyw).xyz, 0.0)
    )), line_reverse(self_));
}
fn line_sandwich_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * other.e3_ * -1.0, self_.e12_ * other.e1_ * -1.0, self_.e23_ * other.e2_ * -1.0, (self_.e42_ * other.e2_) + (self_.e43_ * other.e3_)) + (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    )), line_reverse(self_));
}
fn line_sandwich_scalar(self_: Line, other: Scalar) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = scalar_grouped(other);
    return line_geometricProduct_line(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    )), line_reverse(self_));
}
fn motor_sandwich_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return motor_geometricProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group1_, 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    )), motor_reverse(self_));
}
fn motor_sandwich_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return motor_geometricProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(other.e1234_) * self_groups.group1_), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    )), motor_reverse(self_));
}
fn motor_sandwich_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ (other_groups.group0_.xyxx * vec4<f32>(self_groups.group1_.wwyw.xyz, self_.e41_)) + (other_groups.group0_.yzzy * vec4<f32>(self_groups.group1_.zxww.xyz, self_.e42_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e4_ * self_.scalar) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_) - (other.e321_ * self_.e1234_)) + vec4<f32>((other_groups.group1_.wwww * self_groups.group1_).xyz, other.e3_ * self_.e43_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e423_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e23_) + (other.e423_ * self_.scalar) + (other.e431_ * self_.e12_) - (other.e321_ * self_.e41_), (other.e4_ * self_.e31_) + (other.e431_ * self_.scalar) + (other.e412_ * self_.e23_) - (other.e321_ * self_.e42_), (other.e4_ * self_.e12_) + (other.e423_ * self_.e31_) + (other.e412_ * self_.scalar) - (other.e321_ * self_.e43_), 0.0) + vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, other.e321_ * self_.scalar) - (other_groups.group0_.xyxx * vec4<f32>(self_groups.group0_.wwyw.xyz, self_.e23_)) - (other_groups.group0_.yzzy * vec4<f32>(self_groups.group0_.zxww.xyz, self_.e31_)) - (self_groups.group1_.yzxz * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e3_))
    )), motor_reverse(self_));
}
fn motor_sandwich_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = horizon_grouped(other);
    return flector_geometricProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    )), motor_reverse(self_));
}
fn motor_sandwich_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_geometricProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e41_ * self_.scalar) + (other.e42_ * self_.e12_) + (other.e23_ * self_.e1234_) + (other.e31_ * self_.e43_), (other.e42_ * self_.scalar) + (other.e43_ * self_.e23_) + (other.e31_ * self_.e1234_) + (other.e12_ * self_.e41_), (other.e41_ * self_.e31_) + (other.e43_ * self_.scalar) + (other.e23_ * self_.e42_) + (other.e12_ * self_.e1234_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e41_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, other.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e23_ * self_.scalar) + (other.e31_ * self_.e12_), (other.e31_ * self_.scalar) + (other.e12_ * self_.e23_), (other.e23_ * self_.e31_) + (other.e12_ * self_.scalar), -(other.e31_ * self_.e31_) - (other.e12_ * self_.e12_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e23_))
    )), motor_reverse(self_));
}
fn motor_sandwich_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e1234_ * self_.e23_) + (other.e23_ * self_.e1234_) + (other.e31_ * self_.e43_) + (other.scalar * self_.e41_), (other.e1234_ * self_.e31_) + (other.e31_ * self_.e1234_) + (other.e12_ * self_.e41_) + (other.scalar * self_.e42_), (other.e1234_ * self_.e12_) + (other.e23_ * self_.e42_) + (other.e12_ * self_.e1234_) + (other.scalar * self_.e43_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) + (other_groups.group0_.xyxw * self_groups.group1_.wwyw) + vec4<f32>((other_groups.group0_.yzzw * self_groups.group1_.zxww).xyz, other.scalar * self_.e1234_) - (other_groups.group0_.zxyx * self_groups.group1_.yzxx) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, other.e42_ * self_.e31_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e31_ * self_.e12_) + (other.scalar * self_.e23_), (other.e12_ * self_.e23_) + (other.scalar * self_.e31_), (other.e12_ * self_.scalar) + (other.scalar * self_.e12_), -(other.e31_ * self_.e31_) - (other.e12_ * self_.e12_)) + (other_groups.group1_.xyxw * self_groups.group1_.wwyw) - (other_groups.group1_.zxyx * self_groups.group1_.yzxx)
    )), motor_reverse(self_));
}
fn motor_sandwich_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_motor(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_), 0.0, 0.0) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group1_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group1_.xxyw.xyz, self_.e41_)) + (other_groups.group1_.xyzz * vec4<f32>(self_groups.group1_.wwww.xyz, self_.e43_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.scalar * other.e4_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - vec4<f32>((self_groups.group1_.yzxw * other_groups.group1_.zxyw).xyz, self_.e1234_ * other.e321_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (other_groups.group2_.xyxw * self_groups.group1_.wwyw) + (other_groups.group2_.yzzw * self_groups.group1_.zxww) + (other_groups.group3_.xyxw * self_groups.group0_.wwyw) + (other_groups.group3_.yzzw * self_groups.group0_.zxww) - (other_groups.group2_.zxyw * self_groups.group1_.yzxw) - (other_groups.group3_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (other_groups.group3_.xyxw * self_groups.group1_.wwyw) + (other_groups.group3_.yzzw * self_groups.group1_.zxww) - (other_groups.group3_.zxyw * self_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * other.e4_) + (self_.e12_ * other.e431_) + (self_.scalar * other.e423_) - (self_.e31_ * other.e412_), (self_.e23_ * other.e412_) + (self_.e31_ * other.e4_) + (self_.scalar * other.e431_) - (self_.e12_ * other.e423_), (self_.e31_ * other.e423_) + (self_.e12_ * other.e4_) + (self_.scalar * other.e412_) - (self_.e23_ * other.e431_), 0.0) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group1_.zxyw).xyz, self_.scalar * other.e321_) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group0_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group0_.xxyw.xyz, self_.e23_)) - (other_groups.group1_.xyzz * vec4<f32>(self_groups.group0_.wwww.xyz, self_.e12_))
    )), motor_reverse(self_));
}
fn motor_sandwich_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = origin_grouped(other);
    return flector_geometricProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    )), motor_reverse(self_));
}
fn motor_sandwich_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, -(self_.e1234_ * other.e321_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group1_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw)).xyz, self_.scalar * other.e321_)
    )), motor_reverse(self_));
}
fn motor_sandwich_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * other.e3_ * -1.0, self_.e12_ * other.e1_ * -1.0, self_.e23_ * other.e2_ * -1.0, (self_.e43_ * other.e3_) + (self_.scalar * other.e4_)) + (other_groups.group0_.xyzy * vec4<f32>(self_groups.group1_.wwww.xyz, self_.e42_)) + (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), self_.e12_ * other.e3_ * -1.0) - (other_groups.group0_.xyzy * vec4<f32>(self_groups.group0_.wwww.xyz, self_.e31_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    )), motor_reverse(self_));
}
fn motor_sandwich_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = scalar_grouped(other);
    return motor_geometricProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    )), motor_reverse(self_));
}
fn multiVector_sandwich_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_ * self_.scalar, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e4_) + (other.e1234_ * self_.e321_)) * vec4<f32>(self_groups.group1_.xyz, 1.0), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)).xyz, other.scalar * self_.e321_)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)) - (vec4<f32>(other.e321_, other.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(self_.scalar) * other_groups.group0_) + (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e42_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e41_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((self_groups.group3_.yzxw * other_groups.group0_.zxyw).xyz, other.e321_ * self_.e1234_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e4_, self_.e431_, 0.0) * other_groups.group0_.xyxw) + (vec4<f32>(self_.e412_, self_.e423_, self_.e4_, 0.0) * other_groups.group0_.yzzw) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group1_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group1_.xyxw) - (other_groups.group0_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group0_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group0_.xyxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e431_ * self_.e12_) - (other.e412_ * self_.e31_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e412_ * self_.e23_) - (other.e423_ * self_.e12_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e423_ * self_.e31_) - (other.e431_ * self_.e23_), 0.0) + (vec4<f32>(self_.scalar) * other_groups.group1_) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e3_) * vec4<f32>(self_groups.group2_.zyzw.xyz, self_.e12_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e2_) * vec4<f32>(self_groups.group2_.xxyw.xyz, self_.e31_)) - (other_groups.group0_.xyzx * vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.e23_))
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = horizon_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e321_, self_.e4_, 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group3_.xyz, self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e41, e42, e43 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group2_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e23_ * self_.e321_) + (other.e31_ * self_.e3_), (other.e31_ * self_.e321_) + (other.e12_ * self_.e1_), (other.e23_ * self_.e2_) + (other.e12_ * self_.e321_), -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group0_.yzxw * self_groups.group3_.zxyw) + (other_groups.group1_.yzxw * self_groups.group2_.zxyw) - (other_groups.group0_.zxyw * self_groups.group3_.yzxw) - (other_groups.group1_.zxyw * self_groups.group2_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group1_.yzxw * self_groups.group3_.zxyw) - (other_groups.group1_.zxyw * self_groups.group3_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_) + (other.e12_ * self_.e423_), (other.e41_ * self_.e2_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e12_ * self_.e4_), other.e12_ * self_.e3_ * -1.0) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_)) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group4_.yzxw).xyz, other.e31_ * self_.e2_)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_), 0.0, 0.0) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0)) - ((vec4<f32>(other.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar * self_.e1_, other.scalar * self_.e2_, other.scalar * self_.e3_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)) + (other_groups.group1_.yzzw * vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, self_.e4_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group1_.xyxw.xyz, other.e1234_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (self_groups.group2_.xxyw * other_groups.group1_.wzxw) + (self_groups.group2_.zyzw * other_groups.group1_.ywww) + (self_groups.group3_.xxyw * other_groups.group0_.wzxw) + (self_groups.group3_.zyzw * other_groups.group0_.ywww) - (self_groups.group2_.yzxw * other_groups.group1_.zxyw) - (self_groups.group3_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (self_groups.group3_.xxyw * other_groups.group1_.wzxw) + (self_groups.group3_.zyzw * other_groups.group1_.ywww) - (self_groups.group3_.yzxw * other_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e1234_ * self_.e1_) + (other.e23_ * self_.e4_) + (other.e31_ * self_.e412_) + (other.scalar * self_.e423_), (other.e43_ * self_.e1_) + (other.e1234_ * self_.e2_) + (other.e31_ * self_.e4_) + (other.e12_ * self_.e423_) + (other.scalar * self_.e431_), (other.e43_ * self_.e321_) + (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_) + (other.e12_ * self_.e4_) + (other.scalar * self_.e412_), other.e12_ * self_.e3_ * -1.0) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, self_.e321_) * vec4<f32>(other_groups.group0_.xyxw.xyz, other.scalar)) - (other_groups.group1_.zxyy * vec4<f32>(self_groups.group4_.yzxw.xyz, self_.e2_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e1234_ * self_.scalar) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)) - ((vec4<f32>(self_.e23_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e31_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e12_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)) - (vec4<f32>(other.e321_, other.e1_, 0.0, 0.0) * self_groups.group4_.wxzw), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.scalar) * self_groups.group1_) + (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e3_) * vec4<f32>(self_groups.group3_.zyzw.xyz, self_.e43_)) + (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e2_) * vec4<f32>(self_groups.group3_.xxyw.xyz, self_.e42_)) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, other.e1234_) * vec4<f32>(other_groups.group1_.xyz, self_.e321_)) + (vec4<f32>(self_groups.group1_.zxzw.xy, self_.e321_, other.e1_) * vec4<f32>(other_groups.group3_.yzzw.xyz, self_.e41_)) + (vec4<f32>(self_groups.group4_.wwzw.xy, self_.e2_, other.e4_) * vec4<f32>(other_groups.group3_.xyxw.xyz, self_.scalar)) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((other_groups.group3_.zxyw * self_groups.group1_.yzxw).xyz, other.e321_ * self_.e1234_) - vec4<f32>((self_groups.group3_.yzxw * other_groups.group1_.zxyw).xyz, other.e41_ * self_.e1_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (vec4<f32>(self_.e4_, self_.e4_, self_.e431_, 0.0) * other_groups.group1_.xyxw) + (vec4<f32>(self_.e412_, self_.e423_, self_.e4_, 0.0) * other_groups.group1_.yzzw) + (other_groups.group2_.yzxw * self_groups.group3_.zxyw) + (other_groups.group3_.yzxw * self_groups.group2_.zxyw) + (other_groups.group4_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group4_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group4_.xyxw) - (other_groups.group2_.zxyw * self_groups.group3_.yzxw) - (other_groups.group3_.zxyw * self_groups.group2_.yzxw) - (other_groups.group1_.zxyw * self_groups.group4_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (other_groups.group3_.yzxw * self_groups.group3_.zxyw) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e3_, self_.e1_, self_.e321_, 0.0) * other_groups.group1_.yzzw) - (vec4<f32>(self_.e321_, self_.e321_, self_.e2_, 0.0) * other_groups.group1_.xyxw) - (other_groups.group3_.zxyw * self_groups.group3_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e41_ * self_.e321_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_) + (other.e31_ * self_.e412_) + (other.e423_ * self_.scalar) + (other.e431_ * self_.e12_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e42_ * self_.e321_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_) + (other.e12_ * self_.e423_) + (other.e431_ * self_.scalar) + (other.e412_ * self_.e23_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e41_ * self_.e2_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e12_ * self_.e4_) + (other.e423_ * self_.e31_) + (other.e412_ * self_.scalar), 0.0) + (vec4<f32>(other.scalar) * self_groups.group4_) + (vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, self_.scalar) * vec4<f32>(self_groups.group1_.xyz, other.e321_)) - (vec4<f32>(other.e2_, other.e321_, other.e321_, other.e2_) * vec4<f32>(self_groups.group2_.zyzw.xyz, self_.e31_)) - (vec4<f32>(other.e321_, other.e3_, other.e1_, other.e1_) * vec4<f32>(self_groups.group2_.xxyw.xyz, self_.e23_)) - (self_groups.group1_.yzxy * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e31_)) - (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, other.e23_) * vec4<f32>(other_groups.group1_.xyz, self_.e1_)) - vec4<f32>((other_groups.group3_.zxyw * self_groups.group4_.yzxw).xyz, other.e12_ * self_.e3_) - vec4<f32>((self_groups.group3_.yzxw * other_groups.group4_.zxyw).xyz, other.e3_ * self_.e12_)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = origin_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * other.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e321_, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, -(self_.e1234_ * other.e321_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group3_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) - (self_groups.group3_.yzxw * other_groups.group0_.zxyw)).xyz, self_.scalar * other.e321_)
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e1_ * other.e1_) + (self_.e2_ * other.e2_) + (self_.e3_ * other.e3_), -(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e31_ * other.e3_ * -1.0, self_.e12_ * other.e1_ * -1.0, self_.e23_ * other.e2_ * -1.0, (self_.e42_ * other.e2_) + (self_.e43_ * other.e3_)) + (vec4<f32>(self_.scalar) * other_groups.group0_) + (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), self_.e12_ * other.e3_ * -1.0) - (other_groups.group0_.xyzx * vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.e23_)) - (other_groups.group0_.yzxy * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e31_))
    )), multiVector_reverse(self_));
}
fn multiVector_sandwich_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = scalar_grouped(other);
    return multiVector_geometricProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    )), multiVector_reverse(self_));
}
fn origin_sandwich_flector(self_: Origin, other: Flector) -> Flector {
    let self_groups = origin_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricProduct_origin(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    )), origin_reverse(self_));
}
fn origin_sandwich_line(self_: Origin, other: Line) -> AntiScalar {
    let other_groups = line_grouped(other);
    return plane_geometricProduct_origin(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    )), origin_reverse(self_));
}
fn origin_sandwich_motor(self_: Origin, other: Motor) -> Motor {
    let self_groups = origin_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricProduct_origin(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    )), origin_reverse(self_));
}
fn origin_sandwich_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let self_groups = origin_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_origin(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    )), origin_reverse(self_));
}
fn origin_sandwich_point(self_: Origin, other: Point) -> Plane {
    let self_groups = origin_grouped(self_);
    let other_groups = point_grouped(other);
    return line_geometricProduct_origin(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    )), origin_reverse(self_));
}
fn plane_sandwich_antiScalar(self_: Plane, other: AntiScalar) -> AntiScalar {
    let self_groups = plane_grouped(self_);
    return origin_geometricProduct_plane(Origin(other.e1234_ * self_.e321_), plane_reverse(self_));
}
fn plane_sandwich_dualNum(self_: Plane, other: DualNum) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricProduct_plane(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e321_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    )), plane_reverse(self_));
}
fn plane_sandwich_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e2_ * self_.e412_) + (other.e321_ * self_.e423_), (other.e3_ * self_.e423_) + (other.e321_ * self_.e431_), (other.e1_ * self_.e431_) + (other.e321_ * self_.e412_), -(other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.zxyx * self_groups.group0_.yzxx) - (self_groups.group0_.wwwy * vec4<f32>(other_groups.group1_.xyz, other.e2_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group0_.xyz, other.e321_) * vec4<f32>(-1.0)
    )), plane_reverse(self_));
}
fn plane_sandwich_horizon(self_: Plane, other: Horizon) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = horizon_grouped(other);
    return motor_geometricProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e321_ * -1.0)
    )), plane_reverse(self_));
}
fn plane_sandwich_line(self_: Plane, other: Line) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricProduct_plane(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, -(other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0) + vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((other_groups.group1_.zxyw * self_groups.group0_.yzxw).xyz, 0.0)
    )), plane_reverse(self_));
}
fn plane_sandwich_motor(self_: Plane, other: Motor) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricProduct_plane(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, (other.e1234_ * self_.e321_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw)).xyz, other.scalar * self_.e321_)
    )), plane_reverse(self_));
}
fn plane_sandwich_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_plane(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e321_, -(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, (other.e1234_ * self_.e321_) - (other.e23_ * self_.e423_) - (other.e31_ * self_.e431_) - (other.e12_ * self_.e412_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group1_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (other_groups.group1_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group3_.yzxw * self_groups.group0_.zxyw) - (other_groups.group3_.zxyw * self_groups.group0_.yzxw)).xyz, other.scalar * self_.e321_)
    )), plane_reverse(self_));
}
fn plane_sandwich_origin(self_: Plane, other: Origin) -> Origin {
    let self_groups = plane_grouped(self_);
    return antiScalar_geometricProduct_plane(AntiScalar(other.e4_ * self_.e321_ * -1.0), plane_reverse(self_));
}
fn plane_sandwich_plane(self_: Plane, other: Plane) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e321_ * -1.0)
    )), plane_reverse(self_));
}
fn plane_sandwich_point(self_: Plane, other: Point) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e412_ * other.e2_, self_.e423_ * other.e3_, self_.e431_ * other.e1_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group0_.yzxx * other_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    )), plane_reverse(self_));
}
fn plane_sandwich_scalar(self_: Plane, other: Scalar) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = scalar_grouped(other);
    return plane_geometricProduct_plane(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    )), plane_reverse(self_));
}
fn point_sandwich_antiScalar(self_: Point, other: AntiScalar) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return plane_geometricProduct_point(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    )), point_reverse(self_));
}
fn point_sandwich_dualNum(self_: Point, other: DualNum) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricProduct_point(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    )), point_reverse(self_));
}
fn point_sandwich_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(other.e4_ * self_.e1_) - (other.e431_ * self_.e3_), -(other.e4_ * self_.e2_) - (other.e412_ * self_.e1_), -(other.e4_ * self_.e3_) - (other.e423_ * self_.e2_), (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group1_.zxyy * self_groups.group0_.yzxy) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(other.e2_ * self_.e3_) - (other.e321_ * self_.e1_), -(other.e3_ * self_.e1_) - (other.e321_ * self_.e2_), -(other.e1_ * self_.e2_) - (other.e321_ * self_.e3_), (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx)
    )), point_reverse(self_));
}
fn point_sandwich_horizon(self_: Point, other: Horizon) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = horizon_grouped(other);
    return motor_geometricProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e4_), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), point_reverse(self_));
}
fn point_sandwich_line(self_: Point, other: Line) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricProduct_point(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e31_ * self_.e3_, other.e12_ * self_.e1_, other.e23_ * self_.e2_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    )), point_reverse(self_));
}
fn point_sandwich_motor(self_: Point, other: Motor) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricProduct_point(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar * self_.e1_, other.scalar * self_.e2_, other.scalar * self_.e3_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) + (other_groups.group1_.yzxw * self_groups.group0_.zxyw) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e1234_ * self_.e1_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e1234_ * self_.e2_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e1234_ * self_.e3_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    )), point_reverse(self_));
}
fn point_sandwich_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_point(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e321_ * self_.e4_, 0.0, 0.0) + ((vec4<f32>(self_.e1_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e1_, other.e423_, 0.0, 0.0)) + ((vec4<f32>(self_.e2_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e2_, other.e431_, 0.0, 0.0)) + ((vec4<f32>(self_.e3_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e3_, other.e412_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e31_ * self_.e3_, other.e12_ * self_.e1_, other.e23_ * self_.e2_, -(other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) + (vec4<f32>(other.scalar) * self_groups.group0_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e41_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group4_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group4_.yzxw * self_groups.group0_.zxyw), 
        /* e23, e31, e12 */ (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e1234_ * self_.e1_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e1234_ * self_.e2_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e1234_ * self_.e3_) + (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    )), point_reverse(self_));
}
fn point_sandwich_origin(self_: Point, other: Origin) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = origin_grouped(other);
    return line_geometricProduct_point(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    )), point_reverse(self_));
}
fn point_sandwich_plane(self_: Point, other: Plane) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e431_ * self_.e3_ * -1.0, other.e412_ * self_.e1_ * -1.0, other.e423_ * self_.e2_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0)
    )), point_reverse(self_));
}
fn point_sandwich_point(self_: Point, other: Point) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e2_ * self_.e3_ * -1.0, other.e3_ * self_.e1_ * -1.0, other.e1_ * self_.e2_ * -1.0, (other.e2_ * self_.e2_) + (other.e3_ * self_.e3_)) + (other_groups.group0_.zxyx * self_groups.group0_.yzxx)
    )), point_reverse(self_));
}
fn point_sandwich_scalar(self_: Point, other: Scalar) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = scalar_grouped(other);
    return point_geometricProduct_point(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_
    )), point_reverse(self_));
}
fn scalar_sandwich_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return antiScalar_geometricProduct_scalar(AntiScalar(other.e1234_ * self_.scalar), scalar_reverse(self_));
}
fn scalar_sandwich_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let self_groups = scalar_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return dualNum_geometricProduct_scalar(dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_flector(self_: Scalar, other: Flector) -> Flector {
    let self_groups = scalar_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricProduct_scalar(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return horizon_geometricProduct_scalar(Horizon(other.e321_ * self_.scalar), scalar_reverse(self_));
}
fn scalar_sandwich_line(self_: Scalar, other: Line) -> Line {
    let self_groups = scalar_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricProduct_scalar(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_motor(self_: Scalar, other: Motor) -> Motor {
    let self_groups = scalar_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricProduct_scalar(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let self_groups = scalar_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricProduct_scalar(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_origin(self_: Scalar, other: Origin) -> Origin {
    return origin_geometricProduct_scalar(Origin(other.e4_ * self_.scalar), scalar_reverse(self_));
}
fn scalar_sandwich_plane(self_: Scalar, other: Plane) -> Plane {
    let self_groups = scalar_grouped(self_);
    let other_groups = plane_grouped(other);
    return plane_geometricProduct_scalar(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_point(self_: Scalar, other: Point) -> Point {
    let self_groups = scalar_grouped(self_);
    let other_groups = point_grouped(other);
    return point_geometricProduct_scalar(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    )), scalar_reverse(self_));
}
fn scalar_sandwich_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return scalar_geometricProduct_scalar(Scalar(other.scalar * self_.scalar), scalar_reverse(self_));
}
fn scalar_squareRoot(self_: Scalar) -> Scalar {
    return Scalar(pow(self_.scalar, 0.5));
}
fn antiScalar_sub_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ - other.e1234_);
}
fn antiScalar_sub_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, self_.e1234_ - other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0, 1.0)
    ));
}
fn antiScalar_sub_flector(self_: AntiScalar, other: Flector) -> MultiVector {
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn antiScalar_sub_horizon(self_: AntiScalar, other: Horizon) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn antiScalar_sub_line(self_: AntiScalar, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((other_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0)
    ));
}
fn antiScalar_sub_motor(self_: AntiScalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_ - other.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn antiScalar_sub_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, self_.e1234_ - other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0, 1.0), 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn antiScalar_sub_origin(self_: AntiScalar, other: Origin) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_sub_plane(self_: AntiScalar, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn antiScalar_sub_point(self_: AntiScalar, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn antiScalar_sub_scalar(self_: AntiScalar, other: Scalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, self_.e1234_, 0.0, 0.0) * vec4<f32>(-1.0, 1.0)
    ));
}
fn dualNum_sub_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_ * -1.0, 0.0, 0.0) + self_groups.group0_
    ));
}
fn dualNum_sub_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ self_groups.group0_ - other_groups.group0_
    ));
}
fn dualNum_sub_flector(self_: DualNum, other: Flector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn dualNum_sub_horizon(self_: DualNum, other: Horizon) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn dualNum_sub_line(self_: DualNum, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn dualNum_sub_motor(self_: DualNum, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xyz, self_.e1234_ - other.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar - other.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn dualNum_sub_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_ - other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn dualNum_sub_origin(self_: DualNum, other: Origin) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_sub_plane(self_: DualNum, other: Plane) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn dualNum_sub_point(self_: DualNum, other: Point) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn dualNum_sub_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * -1.0, 0.0, 0.0, 0.0) + self_groups.group0_
    ));
}
fn flector_sub_antiScalar(self_: Flector, other: AntiScalar) -> MultiVector {
    let self_groups = flector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_sub_dualNum(self_: Flector, other: DualNum) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_sub_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ - other_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ - other_groups.group1_
    ));
}
fn flector_sub_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn flector_sub_line(self_: Flector, other: Line) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_sub_motor(self_: Flector, other: Motor) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_sub_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_ - other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_ - other_groups.group4_
    ));
}
fn flector_sub_origin(self_: Flector, other: Origin) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_sub_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_ - other_groups.group0_
    ));
}
fn flector_sub_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ - other_groups.group0_, 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn flector_sub_scalar(self_: Flector, other: Scalar) -> MultiVector {
    let self_groups = flector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group1_
    ));
}
fn horizon_sub_antiScalar(self_: Horizon, other: AntiScalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_sub_dualNum(self_: Horizon, other: DualNum) -> MultiVector {
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_sub_flector(self_: Horizon, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group1_.xyz, self_.e321_ - other.e321_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn horizon_sub_horizon(self_: Horizon, other: Horizon) -> Horizon {
    return Horizon(self_.e321_ - other.e321_);
}
fn horizon_sub_line(self_: Horizon, other: Line) -> MultiVector {
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_sub_motor(self_: Horizon, other: Motor) -> MultiVector {
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_sub_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group4_.xyz, self_.e321_ - other.e321_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn horizon_sub_origin(self_: Horizon, other: Origin) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_sub_plane(self_: Horizon, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.xyz, self_.e321_ - other.e321_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn horizon_sub_point(self_: Horizon, other: Point) -> Flector {
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn horizon_sub_scalar(self_: Horizon, other: Scalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_)
    ));
}
fn line_sub_antiScalar(self_: Line, other: AntiScalar) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, other.e1234_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn line_sub_dualNum(self_: Line, other: DualNum) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, other.e1234_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, other.scalar * -1.0)
    ));
}
fn line_sub_flector(self_: Line, other: Flector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn line_sub_horizon(self_: Line, other: Horizon) -> MultiVector {
    let self_groups = line_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn line_sub_line(self_: Line, other: Line) -> Line {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_ - other_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_ - other_groups.group1_
    ));
}
fn line_sub_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_groups.group0_ - other_groups.group0_).xyz, other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_groups.group1_ - other_groups.group1_).xyz, other.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    ));
}
fn line_sub_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group0_ - other_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group1_ - other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn line_sub_origin(self_: Line, other: Origin) -> MultiVector {
    let self_groups = line_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn line_sub_plane(self_: Line, other: Plane) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn line_sub_point(self_: Line, other: Point) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn line_sub_scalar(self_: Line, other: Scalar) -> Motor {
    let self_groups = line_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_groups.group1_.xyz, other.scalar * -1.0)
    ));
}
fn motor_sub_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * -1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_
    ));
}
fn motor_sub_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * -1.0), 
        /* e23, e31, e12, scalar */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * -1.0)
    ));
}
fn motor_sub_flector(self_: Motor, other: Flector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn motor_sub_horizon(self_: Motor, other: Horizon) -> MultiVector {
    let self_groups = motor_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn motor_sub_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e41_ * -1.0, other.e42_ * -1.0, other.e43_ * -1.0, 0.0) + self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e23_ * -1.0, other.e31_ * -1.0, other.e12_ * -1.0, 0.0) + self_groups.group1_
    ));
}
fn motor_sub_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_ - other_groups.group0_, 
        /* e23, e31, e12, scalar */ self_groups.group1_ - other_groups.group1_
    ));
}
fn motor_sub_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0) - other_groups.group0_, 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group0_ - other_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group1_ - other_groups.group3_, 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn motor_sub_origin(self_: Motor, other: Origin) -> MultiVector {
    let self_groups = motor_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn motor_sub_plane(self_: Motor, other: Plane) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn motor_sub_point(self_: Motor, other: Point) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn motor_sub_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_, 
        /* e23, e31, e12, scalar */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * -1.0)
    ));
}
fn multiVector_sub_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, other.e1234_ * -1.0, 0.0, 0.0) + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_sub_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_ - other_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_sub_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ - other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ - other_groups.group1_
    ));
}
fn multiVector_sub_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn multiVector_sub_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ - other_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group3_ - other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_sub_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * -1.0, other.e1234_ * -1.0, 0.0, 0.0) + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ - other_groups.group0_, 
        /* e23, e31, e12 */ self_groups.group3_ - other_groups.group1_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_sub_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_ - other_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ - other_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_ - other_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_ - other_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ - other_groups.group4_
    ));
}
fn multiVector_sub_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_sub_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_ - other_groups.group0_
    ));
}
fn multiVector_sub_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_ - other_groups.group0_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn multiVector_sub_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * -1.0, 0.0, 0.0, 0.0) + self_groups.group0_, 
        /* e1, e2, e3, e4 */ self_groups.group1_, 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ self_groups.group3_, 
        /* e423, e431, e412, e321 */ self_groups.group4_
    ));
}
fn origin_sub_antiScalar(self_: Origin, other: AntiScalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_sub_dualNum(self_: Origin, other: DualNum) -> MultiVector {
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_sub_flector(self_: Origin, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xyz, self_.e4_ - other.e4_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn origin_sub_horizon(self_: Origin, other: Horizon) -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn origin_sub_line(self_: Origin, other: Line) -> MultiVector {
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_sub_motor(self_: Origin, other: Motor) -> MultiVector {
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_sub_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group1_.xyz, self_.e4_ - other.e4_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn origin_sub_origin(self_: Origin, other: Origin) -> Origin {
    return Origin(self_.e4_ - other.e4_);
}
fn origin_sub_plane(self_: Origin, other: Plane) -> Flector {
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn origin_sub_point(self_: Origin, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xyz, self_.e4_ - other.e4_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn origin_sub_scalar(self_: Origin, other: Scalar) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn plane_sub_antiScalar(self_: Plane, other: AntiScalar) -> MultiVector {
    let self_groups = plane_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_sub_dualNum(self_: Plane, other: DualNum) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_sub_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_ - other_groups.group1_
    ));
}
fn plane_sub_horizon(self_: Plane, other: Horizon) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn plane_sub_line(self_: Plane, other: Line) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_sub_motor(self_: Plane, other: Motor) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_sub_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_ - other_groups.group4_
    ));
}
fn plane_sub_origin(self_: Plane, other: Origin) -> Flector {
    let self_groups = plane_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_sub_plane(self_: Plane, other: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ self_groups.group0_ - other_groups.group0_
    ));
}
fn plane_sub_point(self_: Plane, other: Point) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn plane_sub_scalar(self_: Plane, other: Scalar) -> MultiVector {
    let self_groups = plane_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ self_groups.group0_
    ));
}
fn point_sub_antiScalar(self_: Point, other: AntiScalar) -> MultiVector {
    let self_groups = point_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e1234_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_sub_dualNum(self_: Point, other: DualNum) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_sub_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ - other_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn point_sub_horizon(self_: Point, other: Horizon) -> Flector {
    let self_groups = point_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn point_sub_line(self_: Point, other: Line) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_sub_motor(self_: Point, other: Motor) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_sub_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_ - other_groups.group1_, 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn point_sub_origin(self_: Point, other: Origin) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ + vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0)
    ));
}
fn point_sub_plane(self_: Point, other: Plane) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn point_sub_point(self_: Point, other: Point) -> Point {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ self_groups.group0_ - other_groups.group0_
    ));
}
fn point_sub_scalar(self_: Point, other: Scalar) -> MultiVector {
    let self_groups = point_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ self_groups.group0_, 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_sub_antiScalar(self_: Scalar, other: AntiScalar) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(1.0, -1.0)
    ));
}
fn scalar_sub_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar - other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(1.0, -1.0)
    ));
}
fn scalar_sub_flector(self_: Scalar, other: Flector) -> MultiVector {
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group1_ * vec4<f32>(-1.0)
    ));
}
fn scalar_sub_horizon(self_: Scalar, other: Horizon) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * -1.0)
    ));
}
fn scalar_sub_line(self_: Scalar, other: Line) -> Motor {
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn scalar_sub_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other_groups.group1_.xyz, self_.scalar - other.scalar) * vec4<f32>(-1.0, -1.0, -1.0, 1.0)
    ));
}
fn scalar_sub_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar - other.scalar, other.e1234_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ other_groups.group1_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ other_groups.group2_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ other_groups.group3_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ other_groups.group4_ * vec4<f32>(-1.0)
    ));
}
fn scalar_sub_origin(self_: Scalar, other: Origin) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * -1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_sub_plane(self_: Scalar, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ other_groups.group0_ * vec4<f32>(-1.0)
    ));
}
fn scalar_sub_point(self_: Scalar, other: Point) -> MultiVector {
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar, 0.0, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ other_groups.group0_ * vec4<f32>(-1.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn scalar_sub_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(self_.scalar - other.scalar);
}
fn antiScalar_unit() -> AntiScalar {
    return AntiScalar(1.0);
}
fn dualNum_unit() -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 0.0, 0.0))
    ));
}
fn flector_unit() -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(1.0)
    ));
}
fn horizon_unit() -> Horizon {
    return Horizon(1.0);
}
fn line_unit() -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)), 
        /* e23, e31, e12 */ (vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0))
    ));
}
fn motor_unit() -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(1.0)
    ));
}
fn multiVector_unit() -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>(1.0), 
        /* e41, e42, e43 */ (vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)), 
        /* e23, e31, e12 */ (vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)), 
        /* e423, e431, e412, e321 */ vec4<f32>(1.0)
    ));
}
fn origin_unit() -> Origin {
    return Origin(1.0);
}
fn plane_unit() -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(1.0)
    ));
}
fn point_unit() -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(1.0)
    ));
}
fn scalar_unit() -> Scalar {
    return Scalar(1.0);
}
fn antiScalar_unitize(self_: AntiScalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ / (antiScalar_antiSquareRoot(antiScalar_flatWeightNormSquared(self_)).e1234_));
}
fn dualNum_unitize(self_: DualNum) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(1.0/(antiScalar_antiSquareRoot(dualNum_flatWeightNormSquared(self_)).e1234_)) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn flector_unitize(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(antiScalar_antiSquareRoot(flector_flatWeightNormSquared(self_)).e1234_));
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_
    ));
}
fn line_unitize(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(antiScalar_antiSquareRoot(line_flatWeightNormSquared(self_)).e1234_));
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn motor_unitize(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(antiScalar_antiSquareRoot(motor_flatWeightNormSquared(self_)).e1234_));
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_
    ));
}
fn multiVector_unitize(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let geometric_anti_product: AntiScalar = AntiScalar(1.0/(antiScalar_antiSquareRoot(multiVector_flatWeightNormSquared(self_)).e1234_));
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(geometric_anti_product.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(geometric_anti_product.e1234_) * self_groups.group4_
    ));
}
fn origin_unitize(self_: Origin) -> Origin {
    return Origin(self_.e4_ / (antiScalar_antiSquareRoot(origin_flatWeightNormSquared(self_)).e1234_));
}
fn plane_unitize(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(1.0/(antiScalar_antiSquareRoot(plane_flatWeightNormSquared(self_)).e1234_)) * self_groups.group0_
    ));
}
fn point_unitize(self_: Point) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(1.0/(antiScalar_antiSquareRoot(point_flatWeightNormSquared(self_)).e1234_)) * self_groups.group0_
    ));
}
fn antiScalar_wedge_dualNum(self_: AntiScalar, other: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.scalar);
}
fn antiScalar_wedge_motor(self_: AntiScalar, other: Motor) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.scalar);
}
fn antiScalar_wedge_multiVector(self_: AntiScalar, other: MultiVector) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.scalar);
}
fn antiScalar_wedge_scalar(self_: AntiScalar, other: Scalar) -> AntiScalar {
    return AntiScalar(self_.e1234_ * other.scalar);
}
fn dualNum_wedge_antiScalar(self_: DualNum, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.scalar);
}
fn dualNum_wedge_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0)
    ));
}
fn dualNum_wedge_flector(self_: DualNum, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn dualNum_wedge_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return Horizon(self_.scalar * other.e321_);
}
fn dualNum_wedge_line(self_: DualNum, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn dualNum_wedge_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar)) * vec4<f32>(other_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn dualNum_wedge_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    ));
}
fn dualNum_wedge_origin(self_: DualNum, other: Origin) -> Origin {
    return Origin(self_.scalar * other.e4_);
}
fn dualNum_wedge_plane(self_: DualNum, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn dualNum_wedge_point(self_: DualNum, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn dualNum_wedge_scalar(self_: DualNum, other: Scalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    ));
}
fn flector_wedge_dualNum(self_: Flector, other: DualNum) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn flector_wedge_flector(self_: Flector, other: Flector) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn flector_wedge_horizon(self_: Flector, other: Horizon) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e321_);
}
fn flector_wedge_line(self_: Flector, other: Line) -> Plane {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn flector_wedge_motor(self_: Flector, other: Motor) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e4_ * other.e23_) + (self_.e423_ * other.scalar), (self_.e4_ * other.e31_) + (self_.e431_ * other.scalar), (self_.e4_ * other.e12_) + (self_.e412_ * other.scalar), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) + vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, self_.e321_ * other.scalar) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn flector_wedge_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_) - (self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (self_groups.group0_.yzxw * other_groups.group1_.zxyw) - (self_groups.group0_.zxyw * other_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e3_ * other.e42_) + (self_.e4_ * other.e23_), (self_.e1_ * other.e43_) + (self_.e4_ * other.e31_), (self_.e2_ * other.e41_) + (self_.e4_ * other.e12_), -(self_.e2_ * other.e31_) - (self_.e3_ * other.e12_)) + (vec4<f32>(other.scalar) * self_groups.group1_) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    ));
}
fn flector_wedge_origin(self_: Flector, other: Origin) -> Motor {
    let self_groups = flector_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn flector_wedge_plane(self_: Flector, other: Plane) -> AntiScalar {
    return AntiScalar((self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_));
}
fn flector_wedge_point(self_: Flector, other: Point) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_ * other.e1_, self_.e4_ * other.e2_, self_.e4_ * other.e3_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (self_groups.group0_.zxyw * other_groups.group0_.yzxw)).xyz, 0.0)
    ));
}
fn flector_wedge_scalar(self_: Flector, other: Scalar) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn horizon_wedge_dualNum(self_: Horizon, other: DualNum) -> Horizon {
    return Horizon(other.scalar * self_.e321_);
}
fn horizon_wedge_flector(self_: Horizon, other: Flector) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e321_ * -1.0);
}
fn horizon_wedge_motor(self_: Horizon, other: Motor) -> Horizon {
    return Horizon(self_.e321_ * other.scalar);
}
fn horizon_wedge_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * other.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.scalar)
    ));
}
fn horizon_wedge_origin(self_: Horizon, other: Origin) -> AntiScalar {
    return AntiScalar(self_.e321_ * other.e4_ * -1.0);
}
fn horizon_wedge_point(self_: Horizon, other: Point) -> AntiScalar {
    return AntiScalar(self_.e321_ * other.e4_ * -1.0);
}
fn horizon_wedge_scalar(self_: Horizon, other: Scalar) -> Horizon {
    return Horizon(self_.e321_ * other.scalar);
}
fn line_wedge_dualNum(self_: Line, other: DualNum) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn line_wedge_flector(self_: Line, other: Flector) -> Plane {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_wedge_line(self_: Line, other: Line) -> AntiScalar {
    return AntiScalar(-(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_));
}
fn line_wedge_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group1_.xyz, 0.0) * vec4<f32>(other_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn line_wedge_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_wedge_origin(self_: Line, other: Origin) -> Plane {
    let self_groups = line_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    ));
}
fn line_wedge_point(self_: Line, other: Point) -> Plane {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn line_wedge_scalar(self_: Line, other: Scalar) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    ));
}
fn motor_wedge_antiScalar(self_: Motor, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.scalar);
}
fn motor_wedge_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar)) * vec4<f32>(self_groups.group0_.xyz, 1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn motor_wedge_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e23_) + (other.e423_ * self_.scalar), (other.e4_ * self_.e31_) + (other.e431_ * self_.scalar), (other.e4_ * self_.e12_) + (other.e412_ * self_.scalar), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) + vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, other.e321_ * self_.scalar) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_wedge_horizon(self_: Motor, other: Horizon) -> Horizon {
    return Horizon(other.e321_ * self_.scalar);
}
fn motor_wedge_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group1_.xyz, 0.0) * vec4<f32>(self_groups.group1_.wwww.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)
    ));
}
fn motor_wedge_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(self_.scalar) * other_groups.group0_) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, other.scalar * self_.scalar)
    ));
}
fn motor_wedge_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.scalar * other.scalar, (self_.e1234_ * other.scalar) + (self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e23_ * other.e4_) + (self_.scalar * other.e423_), (self_.e31_ * other.e4_) + (self_.scalar * other.e431_), (self_.e12_ * other.e4_) + (self_.scalar * other.e412_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group1_.zxyw).xyz, self_.scalar * other.e321_) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_wedge_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0)
    ));
}
fn motor_wedge_plane(self_: Motor, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn motor_wedge_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    ));
}
fn motor_wedge_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group1_
    ));
}
fn multiVector_wedge_antiScalar(self_: MultiVector, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.scalar);
}
fn multiVector_wedge_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    ));
}
fn multiVector_wedge_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group1_.yzxw) - (other_groups.group0_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_), -(other.e2_ * self_.e31_) - (other.e3_ * self_.e12_)) + (vec4<f32>(self_.scalar) * other_groups.group1_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    ));
}
fn multiVector_wedge_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.scalar)
    ));
}
fn multiVector_wedge_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_wedge_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.e1234_ * self_.scalar) + (other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e23_ * self_.e4_) + (other.scalar * self_.e423_), (other.e31_ * self_.e4_) + (other.scalar * self_.e431_), (other.e12_ * self_.e4_) + (other.scalar * self_.e412_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) + vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.scalar * self_.e321_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn multiVector_wedge_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.scalar * self_.scalar, (other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar) + (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_) - (other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ (vec4<f32>(other.scalar) * self_groups.group1_) + (vec4<f32>(self_.scalar) * other_groups.group1_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (other_groups.group1_.zxyw * self_groups.group1_.yzxw) - (other_groups.group1_.yzxw * self_groups.group1_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e1_ * self_.e23_) - (other.e2_ * self_.e31_) - (other.e3_ * self_.e12_) - (other.e12_ * self_.e3_)) + (vec4<f32>(other.scalar) * self_groups.group4_) + (vec4<f32>(self_.scalar) * other_groups.group4_) - (self_groups.group1_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e31_ * self_.e2_)
    ));
}
fn multiVector_wedge_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, self_.e321_ * other.e4_, 0.0, 0.0) * vec4<f32>(0.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_).xyz, 0.0)
    ));
}
fn multiVector_wedge_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let other_groups = plane_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (self_.e1_ * other.e423_) + (self_.e2_ * other.e431_) + (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn multiVector_wedge_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_), 
        /* e23, e31, e12 */ (self_groups.group1_.yzxw * other_groups.group0_.zxyw) - (self_groups.group1_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e23_ * other.e4_), (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_), (self_.e41_ * other.e2_) + (self_.e12_ * other.e4_), -(self_.e31_ * other.e2_) - (self_.e12_ * other.e3_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    ));
}
fn multiVector_wedge_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group4_
    ));
}
fn origin_wedge_dualNum(self_: Origin, other: DualNum) -> Origin {
    return Origin(other.scalar * self_.e4_);
}
fn origin_wedge_flector(self_: Origin, other: Flector) -> Motor {
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn origin_wedge_horizon(self_: Origin, other: Horizon) -> AntiScalar {
    return AntiScalar(other.e321_ * self_.e4_);
}
fn origin_wedge_line(self_: Origin, other: Line) -> Plane {
    let other_groups = line_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
}
fn origin_wedge_motor(self_: Origin, other: Motor) -> Flector {
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0)
    ));
}
fn origin_wedge_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(1.0, other.e321_ * self_.e4_, 0.0, 0.0) * vec4<f32>(0.0, 1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_).xyz, 0.0)
    ));
}
fn origin_wedge_plane(self_: Origin, other: Plane) -> AntiScalar {
    return AntiScalar(self_.e4_ * other.e321_);
}
fn origin_wedge_point(self_: Origin, other: Point) -> Line {
    let other_groups = point_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn origin_wedge_scalar(self_: Origin, other: Scalar) -> Origin {
    return Origin(self_.e4_ * other.scalar);
}
fn plane_wedge_dualNum(self_: Plane, other: DualNum) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn plane_wedge_flector(self_: Plane, other: Flector) -> AntiScalar {
    return AntiScalar(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_));
}
fn plane_wedge_motor(self_: Plane, other: Motor) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn plane_wedge_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, -(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn plane_wedge_origin(self_: Plane, other: Origin) -> AntiScalar {
    return AntiScalar(other.e4_ * self_.e321_ * -1.0);
}
fn plane_wedge_point(self_: Plane, other: Point) -> AntiScalar {
    return AntiScalar(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_));
}
fn plane_wedge_scalar(self_: Plane, other: Scalar) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn point_wedge_dualNum(self_: Point, other: DualNum) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn point_wedge_flector(self_: Point, other: Flector) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_ * self_.e1_ * -1.0, other.e4_ * self_.e2_ * -1.0, other.e4_ * self_.e3_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_)), 
        /* e23, e31, e12, scalar */ vec4<f32>(((other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, 0.0)
    ));
}
fn point_wedge_horizon(self_: Point, other: Horizon) -> AntiScalar {
    return AntiScalar(other.e321_ * self_.e4_);
}
fn point_wedge_line(self_: Point, other: Line) -> Plane {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn point_wedge_motor(self_: Point, other: Motor) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    ));
}
fn point_wedge_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, (other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_, 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e42_ * self_.e3_) + (other.e23_ * self_.e4_), (other.e43_ * self_.e1_) + (other.e31_ * self_.e4_), (other.e41_ * self_.e2_) + (other.e12_ * self_.e4_), -(other.e31_ * self_.e2_) - (other.e12_ * self_.e3_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    ));
}
fn point_wedge_origin(self_: Point, other: Origin) -> Line {
    let self_groups = point_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn point_wedge_plane(self_: Point, other: Plane) -> AntiScalar {
    return AntiScalar((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_));
}
fn point_wedge_point(self_: Point, other: Point) -> Line {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_), 
        /* e23, e31, e12 */ (other_groups.group0_.zxyw * self_groups.group0_.yzxw) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)
    ));
}
fn point_wedge_scalar(self_: Point, other: Scalar) -> Point {
    let self_groups = point_grouped(self_);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.scalar) * self_groups.group0_
    ));
}
fn scalar_wedge_antiScalar(self_: Scalar, other: AntiScalar) -> AntiScalar {
    return AntiScalar(other.e1234_ * self_.scalar);
}
fn scalar_wedge_dualNum(self_: Scalar, other: DualNum) -> DualNum {
    let other_groups = dualNum_grouped(other);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    ));
}
fn scalar_wedge_flector(self_: Scalar, other: Flector) -> Flector {
    let other_groups = flector_grouped(other);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn scalar_wedge_horizon(self_: Scalar, other: Horizon) -> Horizon {
    return Horizon(other.e321_ * self_.scalar);
}
fn scalar_wedge_line(self_: Scalar, other: Line) -> Line {
    let other_groups = line_grouped(other);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    ));
}
fn scalar_wedge_motor(self_: Scalar, other: Motor) -> Motor {
    let other_groups = motor_grouped(other);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.scalar) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group1_
    ));
}
fn scalar_wedge_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let other_groups = multiVector_grouped(other);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group4_
    ));
}
fn scalar_wedge_origin(self_: Scalar, other: Origin) -> Origin {
    return Origin(other.e4_ * self_.scalar);
}
fn scalar_wedge_plane(self_: Scalar, other: Plane) -> Plane {
    let other_groups = plane_grouped(other);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn scalar_wedge_point(self_: Scalar, other: Point) -> Point {
    let other_groups = point_grouped(other);
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.scalar) * other_groups.group0_
    ));
}
fn scalar_wedge_scalar(self_: Scalar, other: Scalar) -> Scalar {
    return Scalar(other.scalar * self_.scalar);
}
fn antiScalar_weight(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn dualNum_weight(self_: DualNum) -> AntiScalar {
    return AntiScalar(self_.e1234_);
}
fn flector_weight(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group1_.xyz, 0.0)
    ));
}
fn line_weight(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ self_groups.group0_, 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_weight(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn multiVector_weight(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0, self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_), 
        /* e41, e42, e43 */ self_groups.group2_, 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group4_.xyz, 0.0)
    ));
}
fn origin_weight(self_: Origin) -> Origin {
    return self_;
}
fn plane_weight(self_: Plane) -> Plane {
    let self_groups = plane_grouped(self_);
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.xyz, 0.0)
    ));
}
fn point_weight(self_: Point) -> Origin {
    return Origin(self_.e4_);
}
fn antiScalar_weightNorm(self_: AntiScalar) -> AntiScalar {
    return antiScalar_antiSquareRoot(antiScalar_flatWeightNormSquared(self_));
}
fn dualNum_weightNorm(self_: DualNum) -> AntiScalar {
    return antiScalar_antiSquareRoot(dualNum_flatWeightNormSquared(self_));
}
fn flector_weightNorm(self_: Flector) -> AntiScalar {
    let self_groups = flector_grouped(self_);
    return antiScalar_antiSquareRoot(flector_flatWeightNormSquared(self_));
}
fn line_weightNorm(self_: Line) -> AntiScalar {
    let self_groups = line_grouped(self_);
    return antiScalar_antiSquareRoot(line_flatWeightNormSquared(self_));
}
fn motor_weightNorm(self_: Motor) -> AntiScalar {
    let self_groups = motor_grouped(self_);
    return antiScalar_antiSquareRoot(motor_flatWeightNormSquared(self_));
}
fn multiVector_weightNorm(self_: MultiVector) -> AntiScalar {
    let self_groups = multiVector_grouped(self_);
    return antiScalar_antiSquareRoot(multiVector_flatWeightNormSquared(self_));
}
fn origin_weightNorm(self_: Origin) -> AntiScalar {
    return antiScalar_antiSquareRoot(origin_flatWeightNormSquared(self_));
}
fn plane_weightNorm(self_: Plane) -> AntiScalar {
    let self_groups = plane_grouped(self_);
    return antiScalar_antiSquareRoot(plane_flatWeightNormSquared(self_));
}
fn point_weightNorm(self_: Point) -> AntiScalar {
    return antiScalar_antiSquareRoot(point_flatWeightNormSquared(self_));
}
fn antiScalar_weightNormSquared(self_: AntiScalar) -> AntiScalar {
    let flat_weight: AntiScalar = antiScalar_flatWeight(self_);
    return antiScalar_antiDotProduct_antiScalar(flat_weight, flat_weight);
}
fn dualNum_weightNormSquared(self_: DualNum) -> AntiScalar {
    let flat_weight: AntiScalar = dualNum_flatWeight(self_);
    return antiScalar_antiDotProduct_antiScalar(flat_weight, flat_weight);
}
fn flector_weightNormSquared(self_: Flector) -> AntiScalar {
    let self_groups = flector_grouped(self_);
    let flat_weight: Flector = flector_flatWeight(self_);
    return flector_antiDotProduct_flector(flat_weight, flat_weight);
}
fn line_weightNormSquared(self_: Line) -> AntiScalar {
    let self_groups = line_grouped(self_);
    let flat_weight: Line = line_flatWeight(self_);
    return line_antiDotProduct_line(flat_weight, flat_weight);
}
fn motor_weightNormSquared(self_: Motor) -> AntiScalar {
    let self_groups = motor_grouped(self_);
    let flat_weight: Motor = motor_flatWeight(self_);
    return motor_antiDotProduct_motor(flat_weight, flat_weight);
}
fn multiVector_weightNormSquared(self_: MultiVector) -> AntiScalar {
    let self_groups = multiVector_grouped(self_);
    let flat_weight: MultiVector = multiVector_flatWeight(self_);
    return multiVector_antiDotProduct_multiVector(flat_weight, flat_weight);
}
fn origin_weightNormSquared(self_: Origin) -> AntiScalar {
    let flat_weight: Origin = origin_flatWeight(self_);
    return origin_antiDotProduct_origin(flat_weight, flat_weight);
}
fn plane_weightNormSquared(self_: Plane) -> AntiScalar {
    let self_groups = plane_grouped(self_);
    let flat_weight: Plane = plane_flatWeight(self_);
    return plane_antiDotProduct_plane(flat_weight, flat_weight);
}
fn point_weightNormSquared(self_: Point) -> AntiScalar {
    let flat_weight: Origin = point_flatWeight(self_);
    return origin_antiDotProduct_origin(flat_weight, flat_weight);
}
fn antiScalar_zero() -> AntiScalar {
    return AntiScalar(0.0);
}
fn dualNum_zero() -> DualNum {
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(0.0)
    ));
}
fn flector_zero() -> Flector {
    return flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn horizon_zero() -> Horizon {
    return Horizon(0.0);
}
fn line_zero() -> Line {
    return line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0)
    ));
}
fn motor_zero() -> Motor {
    return motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(0.0)
    ));
}
fn multiVector_zero() -> MultiVector {
    return multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ vec4<f32>(0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn origin_zero() -> Origin {
    return Origin(0.0);
}
fn plane_zero() -> Plane {
    return plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(0.0)
    ));
}
fn point_zero() -> Point {
    return point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(0.0)
    ));
}
fn scalar_zero() -> Scalar {
    return Scalar(0.0);
}
fn antiScalar_antiConstraintValid(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn horizon_antiConstraintValid(self_: Horizon) -> Horizon {
    return self_;
}
fn origin_antiConstraintValid(self_: Origin) -> Origin {
    return self_;
}
fn plane_antiConstraintValid(self_: Plane) -> Plane {
    return self_;
}
fn point_antiConstraintValid(self_: Point) -> Point {
    return self_;
}
fn scalar_antiConstraintValid(self_: Scalar) -> Scalar {
    return self_;
}
fn antiScalar_antiSandwich_antiScalar(self_: AntiScalar, other: AntiScalar) -> AntiScalar {
    return antiScalar_geometricAntiProduct_antiScalar(AntiScalar(other.e1234_ * self_.e1234_), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_dualNum(self_: AntiScalar, other: DualNum) -> DualNum {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return dualNum_geometricAntiProduct_antiScalar(dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_flector(self_: AntiScalar, other: Flector) -> Flector {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricAntiProduct_antiScalar(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group1_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_horizon(self_: AntiScalar, other: Horizon) -> Horizon {
    return horizon_geometricAntiProduct_antiScalar(Horizon(self_.e1234_ * other.e321_), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_line(self_: AntiScalar, other: Line) -> Line {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricAntiProduct_antiScalar(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_motor(self_: AntiScalar, other: Motor) -> Motor {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricAntiProduct_antiScalar(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e1234_) * other_groups.group1_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_multiVector(self_: AntiScalar, other: MultiVector) -> MultiVector {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_antiScalar(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group4_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_origin(self_: AntiScalar, other: Origin) -> Origin {
    return origin_geometricAntiProduct_antiScalar(Origin(self_.e1234_ * other.e4_), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_plane(self_: AntiScalar, other: Plane) -> Plane {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = plane_grouped(other);
    return plane_geometricAntiProduct_antiScalar(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_point(self_: AntiScalar, other: Point) -> Point {
    let self_groups = antiScalar_grouped(self_);
    let other_groups = point_grouped(other);
    return point_geometricAntiProduct_antiScalar(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    )), antiScalar_antiReverse(self_));
}
fn antiScalar_antiSandwich_scalar(self_: AntiScalar, other: Scalar) -> Scalar {
    return scalar_geometricAntiProduct_antiScalar(Scalar(self_.e1234_ * other.scalar), antiScalar_antiReverse(self_));
}
fn dualNum_antiSandwich_antiScalar(self_: DualNum, other: AntiScalar) -> DualNum {
    let self_groups = dualNum_grouped(self_);
    return dualNum_geometricAntiProduct_dualNum(dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_dualNum(self_: DualNum, other: DualNum) -> DualNum {
    return dualNum_geometricAntiProduct_dualNum(dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), other.e1234_ * self_.e1234_, 0.0, 0.0)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_flector(self_: DualNum, other: Flector) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricAntiProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, self_.e1234_ * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e4_) + (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group1_.xyz, 1.0)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_horizon(self_: DualNum, other: Horizon) -> Horizon {
    return horizon_geometricAntiProduct_dualNum(Horizon(self_.e1234_ * other.e321_), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_line(self_: DualNum, other: Line) -> Line {
    let self_groups = dualNum_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricAntiProduct_dualNum(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_, 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_motor(self_: DualNum, other: Motor) -> Motor {
    let self_groups = dualNum_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricAntiProduct_dualNum(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e23, e31, e12, scalar */ (vec4<f32>(self_.scalar) * other_groups.group0_) + (vec4<f32>(self_.e1234_) * other_groups.group1_)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_multiVector(self_: DualNum, other: MultiVector) -> MultiVector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_dualNum(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) + (self_.e1234_ * other.scalar), self_.e1234_ * other.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_)).xyz, self_.e1234_ * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, (self_.scalar * other.e4_) + (self_.e1234_ * other.e321_)) * vec4<f32>(other_groups.group4_.xyz, 1.0)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_origin(self_: DualNum, other: Origin) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = origin_grouped(other);
    return flector_geometricAntiProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e1234_ * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_plane(self_: DualNum, other: Plane) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricAntiProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_) * other_groups.group0_
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_point(self_: DualNum, other: Point) -> Flector {
    let self_groups = dualNum_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricAntiProduct_dualNum(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e1234_) * other_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.scalar * other.e4_)
    )), dualNum_antiReverse(self_));
}
fn dualNum_antiSandwich_scalar(self_: DualNum, other: Scalar) -> Scalar {
    return scalar_geometricAntiProduct_dualNum(Scalar(self_.e1234_ * other.scalar), dualNum_antiReverse(self_));
}
fn flector_antiSandwich_antiScalar(self_: Flector, other: AntiScalar) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return flector_geometricAntiProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group1_
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_dualNum(self_: Flector, other: DualNum) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricAntiProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)).xyz, other.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, (other.e1234_ * self_.e321_) - (other.scalar * self_.e4_)) * vec4<f32>(self_groups.group1_.xyz, 1.0)
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_flector(self_: Flector, other: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricAntiProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(other.e423_ * self_.e4_) - (other.e412_ * self_.e431_), -(other.e423_ * self_.e412_) - (other.e431_ * self_.e4_), -(other.e431_ * self_.e423_) - (other.e412_ * self_.e4_), (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_)) + (other_groups.group1_.yzxx * self_groups.group1_.zxyx) - (vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)), 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e1_) * vec4<f32>(other_groups.group0_.xxyw.xyz, other.e423_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e2_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e431_)) + (other_groups.group1_.yzxz * self_groups.group0_.zxyz) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, self_.e321_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e4_)) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, self_.e412_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e3_)) - (other_groups.group0_.yzxx * self_groups.group1_.zxyx) - (other_groups.group0_.wwwy * vec4<f32>(self_groups.group0_.xyz, self_.e431_))
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_horizon(self_: Flector, other: Horizon) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = horizon_grouped(other);
    return motor_geometricAntiProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e321_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_)
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_line(self_: Flector, other: Line) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricAntiProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * other.e43_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_), (self_.e3_ * other.e41_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_), (self_.e1_ * other.e42_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_), 0.0) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, self_.e423_ * other.e41_), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(other_groups.group0_.xxyw.xyz, other.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e412_ * other.e12_) - (self_.e2_ * other.e42_) - (self_.e3_ * other.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, self_.e1_ * other.e41_)
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_motor(self_: Flector, other: Motor) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricAntiProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * other.e43_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_) - (self_.e431_ * other.e12_), (self_.e3_ * other.e41_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_) - (self_.e412_ * other.e23_), (self_.e3_ * other.e1234_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_) - (self_.e412_ * other.scalar), 0.0) + (self_groups.group0_.xyxw * other_groups.group0_.wwyw) - (self_groups.group1_.xyxz * vec4<f32>(other_groups.group1_.wwyw.xyz, other.e43_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e423_)) - vec4<f32>((self_groups.group0_.wwww * other_groups.group1_).xyz, self_.e431_ * other.e42_), 
        /* e423, e431, e412, e321 */ (self_groups.group1_.xyxy * vec4<f32>(other_groups.group0_.wwyw.xyz, other.e31_)) + (self_groups.group1_.yzzz * vec4<f32>(other_groups.group0_.zxww.xyz, other.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e321_ * other.e1234_) - (self_.e2_ * other.e42_) - (self_.e3_ * other.e43_) - (self_.e4_ * other.scalar)) + vec4<f32>((self_groups.group0_.wwww * other_groups.group0_).xyz, self_.e423_ * other.e23_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e1_))
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_multiVector(self_: Flector, other: MultiVector) -> MultiVector {
    let self_groups = flector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_flector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.e4_ * other.e321_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * other_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e2_ * other.e43_) + (self_.e412_ * other.e31_) + (self_.e321_ * other.e41_) - (self_.e431_ * other.e12_), (self_.e3_ * other.e41_) + (self_.e423_ * other.e12_) + (self_.e321_ * other.e42_) - (self_.e4_ * other.e31_), (self_.e1_ * other.e42_) + (self_.e431_ * other.e23_) + (self_.e321_ * other.e43_) - (self_.e4_ * other.e12_), 0.0) + (vec4<f32>(other.e1234_) * self_groups.group0_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e412_) * vec4<f32>(other_groups.group3_.xxyw.xyz, other.e43_)) - (self_groups.group1_.xyzx * vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, other.e41_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group0_.zxyw).xyz, self_.e431_ * other.e42_), 
        /* e41, e42, e43 */ (self_groups.group1_.zxyw * other_groups.group4_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (vec4<f32>(other.e4_, other.e4_, other.e431_, 0.0) * self_groups.group1_.xyxw) - (vec4<f32>(other.e412_, other.e423_, other.e4_, 0.0) * self_groups.group1_.yzzw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (vec4<f32>(other.e3_, other.e1_, other.e321_, 0.0) * self_groups.group1_.yzzw) + (vec4<f32>(other.e321_, other.e321_, other.e2_, 0.0) * self_groups.group1_.xyxw) + (self_groups.group0_.zxyw * other_groups.group4_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (vec4<f32>(other.e4_, other.e4_, other.e431_, 0.0) * self_groups.group0_.xyxw) - (vec4<f32>(other.e412_, other.e423_, other.e4_, 0.0) * self_groups.group0_.yzzw) - (self_groups.group1_.zxyw * other_groups.group1_.yzxw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(other_groups.group2_.xxyw.xyz, other.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(other_groups.group2_.zyzw.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (self_.e412_ * other.e12_) - (self_.e1_ * other.e41_) - (self_.e2_ * other.e42_) - (self_.e3_ * other.e43_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group1_.zxyw).xyz, self_.e4_ * other.scalar)
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_origin(self_: Flector, other: Origin) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = origin_grouped(other);
    return motor_geometricAntiProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.e321_) * vec4<f32>(-1.0)
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_plane(self_: Flector, other: Plane) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricAntiProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(self_.e4_ * other.e423_) - (self_.e431_ * other.e412_), -(self_.e4_ * other.e431_) - (self_.e412_ * other.e423_), -(self_.e4_ * other.e412_) - (self_.e423_ * other.e431_), (self_.e431_ * other.e431_) + (self_.e412_ * other.e412_)) + (self_groups.group1_.zxyx * other_groups.group0_.yzxx), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(self_.e2_ * other.e412_) - (self_.e321_ * other.e423_), -(self_.e3_ * other.e423_) - (self_.e321_ * other.e431_), -(self_.e1_ * other.e431_) - (self_.e321_ * other.e412_), (self_.e3_ * other.e412_) + (self_.e4_ * other.e321_)) + (self_groups.group0_.zxyx * other_groups.group0_.yzxx) + (other_groups.group0_.wwwy * vec4<f32>(self_groups.group1_.xyz, self_.e2_))
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_point(self_: Flector, other: Point) -> Flector {
    let self_groups = flector_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricAntiProduct_flector(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e4_ * other.e1_) + (self_.e431_ * other.e3_), (self_.e4_ * other.e2_) + (self_.e412_ * other.e1_), (self_.e4_ * other.e3_) + (self_.e423_ * other.e2_), -(self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group1_.zxyy * other_groups.group0_.yzxy) - (other_groups.group0_.wwwx * vec4<f32>(self_groups.group0_.xyz, self_.e423_))
    )), flector_antiReverse(self_));
}
fn flector_antiSandwich_scalar(self_: Flector, other: Scalar) -> Motor {
    let self_groups = flector_grouped(self_);
    let other_groups = scalar_grouped(other);
    return flector_geometricAntiProduct_flector(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.scalar * -1.0)
    )), flector_antiReverse(self_));
}
fn horizon_antiSandwich_flector(self_: Horizon, other: Flector) -> Flector {
    let self_groups = horizon_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricAntiProduct_horizon(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e321_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0)
    )), horizon_antiReverse(self_));
}
fn horizon_antiSandwich_line(self_: Horizon, other: Line) -> Scalar {
    let other_groups = line_grouped(other);
    return point_geometricAntiProduct_horizon(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    )), horizon_antiReverse(self_));
}
fn horizon_antiSandwich_motor(self_: Horizon, other: Motor) -> Motor {
    let self_groups = horizon_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricAntiProduct_horizon(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    )), horizon_antiReverse(self_));
}
fn horizon_antiSandwich_multiVector(self_: Horizon, other: MultiVector) -> MultiVector {
    let self_groups = horizon_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_horizon(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e321_ * other.e4_, 1.0, 0.0, 0.0) * vec4<f32>(-1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e321_ * other.e1234_)
    )), horizon_antiReverse(self_));
}
fn horizon_antiSandwich_plane(self_: Horizon, other: Plane) -> Point {
    let self_groups = horizon_grouped(self_);
    let other_groups = plane_grouped(other);
    return line_geometricAntiProduct_horizon(line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)
    )), horizon_antiReverse(self_));
}
fn line_antiSandwich_antiScalar(self_: Line, other: AntiScalar) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return line_geometricAntiProduct_line(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_
    )), line_antiReverse(self_));
}
fn line_antiSandwich_dualNum(self_: Line, other: DualNum) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return line_geometricAntiProduct_line(line_degroup(LineGroups(
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_, 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_flector(self_: Line, other: Flector) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricAntiProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e1_ * self_.e43_) + (other.e4_ * self_.e31_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e2_ * self_.e41_) + (other.e4_ * self_.e12_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), other.e412_ * self_.e43_ * -1.0) - (other_groups.group1_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, other.e423_ * self_.e41_), 
        /* e423, e431, e412, e321 */ vec4<f32>((other.e4_ * self_.e41_) + (other.e412_ * self_.e42_), (other.e4_ * self_.e42_) + (other.e423_ * self_.e43_), (other.e4_ * self_.e43_) + (other.e431_ * self_.e41_), -(other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group1_.yzxw).xyz, other.e1_ * self_.e41_)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_horizon(self_: Line, other: Horizon) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = horizon_grouped(other);
    return point_geometricAntiProduct_line(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_line(self_: Line, other: Line) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_geometricAntiProduct_line(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e43_ * self_.e42_, other.e41_ * self_.e43_, other.e42_ * self_.e41_, -(other.e42_ * self_.e42_) - (other.e43_ * self_.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, other.e41_ * self_.e41_), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e43_ * self_.e31_) + (other.e12_ * self_.e42_), (other.e41_ * self_.e12_) + (other.e23_ * self_.e43_), (other.e42_ * self_.e23_) + (other.e31_ * self_.e41_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.e41_ * self_.e23_) - vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, other.e42_ * self_.e31_)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_motor(self_: Line, other: Motor) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricAntiProduct_line(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((self_.e41_ * other.e1234_) + (self_.e42_ * other.e43_), (self_.e42_ * other.e1234_) + (self_.e43_ * other.e41_), (self_.e41_ * other.e42_) + (self_.e43_ * other.e1234_), -(self_.e42_ * other.e42_) - (self_.e43_ * other.e43_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e41_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((self_.e41_ * other.scalar) + (self_.e42_ * other.e12_) + (self_.e23_ * other.e1234_) + (self_.e31_ * other.e43_), (self_.e42_ * other.scalar) + (self_.e43_ * other.e23_) + (self_.e31_ * other.e1234_) + (self_.e12_ * other.e41_), (self_.e41_ * other.e31_) + (self_.e43_ * other.scalar) + (self_.e23_ * other.e42_) + (self_.e12_ * other.e1234_), -(self_.e43_ * other.e12_) - (self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_)) - (other_groups.group1_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e41_)) - vec4<f32>((self_groups.group1_.zxyw * other_groups.group0_.yzxw).xyz, self_.e42_ * other.e31_)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_multiVector(self_: Line, other: MultiVector) -> MultiVector {
    let self_groups = line_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_line(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e23_ * other.e41_) - (self_.e31_ * other.e42_) - (self_.e12_ * other.e43_), 0.0, 0.0, 0.0) - ((vec4<f32>(self_.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e42_ * other.e3_) + (self_.e23_ * other.e4_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e43_ * other.e1_) + (self_.e31_ * other.e4_) + (self_.e12_ * other.e423_), (self_.e41_ * other.e2_) + (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_) + (self_.e12_ * other.e4_), self_.e43_ * other.e412_ * -1.0) - (other_groups.group4_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group1_.yzxw).xyz, self_.e41_ * other.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (self_groups.group0_.yzxw * other_groups.group2_.zxyw) - (self_groups.group0_.zxyw * other_groups.group2_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.yzxw * other_groups.group3_.zxyw) + (self_groups.group1_.yzxw * other_groups.group2_.zxyw) - (self_groups.group0_.zxyw * other_groups.group3_.yzxw) - (self_groups.group1_.zxyw * other_groups.group2_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>((self_.e41_ * other.e4_) + (self_.e42_ * other.e412_), (self_.e42_ * other.e4_) + (self_.e43_ * other.e423_), (self_.e41_ * other.e431_) + (self_.e43_ * other.e4_), -(self_.e42_ * other.e2_) - (self_.e43_ * other.e3_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group4_.yzxw).xyz, self_.e41_ * other.e1_)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_origin(self_: Line, other: Origin) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = origin_grouped(other);
    return flector_geometricAntiProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0)
    )), line_antiReverse(self_));
}
fn line_antiSandwich_plane(self_: Line, other: Plane) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricAntiProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e42_ * other.e412_, self_.e43_ * other.e423_, self_.e41_ * other.e431_, -(self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    )), line_antiReverse(self_));
}
fn line_antiSandwich_point(self_: Line, other: Point) -> Flector {
    let self_groups = line_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricAntiProduct_line(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_).xyz, 0.0) + vec4<f32>((self_groups.group0_.yzxw * other_groups.group0_.zxyw).xyz, 0.0) - vec4<f32>((self_groups.group0_.zxyw * other_groups.group0_.yzxw).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, -(self_.e41_ * other.e1_) - (self_.e42_ * other.e2_) - (self_.e43_ * other.e3_))
    )), line_antiReverse(self_));
}
fn line_antiSandwich_scalar(self_: Line, other: Scalar) -> Motor {
    let self_groups = line_grouped(self_);
    let other_groups = scalar_grouped(other);
    return line_geometricAntiProduct_line(line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_
    )), line_antiReverse(self_));
}
fn motor_antiSandwich_antiScalar(self_: Motor, other: AntiScalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return motor_geometricAntiProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e1234_) * self_groups.group1_
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_dualNum(self_: Motor, other: DualNum) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return motor_geometricAntiProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e23, e31, e12, scalar */ (vec4<f32>(other.scalar) * self_groups.group0_) + (vec4<f32>(other.e1234_) * self_groups.group1_)
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_flector(self_: Motor, other: Flector) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricAntiProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e423_ * self_.scalar) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e2_ * self_.e1234_) + (other.e4_ * self_.e31_) + (other.e423_ * self_.e12_) + (other.e431_ * self_.scalar) + (other.e321_ * self_.e42_), (other.e3_ * self_.e1234_) + (other.e4_ * self_.e12_) + (other.e431_ * self_.e23_) + (other.e412_ * self_.scalar) + (other.e321_ * self_.e43_), other.e412_ * self_.e43_ * -1.0) + (other_groups.group0_.xxyw * self_groups.group0_.wzxw) - (other_groups.group1_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group0_.yzxw.xyz, other.e423_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e412_ * self_.e42_, other.e431_ * self_.e1234_, other.e412_ * self_.e1234_, -(other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) + (vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar)) + (other_groups.group1_.xxyw * self_groups.group0_.wzxw) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group1_.yzxw.xyz, other.e1_))
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_horizon(self_: Motor, other: Horizon) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = horizon_grouped(other);
    return flector_geometricAntiProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_line(self_: Motor, other: Line) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = line_grouped(other);
    return motor_geometricAntiProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e41_ * self_.e1234_) + (other.e43_ * self_.e42_), (other.e41_ * self_.e43_) + (other.e42_ * self_.e1234_), (other.e42_ * self_.e41_) + (other.e43_ * self_.e1234_), -(other.e42_ * self_.e42_) - (other.e43_ * self_.e43_)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group0_.yzxw.xyz, other.e41_)), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e41_ * self_.scalar) + (other.e43_ * self_.e31_) + (other.e23_ * self_.e1234_) + (other.e12_ * self_.e42_), (other.e41_ * self_.e12_) + (other.e42_ * self_.scalar) + (other.e23_ * self_.e43_) + (other.e31_ * self_.e1234_), (other.e42_ * self_.e23_) + (other.e43_ * self_.scalar) + (other.e31_ * self_.e41_) + (other.e12_ * self_.e1234_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) - (self_groups.group1_.zxyx * vec4<f32>(other_groups.group0_.yzxw.xyz, other.e41_)) - vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, other.e42_ * self_.e31_)
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_motor(self_: Motor, other: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricAntiProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((other.e43_ * self_.e42_) + (other.e1234_ * self_.e41_), (other.e42_ * self_.e1234_) + (other.e1234_ * self_.e42_), (other.e43_ * self_.e1234_) + (other.e1234_ * self_.e43_), -(other.e42_ * self_.e42_) - (other.e43_ * self_.e43_)) + (other_groups.group0_.xxyw * self_groups.group0_.wzxw) - (other_groups.group0_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e1234_ * self_.e23_) + (other.e23_ * self_.e1234_) + (other.e12_ * self_.e42_) + (other.scalar * self_.e41_), (other.e1234_ * self_.e31_) + (other.e23_ * self_.e43_) + (other.e31_ * self_.e1234_) + (other.scalar * self_.e42_), (other.e1234_ * self_.e12_) + (other.e31_ * self_.e41_) + (other.e12_ * self_.e1234_) + (other.scalar * self_.e43_), -(other.e43_ * self_.e12_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_)) + (other_groups.group0_.xxyw * self_groups.group1_.wzxw) + vec4<f32>((other_groups.group0_.zyzw * self_groups.group1_.ywww).xyz, other.scalar * self_.e1234_) - (other_groups.group0_.yzxx * self_groups.group1_.zxyx) - vec4<f32>((other_groups.group1_.yzxw * self_groups.group0_.zxyw).xyz, other.e42_ * self_.e31_)
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_multiVector(self_: Motor, other: MultiVector) -> MultiVector {
    let self_groups = motor_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_motor(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((self_.scalar * other.e1234_) - (self_.e41_ * other.e23_) - (self_.e42_ * other.e31_) - (self_.e43_ * other.e12_), 0.0, 0.0, 0.0) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e42_ * other.e3_) + (self_.e1234_ * other.e1_) + (self_.e23_ * other.e4_) + (self_.e31_ * other.e412_) + (self_.scalar * other.e423_), (self_.e43_ * other.e1_) + (self_.e1234_ * other.e2_) + (self_.e31_ * other.e4_) + (self_.e12_ * other.e423_) + (self_.scalar * other.e431_), (self_.e43_ * other.e321_) + (self_.e1234_ * other.e3_) + (self_.e23_ * other.e431_) + (self_.e12_ * other.e4_) + (self_.scalar * other.e412_), self_.e43_ * other.e412_ * -1.0) + (self_groups.group0_.xyxw * vec4<f32>(other_groups.group4_.wwzw.xy, other.e2_, other.e4_)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group1_.yzxw.xyz, other.e423_)) - (other_groups.group4_.yzxy * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e42_)), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group2_.xxyw * self_groups.group0_.wzxw) + (other_groups.group2_.zyzw * self_groups.group0_.ywww) - (other_groups.group2_.yzxw * self_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (other_groups.group2_.xxyw * self_groups.group1_.wzxw) + (other_groups.group2_.zyzw * self_groups.group1_.ywww) + (other_groups.group3_.xxyw * self_groups.group0_.wzxw) + (other_groups.group3_.zyzw * self_groups.group0_.ywww) - (other_groups.group2_.yzxw * self_groups.group1_.zxyw) - (other_groups.group3_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_ * other.e423_, self_.e1234_ * other.e431_, self_.e1234_ * other.e412_, -(self_.e42_ * other.e2_) - (self_.e43_ * other.e3_) - (self_.e23_ * other.e423_) - (self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) + (self_groups.group0_.xyxw * vec4<f32>(other_groups.group1_.wwzw.xy, other.e431_, other.e321_)) + (vec4<f32>(other_groups.group4_.zxzw.xy, other.e4_, other.e4_) * vec4<f32>(self_groups.group0_.yzzw.xyz, self_.scalar)) - (self_groups.group0_.zxyx * vec4<f32>(other_groups.group4_.yzxw.xyz, other.e1_))
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_origin(self_: Motor, other: Origin) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = origin_grouped(other);
    return flector_geometricAntiProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group1_.xyz, self_.e1234_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group0_.xyz, self_.scalar)
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_plane(self_: Motor, other: Plane) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = plane_grouped(other);
    return flector_geometricAntiProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((self_.e41_ * other.e321_) + (self_.e31_ * other.e412_) + (self_.scalar * other.e423_), (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_) + (self_.scalar * other.e431_), (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_) + (self_.scalar * other.e412_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e1234_ * other.e423_, self_.e1234_ * other.e431_, self_.e1234_ * other.e412_, -(self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) + (self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group0_.zxyw.xyz, self_.e23_))
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_point(self_: Motor, other: Point) -> Flector {
    let self_groups = motor_grouped(self_);
    let other_groups = point_grouped(other);
    return flector_geometricAntiProduct_motor(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) + (self_groups.group0_.yzxw * other_groups.group0_.zxyw) - (self_groups.group0_.zxyw * other_groups.group0_.yzxw)).xyz, self_.e1234_ * other.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_).xyz, (self_.scalar * other.e4_) - (self_.e41_ * other.e1_) - (self_.e42_ * other.e2_) - (self_.e43_ * other.e3_))
    )), motor_antiReverse(self_));
}
fn motor_antiSandwich_scalar(self_: Motor, other: Scalar) -> Motor {
    let self_groups = motor_grouped(self_);
    let other_groups = scalar_grouped(other);
    return motor_geometricAntiProduct_motor(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.scalar) * self_groups.group0_
    )), motor_antiReverse(self_));
}
fn multiVector_antiSandwich_antiScalar(self_: MultiVector, other: AntiScalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_, 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group1_, 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_, 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group4_
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_dualNum(self_: MultiVector, other: DualNum) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) + (other.e1234_ * self_.scalar), other.e1234_ * self_.e1234_, 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_)).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_), 
        /* e423, e431, e412, e321 */ vec4<f32>(other_groups.group0_.yyzw.xy, other.e1234_, (other.e1234_ * self_.e321_) - (other.scalar * self_.e4_)) * vec4<f32>(self_groups.group4_.xyz, 1.0)
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_flector(self_: MultiVector, other: Flector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = flector_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * other_groups.group0_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1_ * self_.e1234_) + (other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e1_ * self_.e43_) + (other.e2_ * self_.e1234_) + (other.e4_ * self_.e31_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e2_ * self_.e41_) + (other.e3_ * self_.e1234_) + (other.e4_ * self_.e12_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), other.e412_ * self_.e43_ * -1.0) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, self_.e1234_) * vec4<f32>(other_groups.group1_.xyz, other.e4_)) - (other_groups.group1_.yzxy * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e42_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group0_.yzxw).xyz, other.e423_ * self_.e41_), 
        /* e41, e42, e43 */ (other_groups.group1_.yzxw * self_groups.group4_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group1_.xxyw) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group1_.zyzw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group0_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group0_.zyzw) + (other_groups.group1_.yzxw * self_groups.group1_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, 0.0) * other_groups.group1_.zyzw) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, 0.0) * other_groups.group1_.xxyw) - (other_groups.group0_.yzxw * self_groups.group4_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e412_ * self_.e42_, other.e423_ * self_.e43_, other.e4_ * self_.e43_, -(other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(other_groups.group1_.xyz, other.e4_)) + (vec4<f32>(other_groups.group0_.wwzw.xy, other.e431_, other.e321_) * vec4<f32>(self_groups.group2_.xyxw.xyz, self_.e1234_)) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e1_ * self_.e41_)
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_horizon(self_: MultiVector, other: Horizon) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = horizon_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e321_ * self_.e4_, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e321_ * self_.e1234_)
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_line(self_: MultiVector, other: Line) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = line_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0) - ((vec4<f32>(other.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e43_ * self_.e2_) + (other.e31_ * self_.e412_), (other.e41_ * self_.e3_) + (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e42_ * self_.e1_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), 0.0) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e43_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group1_.zxyw).xyz, other.e41_ * self_.e423_), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (other_groups.group0_.zxyw * self_groups.group2_.yzxw) - (other_groups.group0_.yzxw * self_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group0_.zxyw * self_groups.group3_.yzxw) + (other_groups.group1_.zxyw * self_groups.group2_.yzxw) - (other_groups.group0_.yzxw * self_groups.group3_.zxyw) - (other_groups.group1_.yzxw * self_groups.group2_.zxyw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e423_) * vec4<f32>(other_groups.group0_.xxyw.xyz, other.e23_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e431_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e12_ * self_.e412_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_)) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group4_.zxyw).xyz, other.e41_ * self_.e1_)
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_motor(self_: MultiVector, other: Motor) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = motor_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.scalar * self_.e1234_) - (other.e41_ * self_.e23_) - (other.e42_ * self_.e31_) - (other.e43_ * self_.e12_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e23_, other.e41_, 0.0, 0.0)) - ((vec4<f32>(self_.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e31_, other.e42_, 0.0, 0.0)) - ((vec4<f32>(self_.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e12_, other.e43_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e43_ * self_.e2_) + (other.e1234_ * self_.e1_) + (other.e31_ * self_.e412_) - (other.scalar * self_.e423_), (other.e42_ * self_.e321_) + (other.e1234_ * self_.e2_) + (other.e12_ * self_.e423_) - (other.scalar * self_.e431_), (other.e43_ * self_.e321_) + (other.e1234_ * self_.e3_) + (other.e23_ * self_.e431_) - (other.scalar * self_.e412_), 0.0) + (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, self_.e4_) * other_groups.group0_.xxyw) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e431_) * vec4<f32>(other_groups.group1_.xxyw.xyz, other.e42_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e412_) * vec4<f32>(other_groups.group1_.zyzw.xyz, other.e43_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group1_.zxyw.xyz, self_.e423_)), 
        /* e41, e42, e43 */ ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group2_.xyxw * other_groups.group0_.wwyw) + (self_groups.group2_.yzzw * other_groups.group0_.zxww) - (self_groups.group2_.zxyw * other_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (self_groups.group2_.xyxw * other_groups.group1_.wwyw) + (self_groups.group2_.yzzw * other_groups.group1_.zxww) + (self_groups.group3_.xyxw * other_groups.group0_.wwyw) + (self_groups.group3_.yzzw * other_groups.group0_.zxww) - (self_groups.group2_.zxyw * other_groups.group1_.yzxw) - (self_groups.group3_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e321_) * other_groups.group0_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(other_groups.group0_.zyzw.xyz, other.e23_)) + (self_groups.group4_.xyzy * vec4<f32>(other_groups.group0_.wwww.xyz, other.e31_)) + vec4<f32>(vec4<f32>(0.0).xyz, (other.e12_ * self_.e412_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.scalar * self_.e4_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group4_.zxyw.xyz, self_.e1_))
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_multiVector(self_: MultiVector, other: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e1234_ * self_.scalar) + (other.e321_ * self_.e4_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_) - (other.e23_ * self_.e41_) - (other.e31_ * self_.e42_) - (other.e12_ * self_.e43_), 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e41_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e23_, self_.e41_, 0.0, 0.0)) - ((vec4<f32>(other.e42_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e31_, self_.e42_, 0.0, 0.0)) - ((vec4<f32>(other.e43_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e12_, self_.e43_, 0.0, 0.0)) - (vec4<f32>(self_.e423_, self_.e4_, 0.0, 0.0) * other_groups.group1_.xwzw), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e1_ * self_.e1234_) + (other.e3_ * self_.e42_) + (other.e4_ * self_.e23_) + (other.e41_ * self_.e321_) + (other.e43_ * self_.e2_) + (other.e31_ * self_.e412_) + (other.e412_ * self_.e31_) + (other.e321_ * self_.e41_), (other.e1_ * self_.e43_) + (other.e2_ * self_.e1234_) + (other.e4_ * self_.e31_) + (other.e41_ * self_.e3_) + (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_) + (other.e423_ * self_.e12_) + (other.e321_ * self_.e42_), (other.e2_ * self_.e41_) + (other.e3_ * self_.e1234_) + (other.e4_ * self_.e12_) + (other.e42_ * self_.e1_) + (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_) + (other.e431_ * self_.e23_) + (other.e321_ * self_.e43_), 0.0) + (vec4<f32>(other.e1234_) * self_groups.group1_) + (vec4<f32>(self_groups.group0_.xxzw.xy, self_.scalar, self_.e1234_) * vec4<f32>(other_groups.group4_.xyz, other.e4_)) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, self_.e412_) * vec4<f32>(other_groups.group3_.xxyw.xyz, other.e43_)) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, other.e423_) * vec4<f32>(other_groups.group3_.zyzw.xyz, self_.e41_)) - (other_groups.group4_.yzxz * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e43_)) - (self_groups.group4_.xyzx * vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, other.e41_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group1_.zxyw).xyz, other.e42_ * self_.e431_) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group1_.yzxw).xyz, other.e431_ * self_.e42_), 
        /* e41, e42, e43 */ ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + (other_groups.group2_.zxyw * self_groups.group2_.yzxw) + (other_groups.group4_.yzxw * self_groups.group4_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) - (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group4_.xxyw) - (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group4_.zyzw) - (other_groups.group2_.yzxw * self_groups.group2_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_) + ((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + ((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_) + ((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, 0.0) * other_groups.group1_.xxyw) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, 0.0) * other_groups.group1_.zyzw) + (other_groups.group2_.zxyw * self_groups.group3_.yzxw) + (other_groups.group3_.zxyw * self_groups.group2_.yzxw) + (other_groups.group4_.yzxw * self_groups.group1_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (vec4<f32>(self_.e2_, self_.e321_, self_.e321_, 0.0) * other_groups.group4_.zyzw) - (vec4<f32>(self_.e321_, self_.e3_, self_.e1_, 0.0) * other_groups.group4_.xxyw) - (other_groups.group2_.yzxw * self_groups.group3_.zxyw) - (other_groups.group3_.yzxw * self_groups.group2_.zxyw) - (other_groups.group1_.yzxw * self_groups.group4_.zxyw), 
        /* e423, e431, e412, e321 */ (vec4<f32>(other.e1234_) * self_groups.group4_) + (vec4<f32>(self_.e4_, self_.e412_, self_.e423_, other.e321_) * vec4<f32>(other_groups.group2_.xxyw.xyz, self_.e1234_)) + (vec4<f32>(self_.e431_, self_.e4_, self_.e4_, self_.e423_) * vec4<f32>(other_groups.group2_.zyzw.xyz, other.e23_)) + (vec4<f32>(self_groups.group0_.yyzw.xy, self_.e1234_, self_.scalar) * vec4<f32>(other_groups.group4_.xyz, other.e4_)) + (vec4<f32>(other_groups.group1_.wwzw.xy, other.e431_, self_.e431_) * vec4<f32>(self_groups.group2_.xyxw.xyz, other.e31_)) + (vec4<f32>(other_groups.group4_.zxzw.xy, other.e4_, self_.e412_) * vec4<f32>(self_groups.group2_.yzzw.xyz, other.e12_)) + vec4<f32>(vec4<f32>(0.0).xyz, -(other.e1_ * self_.e41_) - (other.e2_ * self_.e42_) - (other.e3_ * self_.e43_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.e423_ * self_.e23_) - (other.e431_ * self_.e31_) - (other.e412_ * self_.e12_)) - vec4<f32>((other_groups.group2_.yzxw * self_groups.group4_.zxyw).xyz, other.scalar * self_.e4_) - vec4<f32>((self_groups.group2_.zxyw * other_groups.group4_.yzxw).xyz, other.e41_ * self_.e1_)
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_origin(self_: MultiVector, other: Origin) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = origin_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e321_, self_.e4_, 0.0, 0.0) * vec4<f32>(-1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group3_.xyz, self_.e1234_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_ * vec4<f32>(-1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e4_) * vec4<f32>(self_groups.group2_.xyz, self_.scalar)
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_plane(self_: MultiVector, other: Plane) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = plane_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e4_ * other.e321_, 0.0, 0.0, 0.0) + ((vec4<f32>(other.e423_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e1_, self_.e423_, 0.0, 0.0)) + ((vec4<f32>(other.e431_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e2_, self_.e431_, 0.0, 0.0)) + ((vec4<f32>(other.e412_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(self_.e3_, self_.e412_, 0.0, 0.0)), 
        /* e1, e2, e3, e4 */ vec4<f32>((self_.scalar * other.e423_) + (self_.e41_ * other.e321_) + (self_.e31_ * other.e412_), (self_.scalar * other.e431_) + (self_.e42_ * other.e321_) + (self_.e12_ * other.e423_), (self_.scalar * other.e412_) + (self_.e43_ * other.e321_) + (self_.e23_ * other.e431_), -(self_.e42_ * other.e431_) - (self_.e43_ * other.e412_)) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group3_.zxyw.xyz, self_.e41_)), 
        /* e41, e42, e43 */ (self_groups.group4_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group4_.yzxw * other_groups.group0_.zxyw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_) + (self_groups.group1_.zxyw * other_groups.group0_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - (self_groups.group1_.yzxw * other_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e42_ * other.e412_, self_.e43_ * other.e423_, self_.e41_ * other.e431_, -(self_.e31_ * other.e431_) - (self_.e12_ * other.e412_)) + (vec4<f32>(self_.e1234_) * other_groups.group0_) - (other_groups.group0_.yzxx * vec4<f32>(self_groups.group2_.zxyw.xyz, self_.e23_))
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_point(self_: MultiVector, other: Point) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = point_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(self_.e423_ * other.e1_) - (self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_), self_.e4_ * other.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(self_.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group3_) + (self_groups.group2_.yzxw * other_groups.group0_.zxyw) - (self_groups.group2_.zxyw * other_groups.group0_.yzxw)).xyz, self_.e1234_ * other.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) + (self_groups.group4_.yzxw * other_groups.group0_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group1_) - (self_groups.group4_.zxyw * other_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_).xyz, (self_.scalar * other.e4_) - (self_.e41_ * other.e1_) - (self_.e42_ * other.e2_) - (self_.e43_ * other.e3_))
    )), multiVector_antiReverse(self_));
}
fn multiVector_antiSandwich_scalar(self_: MultiVector, other: Scalar) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    let other_groups = scalar_grouped(other);
    return multiVector_geometricAntiProduct_multiVector(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(self_.e1234_ * other.scalar, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group4_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group2_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.scalar * -1.0)
    )), multiVector_antiReverse(self_));
}
fn origin_antiSandwich_antiScalar(self_: Origin, other: AntiScalar) -> AntiScalar {
    return origin_geometricAntiProduct_origin(Origin(other.e1234_ * self_.e4_), origin_antiReverse(self_));
}
fn origin_antiSandwich_dualNum(self_: Origin, other: DualNum) -> Motor {
    let self_groups = origin_grouped(self_);
    return flector_geometricAntiProduct_origin(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_ * -1.0)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_flector(self_: Origin, other: Flector) -> Flector {
    let self_groups = origin_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricAntiProduct_origin(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.e321_)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_horizon(self_: Origin, other: Horizon) -> Horizon {
    return scalar_geometricAntiProduct_origin(Scalar(other.e321_ * self_.e4_), origin_antiReverse(self_));
}
fn origin_antiSandwich_line(self_: Origin, other: Line) -> Motor {
    let self_groups = origin_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricAntiProduct_origin(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_motor(self_: Origin, other: Motor) -> Motor {
    let self_groups = origin_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricAntiProduct_origin(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group1_.xyz, other.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group0_.xyz, other.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_multiVector(self_: Origin, other: MultiVector) -> MultiVector {
    let self_groups = origin_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_origin(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 0.0, 0.0)) * vec4<f32>(other.e321_, other.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group3_.xyz, other.e1234_) * vec4<f32>(-1.0, -1.0, -1.0, 1.0), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_, 
        /* e423, e431, e412, e321 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group2_.xyz, other.scalar) * vec4<f32>(1.0, 1.0, 1.0, -1.0)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_origin(self_: Origin, other: Origin) -> Origin {
    return antiScalar_geometricAntiProduct_origin(AntiScalar(other.e4_ * self_.e4_ * -1.0), origin_antiReverse(self_));
}
fn origin_antiSandwich_plane(self_: Origin, other: Plane) -> Flector {
    let self_groups = origin_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricAntiProduct_origin(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.e321_)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_point(self_: Origin, other: Point) -> Flector {
    let self_groups = origin_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricAntiProduct_origin(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, self_.e4_ * other.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    )), origin_antiReverse(self_));
}
fn origin_antiSandwich_scalar(self_: Origin, other: Scalar) -> Scalar {
    return horizon_geometricAntiProduct_origin(Horizon(self_.e4_ * other.scalar * -1.0), origin_antiReverse(self_));
}
fn plane_antiSandwich_antiScalar(self_: Plane, other: AntiScalar) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return plane_geometricAntiProduct_plane(plane_degroup(PlaneGroups(
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_dualNum(self_: Plane, other: DualNum) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricAntiProduct_plane(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, 0.0) * vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e1234_) * self_groups.group0_
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_flector(self_: Plane, other: Flector) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricAntiProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(-(other.e4_ * self_.e423_) - (other.e412_ * self_.e431_), -(other.e4_ * self_.e431_) - (other.e423_ * self_.e412_), -(other.e4_ * self_.e412_) - (other.e431_ * self_.e423_), (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_)) + (other_groups.group1_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((other.e3_ * self_.e431_) + (other.e321_ * self_.e423_), (other.e1_ * self_.e412_) + (other.e321_ * self_.e431_), (other.e2_ * self_.e423_) + (other.e321_ * self_.e412_), -(other.e3_ * self_.e412_) - (other.e4_ * self_.e321_)) - (other_groups.group0_.yzxx * self_groups.group0_.zxyx) - (self_groups.group0_.wwwy * vec4<f32>(other_groups.group1_.xyz, other.e2_))
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_horizon(self_: Plane, other: Horizon) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = horizon_grouped(other);
    return line_geometricAntiProduct_plane(line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_line(self_: Plane, other: Line) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricAntiProduct_plane(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), -(other.e42_ * self_.e431_) - (other.e43_ * self_.e412_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e42_ * self_.e412_ * -1.0, other.e43_ * self_.e423_ * -1.0, other.e41_ * self_.e431_ * -1.0, (other.e31_ * self_.e431_) + (other.e12_ * self_.e412_)) + (self_groups.group0_.yzxx * vec4<f32>(other_groups.group0_.zxyw.xyz, other.e23_))
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_motor(self_: Plane, other: Motor) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricAntiProduct_plane(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), other.e43_ * self_.e412_ * -1.0) - (self_groups.group0_.xyzy * vec4<f32>(other_groups.group1_.wwww.xyz, other.e42_)) - (self_groups.group0_.yzxx * vec4<f32>(other_groups.group1_.zxyw.xyz, other.e41_)), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e42_ * self_.e412_ * -1.0, other.e43_ * self_.e423_ * -1.0, other.e41_ * self_.e431_ * -1.0, (other.e31_ * self_.e431_) + (other.e12_ * self_.e412_)) + (other_groups.group0_.zxyw * self_groups.group0_.yzxw) + (self_groups.group0_.xyzx * vec4<f32>(other_groups.group0_.wwww.xyz, other.e23_))
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_multiVector(self_: Plane, other: MultiVector) -> MultiVector {
    let self_groups = plane_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_plane(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(-(other.e1_ * self_.e423_) - (other.e2_ * self_.e431_) - (other.e3_ * self_.e412_) - (other.e4_ * self_.e321_), (other.e423_ * self_.e423_) + (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_), 0.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((other.e41_ * self_.e321_) + (other.e31_ * self_.e412_), (other.e42_ * self_.e321_) + (other.e12_ * self_.e423_), (other.e43_ * self_.e321_) + (other.e23_ * self_.e431_), other.e43_ * self_.e412_ * -1.0) - (self_groups.group0_.xyzx * vec4<f32>(other_groups.group0_.xxzw.xy, other.scalar, other.e41_)) - (self_groups.group0_.yzxy * vec4<f32>(other_groups.group3_.zxyw.xyz, other.e42_)), 
        /* e41, e42, e43 */ (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e23, e31, e12 */ ((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group1_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_) - (other_groups.group1_.yzxw * self_groups.group0_.zxyw), 
        /* e423, e431, e412, e321 */ vec4<f32>(other.e42_ * self_.e412_ * -1.0, other.e43_ * self_.e423_ * -1.0, other.e41_ * self_.e431_ * -1.0, (other.e31_ * self_.e431_) + (other.e12_ * self_.e412_)) + (vec4<f32>(other.e1234_) * self_groups.group0_) + (self_groups.group0_.yzxx * vec4<f32>(other_groups.group2_.zxyw.xyz, other.e23_))
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_origin(self_: Plane, other: Origin) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = origin_grouped(other);
    return motor_geometricAntiProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.e321_ * -1.0)
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_plane(self_: Plane, other: Plane) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricAntiProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(other.e412_ * self_.e431_ * -1.0, other.e423_ * self_.e412_ * -1.0, other.e431_ * self_.e423_ * -1.0, (other.e431_ * self_.e431_) + (other.e412_ * self_.e412_)) + (other_groups.group0_.yzxx * self_groups.group0_.zxyx), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(other.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - ((vec4<f32>(self_.e321_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_)).xyz, 0.0)
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_point(self_: Plane, other: Point) -> Flector {
    let self_groups = plane_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricAntiProduct_plane(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(other_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(self_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.e431_ * other.e3_, self_.e412_ * other.e1_, self_.e423_ * other.e2_, -(self_.e431_ * other.e2_) - (self_.e412_ * other.e3_) - (self_.e321_ * other.e4_)) - (self_groups.group0_.zxyx * other_groups.group0_.yzxx)
    )), plane_antiReverse(self_));
}
fn plane_antiSandwich_scalar(self_: Plane, other: Scalar) -> Motor {
    let self_groups = plane_grouped(self_);
    let other_groups = scalar_grouped(other);
    return point_geometricAntiProduct_plane(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(other.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), plane_antiReverse(self_));
}
fn point_antiSandwich_antiScalar(self_: Point, other: AntiScalar) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = antiScalar_grouped(other);
    return point_geometricAntiProduct_point(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_
    )), point_antiReverse(self_));
}
fn point_antiSandwich_dualNum(self_: Point, other: DualNum) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = dualNum_grouped(other);
    return flector_geometricAntiProduct_point(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(other.e1234_) * self_groups.group0_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.scalar * self_.e4_ * -1.0)
    )), point_antiReverse(self_));
}
fn point_antiSandwich_flector(self_: Point, other: Flector) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = flector_grouped(other);
    return motor_geometricAntiProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(self_.e4_) * vec4<f32>(other_groups.group1_.xyz, other.e4_) * vec4<f32>(-1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(-(other.e4_ * self_.e1_) - (other.e412_ * self_.e2_), -(other.e4_ * self_.e2_) - (other.e423_ * self_.e3_), -(other.e4_ * self_.e3_) - (other.e431_ * self_.e1_), (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group1_.yzxy * self_groups.group0_.zxyy) + (self_groups.group0_.wwwx * vec4<f32>(other_groups.group0_.xyz, other.e423_))
    )), point_antiReverse(self_));
}
fn point_antiSandwich_horizon(self_: Point, other: Horizon) -> Horizon {
    let self_groups = point_grouped(self_);
    return scalar_geometricAntiProduct_point(Scalar(other.e321_ * self_.e4_), point_antiReverse(self_));
}
fn point_antiSandwich_line(self_: Point, other: Line) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = line_grouped(other);
    return flector_geometricAntiProduct_point(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((other_groups.group0_.zxyw * self_groups.group0_.yzxw).xyz, 0.0) - vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0) - vec4<f32>((other_groups.group0_.yzxw * self_groups.group0_.zxyw).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e1_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_))
    )), point_antiReverse(self_));
}
fn point_antiSandwich_motor(self_: Point, other: Motor) -> Motor {
    let self_groups = point_grouped(self_);
    let other_groups = motor_grouped(other);
    return flector_geometricAntiProduct_point(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group0_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) - (other_groups.group0_.yzxw * self_groups.group0_.zxyw)).xyz, other.e1234_ * self_.e4_), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, -(other.e41_ * self_.e1_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_) - (other.scalar * self_.e4_))
    )), point_antiReverse(self_));
}
fn point_antiSandwich_multiVector(self_: Point, other: MultiVector) -> MultiVector {
    let self_groups = point_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_point(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>((other.e423_ * self_.e1_) + (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_), other.e4_ * self_.e4_, 0.0, 0.0) * vec4<f32>(1.0, -1.0), 
        /* e1, e2, e3, e4 */ vec4<f32>((((vec4<f32>(other.e1234_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) + (other_groups.group2_.zxyw * self_groups.group0_.yzxw) - ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group3_) - (other_groups.group2_.yzxw * self_groups.group0_.zxyw)).xyz, other.e1234_ * self_.e4_), 
        /* e41, e42, e43 */ (vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_ * vec4<f32>(-1.0), 
        /* e23, e31, e12 */ ((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_) + (other_groups.group4_.yzxw * self_groups.group0_.zxyw) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_) - (other_groups.group4_.zxyw * self_groups.group0_.yzxw), 
        /* e423, e431, e412, e321 */ vec4<f32>(((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_).xyz, -(other.scalar * self_.e4_) - (other.e41_ * self_.e1_) - (other.e42_ * self_.e2_) - (other.e43_ * self_.e3_))
    )), point_antiReverse(self_));
}
fn point_antiSandwich_origin(self_: Point, other: Origin) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = origin_grouped(other);
    return motor_geometricAntiProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_ * vec4<f32>(-1.0)).xyz, 0.0)
    )), point_antiReverse(self_));
}
fn point_antiSandwich_plane(self_: Point, other: Plane) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = plane_grouped(other);
    return motor_geometricAntiProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>((vec4<f32>(1.0) * vec4<f32>(1.0, 1.0, 1.0, 0.0)).xyz, 0.0) * vec4<f32>(self_groups.group0_.wwww.xyz, 0.0) * vec4<f32>(other_groups.group0_.xyz, 0.0) * vec4<f32>(-1.0, -1.0, -1.0, 0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(other.e412_ * self_.e2_ * -1.0, other.e423_ * self_.e3_ * -1.0, other.e431_ * self_.e1_ * -1.0, (other.e431_ * self_.e2_) + (other.e412_ * self_.e3_) + (other.e321_ * self_.e4_)) + (other_groups.group0_.yzxx * self_groups.group0_.zxyx)
    )), point_antiReverse(self_));
}
fn point_antiSandwich_point(self_: Point, other: Point) -> Flector {
    let self_groups = point_grouped(self_);
    let other_groups = point_grouped(other);
    return motor_geometricAntiProduct_point(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.e4_ * -1.0), 
        /* e23, e31, e12, scalar */ vec4<f32>((((vec4<f32>(self_.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_) - ((vec4<f32>(other.e4_) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * self_groups.group0_)).xyz, 0.0)
    )), point_antiReverse(self_));
}
fn point_antiSandwich_scalar(self_: Point, other: Scalar) -> Scalar {
    let self_groups = point_grouped(self_);
    return horizon_geometricAntiProduct_point(Horizon(self_.e4_ * other.scalar * -1.0), point_antiReverse(self_));
}
fn scalar_antiSandwich_flector(self_: Scalar, other: Flector) -> Flector {
    let self_groups = scalar_grouped(self_);
    let other_groups = flector_grouped(other);
    return flector_geometricAntiProduct_scalar(flector_degroup(FlectorGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group1_).xyz, 0.0), 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.scalar)
    )), scalar_antiReverse(self_));
}
fn scalar_antiSandwich_line(self_: Scalar, other: Line) -> Line {
    let self_groups = scalar_grouped(self_);
    let other_groups = line_grouped(other);
    return line_geometricAntiProduct_scalar(line_degroup(LineGroups(
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_
    )), scalar_antiReverse(self_));
}
fn scalar_antiSandwich_motor(self_: Scalar, other: Motor) -> Motor {
    let self_groups = scalar_grouped(self_);
    let other_groups = motor_grouped(other);
    return motor_geometricAntiProduct_scalar(motor_degroup(MotorGroups(
        /* e41, e42, e43, e1234 */ vec4<f32>(0.0), 
        /* e23, e31, e12, scalar */ vec4<f32>(self_.scalar) * other_groups.group0_
    )), scalar_antiReverse(self_));
}
fn scalar_antiSandwich_multiVector(self_: Scalar, other: MultiVector) -> MultiVector {
    let self_groups = scalar_grouped(self_);
    let other_groups = multiVector_grouped(other);
    return multiVector_geometricAntiProduct_scalar(multiVector_degroup(MultiVectorGroups(
        /* scalar, e1234 */ vec4<f32>(other.e1234_ * self_.scalar, 1.0, 0.0, 0.0) * vec4<f32>(1.0, 0.0), 
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group4_).xyz, 0.0), 
        /* e41, e42, e43 */ vec4<f32>(0.0), 
        /* e23, e31, e12 */ (vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group2_, 
        /* e423, e431, e412, e321 */ vec4<f32>(vec4<f32>(0.0).xyz, other.e4_ * self_.scalar)
    )), scalar_antiReverse(self_));
}
fn scalar_antiSandwich_plane(self_: Scalar, other: Plane) -> Horizon {
    let other_groups = plane_grouped(other);
    return point_geometricAntiProduct_scalar(point_degroup(PointGroups(
        /* e1, e2, e3, e4 */ vec4<f32>(((vec4<f32>(self_.scalar) * vec4<f32>(1.0, 1.0, 1.0, 0.0)) * other_groups.group0_).xyz, 0.0)
    )), scalar_antiReverse(self_));
}
fn flector_bulkNormSquared(self_: Flector) -> Scalar {
    let self_groups = flector_grouped(self_);
    let flat_bulk_thing: Motor = flector_wedge_origin(flector_flatBulk(self_), Origin(1.0));
    return motor_dotProduct_motor(flat_bulk_thing, flat_bulk_thing);
}
fn line_bulkNormSquared(self_: Line) -> Scalar {
    let self_groups = line_grouped(self_);
    let flat_bulk_thing: Plane = line_wedge_origin(line_flatBulk(self_), Origin(1.0));
    return plane_dotProduct_plane(flat_bulk_thing, flat_bulk_thing);
}
fn motor_bulkNormSquared(self_: Motor) -> Scalar {
    let self_groups = motor_grouped(self_);
    let flat_bulk_thing: Flector = motor_wedge_origin(motor_flatBulk(self_), Origin(1.0));
    return flector_dotProduct_flector(flat_bulk_thing, flat_bulk_thing);
}
fn multiVector_bulkNormSquared(self_: MultiVector) -> Scalar {
    let self_groups = multiVector_grouped(self_);
    let flat_bulk_thing: MultiVector = multiVector_wedge_origin(multiVector_flatBulk(self_), Origin(1.0));
    return multiVector_dotProduct_multiVector(flat_bulk_thing, flat_bulk_thing);
}
fn point_bulkNormSquared(self_: Point) -> Scalar {
    let self_groups = point_grouped(self_);
    let flat_bulk_thing: Line = point_wedge_origin(point_flatBulk(self_), Origin(1.0));
    return line_dotProduct_line(flat_bulk_thing, flat_bulk_thing);
}
fn antiScalar_constraintValid(self_: AntiScalar) -> AntiScalar {
    return self_;
}
fn horizon_constraintValid(self_: Horizon) -> Horizon {
    return self_;
}
fn origin_constraintValid(self_: Origin) -> Origin {
    return self_;
}
fn plane_constraintValid(self_: Plane) -> Plane {
    return self_;
}
fn point_constraintValid(self_: Point) -> Point {
    return self_;
}
fn scalar_constraintValid(self_: Scalar) -> Scalar {
    return self_;
}
fn flector_flatBulkNormSquared(self_: Flector) -> Scalar {
    let self_groups = flector_grouped(self_);
    let flat_bulk_thing: Motor = flector_wedge_origin(flector_flatBulk(self_), Origin(1.0));
    return motor_dotProduct_motor(flat_bulk_thing, flat_bulk_thing);
}
fn line_flatBulkNormSquared(self_: Line) -> Scalar {
    let self_groups = line_grouped(self_);
    let flat_bulk_thing: Plane = line_wedge_origin(line_flatBulk(self_), Origin(1.0));
    return plane_dotProduct_plane(flat_bulk_thing, flat_bulk_thing);
}
fn motor_flatBulkNormSquared(self_: Motor) -> Scalar {
    let self_groups = motor_grouped(self_);
    let flat_bulk_thing: Flector = motor_wedge_origin(motor_flatBulk(self_), Origin(1.0));
    return flector_dotProduct_flector(flat_bulk_thing, flat_bulk_thing);
}
fn multiVector_flatBulkNormSquared(self_: MultiVector) -> Scalar {
    let self_groups = multiVector_grouped(self_);
    let flat_bulk_thing: MultiVector = multiVector_wedge_origin(multiVector_flatBulk(self_), Origin(1.0));
    return multiVector_dotProduct_multiVector(flat_bulk_thing, flat_bulk_thing);
}
fn point_flatBulkNormSquared(self_: Point) -> Scalar {
    let self_groups = point_grouped(self_);
    let flat_bulk_thing: Line = point_wedge_origin(point_flatBulk(self_), Origin(1.0));
    return line_dotProduct_line(flat_bulk_thing, flat_bulk_thing);
}
fn flector_flatWeightNorm(self_: Flector) -> AntiScalar {
    let self_groups = flector_grouped(self_);
    return antiScalar_antiSquareRoot(flector_flatWeightNormSquared(self_));
}
fn line_flatWeightNorm(self_: Line) -> AntiScalar {
    let self_groups = line_grouped(self_);
    return antiScalar_antiSquareRoot(line_flatWeightNormSquared(self_));
}
fn motor_flatWeightNorm(self_: Motor) -> AntiScalar {
    let self_groups = motor_grouped(self_);
    return antiScalar_antiSquareRoot(motor_flatWeightNormSquared(self_));
}
fn multiVector_flatWeightNorm(self_: MultiVector) -> AntiScalar {
    let self_groups = multiVector_grouped(self_);
    return antiScalar_antiSquareRoot(multiVector_flatWeightNormSquared(self_));
}
fn point_flatWeightNorm(self_: Point) -> AntiScalar {
    return antiScalar_antiSquareRoot(point_flatWeightNormSquared(self_));
}
fn flector_normSquared(self_: Flector) -> DualNum {
    let self_groups = flector_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(flector_flatBulkNormSquared(self_).scalar, flector_flatWeightNormSquared(self_).e1234_, 0.0, 0.0)
    ));
}
fn line_normSquared(self_: Line) -> DualNum {
    let self_groups = line_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(line_flatBulkNormSquared(self_).scalar, line_flatWeightNormSquared(self_).e1234_, 0.0, 0.0)
    ));
}
fn motor_normSquared(self_: Motor) -> DualNum {
    let self_groups = motor_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(motor_flatBulkNormSquared(self_).scalar, motor_flatWeightNormSquared(self_).e1234_, 0.0, 0.0)
    ));
}
fn multiVector_normSquared(self_: MultiVector) -> DualNum {
    let self_groups = multiVector_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(multiVector_flatBulkNormSquared(self_).scalar, multiVector_flatWeightNormSquared(self_).e1234_, 0.0, 0.0)
    ));
}
fn point_normSquared(self_: Point) -> DualNum {
    let self_groups = point_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(point_flatBulkNormSquared(self_).scalar, point_flatWeightNormSquared(self_).e1234_, 0.0, 0.0)
    ));
}
fn dualNum_not(self_: DualNum) -> AntiScalar {
    return dualNum_rightDual(self_);
}
fn flector_not(self_: Flector) -> Flector {
    let self_groups = flector_grouped(self_);
    return flector_rightDual(self_);
}
fn horizon_not(self_: Horizon) -> Origin {
    return horizon_rightDual(self_);
}
fn line_not(self_: Line) -> Line {
    let self_groups = line_grouped(self_);
    return line_rightDual(self_);
}
fn motor_not(self_: Motor) -> Motor {
    let self_groups = motor_grouped(self_);
    return motor_rightDual(self_);
}
fn multiVector_not(self_: MultiVector) -> MultiVector {
    let self_groups = multiVector_grouped(self_);
    return multiVector_rightDual(self_);
}
fn plane_not(self_: Plane) -> Origin {
    return plane_rightDual(self_);
}
fn point_not(self_: Point) -> Plane {
    let self_groups = point_grouped(self_);
    return point_rightDual(self_);
}
fn scalar_not(self_: Scalar) -> AntiScalar {
    return scalar_rightDual(self_);
}
fn flector_unitizedFlatNormSquared(self_: Flector) -> f32 {
    let self_groups = flector_grouped(self_);
    return flector_flatBulkNormSquared(self_).scalar / (flector_flatWeightNormSquared(self_).e1234_);
}
fn line_unitizedFlatNormSquared(self_: Line) -> f32 {
    let self_groups = line_grouped(self_);
    return line_flatBulkNormSquared(self_).scalar / (line_flatWeightNormSquared(self_).e1234_);
}
fn motor_unitizedFlatNormSquared(self_: Motor) -> f32 {
    let self_groups = motor_grouped(self_);
    return motor_flatBulkNormSquared(self_).scalar / (motor_flatWeightNormSquared(self_).e1234_);
}
fn multiVector_unitizedFlatNormSquared(self_: MultiVector) -> f32 {
    let self_groups = multiVector_grouped(self_);
    return multiVector_flatBulkNormSquared(self_).scalar / (multiVector_flatWeightNormSquared(self_).e1234_);
}
fn point_unitizedFlatNormSquared(self_: Point) -> f32 {
    let self_groups = point_grouped(self_);
    return point_flatBulkNormSquared(self_).scalar / (point_flatWeightNormSquared(self_).e1234_);
}
fn flector_unitizedNorm(self_: Flector) -> f32 {
    let self_groups = flector_grouped(self_);
    return pow(flector_unitizedFlatNormSquared(self_), 0.5);
}
fn line_unitizedNorm(self_: Line) -> f32 {
    let self_groups = line_grouped(self_);
    return pow(line_unitizedFlatNormSquared(self_), 0.5);
}
fn motor_unitizedNorm(self_: Motor) -> f32 {
    let self_groups = motor_grouped(self_);
    return pow(motor_unitizedFlatNormSquared(self_), 0.5);
}
fn multiVector_unitizedNorm(self_: MultiVector) -> f32 {
    let self_groups = multiVector_grouped(self_);
    return pow(multiVector_unitizedFlatNormSquared(self_), 0.5);
}
fn point_unitizedNorm(self_: Point) -> f32 {
    let self_groups = point_grouped(self_);
    return pow(point_unitizedFlatNormSquared(self_), 0.5);
}
fn flector_bulkNorm(self_: Flector) -> Scalar {
    let self_groups = flector_grouped(self_);
    return scalar_squareRoot(flector_flatBulkNormSquared(self_));
}
fn line_bulkNorm(self_: Line) -> Scalar {
    let self_groups = line_grouped(self_);
    return scalar_squareRoot(line_flatBulkNormSquared(self_));
}
fn motor_bulkNorm(self_: Motor) -> Scalar {
    let self_groups = motor_grouped(self_);
    return scalar_squareRoot(motor_flatBulkNormSquared(self_));
}
fn multiVector_bulkNorm(self_: MultiVector) -> Scalar {
    let self_groups = multiVector_grouped(self_);
    return scalar_squareRoot(multiVector_flatBulkNormSquared(self_));
}
fn point_bulkNorm(self_: Point) -> Scalar {
    let self_groups = point_grouped(self_);
    return scalar_squareRoot(point_flatBulkNormSquared(self_));
}
fn flector_flatBulkNorm(self_: Flector) -> Scalar {
    let self_groups = flector_grouped(self_);
    return scalar_squareRoot(flector_flatBulkNormSquared(self_));
}
fn line_flatBulkNorm(self_: Line) -> Scalar {
    let self_groups = line_grouped(self_);
    return scalar_squareRoot(line_flatBulkNormSquared(self_));
}
fn motor_flatBulkNorm(self_: Motor) -> Scalar {
    let self_groups = motor_grouped(self_);
    return scalar_squareRoot(motor_flatBulkNormSquared(self_));
}
fn multiVector_flatBulkNorm(self_: MultiVector) -> Scalar {
    let self_groups = multiVector_grouped(self_);
    return scalar_squareRoot(multiVector_flatBulkNormSquared(self_));
}
fn point_flatBulkNorm(self_: Point) -> Scalar {
    let self_groups = point_grouped(self_);
    return scalar_squareRoot(point_flatBulkNormSquared(self_));
}
fn flector_norm(self_: Flector) -> DualNum {
    let self_groups = flector_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(flector_flatBulkNorm(self_).scalar, flector_flatWeightNorm(self_).e1234_, 0.0, 0.0)
    ));
}
fn line_norm(self_: Line) -> DualNum {
    let self_groups = line_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(line_flatBulkNorm(self_).scalar, line_flatWeightNorm(self_).e1234_, 0.0, 0.0)
    ));
}
fn motor_norm(self_: Motor) -> DualNum {
    let self_groups = motor_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(motor_flatBulkNorm(self_).scalar, motor_flatWeightNorm(self_).e1234_, 0.0, 0.0)
    ));
}
fn multiVector_norm(self_: MultiVector) -> DualNum {
    let self_groups = multiVector_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(multiVector_flatBulkNorm(self_).scalar, multiVector_flatWeightNorm(self_).e1234_, 0.0, 0.0)
    ));
}
fn point_norm(self_: Point) -> DualNum {
    let self_groups = point_grouped(self_);
    return dualNum_degroup(DualNumGroups(
        /* scalar, e1234 */ vec4<f32>(point_flatBulkNorm(self_).scalar, point_flatWeightNorm(self_).e1234_, 0.0, 0.0)
    ));
}
